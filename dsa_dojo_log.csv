ID,Category,Concepts,Question,Constraints,Sample Input,Sample Output,Test Cases,Solution_C,Solution_Python,Solution_Java,Solution_Javascript,Solution_C++,QC Score
White-1,String Reversal,,Write a function that reverses a given string.  The function should take a string as input and return the reversed string.,"- The input string will only contain lowercase letters.
- The length of the input string will be between 1 and 1000 characters (inclusive).","**  ""hello""

**","** ""olleh""","abcde
hello
madam
a
racecar",,,,,,
White-2,Break & Continue,,"Given an array of integers, calculate the sum of only the even numbers. Skip odd numbers using a loop and the `continue` statement.  If the input array is empty, return 0.","- The array will contain only integers.
- The array size will be at most 100.
- Integers in the array will be within the range of -1000 to 1000.","** `[1, 2, 3, 4, 5, 6]`
**",** `12` (2 + 4 + 6),"[2, 4, 6, 8, 10]
[1, 3, 5, 7, 9]
[-2, 0, 2, 4]
[]
[-1, -2, -3, -4]",,,,,,
White-3,Modulo Arithmetic,,"Given two integers, `a` and `b`, find the remainder when `a` is divided by `b`.  This is the modulo operation (%).","- `1 ≤ a, b ≤ 1000`
- `b > 0`","**
`a = 17`
`b = 5`

**","**
`2`  (Because 17 divided by 5 leaves a remainder of 2)","10 3
25 7
100 11
5 5
1000 1",,,,,,
White-4,Intro to Recursion (factorial),,"Write a function that calculates the factorial of a non-negative integer using recursion. The factorial of a non-negative integer n, denoted by n!, is the product of all positive integers less than or equal to n. For example, 5! = 5 * 4 * 3 * 2 * 1 = 120.","- The input integer n will be non-negative (0 or greater).
- The input integer n will be less than or equal to 12 (to avoid potential integer overflow).",5,120,"10
0
7
12
1",,,,,,
White-5,Parameters & Arguments,,"Write a function that takes two integer parameters, `a` and `b`, and returns their sum.  However, there's a twist! The function should also print the value of 'a' before calculating and returning the sum.","* -1000 ≤ a, b ≤ 1000","**

5 10

**","**

5
15","15 20
-5 10
0 0
100 -50
-20 -30",,,,,,
White-6,Intro to Time & Space Complexity,,"Given an integer `n`, count the number of sheep from 1 to n.  This seems simple, but we'll focus on understanding the time complexity.",- 1 ≤ n ≤ 100000,5,15 (1 + 2 + 3 + 4 + 5 = 15),"10
100
10000
50000
78945",,,,,,
White-7,"Basic Array Operations (sum, max, min)",,"Given an array of integers, find the sum, maximum, and minimum values within the array.","* The array will contain at least one integer.
* The integers in the array will be within the range of a 32-bit integer.","[1, 5, 2, 8, 3]","Sum: 19, Max: 8, Min: 1","[10, 20, 30, 40, 50]
[-5, 0, 5, 10, -15]
[1, 1, 1, 1, 1]
[100, -10, 50, 20, -50]
[-1, -2, -3, -4, -5]",,,,,,
White-8,1D Array Declaration & Traversal,,"Given an array of integers, find the sum of all even numbers in the array.","* The array will contain at least one element.
* The array will contain only integers between -100 and 100 (inclusive).
* The size of the array will not exceed 100 elements.","**  `[1, 2, 3, 4, 5, 6]`
**",** `12` (2 + 4 + 6),"[1, 2, 3, 4, 5, 6]
[10, -20, 30, -40]
[-1, -2, -3, -4]
[1, 3, 5, 7, 9]
[2, 4, 6, 8, 10]",,,,,,
White-9,Bitwise Operators,,"Given an 8-bit unsigned integer, write a function that flips all its bits (0s become 1s and vice-versa).",- The input will always be an 8-bit unsigned integer (0-255).,10 (binary: 00001010),245 (binary: 11110101),"15
255
0
128
64",,,,,,
White-10,1D Array Declaration & Traversal,,"Given an array of integers, calculate the sum of all the digits present in each integer within the array.  For example, if the array contains [123, 45, 6], the function should return 1 + 2 + 3 + 4 + 5 + 6 = 21.","- The array will contain only positive integers.
- The array size will be between 1 and 100.
- Each integer in the array will be between 0 and 1000.","** [12, 4, 87]

**",** 22 (1 + 2 + 4 + 8 + 7),"[1,2,3]
[999,1]
[100,200,300]
[1,10,100,1000]
[5,5,5,5]",,,,,,
White-11,Bitwise Operators,,"Given an integer, determine if its binary representation is a palindrome. A palindrome is a sequence that reads the same backward as forward.",#NAME?,10,"true (Binary representation of 10 is 1010, which is a palindrome)

Input: 13","5
100
255
1023
0",,,,,,
White-12,1D Array Declaration & Traversal,,You're on a treasure hunt! The treasure map is encoded in a 1D array. Each element represents a location. Find the total number of locations visited before you stumble upon the 'X' marking the treasure spot.,"- The array will contain only lowercase English alphabets and 'X'.
- The array size will be between 1 and 100.
- 'X' will always be present in the array.","`['a', 'b', 'c', 'X', 'e']`",4 (4 locations visited before finding 'X'),"['a', 'b', 'X', 'd']
['p', 'q', 'r', 's', 'X', 'u']
['X']
['a', 'b', 'c', 'd', 'e', 'f']
['a','x','X','b']",,,,,,
White-13,Type Casting,,"You are given an integer representing the number of seconds since the start of a race.  Your task is to convert this total number of seconds into hours, minutes, and remaining seconds.  For example, 3700 seconds translates to 1 hour, 1 minute, and 40 seconds.",#NAME?,3700,1 1 40,"10000
3661
0
86400
4500",,,,,,
White-14,String Reversal,,Write a function that reverses a given string.  The function should take a string as input and return the reversed string.,"* The input string will contain only lowercase English letters.
* The input string will have a length between 1 and 1000 characters (inclusive).","**  ""hello""
**","** ""olleh""","madam
racecar
hello world
level
rotor",,,,,,
White-15,Parameters & Arguments,,"You're organizing your socks!  Given the number of red socks and blue socks, write a function that returns the total number of socks.",* The number of red and blue socks will be non-negative integers.,"red_socks = 5, blue_socks = 3",8,"Input: 10 20
Output: 30
Input: 0 5
Output: 5
Input: 15 0
Output: 15
Input: 25 75
Output: 100
Input: 100 100
Output: 200",,,,,,
White-16,Break & Continue,,"Given an array of integers, print only the positive numbers, skipping any zeros encountered. Use `break` and `continue` statements to control the flow of your loop.","- The array will contain integers between -100 and 100.
- The array size will be between 1 and 100.","[1, 0, 2, 0, 3, -1, 4, 0, 5]",1 2 3 4 5,"Input: [1, 2, 3, 4, 5]
Output: 1 2 3 4 5
Input: [0, 0, 0, 0, 0]
Output: 
Input: [-1, 0, 1, 2, 3]
Output: 
Input: [1, 0, -1, 2, 0, 3]
Output: 1",,,,,,
White-17,Best/Worst/Average Case Basics,,"Given an unsorted array of integers, determine the number of comparisons needed to find the minimum element in the array in the best, worst, and average cases.","- The array will contain at least one element.
- The elements of the array are integers.
- Assume the average case is the case when the minimum element is in the middle of the array","[3, 1, 4, 1, 5, 9, 2, 6]","Best Case: 0, Worst Case: 7, Average Case: 4","Input: [1, 2, 3, 4, 5]
Output: Best Case: 0, Worst Case: 4, Average Case: 2
Input: [5, 4, 3, 2, 1]
Output: Best Case: 0, Worst Case: 4, Average Case: 2
Input: [10, 5, 20, 15, 30]
Output: Best Case: 0, Worst Case: 4, Average Case: 2
Input: [1]
Output: Best Case: 0, Worst Case: 0, Average Case: 0",,,,,,
White-N/A,Function Definition & Call,,"You're designing a snack dispenser for a spaceship!  The dispenser has a limited number of snacks, and each snack has a unique code.  Your task is to write a function that checks if a given snack code is available in the dispenser.","- The snack codes are integers.
- The number of snacks in the dispenser is fixed and given as input.
- The available snack codes are given as an array.
- Assume that snack codes are always positive integers.
- The function should return `true` if the snack code is available, and `false` otherwise.","Available snacks: [1, 5, 3, 7], Snack code to check: 5","true

Input: Available snacks: [1, 5, 3, 7], Snack code to check: 9","Input: [1, 2, 3, 4, 5]
Output: true
Input: [10, 20, 30]
Output: false
Input: [5, 15, 25, 35, 5]
Output: true
Input: []
Output: false
Input: [1,1,1,1,1,2]
Output: true",,,,,,
White-N/A,"Conditionals (if-else, switch-case)",,"You're designing a software for a candy machine.  The machine dispenses different candies based on the code entered.  Your task is to write a program that takes a candy code as input and prints the name of the candy.  If the code is invalid, print ""Invalid Code"".","- The candy codes are integers between 1 and 5 (inclusive).
- Candy codes and their corresponding names:
    - 1: Chocolate
    - 2: Lollipop
    - 3: Gummy Bears
    - 4: Marshmallow
    - 5: Caramel",3,Gummy Bears,"Input: 1
Output: Chocolate
Input: 5
Output: Caramel
Input: 0
Output: Invalid Code
Input: 6
Output: Invalid Code
Input: 3
Output: Gummy Bears",,,,,,
White-N/A,Variables & Data Types,,"The Galactic Snack Bar is tracking its daily sales.  They sell three types of snacks: Fizzbangs, ZapZaps, and Glimmerglobs.  Given the number of each snack sold, calculate the total number of snacks sold.",* The number of each snack type sold will be a non-negative integer.,"Fizzbangs = 10, ZapZaps = 5, Glimmerglobs = 20",35,"Input: 15 25 35
Output: 75
Input: 0 10 0
Output: 10
Input: 100 200 300
Output: 600
Input: 5 5 5
Output: 15",,,,,,
White-18,Variables & Data Types,,"Given two strings, `str1` and `str2`, concatenate them and print the resulting string.  The concatenation should be done such that `str1` comes before `str2`.","- The length of each string will be between 1 and 100 characters (inclusive).
- The strings will only contain lowercase English alphabets.","str1 = ""hello"", str2 = ""world""",helloworld,"Input: abc def
Output: abcdef
Input: programming is
Output: programmingis
Input: hello world
Output: helloworld
Input: a b
Output: ab
Input: code forces
Output: codeforces",,,,,,
White-19,"Input: 15 25 35
Output: 75
Input: 0 10 0
Output: 10
Input: 100 200 300
Output: 600
Input: 5 5 5
Output: 15",,"The Galactic Snack Bar is tracking its daily sales.  They sell three types of snacks: Fizzbangs, ZapZaps, and Glimmerglobs.  Given the number of each snack sold, calculate the total number of snacks sold.",* The number of each snack type sold will be a non-negative integer.,"Fizzbangs = 10, ZapZaps = 5, Glimmerglobs = 20",35,Variables & Data Types,,,,,,
White-20,Prime Check,,"Determine if a given positive integer is a prime number. A prime number is a natural number greater than 1 that is not a product of two smaller natural numbers.  Your function should return `true` if the number is prime, and `false` otherwise.",* 2 ≤ n ≤ 1000,17,"true

Input: 15","Input: 2
Output: true
Input: 97
Output: true
Input: 100
Output: false
Input: 49
Output: false
Input: 29
Output: true",,,,,,
White-21,Input/Output,,Write a program that reads a line of text from the standard input and prints the same line to the standard output.,"- The input line will contain at most 1000 characters.
- The input line will not contain any leading or trailing spaces.","Hello, world!","Hello, world!","Input: This is a test.
Output: This is a test.
Input: 12345
Output: 12345
Input:  Leading and trailing spaces are removed.
Output: Leading and trailing spaces are removed.
Input: !@#$%^&*()
Output: !@#$%^&*()",,,,,,
White-N/A,"Operators (Arithmetic, Relational, Logical)",,"Given three integers, determine if their sum is greater than 100. If it is, return the sum; otherwise, return -1.","-1000 ≤ a, b, c ≤ 1000","a = 50, b = 50, c = 10","110

Input: a = 20, b = 30, c = 40","Input: 10 20 80
Output: 110
Input: 10 10 10
Output: -1
Input: 50 50 50
Output: 150
Input: -50, 0, 50
Output: -1
Input: 100, 1, 1
Output: 102",,,,,,
White-N/A,"Operators (Arithmetic, Relational, Logical)",,"Given three boolean variables, `a`, `b`, and `c`, determine if the expression `!(a && b) || c` evaluates to `true` or `false`.  Your program should read the boolean values of `a`, `b`, and `c` from standard input and print `true` or `false` to standard output.","- The input will consist of three lines, each containing either ""true"" or ""false"".
- You can assume the input is always valid.","true
false
true",TRUE,"Input: true
true
true
Output: true
Input: false
false
false
Output: true
Input: true
false
false
Output: true
Input: false
true
true
Output: true
Input: true
true
false
Output: false",,,,,,
White-22,"Input: 10 20 80
Output: 110
Input: 10 10 10
Output: -1
Input: 50 50 50
Output: 150
Input: -50, 0, 50
Output: -1
Input: 100, 1, 1
Output: 102",,"Given three integers, determine if their sum is greater than 100. If it is, return the sum; otherwise, return -1.","-1000 ≤ a, b, c ≤ 1000","a = 50, b = 50, c = 10","110

Input: a = 20, b = 30, c = 40","Operators (Arithmetic, Relational, Logical)",,,,,,
White-23,"Input: true
true
true
Output: true
Input: false
false
false
Output: true
Input: true
false
false
Output: true
Input: false
true
true
Output: true
Input: true
true
false
Output: false",,"Given three boolean variables, `a`, `b`, and `c`, determine if the expression `!(a && b) || c` evaluates to `true` or `false`.  Your program should read the boolean values of `a`, `b`, and `c` from standard input and print `true` or `false` to standard output.","- The input will consist of three lines, each containing either ""true"" or ""false"".
- You can assume the input is always valid.","true
false
true",TRUE,"Operators (Arithmetic, Relational, Logical)",,,,,,
White-24,"Loops (for, while)",,"Given a range of numbers (inclusive), calculate the sum of all even numbers within that range.","- The input will consist of two integers, representing the start and end of the range.
- The range will always be valid (start <= end).
- The numbers in the range will be between 1 and 1000 (inclusive).","1, 10",30 (2 + 4 + 6 + 8 + 10),"Input: 1, 5
Output: 6
Input: 10, 20
Output: 165
Input: 5, 15
Output: 50
Input: 1,1000
Output:250500",,,,,,
White-25,Modulo Arithmetic,,"Given two integers, `a` and `b`, find the remainder when `a` is divided by `b`.","* `1 <= a, b <= 1000`
* `b` will not be 0.","a = 10, b = 3",1,"Input: 15 4
Output: 3
Input: 20 5
Output: 0
Input: 100 7
Output: 2
Input: 999 10
Output: 9
Input: 1024 1000
Output: 24",,,,,,
White-26,Return Values,,Write a function that takes two integers as input and returns their sum.,* The input integers will be within the range of a 32-bit integer.,"5, 10",15,"Input: 25, 75
Output: 100
Input: -10, 10
Output: 0
Input: 1000, 2000
Output: 3000
Input: 0, 0
Output: 0",,,,,,
White-27,Palindrome Check,,"Given a string, determine if it's a palindrome (reads the same forwards and backward, ignoring case and non-alphanumeric characters).","- The input string will contain only ASCII characters.
- The string's length will be between 1 and 1000 characters.","""A man, a plan, a canal: Panama""","true

Input: ""race a car""","Input: ""Race car""
Output: true
Input: ""A man, a plan, a canal: Panama""
Output: true
Input: "".,""
Output: true
Input: ""1a2""
Output: false
Input: ""Was it a car or a cat I saw?""
Output: true",,,,,,
White-28,Bitwise Operators,,"Given two integers, `a` and `b`, determine if setting the least significant bit of `a` to 1 and clearing the least significant bit of `b` results in `a` being greater than `b`.",- `a` and `b` are non-negative integers.,"a = 5, b = 6","true

(Because 5 with its least significant bit set to 1 is 5 | 1 = 5, and 6 with its least significant bit cleared is 6 & ~1 = 4. 5 > 4, hence true.)","Input: 5 6
Output: true
Input: 10 12
Output: true
Input: 0 1
Output: true
Input: 7 7
Output: false
Input: 2 4
Output: false",,,,,,
White-N/A,Bitwise Operators,,"Given an integer `n`, count the total number of set bits (1s) in the binary representation of all numbers from 1 to n (inclusive).",* 1 ≤ n ≤ 10^6,n = 3,4,"Input: 5
Output: 7
Input: 10
Output: 17
Input: 1
Output: 1
Input: 100
Output: 266",,,,,,
White-N/A,1D Array Declaration & Traversal,,"Given an array of integers, calculate the sum of all elements in the array.","* The array will contain only integers.
* The array will have at least one element.
* The array will have at most 100 elements.
* The sum of the elements will not exceed the maximum integer value for the language.","[1, 2, 3, 4, 5]",15,"Input: [10, 20, 30]
Output: 60
Input: [-1, 0, 1]
Output: 0
Input: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Output: 10
Input: [100, -50, 25, 75]
Output: 150",,,,,,
White-29,Intro to Recursion (factorial),,"Write a function that calculates the factorial of a non-negative integer using recursion.  The factorial of a non-negative integer n, denoted by n!, is the product of all positive integers less than or equal to n. For example, 5! = 5 * 4 * 3 * 2 * 1 = 120.","- The input integer will be non-negative.
- The input integer will be less than or equal to 12 to avoid integer overflow in most languages.",5,120,"Input: 0
Output: 1
Input: 1
Output: 1
Input: 7
Output: 5040
Input: 10
Output: 3628800
Input: 12
Output: 479001600",,,,,,
White-30,GCD/LCM,,"Given two positive integers, determine if they are co-prime (i.e., their greatest common divisor (GCD) is 1).","- 1 ≤ a, b ≤ 1000","15, 22","Yes

Input: 12, 18","Input: 10, 15
Output: No
Input: 7, 11
Output: Yes
Input: 25, 35
Output: No
Input: 1, 2
Output: Yes
Input: 17, 23
Output: Yes",,,,,,
White-31,"Input: 5
Output: 7
Input: 10
Output: 17
Input: 1
Output: 1
Input: 100
Output: 266",,"Given an integer `n`, count the total number of set bits (1s) in the binary representation of all numbers from 1 to n (inclusive).",* 1 ≤ n ≤ 10^6,n = 3,4,Bitwise Operators,,,,,,
White-32,"Input: [10, 20, 30]
Output: 60
Input: [-1, 0, 1]
Output: 0
Input: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Output: 10
Input: [100, -50, 25, 75]
Output: 150",,"Given an array of integers, calculate the sum of all elements in the array.","* The array will contain only integers.
* The array will have at least one element.
* The array will have at most 100 elements.
* The sum of the elements will not exceed the maximum integer value for the language.","[1, 2, 3, 4, 5]",15,1D Array Declaration & Traversal,,,,,,
White-33,"Basic Array Operations (sum, max, min)",,"Given an array of integers, find the sum, maximum, and minimum values within the array.","* The array will contain at least one element.
* The array will only contain integers.
* The integers can be positive, negative, or zero.","[1, 5, 2, 8, 3]","Sum: 19, Max: 8, Min: 1","Input: [10, 20, 30, 40, 50]
Output: Sum: 150, Max: 50, Min: 10
Input: [-1, 0, 1]
Output: Sum: 0, Max: 1, Min: -1
Input: [5]
Output: Sum: 5, Max: 5, Min: 5
Input: [-5,-10,-15]
Output: Sum: -30, Max: -5, Min: -15",,,,,,
White-34,Intro to Time & Space Complexity,,"Given an integer `n`, count the number of sheep from 1 to n.  This seems simple, but let's analyze its time and space complexity!",- `n` will be a non-negative integer.,5,15 (1 + 2 + 3 + 4 + 5),"Input: 0
Output: 0
Input: 10
Output: 55
Input: 100
Output: 5050
Input: 1000
Output: 500500",,,,,,
White-35,"Basic Array Operations (sum, max, min)",,"Given an array of integers, find the sum, maximum, and minimum values.","- The array will contain at least one element.
- The array elements will be integers within the range of [-1000, 1000].
- The array size will not exceed 1000 elements.","[1, 5, 2, 8, 3]","Sum: 19, Max: 8, Min: 1","Input: [10, 20, 30, 40, 50]
Output: Sum: 150, Max: 50, Min: 10
Input: [-5, 0, 5, 10, -10]
Output: Sum: 0, Max: 10, Min: -10
Input: [1, 1, 1, 1, 1]
Output: Sum: 5, Max: 1, Min: 1
Input: [-1000, 1000]
Output: Sum: 0, Max: 1000, Min: -1000",,,,,,
White-36,Intro to Time & Space Complexity,,"Given an integer `n`, count the number of sheep from 1 to n.  This sounds simple, but let's analyze its efficiency!",- `n` will be a non-negative integer.,5,15 (1 + 2 + 3 + 4 + 5 = 15),"Input: 0
Output: 0
Input: 10
Output: 55
Input: 100
Output: 5050
Input: 1
Output: 1
Input: 7
Output: 28",,,,,,
White-37,Basic String Manipulation,,"Given a string, reverse only the vowel words within the string. A vowel word is defined as a word containing at least one vowel (a, e, i, o, u).  Words are separated by spaces.","- The input string will contain only lowercase letters and spaces.
- The input string will not be empty.
- The input string will not contain leading or trailing spaces.
- Words will be separated by single spaces.","""hello world amazing""",olleh dlrow gnizama,"Input: hello world amazing
Output: olleh dlrow gnizama
Input: this is a test
Output: siht is a tset
Input: quick brown rabbit
Output: quick nworb tibbar
Input: aeiou
Output: uoiea",,,,,,
White-38,"Conditionals (if-else, switch-case)",,"Write a program that takes a student's numerical score as input and outputs their letter grade based on the following scale:

* 90-100: A
* 80-89: B
* 70-79: C
* 60-69: D
* Below 60: F",* The input score will be an integer between 0 and 100 (inclusive).,85,B,"Input: 95
Output: A
Input: 78
Output: C
Input: 60
Output: D
Input: 55
Output: F
Input: 88
Output: B",,,,,,
White-39,"Basic Array Operations (sum, max, min)",,"Given an array of integers, find the sum, maximum, and minimum values.","- The array will contain at least one integer.
- The integers in the array will be within the range of your chosen language's integer type.","[1, 5, 2, 8, 3]","Sum: 19, Max: 8, Min: 1","Input: [10, 20, 30, 40, 50]
Output: Sum: 150, Max: 50, Min: 10
Input: [-1, 0, 1]
Output: Sum: 0, Max: 1, Min: -1
Input: [5]
Output: Sum: 5, Max: 5, Min: 5
Input: [-5, -10, -15]
Output: Sum: -30, Max: -5, Min: -15",,,,,,
White-40,GCD/LCM,,"Given two positive integers, find their greatest common divisor (GCD).","* 1 ≤ a, b ≤ 1000","a = 12, b = 18",6,"Input: 48 18
Output: 6
Input: 15 25
Output: 5
Input: 10 5
Output: 5
Input: 7 13
Output: 1",,,,,,
White-41,Variables & Data Types,,You're a programmer planning a tropical island hopping adventure!  You need to keep track of the number of islands visited and the total coconut count collected on your journey.  Write a program that takes the number of islands visited and coconuts collected as input and displays these values.,"- The number of islands visited must be a non-negative integer.
- The total number of coconuts collected must be a non-negative integer.",3 15,"Islands Visited: 3, Total Coconuts: 15","Input: 5 20
Output: Islands Visited: 5, Total Coconuts: 20
Input: 0 0
Output: Islands Visited: 0, Total Coconuts: 0
Input: 1 100
Output: Islands Visited: 1, Total Coconuts: 100
Input: 12 345
Output: Islands Visited: 12, Total Coconuts: 345",,,,,,
White-42,Type Casting,,"You are given an integer `n`. Your task is to convert this integer to a double, then to a float, then back to an integer, and finally print the final integer value.",* -1000 ≤ n ≤ 1000,123,123,"Input: 345
Output: 345
Input: -99
Output: -99
Input: 0
Output: 0
Input: 1000
Output: 1000
Input: -527
Output: -527",,,,,,
White-43,Break & Continue,,"You're navigating a digital labyrinth represented as a list of integers.  Your goal is to find the sum of all even numbers, but you must avoid certain numbers (marked as -1). If you encounter a -1, skip it using 'continue', and if the sum exceeds 100, break out of the loop using 'break'.","- The input list will contain integers between -1 and 1000 (inclusive).
- The list's length will be at most 100.","[2, 4, 6, -1, 8, 10, 12, 14, 16, 18, 20]",56,"Input: [1, 3, 5, 7, 9]
Output: 0
Input: [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22]
Output: 110
Input: [100, -1, 50, 2, 4, 6, 8]
Output: 100
Input: [-1, -1, -1, 2, 4, 6]
Output: 12",,,,,,
White-44,"Loops (for, while)",,"Write a program that calculates the sum of all even numbers from 1 to N, where N is a positive integer provided as input.",- 1 ≤ N ≤ 1000,10,30 (2 + 4 + 6 + 8 + 10),"Input: 5
Output: 6
Input: 100
Output: 2550
Input: 1
Output: 0
Input: 7
Output: 12
Input: 1000
Output: 250500",,,,,,
White-45,"Operators (Arithmetic, Relational, Logical)",,"Given three integers, determine if the sum of any two of them is equal to the third.  If so, return 1; otherwise, return 0.","- All three integers will be within the range of [-100, 100].","5, 3, 8","1 (because 5 + 3 = 8)

Input: 2, 7, 10","Input: 10, 5, 15
Output: 1
Input: 2, 4, 6
Output: 1
Input: 1, 2, 4
Output: 0
Input: -5, 0, 5
Output: 1
Input: 100, -50, 50
Output: 1",,,,,,
White-46,"Operators (Arithmetic, Relational, Logical)",,"Given two integer inputs, `a` and `b`, determine if the following conditions are met simultaneously:

1. `a` is greater than 10.
2. `b` is less than or equal to 5.
3.  The logical AND of (`a` > 10) and (`b` <= 5) is true, but the logical OR of those same conditions is false.  This is a trick to check for understanding of logical operators.

Your program should output `true` if all three conditions are true; otherwise, output `false`.","-100 ≤ a ≤ 100
-100 ≤ b ≤ 100",15 3,"false

Input: 20 5","Input: 15 3
Output: false
Input: 20 5
Output: false
Input: 12 2
Output: false
Input: 5 10
Output: false
Input: 11 0
Output: false",,,,,,
White-47,Palindrome Check,,"Given a string, determine if it is a palindrome. A palindrome is a string that reads the same forwards and backward, ignoring case and non-alphanumeric characters.","- The input string will contain only ASCII characters.
- The length of the string will be between 1 and 1000 characters.","""A man, a plan, a canal: Panama""","true

Input: ""race a car""","Input: ""Racecar""
Output: true
Input: ""A man, a plan, a canal: Panama""
Output: true
Input: ""1a2""
Output: false
Input: "".""
Output: true
Input: "".,""
Output: true",,,,,,
White-48,Bitwise Operators,,"Given an integer `n`, determine if it's a power of 2.  A power of 2 is a number of the form 2<sup>k</sup> where k is a non-negative integer.",* 0 <= n <= 10<sup>9</sup>,16,"true

Input: 10","Input: 64
Output: true
Input: 0
Output: false
Input: 21845
Output: false
Input: 1
Output: true
Input: 1024
Output: true",,,,,,
White-49,String Reversal,,"Given a string containing words separated by spaces, reverse the order of the words.  Do not reverse the characters within each word.","- The input string will contain only lowercase alphabetical characters and spaces.
- There will be at least one word in the input string.
- Leading and trailing spaces should be ignored.
- Multiple spaces between words are allowed, but only single space should be in the output.","""hello world this is a sentence""","""sentence a is this world hello""","Input: This is a test
Output: test a is This
Input:  Leading and trailing spaces  
Output: spaces trailing and Leading
Input: Multiple spaces between words
Output: words between spaces Multiple
Input: a
Output: a
Input:One Word
Output:Word One",,,,,,
White-50,Function Definition & Call,,"Write a function that takes a planet's name and generates a personalized greeting. The greeting should be in the format: ""Greetings from [planet name]! Welcome to the Galactic Federation.""","- The planet name will be a non-empty string.
- The planet name can contain spaces.",Earth,Greetings from Earth! Welcome to the Galactic Federation.,"Input: Kepler-186f
Output: Greetings from Kepler-186f! Welcome to the Galactic Federation.
Input: Mars
Output: Greetings from Mars! Welcome to the Galactic Federation.
Input: Proxima Centauri b
Output: Greetings from Proxima Centauri b! Welcome to the Galactic Federation.
Input:  Alderaan
Output: Greetings from Alderaan! Welcome to the Galactic Federation.",,,,,,
White-51,Bitwise Operators,,"Given an integer, write a function that flips the least significant bit (LSB) of the integer. The LSB is the rightmost bit in the binary representation of the integer.",* The input integer will be within the range of a 32-bit signed integer.,10 (binary: 1010),"9 (binary: 1001)

Input: 5 (binary: 0101)","Input: 15
Output: 14
Input: 0
Output: 1
Input: -1
Output: 0
Input: 255
Output: 254
Input: 1023
Output: 1022",,,,,,
White-52,Return Values,,Write a function that takes two integers as input and returns their sum.  The function should handle both positive and negative integers.,"- The input integers will be within the range of a 32-bit integer.
- The sum of the two integers will also be within the range of a 32-bit integer.","5, 10","15

Input: -3, 7","Input: 15, 20
Output: 35
Input: -10, 5
Output: -5
Input: 0, 0
Output: 0
Input: -20, -30
Output: -50
Input: 100000, -50000
Output: 50000",,,,,,
White-53,Best/Worst/Average Case Basics,,"Given an unsorted array of integers, find the largest element in the array. Analyze the best, worst, and average-case time complexity of your solution.","- The array will contain at least one element.
- The elements in the array are integers.","[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]",9,"Input: [1, 5, 2, 8, 3]
Output: 8
Input: [9, 9, 9, 9, 9]
Output: 9
Input: [-1, -5, -2, -8, -3]
Output: -1
Input: [10, 20, 30, 40, 50, 60]
Output: 60",,,,,,
White-54,Best/Worst/Average Case Basics,,"Given an unsorted array of integers, find the maximum element in the array. Analyze the best, worst, and average-case time complexities.","- The array will contain at least one element.
- The elements in the array are integers.","[3, 1, 4, 1, 5, 9, 2, 6]",9,"Input: [1, 5, 2, 8, 3]
Output: 8
Input: [9, 9, 9, 9]
Output: 9
Input: [-1, -5, -2, -8, -3]
Output: -1
Input: [10]
Output: 10",,,,,,
White-55,Input/Output,,"Write a program that takes two inputs from the user: first, their name (a single word string), and then their age (an integer). After reading these inputs, the program should print a friendly greeting message that includes both the name and age.","- The name will be a single word (no spaces).
- The name will consist only of English alphabet characters.
- The age will be a positive integer between 1 and 120, inclusive.","Sarah
25",Hello Sarah! You are 25 years old.,"Input:
Bob
18
Output:
Hello Bob! You are 18 years old.
Input:
Alice
100
Output:
Hello Alice! You are 100 years old.
Input:
Zoe
7
Output:
Hello Zoe! You are 7 years old.",,,,,,
White-56,Parameters & Arguments,,"Welcome, future DSA expert! Your first mission is to build a friendly ""Greeting Machine."" You'll be given a person's name, and your program needs to generate a personalized greeting message. This exercise is all about understanding how to use **parameters** to pass information into a function and **arguments** as the actual values supplied when calling that function.

Imagine you have a robot that says ""Hello, [name]! Welcome to DSA!"". You need to teach your program to take a name, use it to complete the greeting, and then display the full message.","*   The input `name` will be a single word (no spaces).
*   The `name` will consist only of English alphabet characters (a-z, A-Z).
*   The length of the `name` will be between 1 and 50 characters, inclusive.","`Alice`

####","`Hello, Alice! Welcome to DSA!`","Input: Eve
Output: Hello, Eve! Welcome to DSA!
Input: MaximillianAlexander
Output: Hello, MaximillianAlexander! Welcome to DSA!
Input: dEvID
Output: Hello, dEvID! Welcome to DSA!
Input: Charlie
Output: Hello, Charlie! Welcome to DSA!",,,,,,
White-57,Basic String Manipulation,,"You are given a string `s` and a character `charToRemove`. Your task is to remove all occurrences of `charToRemove` from `s` and return the new string.

For example, if `s = ""hello world""` and `charToRemove = 'l'`, the result should be `""heo word""`.","* The input string `s` will consist of ASCII characters.
* The length of `s` will be between 0 and 1000 characters.
* The `charToRemove` will be a single ASCII character.
* The removal is case-sensitive.","string s = ""programming""
char charToRemove = 'g'","""proammin""","Input: programming
g
Output: proammin
Input: apple
p
Output: ale
Input: test string
x
Output: test string
Input: 
a
Output: 
Input: AAAAA
A
Output: 
Input: Hello World
l
Output: Heo Word",,,,,,
White-58,Prime Check,,"A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. In other words, a prime number has exactly two distinct positive divisors: 1 and the number itself.

Your task is to write a program that takes an integer `N` as input and determines whether it is a prime number. The program should output ""true"" if `N` is prime, and ""false"" otherwise.","- `0 <= N <= 1,000,000`","**
7

**","**
true

**","Input: 0
Output: false
Input: 2
Output: true
Input: 3
Output: true
Input: 9
Output: false
Input: 999983
Output: true",,,,,,
White-59,Intro to Recursion (factorial),,"The factorial of a non-negative integer `n`, denoted as `n!`, is the product of all positive integers less than or equal to `n`. For example, `5! = 5 * 4 * 3 * 2 * 1 = 120`. An important special case is `0!`, which is defined as `1`.

Your task is to write a function that calculates the factorial of a given non-negative integer `n` using recursion. This problem is designed to introduce you to the fundamental concepts of recursion: defining a base case and a recursive step.","*   `0 <= n <= 12` (The result for `n=13` and above might exceed the capacity of a standard 32-bit integer, and for larger values, the call stack might overflow, depending on the language and environment.)","**

5

**","**

120

**","Input: 0
Output: 1
Input: 1
Output: 1
Input: 3
Output: 6
Input: 7
Output: 5040
Input: 12
Output: 479001600",,,,,,
White-60,Parameters & Arguments,,You're building a simple program that greets users personally. Your task is to implement a function that takes a person's name as an input and then prints a friendly greeting using that name. This problem focuses on understanding how to define a function that accepts parameters and how to pass arguments to it.,"* The name will be a single line of text.
* The name will consist of English letters and spaces.
* The length of the name will be between 1 and 50 characters, inclusive.","Alice

####","Hello, Alice! Welcome to the program.","Input: Bob
Output: Hello, Bob! Welcome to the program.
Input: Charlie Brown
Output: Hello, Charlie Brown! Welcome to the program.
Input: Ada Lovelace
Output: Hello, Ada Lovelace! Welcome to the program.
Input: Z
Output: Hello, Z! Welcome to the program.
Input: SuperLongNameWithLotsOfCharactersToTestTheConstraints
Output: Hello, SuperLongNameWithLotsOfCharactersToTestTheConstraints! Welcome to the program.",,,,,,
White-61,1D Array Declaration & Traversal,,"You're given a list of `N` integers. Your task is to read these integers, store them in a 1D array, and then print them out in reverse order, with each number separated by a space.","*   `1 <= N <= 100`
*   `-1000 <= element <= 1000` (Each integer in the list)",,,"Input: 1
500
Output: 500
Input: 3
1 2 3
Output: 3 2 1
Input: 4
-5 0 10 -20
Output: -20 10 0 -5
Input: 6
100 200 300 400 500 600
Output: 600 500 400 300 200 100",,,,,,
White-62,1D Array Declaration & Traversal,,"You are given a list of `N` integers. Your task is to read these integers into a 1D array and then print them out in reverse order, separated by spaces.

For example, if the input integers are `10 20 30`, you should print `30 20 10`.","*   `1 <= N <= 100` (The number of integers will be between 1 and 100)
*   Each integer will be between `1` and `1000`.","3
10 20 30


####",30 20 10,"Input: 1
50
Output: 50
Input: 2
100 200
Output: 200 100
Input: 5
1 2 3 4 5
Output: 5 4 3 2 1
Input: 4
99 88 77 66
Output: 66 77 88 99",,,,,,
White-63,Modulo Arithmetic,,"Imagine a 24-hour clock. Given the current hour and a number of hours that will pass, your task is to determine what the hour will be after the duration has passed. The clock operates from 0 to 23 (e.g., 0 is midnight, 13 is 1 PM, 23 is 11 PM).","*   `0 <= current_hour <= 23`
*   `0 <= duration_hours <= 1000`
*   The final hour should also be between 0 and 23.","**

10
5

This means `current_hour = 10` and `duration_hours = 5`.

**","**

15","Input: 0
0
Output: 0
Input: 23
1
Output: 0
Input: 12
24
Output: 12
Input: 5
40
Output: 21
Input: 1
1000
Output: 17",,,,,,
White-64,Modulo Arithmetic,,"You are given three positive integers: `a`, `b`, and `m`. Your task is to find the sum of `a` and `b`, and then calculate the remainder when this sum is divided by `m`. In mathematical terms, you need to compute `(a + b) % m`.","*   `1 <= a, b, m <= 1000`","**
`a = 5`
`b = 7`
`m = 5`

**","**
`2`

**","Input: 1 1 10
Output: 2
Input: 5 5 10
Output: 0
Input: 9 8 5
Output: 2
Input: 1 1 1
Output: 0
Input: 1000 1000 999
Output: 2",,,,,,
White-65,Modulo Arithmetic,,"You are given two integers, `a` and `b`, and a modulus `m`. Your task is to calculate the sum of `a` and `b`, and then find the remainder when this sum is divided by `m`. In mathematical terms, you need to compute `(a + b) % m`.","* `0 <= a, b <= 10^9`
* `1 <= m <= 10^9`","5
7
3

####","0

####","Input: 10
15
7
Output: 4
Input: 1
1
2
Output: 0
Input: 1000000000
1000000000
999999999
Output: 2
Input: 0
0
5
Output: 0",,,,,,
White-66,Intro to Time & Space Complexity,,"You're given a positive integer `N`. Your task is to calculate the sum of all positive integers from 1 up to `N` (inclusive).

For example, if `N` is 3, the sum would be 1 + 2 + 3 = 6.",* `1 <= N <= 1000`,"3

####",6,"Input: 1
Output: 1
Input: 5
Output: 15
Input: 10
Output: 55
Input: 100
Output: 5050",,,,,,
White-67,Intro to Time & Space Complexity,,You are given an array of integers. Your task is to calculate the sum of all its elements. This is a great starting point to understand how to iterate through data structures and analyze the resources your code uses.,"* The array will contain between 1 and 100 integers, inclusive.
* Each integer in the array will be between -100 and 100, inclusive.","3
1 2 3


####","6


####","Input: 5
10 20 30 40 50
Output: 150
Input: 1
-7
Output: -7
Input: 4
-1 -2 -3 -4
Output: -10
Input: 2
0 0
Output: 0",,,,,,
White-68,Input/Output,,"You are given a single integer as input. Your task is to read this integer, calculate its square (the number multiplied by itself), and then print the result to standard output.

This problem is designed to introduce you to basic input/output operations and simple arithmetic in your chosen programming language.",*   The input integer `N` will be between 1 and 1000 (inclusive).,"5


####",25,"Input: 1
Output: 1
Input: 10
Output: 100
Input: 1000
Output: 1000000
Input: 50
Output: 2500",,,,,,
White-69,Best/Worst/Average Case Basics,,"You are given an array of integers and a target integer. Your task is to implement a linear search algorithm to find the target in the array. In addition to returning the index of the target (or -1 if not found), you must also count the total number of comparisons made during the search.

This problem helps you understand the concepts of Best, Worst, and Average case time complexity by observing how the number of comparisons changes based on the target's position.","- The array `nums` will have a length `N` between 1 and 100.
- Each element `nums[i]` will be an integer between -100 and 100.
- The target integer `target` will be between -100 and 100.","**
N = 5
nums = [10, 20, 30, 40, 50]
target = 30

**","**
Found at index 2 in 3 comparisons

**Input:**
N = 4
nums = [5, 15, 25, 35]
target = 40

**","Input:
7
1 2 3 4 5 6 7
1
Output:
Found at index 0 in 1 comparisons
Input:
5
-10 -5 0 5 10
10
Output:
Found at index 4 in 5 comparisons
Input:
6
100 90 80 70 60 50
45
Output:
Not found in 6 comparisons
Input:
1
42
42
Output:
Found at index 0 in 1 comparisons
Input:
1
42
99
Output:
Not found in 1 comparisons",,,,,,
White-70,String Reversal,,"Your task is to write a program that takes a given string and reverses the order of its characters. For example, if the input is ""hello"", the output should be ""olleh"". This is a fundamental problem that helps build a strong understanding of string manipulation and iteration.","*   The input string will contain printable ASCII characters (letters, numbers, symbols, and spaces).
*   The length of the input string will be between 0 and 1000 characters, inclusive.
*   An empty string should remain an empty string.",hello,"olleh



Input: world","Input: racecar
Output: racecar
Input: a
Output: a
Input: 
Output: 
Input: Hello World!
Output: !dlroW olleH
Input: 123456789
Output: 987654321",,,,,,
White-71,Bitwise Operators,,"You are given an integer `num` and a non-negative integer `n`. Your task is to toggle (flip) the `n`-th bit of `num` and return the new integer. The `n`-th bit is 0-indexed, meaning the 0-th bit is the rightmost (least significant) bit.","*   `0 <= num <= 10^9`
*   `0 <= n <= 30`","**

num = 4
n = 1


**Explanation:**
1.  The decimal number `4` in binary is `...0100`.
2.  The `n`-th bit is the 1st bit (0-indexed). In `...0100`, the 1st bit is currently `0`.
3.  To toggle this bit means to flip its value from `0` to `1`.
4.  After flipping, the binary representation becomes `...0110`.
5.  The binary `...0110` is `6` in decimal.

**","**

6","Input: 7 0
Output: 6
Input: 10 3
Output: 2
Input: 0 5
Output: 32
Input: 25 2
Output: 29
Input: 1 0
Output: 0",,,,,,
White-72,"Operators (Arithmetic, Relational, Logical)",,"You are given three integers: `num1`, `num2`, and `num3`. Your task is to perform two distinct calculations and print their results.

1.  **Arithmetic Calculation**: Calculate the value of `(num1 + num2) * num3`.
2.  **Logical Calculation**: Evaluate the boolean expression `(num1 > num2) && (num2 < num3)`.

Print the result of the arithmetic calculation on the first line, and the result of the logical calculation (as `true` or `false` or their equivalent in the respective language, e.g., `1` or `0` for C/C++, `True` or `False` for Python) on the second line.","- `1 <= num1, num2, num3 <= 1000`","10
5
20

####","300
true

####","Input: 1
2
3
Output: 9
false
Input: 100
50
25
Output: 3750
false
Input: 7
7
7
Output: 98
false
Input: 1000
1
500
Output: 500500
true",,,,,,
White-73,Prime Check,,"You've been tasked with a critical mission: to determine if a given positive integer is a prime number. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Your program should read an integer and output ""Yes"" if it's prime, and ""No"" otherwise.","*   `1 <= N <= 1,000,000`","**
7

**","**
Yes

**Input:**
10

**","Input: 1
Output: No
Input: 2
Output: Yes
Input: 4
Output: No
Input: 13
Output: Yes
Input: 999983
Output: Yes",,,,,,
White-74,Parameters & Arguments,,Write a program that takes a string and an integer as input. The program should then print the given string the specified number of times.,"*   The input string will not contain any newlines.
*   The integer will be a non-negative integer.",Hello 3,"Hello
Hello
Hello","Input: Test 2
Output:
Test
Test
Input: Code 4
Output:
Code
Code
Code
Code
Input: Hello_World 1
Output:
Hello_World
Input: Empty 0
Output:
",,,,,,
White-75,Break & Continue,,"Given an integer `limit` and an integer `skip_value`, print all numbers from 1 to `limit` (inclusive), skipping the multiples of `skip_value`.","*   `1 <= limit <= 100`
*   `1 <= skip_value <= 10`",,,"Input: 10 3
Output: 1 2 4 5 7 8 10
Input: 15 5
Output: 1 2 3 4 6 7 8 9 11 12 13 14
Input: 7 2
Output: 1 3 5 7
Input: 5 1
Output: 
Input: 20 4
Output: 1 2 3 5 6 7 9 10 11 13 14 15 17 18 19",,,,,,
White-76,Type Casting,,"You are given an integer `A` and a double-precision floating-point number `B`. Your task is to perform specific type conversions and calculations:

1.  **Integer to Double:** Convert integer `A` to a `double` and store it in a new variable, say `double_A`.
2.  **Double to Integer:** Convert double `B` to an `integer` (truncating any decimal part) and store it in a new variable, say `int_B`.
3.  **Double Sum:** Calculate the sum of `double_A` (the converted `A`) and the original `double B`. Store this in `double_sum`.
4.  **Integer Sum:** Calculate the sum of the original `integer A` and `int_B` (the converted `B`). Store this in `int_sum`.

Finally, print the four resulting values (`double_A`, `int_B`, `double_sum`, `int_sum`) in the order specified, each on a new line. Floating-point numbers should be printed with two decimal places.","- `-1000 <= A <= 1000`
- `-1000.0 <= B <= 1000.0`
- Input will consist of a single line with `A` followed by `B`, separated by a space.",`10 5.75`,"10.00
5
15.75
15","Input: -7 3.14
Output: -7.00
3
-3.86
-4
Input: 0 0.99
Output: 0.00
0
0.99
0
Input: 999 999.99
Output: 999.00
999
1998.99
1998
Input: -1000 -10.5
Output: -1000.00
-10
-1010.50
-1010",,,,,,
White-77,Intro to Time & Space Complexity,,"Imagine you're tracking scores in a game, and you want to know how many players scored above a certain benchmark. Your task is to implement a function that takes a list of integer scores and a threshold integer. It should return the total count of scores that are strictly greater than the given threshold.","*   `1 <= N <= 100` (where `N` is the number of scores in the input list)
*   `0 <= score[i] <= 1000` (each individual score will be between 0 and 1000)
*   `0 <= threshold <= 1000` (the threshold will also be between 0 and 1000)","**
`scores = [10, 20, 5, 30, 15]`
`threshold = 12`

**","**
`3`

**","Input: 5
1 2 3 4 5
0
Output: 5
Input: 3
100 200 300
500
Output: 0
Input: 4
7 7 7 7
7
Output: 0
Input: 1
50
49
Output: 1
Input: 10
10 20 30 40 50 60 70 80 90 100
75
Output: 3",,,,,,
White-78,Variables & Data Types,,"Welcome, White Belt! In this problem, you'll practice one of the most fundamental concepts in programming: using variables to store different types of data and then displaying them. Your task is to read three distinct pieces of information from the user:
1. An integer number.
2. A floating-point number (a number with decimals).
3. A single word (a string).

After reading these inputs, you must store each of them in a variable of the appropriate data type. Finally, you will print all the stored values back to the console, following a specific format, and also show the integer value incremented by one.","*   The integer number will be between 1 and 100 (inclusive).
*   The floating-point number will be between 0.0 and 100.0 (inclusive).
*   The string will be a single word, containing only alphabetical characters, with a maximum length of 10 characters.","10
3.14
Hello


####","You entered:
Integer: 10
Float: 3.14
String: Hello
Next Integer: 11","Input: 5
1.23
World
Output: You entered:
Integer: 5
Float: 1.23
String: World
Next Integer: 6
Input: 99
99.99
Test
Output: You entered:
Integer: 99
Float: 99.99
String: Test
Next Integer: 100
Input: 1
0.0
Start
Output: You entered:
Integer: 1
Float: 0.00
String: Start
Next Integer: 2
Input: 50
25.5
MidPoint
Output: You entered:
Integer: 50
Float: 25.50
String: MidPoint
Next Integer: 51",,,,,,
White-79,Intro to Recursion (factorial),,"Welcome to your first dive into the world of recursion! Your task is to calculate the factorial of a given non-negative integer `n`. The factorial of a non-negative integer `n`, denoted by `n!`, is the product of all positive integers less than or equal to `n`. For example, `5! = 5 × 4 × 3 × 2 × 1 = 120`. A special case is `0!`, which is defined as `1`.

You must implement the factorial calculation **recursively**. This means your function should call itself to solve smaller sub-problems until it reaches a simple base case.","*   `0 <= n <= 12`
*   The input `n` will always be a non-negative integer.
*   The result will fit within a standard 64-bit integer type (like `long long` in C++ or `long` in Java).","**

5


**","**

120","Input: 0
Output: 1
Input: 1
Output: 1
Input: 3
Output: 6
Input: 7
Output: 5040
Input: 10
Output: 3628800",,,,,,
White-80,Function Definition & Call,,"You need to write a program that calculates a ""doubled sum"". Specifically, your program should read two integers, calculate their sum, and then multiply that sum by 2. This core logic must be encapsulated within a function. Your main program will read the inputs, call this function, and print the result.",- The input integers `num1` and `num2` will be between -1000 and 1000.,"5
3",16,"Input: 10
20
Output: 60
Input: -5
-3
Output: -16
Input: 10
-7
Output: 6
Input: 0
0
Output: 0
Input: 15
0
Output: 30",,,,,,
White-81,Return Values,,"You've been hired by a magical shop that specializes in duplicating items! Your first task is to write a program that calculates the ""doubled value"" of any given integer.

Specifically, you need to create a function that takes one integer as input, multiplies it by 2, and then returns the result. Your `main` (or equivalent) function should read an integer, call your duplicating function, and print the returned doubled value.","*   The input integer `N` will be between -1000 and 1000, inclusive.","5

####","10


####","Input: -7
Output: -14
Input: 0
Output: 0
Input: 500
Output: 1000
Input: -499
Output: -998",,,,,,
White-85,Type Casting,,"Welcome, White Belt coder! In this problem, you'll explore the fundamental concept of ""type casting,"" which is how you convert data from one type to another. You will be given two numbers: an integer and a floating-point number (decimal). Your task is to perform two specific type conversions and print the results.

Specifically, you need to:
1. Convert the given integer into a floating-point number.
2. Convert the given floating-point number into an integer.

Pay attention to how different languages handle these conversions and potential data loss when converting from a floating-point number to an integer.","- The input integer `N` will be within the range of standard integer types (e.g., -2 * 10^9 to 2 * 10^9).
- The input floating-point number `D` will be within the range of standard double/float types (e.g., -10^18 to 10^18).
- Inputs will always be valid numbers.","**
15
5.75

**","**
15.000000
5

_Note: The number of decimal places for the float output might vary slightly by language, but the value should be equivalent. We will aim for 6 decimal places where possible._","Input:
-10
-3.14
Output:
-10.000000
-3
Input:
0
0.0
Output:
0.000000
0
Input:
2147483647
12345.6789
Output:
2147483647.000000
12345
Input:
99
4.999999
Output:
99.000000
4
Input:
-5
9.123
Output:
-5.000000
9",,,,,,
Yellow-2,Insertion Sort,,"You are given an unsorted array of integers. Your task is to sort this array in ascending order using the Insertion Sort algorithm.

Insertion Sort works by taking one element at a time from the unsorted part and inserting it into its correct position within the already sorted part of the array. This process continues until all elements are in their sorted positions.","- `1 <= n <= 1000` (where `n` is the number of elements in the array)
- `-1000 <= arr[i] <= 1000` (where `arr[i]` is an element in the array)
- The input array will contain only integers.","6
5 2 4 6 1 3

####",1 2 3 4 5 6,"Input: 5
1 2 3 4 5
Output: 1 2 3 4 5
Input: 5
5 4 3 2 1
Output: 1 2 3 4 5
Input: 5
4 2 1 4 3
Output: 1 2 3 4 4
Input: 1
7
Output: 7
Input: 4
-3 0 -1 2
Output: -3 -1 0 2",,,,,,
White-88,"Operators (Arithmetic, Relational, Logical)",,"You are given two integers, `num1` and `num2`. Your task is to determine if both numbers collectively satisfy a specific set of criteria. You need to combine the results of several individual checks using logical operators.

The conditions are:
1.  `num1` must be an even number.
2.  `num2` must be a positive number (strictly greater than 0).
3.  The sum of `num1` and `num2` must be strictly less than 50.
4.  The product of `num1` and `num2` must be strictly greater than 0.

If all four conditions are met, your function should return `true`. Otherwise, it should return `false`.","*   `num1` and `num2` will be integers.
*   `-100 <= num1, num2 <= 100`","**

10
5


**","**

true


**","Input: 7
10
Output: false
Input: 4
-2
Output: false
Input: 20
30
Output: false
Input: 8
0
Output: false
Input: 2
20
Output: true",,,,,,
White-89,"Array, String",,"Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.

A string is represented by an array if the array elements concatenated in order forms the string.

Example 1:

Input: word1 = [""ab"", ""c""], word2 = [""a"", ""bc""]
Output: true
Explanation:
word1 represents string ""ab"" + ""c"" -> ""abc""
word2 represents string ""a"" + ""bc"" -> ""abc""
The strings are the same, so return true.

Example 2:

Input: word1 = [""a"", ""cb""], word2 = [""ab"", ""c""]
Output: false

Example 3:

Input: word1  = [""abc"", ""d"", ""defg""], word2 = [""abcddefg""]
Output: true

Constraints:

	1 3
	1 3
	1 3
	word1[i] and word2[i] consist of lowercase letters.",,,,"[""ab"", ""c""]
[""a"", ""bc""]
[""a"", ""cb""]
[""ab"", ""c""]
[""abc"", ""d"", ""defg""]
[""abcddefg""]",,,,,,
DELETE-89-check-if-two-string-arrays-are-equivalent,Deletion,N/A,Deleted folder: 89-check-if-two-string-arrays-are-equivalent,N/A,N/A,N/A,N/A,,,,,,
White-89,"Array, String, String Matching",,"Given an array of string words, return all strings in words that are a substring of another word. You can return the answer in any order.

Example 1:

Input: words = [""mass"",""as"",""hero"",""superhero""]
Output: [""as"",""hero""]
Explanation: ""as"" is substring of ""mass"" and ""hero"" is substring of ""superhero"".
[""hero"",""as""] is also a valid answer.

Example 2:

Input: words = [""leetcode"",""et"",""code""]
Output: [""et"",""code""]
Explanation: ""et"", ""code"" are substring of ""leetcode"".

Example 3:

Input: words = [""blue"",""green"",""bu""]
Output: []
Explanation: No string of words is substring of another string.

Constraints:

	1 
	1 
	words[i] contains only lowercase English letters.
	All the strings of words are unique.",,,,"[""mass"",""as"",""hero"",""superhero""]
[""leetcode"",""et"",""code""]
[""blue"",""green"",""bu""]",,,,,,
White-90,GCD/LCM,,"You are given two positive integers, `a` and `b`. Your task is to find their Greatest Common Divisor (GCD) and Least Common Multiple (LCM).

The Greatest Common Divisor (GCD) of two integers is the largest positive integer that divides both numbers without leaving a remainder. For example, the GCD of 12 and 18 is 6.

The Least Common Multiple (LCM) of two integers is the smallest positive integer that is a multiple of both numbers. For example, the LCM of 12 and 18 is 36.

You need to output both GCD and LCM for the given pair of numbers.","*   `1 <= a, b <= 10^5`
*   `a` and `b` are positive integers.","12 18

####","GCD: 6
LCM: 36","Input: 7 13
Output: GCD: 1
LCM: 91
Input: 100 75
Output: GCD: 25
LCM: 300
Input: 48 36
Output: GCD: 12
LCM: 144
Input: 5 5
Output: GCD: 5
LCM: 5",,,,,,
White-91,"Loops (for, while)",,"You are tasked with writing a program that calculates the sum of all even numbers up to a given positive integer `N`, inclusive. For example, if `N` is 7, the even numbers within the range [1, 7] are 2, 4, and 6, and their sum is 12.",* `1 <= N <= 1000`,"**

7

**","**

12","Input: 1
Output: 0
Input: 2
Output: 2
Input: 10
Output: 30
Input: 99
Output: 2450
Input: 1000
Output: 250500",,,,,,
Yellow-3,2D Arrays / Matrix Operations,,"You are given a 2D integer array (matrix). Your task is to calculate the sum of all elements that lie on the perimeter of the matrix. The perimeter includes all elements in the first row, last row, first column, and last column. Be careful not to double-count elements that are part of multiple perimeter segments (i.e., the corner elements).","*   `1 <= rows, cols <= 100` (where `rows` is the number of rows and `cols` is the number of columns).
*   `-1000 <= matrix[i][j] <= 1000` (elements can be positive, negative, or zero).","3 3
1 2 3
4 5 6
7 8 9

####","40


####","Input: 1 1
5
Output: 5
Input: 1 4
10 20 30 40
Output: 100
Input: 4 1
1
2
3
4
Output: 10
Input: 2 2
1 2
3 4
Output: 10
Input: 4 3
1 -2 3
4 5 6
7 8 9
-10 11 -12
Output: 1",,,,,,
Yellow-4,Sliding Window Intro,,You are given an array of integers `arr` and an integer `k`. Your task is to find the maximum sum of a subarray of `arr` that has a length exactly `k`. This means you need to consider all possible contiguous subarrays of size `k` and determine which one has the largest sum.,"*   `1 <= arr.length <= 10^5`
*   `1 <= k <= arr.length`
*   `0 <= arr[i] <= 1000` (Elements are non-negative to keep it simple for an intro problem)
*   The sum of any subarray will fit within a standard integer type.","**

6
2 1 5 1 3 2
3

**","**

9


**","Input: 5
1 2 3 4 5
3
Output: 12
Input: 1
100
1
Output: 100
Input: 7
10 2 3 4 5 6 7
4
Output: 22
Input: 8
1 1 1 1 1 1 1 1
2
Output: 2
Input: 6
1 2 3 4 5 0
3
Output: 12",,,,,,
Yellow-5,Doubly Linked List basics,,"You're tasked with enhancing a Doubly Linked List (DLL) by implementing a function to append a new node to its very end. Given the head and tail of an existing DLL (which might be empty) and an integer value, your goal is to create a new node with this value and add it as the new tail of the list. Remember to correctly update all `next` and `prev` pointers, including those of the old tail (if it exists) and the new node itself.","*   The input list can be empty.
*   The number of nodes `N` in the initial list will be between `0` and `1000`.
*   The value `V` to insert will be an integer between `-10^9` and `10^9`.
*   The `head` and `tail` pointers should always correctly point to the beginning and end of the list, respectively, after the operation.","**

1 2 3
4

(Initial DLL: `1 <-> 2 <-> 3`, Value to insert: `4`)

**","**

1 <-> 2 <-> 3 <-> 4


#### Example 2:
**Input:**

EMPTY
5

(Initial DLL: `Empty List`, Value to insert: `5`)

**","Input: 10
20
Output: 10 <-> 20
Input: 1 2 3 4 5
0
Output: 1 <-> 2 <-> 3 <-> 4 <-> 5 <-> 0
Input: -5 -4 -3
-2
Output: -5 <-> -4 <-> -3 <-> -2
Input: 7
7
Output: 7 <-> 7",,,,,,
Yellow-6,Stack Implementation (Array/LL),,"Your mission is to implement a basic Stack data structure that supports four fundamental operations: `push`, `pop`, `top`, and `isEmpty`. You will receive a sequence of commands, and your program must process them, outputting results for `pop`, `top`, and `isEmpty` operations.

The stack should adhere to the Last-In, First-Out (LIFO) principle. For operations that attempt to `pop` or retrieve `top` from an empty stack, a specific error value (`-1`) should be returned. Similarly, `push` operations should handle the case where the stack is at its maximum capacity.","*   The stack will have a maximum capacity of `1000` elements.
*   The number of operations `N` will be between `1` and `1000`.
*   Values pushed onto the stack will be integers between `-10^9` and `10^9`.
*   Operations will be one of the following strings:
    *   `push <value>`: Adds `value` to the top of the stack.
    *   `pop`: Removes and returns the top element.
    *   `top`: Returns the top element without removing it.
    *   `isEmpty`: Returns `true` if the stack is empty, `false` otherwise.","8
push 10
push 20
pop
top
isEmpty
pop
pop
isEmpty


####","20
10
false
10
-1
true","Input: 3
pop
top
isEmpty
Output: -1
-1
true
Input: 12
push 1
push 2
push 3
push 4
push 5
push 6
top
pop
top
pop
top
pop
isEmpty
Output: 5
5
4
4
3
3
false
Input: 7
push 100
pop
isEmpty
push 200
top
pop
isEmpty
Output: 100
true
200
200
true",,,,,,
Yellow-7,Bubble Sort,,"You are given an array of integers. Your task is to sort this array in ascending order using the Bubble Sort algorithm.

Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted.","*   `1 <= N <= 1000` (where N is the number of elements in the array)
*   `-10^9 <= array[i] <= 10^9`
*   The array may contain duplicate elements.","**

5
5 1 4 2 8


**","**

1 2 4 5 8","Input: 5
1 2 3 4 5
Output: 1 2 3 4 5
Input: 5
5 4 3 2 1
Output: 1 2 3 4 5
Input: 7
3 1 4 1 5 9 2
Output: 1 1 2 3 4 5 9
Input: 1
42
Output: 42
Input: 2
7 3
Output: 3 7",,,,,,
Yellow-8,Bubble Sort,,"You've been given an array of integers. Your task is to sort this array in ascending order using the Bubble Sort algorithm. Bubble sort works by repeatedly stepping through the list, comparing adjacent elements and swapping them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted.","*   The number of elements `n` in the array will be between 1 and 1000.
*   Each element `arr[i]` will be an integer between -10000 and 10000.","`[5, 1, 4, 2, 8]`","`[1, 2, 4, 5, 8]`

**","Input: 5
1 2 3 4 5
Output: 1 2 3 4 5
Input: 5
5 4 3 2 1
Output: 1 2 3 4 5
Input: 8
3 1 4 1 5 9 2 6
Output: 1 1 2 3 4 5 6 9
Input: 1
7
Output: 7
Input: 5
-5 0 -2 3 1
Output: -5 -2 0 1 3",,,,,,
Yellow-9,Bubble Sort,,"You are tasked with sorting an array of integers in ascending order using the Bubble Sort algorithm. Bubble Sort is a simple comparison-based sorting algorithm. It works by repeatedly stepping through the list, comparing adjacent elements and swapping them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted.

Your program should read an integer `N`, followed by `N` integers representing the elements of the array. It should then apply Bubble Sort and print the sorted array.","*   `1 <= N <= 100`
*   `0 <= arr[i] <= 1000`","**

5
5 1 4 2 8


**","**

1 2 4 5 8","Input: 1
7
Output: 7
Input: 4
4 3 2 1
Output: 1 2 3 4
Input: 6
5 2 8 2 5 1
Output: 1 2 2 5 5 8
Input: 5
10 20 30 40 50
Output: 10 20 30 40 50
Input: 9
99 11 77 33 55 22 88 44 66
Output: 11 22 33 44 55 66 77 88 99",,,,,,
Yellow-10,Selection Sort,,You are given an array of integers. Your task is to sort this array in ascending order using the Selection Sort algorithm. Selection Sort works by repeatedly finding the minimum element from the unsorted part and putting it at the beginning of the unsorted part.,"* `1 <= n <= 1000` (where `n` is the number of elements in the array)
* `-1000 <= arr[i] <= 1000`
* The array may contain duplicate elements.","**
`[64, 25, 12, 22, 11]`

**","**
`[11, 12, 22, 25, 64]`

**","Input: 5
1 2 3 4 5
Output: 1 2 3 4 5
Input: 7
5 4 3 2 1 0 -1
Output: -1 0 1 2 3 4 5
Input: 6
4 2 1 4 3 5
Output: 1 2 3 4 4 5
Input: 4
-5 -2 0 -10
Output: -10 -5 -2 0
Input: 1
7
Output: 7",,,,,,
White-92,Intro to Time & Space Complexity,,"You are given a list (or array) of whole numbers. Your task is to find the single largest number within this list. For example, if the list is `[3, 1, 7, 4, 2]`, the largest number is `7`.","*   The input array will contain at least one element.
*   The number of elements in the array (N) will be between 1 and 1000.
*   Each element in the array will be an integer between -1000 and 1000.","**

5
5 2 9 1 7


**","**

9","Input: 5
10 20 5 30 15
Output: 30
Input: 3
-5 -1 -10
Output: -1
Input: 1
100
Output: 100
Input: 7
7 7 7 7 7 7 7
Output: 7
Input: 4
-10 0 10 -20
Output: 10",,,,,,
White-93,LeetCode,,,,,,"Input: [1,2,0]
Output: [0,1,2],Input: [2,0,1,0]
Output: [0,0,1,2],Input: [0,1,2,0,1,2]
Output: [0,0,1,1,2,2],Input: [2,1,0,1,2,0]
Output: [0,0,1,1,2,2],Input: []
Output: []",,,,,,
,,,,,,,,,,,,,
White-93,1D Array Declaration & Traversal,,"Given an integer array, traverse the array and print each element.","- The array will contain at least one element.
- The array will contain only integers.
- The maximum size of the array is 100.","[1, 2, 3, 4, 5]",1 2 3 4 5,"Input: [1, 2, 3]
Output: 1 2 3,Input: [10, 20, 30, 40, 50]
Output: 10 20 30 40 50,Input: [-1, 0, 1]
Output: -1 0 1,Input: [5, 4, 3, 2, 1]
Output: 5 4 3 2 1",,,,,,
Yellow-11,Naive Pattern Search,"- String manipulation
- Basic iteration
- Algorithm implementation
- Pattern matching","Implement a naive pattern searching algorithm to find all occurrences of a pattern within a text string.  The algorithm should iterate through the text and compare each character to the pattern. If a mismatch occurs, it moves to the next character in the text. If a match is found, the index of the match is recorded.","- The text and pattern will only contain lowercase English alphabet characters ('a' - 'z').
- The pattern's length will be less than or equal to the text's length.
- The pattern can appear multiple times in the text, possibly overlapping.",,,"Input: text = ""abcabcabc"", pattern = ""abc""
Output: [0, 3, 6],Input: text = ""abababab"", pattern = ""aba""
Output: [0, 2, 4],Input: text = ""hello world"", pattern = ""world""
Output: [6],Input: text = ""aaaa"", pattern = ""aa""
Output: [0, 1, 2],Input: text = ""mississippi"", pattern = ""issi""
Output: [4]",,,,,,
Yellow-11,Naive Pattern Search,,"Implement a naive pattern searching algorithm to find all occurrences of a pattern within a text string.  The algorithm should iterate through the text and compare each character to the pattern. If a mismatch occurs, it moves to the next character in the text. If a match is found, the index of the match is recorded.","- The text and pattern will only contain lowercase English alphabet characters ('a' - 'z').
- The pattern's length will be less than or equal to the text's length.
- The pattern can appear multiple times in the text, possibly overlapping.",,,"Input: text = ""abcabcabc"", pattern = ""abc""
Output: [0, 3, 6],Input: text = ""abababab"", pattern = ""aba""
Output: [0, 2, 4],Input: text = ""hello world"", pattern = ""world""
Output: [6],Input: text = ""aaaa"", pattern = ""aa""
Output: [0, 1, 2],Input: text = ""mississippi"", pattern = ""issi""
Output: [4]",,,,,,
Yellow-12,Recursive Power Function,"- Recursion
- Handling negative exponents
- Floating-point arithmetic",Write a function that calculates x raised to the power of n (xⁿ) recursively.  Handle both positive and negative exponents.,"- -100 ≤ x ≤ 100
- -10 ≤ n ≤ 10
- x != 0 when n < 0","x = 2, n = 3","8

Input: x = 5, n = -2","Input: 2 3
Output: 8.00
Input: 5 -2
Output: 0.04
Input: 3 0
Output: 1.00
Input: -2 3
Output: -8.00
Input: 10 2
Output: 100.00",,,,,,
Yellow-12,Recursive Power Function,,Write a function that calculates x raised to the power of n (xⁿ) recursively.  Handle both positive and negative exponents.,"- -100 ≤ x ≤ 100
- -10 ≤ n ≤ 10
- x != 0 when n < 0","x = 2, n = 3","8

Input: x = 5, n = -2","Input: 2 3
Output: 8.00
Input: 5 -2
Output: 0.04
Input: 3 0
Output: 1.00
Input: -2 3
Output: -8.00
Input: 10 2
Output: 100.00",,,,,,
Yellow-14,Binary Search,"*   **Binary Search**: This problem asks for the *minimum* `k` that satisfies a certain condition. The time it takes to eat all bananas is a monotonically decreasing function with respect to `k` (i.e., faster `k` means less time). This property makes it a perfect candidate for binary search on the answer space.
*   **Ceiling Division**: When calculating the time taken to eat a pile of `p` bananas at speed `k`, if `p` is not perfectly divisible by `k`, Koko still spends a full hour on the remaining bananas. This is equivalent to `ceil(p / k)`. In integer arithmetic, `ceil(a / b)` can be calculated as `(a + b - 1) / b` for positive integers `a` and `b`.
*   **Time Complexity Analysis**: Understanding how to calculate the overall time taken for an algorithm, considering the number of operations.
*   **Space Complexity Analysis**: Understanding the memory usage of an algorithm, excluding the input storage.","Koko loves to eat bananas. There are `n` piles of bananas, and the `i`-th pile has `piles[i]` bananas. Koko has to eat all the bananas within `h` hours.

Koko decides her eating speed `k` (bananas per hour). Each hour, she chooses one pile and eats `k` bananas from it. If a pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during that hour. She cannot start eating from a different pile in the same hour.

Koko wants to eat all the bananas, but she also wants to be slow enough to avoid suspicion. Your task is to find the minimum integer eating speed `k` such that she can eat all the bananas within `h` hours.","* `1 <= piles.length <= 10^4`
* `1 <= piles[i] <= 10^9`
* `piles.length <= h <= 10^9`","piles = [3,6,7,11]
h = 8",4,"Input: 4
3 6 7 11
8
Output: 4,Input: 5
30 11 23 4 20
5
Output: 30,Input: 5
30 11 23 4 20
6
Output: 23,Input: 1
1000000000
1
Output: 1000000000,Input: 4
1 1 1 999999999
10
Output: 142857143",,,,,,
Yellow-15,Frequency Count / Anagrams,"- Frequency Counting
- Character Arrays / Hash Maps
- String Manipulation","An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. For example, ""listen"" is an anagram of ""silent"".

Your task is to implement a function that determines if two given strings are anagrams of each other. The strings will consist only of lowercase English letters.","- Both input strings, `s1` and `s2`, will contain only lowercase English letters ('a'-'z').
- The length of `s1` and `s2` will be between 0 and 10^5 characters, inclusive.","s1 = ""rat""
s2 = ""art""",TRUE,"Input: listen
silent
Output: true
Input: hello
world
Output: false
Input: a
a
Output: true
Input: abc
bca
Output: true
Input: abc
ab
Output: false
Input: """"
""""
Output: true","#include <stdio.h>
#include <string.h>
#include <stdbool.h>

#define ALPHABET_SIZE 26

// Function to check if two strings are anagrams
bool areAnagrams(const char* s1, const char* s2) {
    int len1 = strlen(s1);
    int len2 = strlen(s2);

    // If lengths are different, they cannot be anagrams
    if (len1 != len2) {
        return false;
    }

    // Frequency array for lowercase English letters
    int counts[ALPHABET_SIZE] = {0}; // Initialize all to 0

    // Increment counts for characters in s1
    for (int i = 0; i < len1; i++) {
        counts[s1[i] - 'a']++;
    }

    // Decrement counts for characters in s2
    for (int i = 0; i < len2; i++) {
        counts[s2[i] - 'a']--;
    }

    // Check if all counts are zero
    for (int i = 0; i < ALPHABET_SIZE; i++) {
        if (counts[i] != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    char s1_buffer[100001]; // Max length + 1 for null terminator
    char s2_buffer[100001];

    // Read input strings
    if (scanf(""%s"", s1_buffer) != 1) return 1;
    if (scanf(""%s"", s2_buffer) != 1) return 1;

    // Call the core logic function
    if (areAnagrams(s1_buffer, s2_buffer)) {
        printf(""true\n"");
    } else {
        printf(""false\n"");
    }

    return 0;
}","def are_anagrams(s1: str, s2: str) -> bool:
    # If lengths are different, they cannot be anagrams
    if len(s1) != len(s2):
        return False

    # Frequency array (list) for lowercase English letters
    counts = [0] * 26

    # Increment counts for characters in s1
    for char_code in map(ord, s1):
        counts[char_code - ord('a')] += 1

    # Decrement counts for characters in s2
    for char_code in map(ord, s2):
        counts[char_code - ord('a')] -= 1

    # Check if all counts are zero
    for count in counts:
        if count != 0:
            return False

    return True

def main():
    s1 = input()
    s2 = input()

    # Call the core logic function
    if are_anagrams(s1, s2):
        print(""true"")
    else:
        print(""false"")

if __name__ == ""__main__"":
    main()","import java.util.Scanner;

public class Solution {

    // Function to check if two strings are anagrams
    public static boolean areAnagrams(String s1, String s2) {
        // If lengths are different, they cannot be anagrams
        if (s1.length() != s2.length()) {
            return false;
        }

        // Frequency array for lowercase English letters
        int[] counts = new int[26]; // Initialize all to 0 by default

        // Increment counts for characters in s1
        for (char c : s1.toCharArray()) {
            counts[c - 'a']++;
        }

        // Decrement counts for characters in s2
        for (char c : s2.toCharArray()) {
            counts[c - 'a']--;
        }

        // Check if all counts are zero
        for (int count : counts) {
            if (count != 0) {
                return false;
            }
        }

        return true;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read input strings
        String s1 = scanner.next();
        String s2 = scanner.next();

        // Call the core logic function
        if (areAnagrams(s1, s2)) {
            System.out.println(""true"");
        } else {
            System.out.println(""false"");
        }

        scanner.close();
    }
}","// Function to check if two strings are anagrams
function areAnagrams(s1, s2) {
    // If lengths are different, they cannot be anagrams
    if (s1.length !== s2.length) {
        return false;
    }

    // Frequency array for lowercase English letters
    const counts = new Array(26).fill(0);

    // Increment counts for characters in s1
    for (let i = 0; i < s1.length; i++) {
        counts[s1.charCodeAt(i) - 'a'.charCodeAt(0)]++;
    }

    // Decrement counts for characters in s2
    for (let i = 0; i < s2.length; i++) {
        counts[s2.charCodeAt(i) - 'a'.charCodeAt(0)]--;
    }

    // Check if all counts are zero
    for (let i = 0; i < counts.length; i++) {
        if (counts[i] !== 0) {
            return false;
        }
    }

    return true;
}

// Main function to handle I/O
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let lines = [];
    rl.on('line', (line) => {
        lines.push(line);
    }).on('close', () => {
        const s1 = lines[0];
        const s2 = lines[1];

        // Call the core logic function
        if (areAnagrams(s1, s2)) {
            console.log(""true"");
        } else {
            console.log(""false"");
        }
    });
}

// Invoke the main function
main();","#include <iostream>
#include <string>
#include <vector>

// Function to check if two strings are anagrams
bool areAnagrams(const std::string& s1, const std::string& s2) {
    // If lengths are different, they cannot be anagrams
    if (s1.length() != s2.length()) {
        return false;
    }

    // Frequency array for lowercase English letters
    std::vector<int> counts(26, 0); // Initialize all to 0

    // Increment counts for characters in s1
    for (char c : s1) {
        counts[c - 'a']++;
    }

    // Decrement counts for characters in s2
    for (char c : s2) {
        counts[c - 'a']--;
    }

    // Check if all counts are zero
    for (int count : counts) {
        if (count != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    std::ios_base::sync_with_stdio(false); // Optimize C++ I/O
    std::cin.tie(NULL);

    std::string s1, s2;

    // Read input strings
    std::cin >> s1 >> s2;

    // Call the core logic function
    if (areAnagrams(s1, s2)) {
        std::cout << ""true\n"";
    } else {
        std::cout << ""false\n"";
    }

    return 0;
}",
Yellow-16,LeetCode,"*   **Arrays**: Understanding how to store and access collections of data.
*   **Sorted Arrays**: Leveraging the property that elements are in order to optimize solutions.
*   **Iteration**: Traversing through an array to examine each element.
*   **Counting**: Keeping track of how many elements satisfy a certain condition.
*   **Binary Search (Advanced)**: For larger inputs, a more efficient search algorithm can be used to quickly find an element or a position in a sorted array based on a condition. This problem can be optimally solved using binary search by cleverly identifying a monotonic property related to missing numbers.","You are given a **strictly increasing** array `arr` of positive integers and an integer `k`.

Your task is to find the `k`-th positive integer that is **missing** from the array. Positive integers start from `1`.

For example, if `arr = [2,3,4,7,11]` and `k = 5`:
The positive integers are `1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, ...`
Numbers present in `arr`: `2, 3, 4, 7, 11`
Missing positive integers in order: `1, 5, 6, 8, 9, 10, 12, ...`
The 1st missing is `1`.
The 2nd missing is `5`.
The 3rd missing is `6`.
The 4th missing is `8`.
The 5th missing is `9`.
So, the output for this example would be `9`.","*   `1 <= arr.length <= 1000`
*   `1 <= arr[i] <= 1000 + k`
*   `1 <= k <= 1000`
*   `arr` is sorted in strictly increasing order.
*   All elements in `arr` are distinct.","arr = [2,3,4,7,11], k = 5",9,"Input: 5
2 3 4 7 11
5
Output: 9,Input: 2
10 20
5
Output: 5,Input: 4
1 2 3 4
2
Output: 6,Input: 1
1
1
Output: 2,Input: 1
2
1
Output: 1","#include <stdio.h>
#include <stdlib.h>

int findKthPositive(int* arr, int arrSize, int k) {
    int low = 0;
    int high = arrSize - 1;
    
    while (low <= high) {
        int mid = low + (high - low) / 2;
        // Count of missing numbers before arr[mid]
        // If all numbers from 1 to arr[mid] were present, there would be arr[mid] numbers.
        // But we only have (mid + 1) numbers (arr[0] to arr[mid]).
        // So, arr[mid] - (mid + 1) gives the count of missing numbers.
        if (arr[mid] - (mid + 1) < k) {
            low = mid + 1; // Not enough missing numbers, look in the right half
        } else {
            high = mid - 1; // Enough missing numbers, try to find an earlier position
        }
    }
    
    // After the loop, 'low' will be the index where the k-th missing number would be.
    // The k-th missing number is simply 'low + k'.
    return low + k;
}

int main() {
    int arr_size, k;

    // Read arr_size
    scanf(""%d"", &arr_size);

    // Allocate memory for the array
    int* arr = (int*)malloc(arr_size * sizeof(int));

    // Read array elements
    for (int i = 0; i < arr_size; i++) {
        scanf(""%d"", &arr[i]);
    }

    // Read k
    scanf(""%d"", &k);

    // Call the function and print the result
    int result = findKthPositive(arr, arr_size, k);
    printf(""%d\n"", result);

    // Free allocated memory
    free(arr);

    return 0;
}","class Solution:
    def findKthPositive(self, arr: list[int], k: int) -> int:
        low = 0
        high = len(arr) - 1
        
        while low <= high:
            mid = low + (high - low) // 2
            # Count of missing numbers before arr[mid]
            # If all numbers from 1 to arr[mid] were present, there would be arr[mid] numbers.
            # But we only have (mid + 1) numbers (arr[0] to arr[mid]).
            # So, arr[mid] - (mid + 1) gives the count of missing numbers.
            if arr[mid] - (mid + 1) < k:
                low = mid + 1  # Not enough missing numbers, look in the right half
            else:
                high = mid - 1 # Enough missing numbers, try to find an earlier position
            
        # After the loop, 'low' will be the index where the k-th missing number would be.
        # The k-th missing number is simply 'low + k'.
        return low + k

def main():
    # Read array size
    n = int(input())
    # Read array elements
    arr = list(map(int, input().split()))
    # Read k
    k = int(input())

    sol = Solution()
    result = sol.findKthPositive(arr, k)
    print(result)

if __name__ == ""__main__"":
    main()","import java.util.Scanner;

class Solution {
    public int findKthPositive(int[] arr, int k) {
        int low = 0;
        int high = arr.length - 1;
        
        while (low <= high) {
            int mid = low + (high - low) / 2;
            // Count of missing numbers before arr[mid]
            // If all numbers from 1 to arr[mid] were present, there would be arr[mid] numbers.
            // But we only have (mid + 1) numbers (arr[0] to arr[mid]).
            // So, arr[mid] - (mid + 1) gives the count of missing numbers.
            if (arr[mid] - (mid + 1) < k) {
                low = mid + 1; // Not enough missing numbers, look in the right half
            } else {
                high = mid - 1; // Enough missing numbers, try to find an earlier position
            }
        }
        
        // After the loop, 'low' will be the index where the k-th missing number would be.
        // The k-th missing number is simply 'low + k'.
        return low + k;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read array size
        int n = scanner.nextInt();
        int[] arr = new int[n];

        // Read array elements
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        // Read k
        int k = scanner.nextInt();

        Solution sol = new Solution();
        int result = sol.findKthPositive(arr, k);
        System.out.println(result);

        scanner.close();
    }
}","/**
 * @param {number[]} arr
 * @param {number} k
 * @return {number}
 */
var findKthPositive = function(arr, k) {
    let low = 0;
    let high = arr.length - 1;
    
    while (low <= high) {
        let mid = Math.floor(low + (high - low) / 2);
        // Count of missing numbers before arr[mid]
        // If all numbers from 1 to arr[mid] were present, there would be arr[mid] numbers.
        // But we only have (mid + 1) numbers (arr[0] to arr[mid]).
        // So, arr[mid] - (mid + 1) gives the count of missing numbers.
        if (arr[mid] - (mid + 1) < k) {
            low = mid + 1; // Not enough missing numbers, look in the right half
        } else {
            high = mid - 1; // Enough missing numbers, try to find an earlier position
        }
    }
    
    // After the loop, 'low' will be the index where the k-th missing number would be.
    // The k-th missing number is simply 'low + k'.
    return low + k;
};

// Main function for handling input/output
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let inputLines = [];
    rl.on('line', (line) => {
        inputLines.push(line);
    }).on('close', () => {
        let n = parseInt(inputLines[0]);
        let arr = inputLines[1].split(' ').map(Number);
        let k = parseInt(inputLines[2]);

        let result = findKthPositive(arr, k);
        console.log(result);
    });
}

// Call main to start the program
if (require.main === module) {
    main();
}","#include <iostream>
#include <vector>
#include <numeric>

class Solution {
public:
    int findKthPositive(std::vector<int>& arr, int k) {
        int low = 0;
        int high = arr.size() - 1;
        
        while (low <= high) {
            int mid = low + (high - low) / 2;
            // Count of missing numbers before arr[mid]
            // If all numbers from 1 to arr[mid] were present, there would be arr[mid] numbers.
            // But we only have (mid + 1) numbers (arr[0] to arr[mid]).
            // So, arr[mid] - (mid + 1) gives the count of missing numbers.
            if (arr[mid] - (mid + 1) < k) {
                low = mid + 1; // Not enough missing numbers, look in the right half
            } else {
                high = mid - 1; // Enough missing numbers, try to find an earlier position
            }
        }
        
        // After the loop, 'low' will be the index where the k-th missing number would be.
        // The k-th missing number is simply 'low + k'.
        return low + k;
    }
};

int main() {
    int n, k;
    std::cin >> n; // Read array size

    std::vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i]; // Read array elements
    }

    std::cin >> k; // Read k

    Solution sol;
    int result = sol.findKthPositive(arr, k);
    std::cout << result << std::endl;

    return 0;
}",
White-95,Basic String Manipulation,"*   String iteration
*   Conditional logic (if/else statements)
*   Character case checking (e.g., `is_lower`, `is_upper`)
*   Character case conversion (e.g., `to_lower`, `to_upper`)","Your task is to implement a function that takes a string as input and returns a new string where the case of each alphabetic character is swapped. This means all lowercase letters should become uppercase, and all uppercase letters should become lowercase. Non-alphabetic characters (numbers, symbols, spaces) should remain unchanged.","*   The input string will have a length between 0 and 100 characters, inclusive.
*   The string will consist of ASCII characters.","** `Hello World!`
**",** `hELLO wORLD!`,"Input: DSA CHALLENGE
Output: dsa challenge
Input: programmingisfun
Output: PROGRAMMINGISFUN
Input: 123Abc_DEF456
Output: 123aBC_def456
Input: 
Output: 
Input: !@#$%^&*()
Output: !@#$%^&*()","#include <stdio.h>
#include <string.h>
#include <ctype.h> // For islower, isupper, tolower, toupper
#include <stdlib.h> // For malloc, free

// Function to swap the case of characters in a string
char* swapCase(const char* s) {
    if (s == NULL) {
        return NULL;
    }

    size_t len = strlen(s);
    char* result = (char*)malloc(sizeof(char) * (len + 1)); // +1 for null terminator
    if (result == NULL) {
        return NULL; // Memory allocation failed
    }

    for (size_t i = 0; i < len; i++) {
        if (islower((unsigned char)s[i])) {
            result[i] = (char)toupper((unsigned char)s[i]);
        } else if (isupper((unsigned char)s[i])) {
            result[i] = (char)tolower((unsigned char)s[i]);
        } else {
            result[i] = s[i];
        }
    }
    result[len] = '\0'; // Null-terminate the result string
    return result;
}

int main() {
    char input[101]; // Max 100 chars + null terminator
    if (fgets(input, sizeof(input), stdin) == NULL) {
        return 1; // Error reading input
    }

    // Remove trailing newline character if present
    input[strcspn(input, ""\n"")] = 0;

    char* output = swapCase(input);
    if (output != NULL) {
        printf(""%s\n"", output);
        free(output); // Free allocated memory
    } else {
        // Handle error (e.g., malloc failed)
        return 1;
    }

    return 0;
}","def swapCase(s: str) -> str:
    """"""
    Swaps the case of each alphabetic character in a string.
    Lowercase letters become uppercase, and uppercase letters become lowercase.
    Non-alphabetic characters remain unchanged.
    """"""
    result_chars = []
    for char in s:
        if char.islower():
            result_chars.append(char.upper())
        elif char.isupper():
            result_chars.append(char.lower())
        else:
            result_chars.append(char)
    return """".join(result_chars)

if __name__ == ""__main__"":
    input_string = input()
    output_string = swapCase(input_string)
    print(output_string)","import java.util.Scanner;

public class Solution {

    // Function to swap the case of characters in a string
    public static String swapCase(String s) {
        if (s == null || s.isEmpty()) {
            return s;
        }

        StringBuilder result = new StringBuilder(s.length());
        for (char c : s.toCharArray()) {
            if (Character.isLowerCase(c)) {
                result.append(Character.toUpperCase(c));
            } else if (Character.isUpperCase(c)) {
                result.append(Character.toLowerCase(c));
            } else {
                result.append(c);
            }
        }
        return result.toString();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String input = scanner.nextLine();
        String output = swapCase(input);
        System.out.println(output);
        scanner.close();
    }
}","function swapCase(s) {
    if (!s) {
        return s;
    }

    let result = '';
    for (let i = 0; i < s.length; i++) {
        const char = s[i];
        // Check if the character is an alphabetic character
        if (char >= 'a' && char <= 'z') {
            result += char.toUpperCase();
        } else if (char >= 'A' && char <= 'Z') {
            result += char.toLowerCase();
        } else {
            result += char;
        }
    }
    return result;
}

// Read input from stdin
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.on('line', (line) => {
    const output = swapCase(line);
    console.log(output);
    rl.close();
});","#include <iostream>
#include <string>
#include <cctype> // For islower, isupper, tolower, toupper

// Function to swap the case of characters in a string
std::string swapCase(const std::string& s) {
    std::string result = """";
    for (char c : s) {
        if (std::islower(c)) {
            result += static_cast<char>(std::toupper(c));
        } else if (std::isupper(c)) {
            result += static_cast<char>(std::tolower(c));
        } else {
            result += c;
        }
    }
    return result;
}

int main() {
    std::string input;
    std::getline(std::cin, input);
    std::string output = swapCase(input);
    std::cout << output << std::endl;
    return 0;
}",
White-96,Basic String Manipulation,"*   String iteration
*   Character comparison
*   Basic loops (for, while)
*   Variables for counting",You will be given a string `s` and a single character `c`. Your task is to count how many times the character `c` appears in the string `s`. The count should be case-sensitive.,"*   The input string `s` will consist of printable ASCII characters (excluding spaces).
*   The length of `s` will be between 1 and 1000 characters.
*   The target character `c` will be a single printable ASCII character.
*   The count is case-sensitive (e.g., 'a' is different from 'A').","s = ""programming""
c = 'g'","2

#### Example 2:","Input: programming
g
Output: 2

Input: Apple
a
Output: 0

Input: Mississippi
i
Output: 4

Input: hello
z
Output: 0

Input: AAAAA
A
Output: 5","#include <stdio.h>
#include <string.h>

// Function to count occurrences of a character in a string
int countChar(const char* s, char c) {
    int count = 0;
    int len = strlen(s);
    for (int i = 0; i < len; i++) {
        if (s[i] == c) {
            count++;
        }
    }
    return count;
}

int main() {
    char s[1001]; // Max length 1000 + null terminator
    char c;

    // Read the string (assumes no spaces based on constraints)
    scanf(""%s"", s);

    // Read the character, with a space before %c to consume any leftover whitespace (like newline)
    scanf("" %c"", &c);

    int result = countChar(s, c);

    printf(""%d\n"", result);

    return 0;
}","def count_char(s: str, c: str) -> int:
    """"""
    Counts the occurrences of a character in a string.
    """"""
    count = 0
    for char in s:
        if char == c:
            count += 1
    return count

if __name__ == ""__main__"":
    # Read the string (assumes no spaces based on constraints)
    s = input()

    # Read the character (input() reads a line, so c will be a string of length 1)
    c = input()

    result = count_char(s, c)

    print(result)","import java.util.Scanner;

public class Solution {

    // Function to count occurrences of a character in a string
    public int countChar(String s, char c) {
        int count = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == c) {
                count++;
            }
        }
        return count;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the string (assumes no spaces based on constraints)
        String s = scanner.next();

        // Read the character
        // scanner.next() reads the next token as a string, .charAt(0) takes its first character
        char c = scanner.next().charAt(0);

        Solution sol = new Solution();
        int result = sol.countChar(s, c);

        System.out.println(result);

        scanner.close();
    }
}","function countChar(s, c) {
    let count = 0;
    for (let i = 0; i < s.length; i++) {
        if (s[i] === c) {
            count++;
        }
    }
    return count;
}

// --- Standard competitive programming structure for JS on Node.js --- 
// Read all input lines
const inputLines = [];
require('readline').createInterface({
    input: process.stdin,
    output: process.stdout
}).on('line', line => {
    inputLines.push(line);
}).on('close', () => {
    // Once all input is read, call main logic
    main(inputLines);
});

function main(inputLines) {
    const s = inputLines[0]; // First line is the string
    const c = inputLines[1]; // Second line is the character (as a string of length 1)
    
    const result = countChar(s, c);
    console.log(result);
}","#include <iostream>
#include <string>
#include <vector>

// Function to count occurrences of a character in a string
int countChar(const std::string& s, char c) {
    int count = 0;
    for (char current_char : s) { // Use a range-based for loop for elegant iteration
        if (current_char == c) {
            count++;
        }
    }
    return count;
}

int main() {
    std::string s;
    char c;

    // Read the string (assumes no spaces based on constraints)
    std::cin >> s;

    // Read the character
    std::cin >> c;

    int result = countChar(s, c);

    std::cout << result << std::endl;

    return 0;
}",4
Yellow-17,Prefix & Suffix Sums,"*   Arrays
*   Prefix Sums (also known as Cumulative Sums)
*   Time Complexity Optimization
*   Basic I/O","You are given an array of integers `nums` and a list of `Q` queries. Each query consists of two indices, `start` and `end` (inclusive), representing a range within the `nums` array. Your task is to calculate the sum of all elements within each specified range `[start, end]` for every query. You need to do this efficiently, especially if there are many queries.","*   `1 <= N <= 1000` (length of `nums` array)
*   `-100 <= nums[i] <= 100`
*   `1 <= Q <= 100` (number of queries)
*   `0 <= start <= end < N` (query indices)","5
1 2 3 4 5
2
0 2
1 3


####","6
9


####","Input: 4
-1 -2 -3 -4
3
0 3
1 1
2 3
Output: -10
-2
-7
Input: 1
100
1
0 0
Output: 100
Input: 7
10 -5 20 -10 5 0 15
4
0 6
1 3
0 0
4 5
Output: 35
5
10
5
Input: 3
0 0 0
2
0 2
1 1
Output: 0
0","#include <stdio.h>
#include <stdlib.h> // For malloc

// Function to calculate range sums using prefix sums
void calculateRangeSums(int* nums, int N, int* queries, int Q) {
    // Create prefix sum array
    // prefixSum[i] stores the sum of nums[0]...nums[i-1]
    // prefixSum has size N+1
    long long* prefixSum = (long long*)malloc((N + 1) * sizeof(long long));
    if (prefixSum == NULL) {
        // Handle memory allocation failure
        return;
    }

    prefixSum[0] = 0;
    for (int i = 0; i < N; i++) {
        prefixSum[i + 1] = prefixSum[i] + nums[i];
    }

    // Process queries
    for (int i = 0; i < Q; i++) {
        int start = queries[i * 2];
        int end = queries[i * 2 + 1];
        // Sum for range [start, end] is prefixSum[end + 1] - prefixSum[start]
        long long sum = prefixSum[end + 1] - prefixSum[start];
        printf(""%lld\n"", sum);
    }

    free(prefixSum); // Free allocated memory
}

int main() {
    int N;
    scanf(""%d"", &N);

    int* nums = (int*)malloc(N * sizeof(int));
    if (nums == NULL) {
        // Handle memory allocation failure
        return 1;
    }
    for (int i = 0; i < N; i++) {
        scanf(""%d"", &nums[i]);
    }

    int Q;
    scanf(""%d"", &Q);

    // Queries are stored as pairs: [start1, end1, start2, end2, ...]
    int* queries = (int*)malloc(Q * 2 * sizeof(int));
    if (queries == NULL) {
        free(nums);
        return 1;
    }
    for (int i = 0; i < Q * 2; i += 2) {
        scanf(""%d %d"", &queries[i], &queries[i+1]);
    }

    calculateRangeSums(nums, N, queries, Q);

    free(nums);    // Free allocated memory
    free(queries); // Free allocated memory

    return 0;
}","import sys

# Function to calculate range sums using prefix sums
def calculate_range_sums(nums, queries):
    N = len(nums)
    # Create prefix sum list
    # prefix_sum[i] stores the sum of nums[0]...nums[i-1]
    # prefix_sum has size N+1
    prefix_sum = [0] * (N + 1)
    for i in range(N):
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]

    # Process queries
    results = []
    for start, end in queries:
        # Sum for range [start, end] is prefix_sum[end + 1] - prefix_sum[start]
        current_sum = prefix_sum[end + 1] - prefix_sum[start]
        results.append(str(current_sum))
    
    sys.stdout.write(""\n"".join(results) + ""\n"")

if __name__ == ""__main__"":
    N = int(sys.stdin.readline())
    nums = list(map(int, sys.stdin.readline().split()))

    Q = int(sys.stdin.readline())
    queries = []
    for _ in range(Q):
        start, end = map(int, sys.stdin.readline().split())
        queries.append((start, end))

    calculate_range_sums(nums, queries)","import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

public class Main {

    // Function to calculate range sums using prefix sums
    public static void calculateRangeSums(int[] nums, List<int[]> queries) {
        int N = nums.length;
        // Create prefix sum array
        // prefixSum[i] stores the sum of nums[0]...nums[i-1]
        // prefixSum has size N+1
        long[] prefixSum = new long[N + 1];
        prefixSum[0] = 0;
        for (int i = 0; i < N; i++) {
            prefixSum[i + 1] = prefixSum[i] + nums[i];
        }

        // Process queries
        for (int[] query : queries) {
            int start = query[0];
            int end = query[1];
            // Sum for range [start, end] is prefixSum[end + 1] - prefixSum[start]
            long sum = prefixSum[end + 1] - prefixSum[start];
            System.out.println(sum);
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int N = scanner.nextInt();
        int[] nums = new int[N];
        for (int i = 0; i < N; i++) {
            nums[i] = scanner.nextInt();
        }

        int Q = scanner.nextInt();
        List<int[]> queries = new ArrayList<>();
        for (int i = 0; i < Q; i++) {
            int start = scanner.nextInt();
            int end = scanner.nextInt();
            queries.add(new int[]{start, end});
        }

        calculateRangeSums(nums, queries);

        scanner.close();
    }
}","// Function to calculate range sums using prefix sums
function calculateRangeSums(nums, queries) {
    const N = nums.length;
    // Create prefix sum array
    // prefixSum[i] stores the sum of nums[0]...nums[i-1]
    // prefixSum has size N+1
    const prefixSum = new Array(N + 1).fill(0);
    for (let i = 0; i < N; i++) {
        prefixSum[i + 1] = prefixSum[i] + nums[i];
    }

    // Process queries
    const results = [];
    for (const query of queries) {
        const start = query[0];
        const end = query[1];
        // Sum for range [start, end] is prefixSum[end + 1] - prefixSum[start]
        const sum = prefixSum[end + 1] - prefixSum[start];
        results.push(sum);
    }
    
    // Output results
    results.forEach(sum => console.log(sum));
}

// Main function to handle input and call the solver
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let lines = [];
    rl.on('line', (line) => {
        lines.push(line);
    }).on('close', () => {
        let lineIndex = 0;

        const N = parseInt(lines[lineIndex++]);
        const nums = lines[lineIndex++].split(' ').map(Number);

        const Q = parseInt(lines[lineIndex++]);
        const queries = [];
        for (let i = 0; i < Q; i++) {
            queries.push(lines[lineIndex++].split(' ').map(Number));
        }

        calculateRangeSums(nums, queries);
    });
}

main();","#include <iostream>
#include <vector>
#include <numeric> 

// Function to calculate range sums using prefix sums
void calculateRangeSums(const std::vector<int>& nums, const std::vector<std::pair<int, int>>& queries) {
    int N = nums.size();
    // Create prefix sum vector
    // prefixSum[i] stores the sum of nums[0]...nums[i-1]
    // prefixSum has size N+1
    std::vector<long long> prefixSum(N + 1, 0);
    for (int i = 0; i < N; ++i) {
        prefixSum[i + 1] = prefixSum[i] + nums[i];
    }

    // Process queries
    for (const auto& query : queries) {
        int start = query.first;
        int end = query.second;
        // Sum for range [start, end] is prefixSum[end + 1] - prefixSum[start]
        long long sum = prefixSum[end + 1] - prefixSum[start];
        std::cout << sum << std::endl;
    }
}

int main() {
    std::ios_base::sync_with_stdio(false); // Optimize C++ standard streams
    std::cin.tie(NULL);

    int N;
    std::cin >> N;

    std::vector<int> nums(N);
    for (int i = 0; i < N; ++i) {
        std::cin >> nums[i];
    }

    int Q;
    std::cin >> Q;

    std::vector<std::pair<int, int>> queries(Q);
    for (int i = 0; i < Q; ++i) {
        std::cin >> queries[i].first >> queries[i].second;
    }

    calculateRangeSums(nums, queries);

    return 0;
}",4
Yellow-18,Circular Queue basics,"*   Queue Data Structure (FIFO)
*   Array-based Implementation
*   Circular Array (using Modulo Arithmetic)
*   Pointers (Front and Rear) Management
*   Fixed-Size Data Structures","A standard queue follows a First-In-First-Out (FIFO) principle, where elements are added at the rear and removed from the front. However, when implemented with a fixed-size array, a standard queue can run into an issue where even if there's empty space at the beginning of the array, new elements cannot be added if the rear pointer reaches the end of the array.

A **Circular Queue** solves this problem by treating the array as if its ends are connected, forming a circle. When an element is added or removed, the pointers (`front` and `rear`) move in a circular fashion using the modulo operator. This allows for efficient reuse of space within a fixed-size array.

Your task is to implement a `MyCircularQueue` class that supports the following operations:
*   `MyCircularQueue(int k)`: Initializes the object with the size of the queue to be `k`.
*   `enqueue(int value)`: Inserts an element into the circular queue. Returns `true` if the operation is successful, `false` otherwise (if the queue is full).
*   `dequeue()`: Deletes an element from the circular queue. Returns `true` if the operation is successful, `false` otherwise (if the queue is empty).
*   `front()`: Gets the front item from the queue. Returns `-1` if the queue is empty.
*   `rear()`: Gets the last item from the queue. Returns `-1` if the queue is empty.
*   `isEmpty()`: Checks whether the circular queue is empty. Returns `true` if empty, `false` otherwise.
*   `isFull()`: Checks whether the circular queue is full. Returns `true` if full, `false` otherwise.","*   `1 <= k <= 1000` (Capacity of the circular queue)
*   `-1000 <= value <= 1000` (Value to enqueue)
*   At most `10000` calls will be made to `enqueue`, `dequeue`, `front`, `rear`, `isEmpty`, and `isFull`.
*   All values returned by `front()` and `rear()` for an empty queue should be `-1`.","**
MyCircularQueue 3
enqueue 1
enqueue 2
enqueue 3
enqueue 4
rear
isFull
dequeue
enqueue 4
rear
front
isEmpty
dequeue
dequeue
dequeue
isEmpty
front
exit

**","**
null
true
true
true
false
3
true
true
true
4
2
false
true
true
true
true
-1","Input: MyCircularQueue 1
enqueue 10
enqueue 20
front
rear
dequeue
front
rear
isEmpty
enqueue 30
front
rear
isFull
dequeue
exit
Output: null
true
false
10
10
true
-1
-1
true
true
30
30
true
true

Input: MyCircularQueue 5
enqueue 1
enqueue 2
enqueue 3
dequeue
dequeue
enqueue 4
enqueue 5
enqueue 6
enqueue 7
enqueue 8
front
rear
isEmpty
isFull
dequeue
dequeue
dequeue
dequeue
dequeue
dequeue
isEmpty
exit
Output: null
true
true
true
true
true
true
true
true
true
true
false
false
3
8
false
true
true
true
true
true
false
true

Input: MyCircularQueue 2
isEmpty
front
rear
enqueue 5
isEmpty
isFull
enqueue 10
enqueue 15
front
rear
dequeue
dequeue
isEmpty
dequeue
exit
Output: null
true
-1
-1
true
false
true
false
5
10
true
true
true
true","#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

typedef struct {
    int *data;
    int front;
    int rear;
    int capacity;
    int count;
} MyCircularQueue;

MyCircularQueue* myCircularQueueCreate(int k) {
    MyCircularQueue* obj = (MyCircularQueue*) malloc(sizeof(MyCircularQueue));
    obj->data = (int*) malloc(sizeof(int) * k);
    obj->capacity = k;
    obj->front = 0;
    obj->rear = 0; // rear points to the next available slot
    obj->count = 0;
    return obj;
}

bool myCircularQueueIsEmpty(MyCircularQueue* obj) {
    return obj->count == 0;
}

bool myCircularQueueIsFull(MyCircularQueue* obj) {
    return obj->count == obj->capacity;
}

bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) {
    if (myCircularQueueIsFull(obj)) {
        return false;
    }
    obj->data[obj->rear] = value;
    obj->rear = (obj->rear + 1) % obj->capacity;
    obj->count++;
    return true;
}

bool myCircularQueueDeQueue(MyCircularQueue* obj) {
    if (myCircularQueueIsEmpty(obj)) {
        return false;
    }
    obj->front = (obj->front + 1) % obj->capacity;
    obj->count--;
    return true;
}

int myCircularQueueFront(MyCircularQueue* obj) {
    if (myCircularQueueIsEmpty(obj)) {
        return -1;
    }
    return obj->data[obj->front];
}

int myCircularQueueRear(MyCircularQueue* obj) {
    if (myCircularQueueIsEmpty(obj)) {
        return -1;
    }
    // (obj->rear - 1 + obj->capacity) % obj->capacity handles when rear is 0
    return obj->data[(obj->rear - 1 + obj->capacity) % obj->capacity];
}

void myCircularQueueFree(MyCircularQueue* obj) {
    free(obj->data);
    free(obj);
}

int main() {
    char command[20];
    int k, value;
    MyCircularQueue* obj = NULL;

    while (scanf(""%s"", command) != EOF) {
        if (strcmp(command, ""MyCircularQueue"") == 0) {
            scanf(""%d"", &k);
            if (obj != NULL) {
                myCircularQueueFree(obj); // Free previous object if any
            }
            obj = myCircularQueueCreate(k);
            printf(""null\n"");
        } else if (obj == NULL) {
            // Should not happen based on problem constraints (MyCircularQueue will be called first)
            continue;
        } else if (strcmp(command, ""enqueue"") == 0) {
            scanf(""%d"", &value);
            printf(""%s\n"", myCircularQueueEnQueue(obj, value) ? ""true"" : ""false"");
        } else if (strcmp(command, ""dequeue"") == 0) {
            printf(""%s\n"", myCircularQueueDeQueue(obj) ? ""true"" : ""false"");
        } else if (strcmp(command, ""front"") == 0) {
            printf(""%d\n"", myCircularQueueFront(obj));
        } else if (strcmp(command, ""rear"") == 0) {
            printf(""%d\n"", myCircularQueueRear(obj));
        } else if (strcmp(command, ""isEmpty"") == 0) {
            printf(""%s\n"", myCircularQueueIsEmpty(obj) ? ""true"" : ""false"");
        } else if (strcmp(command, ""isFull"") == 0) {
            printf(""%s\n"", myCircularQueueIsFull(obj) ? ""true"" : ""false"");
        } else if (strcmp(command, ""exit"") == 0) {
            break;
        }
    }

    if (obj != NULL) {
        myCircularQueueFree(obj);
    }

    return 0;
}","class MyCircularQueue:
    def __init__(self, k: int):
        self.capacity = k
        self.data = [0] * k
        self.front = 0
        self.rear = 0 # rear points to the next available slot
        self.count = 0

    def enQueue(self, value: int) -> bool:
        if self.isFull():
            return False
        self.data[self.rear] = value
        self.rear = (self.rear + 1) % self.capacity
        self.count += 1
        return True

    def deQueue(self) -> bool:
        if self.isEmpty():
            return False
        self.front = (self.front + 1) % self.capacity
        self.count -= 1
        return True

    def Front(self) -> int:
        if self.isEmpty():
            return -1
        return self.data[self.front]

    def Rear(self) -> int:
        if self.isEmpty():
            return -1
        # (self.rear - 1 + self.capacity) % self.capacity handles when rear is 0
        return self.data[(self.rear - 1 + self.capacity) % self.capacity]

    def isEmpty(self) -> bool:
        return self.count == 0

    def isFull(self) -> bool:
        return self.count == self.capacity

def main():
    obj = None
    while True:
        try:
            line = input().split()
            command = line[0]

            if command == ""MyCircularQueue"":
                k = int(line[1])
                obj = MyCircularQueue(k)
                print(""null"")
            elif obj is None:
                # Should not happen based on problem constraints
                continue
            elif command == ""enqueue"":
                value = int(line[1])
                print(""true"" if obj.enQueue(value) else ""false"")
            elif command == ""dequeue"":
                print(""true"" if obj.deQueue() else ""false"")
            elif command == ""front"":
                print(obj.Front())
            elif command == ""rear"":
                print(obj.Rear())
            elif command == ""isEmpty"":
                print(""true"" if obj.isEmpty() else ""false"")
            elif command == ""isFull"":
                print(""true"" if obj.isFull() else ""false"")
            elif command == ""exit"":
                break
        except EOFError:
            break

if __name__ == ""__main__"":
    main()","import java.util.Scanner;

class MyCircularQueue {
    private int[] data;
    private int front;
    private int rear; // rear points to the next available slot
    private int capacity;
    private int count;

    public MyCircularQueue(int k) {
        capacity = k;
        data = new int[k];
        front = 0;
        rear = 0;
        count = 0;
    }

    public boolean enQueue(int value) {
        if (isFull()) {
            return false;
        }
        data[rear] = value;
        rear = (rear + 1) % capacity;
        count++;
        return true;
    }

    public boolean deQueue() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        count--;
        return true;
    }

    public int Front() {
        if (isEmpty()) {
            return -1;
        }
        return data[front];
    }

    public int Rear() {
        if (isEmpty()) {
            return -1;
        }
        // (rear - 1 + capacity) % capacity handles when rear is 0
        return data[(rear - 1 + capacity) % capacity];
    }

    public boolean isEmpty() {
        return count == 0;
    }

    public boolean isFull() {
        return count == capacity;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String command;
        int k, value;
        MyCircularQueue obj = null;

        while (scanner.hasNext()) {
            command = scanner.next();
            if (command.equals(""MyCircularQueue"")) {
                k = scanner.nextInt();
                obj = new MyCircularQueue(k);
                System.out.println(""null"");
            } else if (obj == null) {
                // Should not happen based on problem constraints
                continue;
            } else if (command.equals(""enqueue"")) {
                value = scanner.nextInt();
                System.out.println(obj.enQueue(value) ? ""true"" : ""false"");
            } else if (command.equals(""dequeue"")) {
                System.out.println(obj.deQueue() ? ""true"" : ""false"");
            } else if (command.equals(""front"")) {
                System.out.println(obj.Front());
            } else if (command.equals(""rear"")) {
                System.out.println(obj.Rear());
            } else if (command.equals(""isEmpty"")) {
                System.out.println(obj.isEmpty() ? ""true"" : ""false"");
            } else if (command.equals(""isFull"")) {
                System.out.println(obj.isFull() ? ""true"" : ""false"");
            } else if (command.equals(""exit"")) {
                break;
            }
        }
        scanner.close();
    }
}","class MyCircularQueue {
    /**
     * @param {number} k
     */
    constructor(k) {
        this.capacity = k;
        this.data = new Array(k);
        this.front = 0;
        this.rear = 0; // rear points to the next available slot
        this.count = 0;
    }

    /**
     * @param {number} value
     * @return {boolean}
     */
    enQueue(value) {
        if (this.isFull()) {
            return false;
        }
        this.data[this.rear] = value;
        this.rear = (this.rear + 1) % this.capacity;
        this.count++;
        return true;
    }

    /**
     * @return {boolean}
     */
    deQueue() {
        if (this.isEmpty()) {
            return false;
        }
        this.front = (this.front + 1) % this.capacity;
        this.count--;
        return true;
    }

    /**
     * @return {number}
     */
    Front() {
        if (this.isEmpty()) {
            return -1;
        }
        return this.data[this.front];
    }

    /**
     * @return {number}
     */
    Rear() {
        if (this.isEmpty()) {
            return -1;
        }
        // (this.rear - 1 + this.capacity) % this.capacity handles when rear is 0
        return this.data[(this.rear - 1 + this.capacity) % this.capacity];
    }

    /**
     * @return {boolean}
     */
    isEmpty() {
        return this.count === 0;
    }

    /**
     * @return {boolean}
     */
    isFull() {
        return this.count === this.capacity;
    }
}

// Main function for I/O handling
function main() {
    let obj = null;
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    rl.on('line', (line) => {
        const parts = line.split(' ');
        const command = parts[0];

        if (command === ""MyCircularQueue"") {
            const k = parseInt(parts[1]);
            obj = new MyCircularQueue(k);
            console.log(""null"");
        } else if (obj === null) {
            // Should not happen based on problem constraints
            return;
        } else if (command === ""enqueue"") {
            const value = parseInt(parts[1]);
            console.log(obj.enQueue(value) ? ""true"" : ""false"");
        } else if (command === ""dequeue"") {
            console.log(obj.deQueue() ? ""true"" : ""false"");
        } else if (command === ""front"") {
            console.log(obj.Front());
        } else if (command === ""rear"") {
            console.log(obj.Rear());
        } else if (command === ""isEmpty"") {
            console.log(obj.isEmpty() ? ""true"" : ""false"");
        } else if (command === ""isFull"") {
            console.log(obj.isFull() ? ""true"" : ""false"");
        } else if (command === ""exit"") {
            rl.close();
        }
    });
}

main();","#include <iostream>
#include <vector>
#include <string>

class MyCircularQueue {
private:
    std::vector<int> data;
    int front;
    int rear; // rear points to the next available slot
    int capacity;
    int count;

public:
    MyCircularQueue(int k) {
        capacity = k;
        data.resize(k);
        front = 0;
        rear = 0;
        count = 0;
    }

    bool enQueue(int value) {
        if (isFull()) {
            return false;
        }
        data[rear] = value;
        rear = (rear + 1) % capacity;
        count++;
        return true;
    }

    bool deQueue() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        count--;
        return true;
    }

    int Front() {
        if (isEmpty()) {
            return -1;
        }
        return data[front];
    }

    int Rear() {
        if (isEmpty()) {
            return -1;
        }
        // (rear - 1 + capacity) % capacity handles when rear is 0
        return data[(rear - 1 + capacity) % capacity];
    }

    bool isEmpty() {
        return count == 0;
    }

    bool isFull() {
        return count == capacity;
    }
};

int main() {
    std::string command;
    int k, value;
    MyCircularQueue* obj = nullptr;

    while (std::cin >> command) {
        if (command == ""MyCircularQueue"") {
            std::cin >> k;
            if (obj != nullptr) {
                delete obj; // Free previous object if any
            }
            obj = new MyCircularQueue(k);
            std::cout << ""null\n"";
        } else if (obj == nullptr) {
            continue; // Should not happen based on problem constraints
        } else if (command == ""enqueue"") {
            std::cin >> value;
            std::cout << (obj->enQueue(value) ? ""true"" : ""false"") << ""\n"";
        } else if (command == ""dequeue"") {
            std::cout << (obj->deQueue() ? ""true"" : ""false"") << ""\n"";
        } else if (command == ""front"") {
            std::cout << obj->Front() << ""\n"";
        } else if (command == ""rear"") {
            std::cout << obj->Rear() << ""\n"";
        } else if (command == ""isEmpty"") {
            std::cout << (obj->isEmpty() ? ""true"" : ""false"") << ""\n"";
        } else if (command == ""isFull"") {
            std::cout << (obj->isFull() ? ""true"" : ""false"") << ""\n"";
        } else if (command == ""exit"") {
            break;
        }
    }

    if (obj != nullptr) {
        delete obj;
    }

    return 0;
}",4
Yellow-19,Linear Search,"*   Arrays
*   Loops (for/while)
*   Conditional Statements (if)
*   Basic Iteration","You are given an array of integers `nums` and a `target` integer. Your task is to find the first occurrence of the `target` in the `nums` array. If the `target` is found, return its index. If the `target` is not present in the array, return `-1`.

This is a classic problem that introduces the concept of iterating through a list of items to find a specific one, also known as Linear Search.","*   `1 <= n <= 1000`, where `n` is the length of `nums`.
*   `-1000 <= nums[i] <= 1000`
*   `-1000 <= target <= 1000`","5
2
5
1
9
7
9",3,"Input:
5
10
20
30
40
50
10
Output:
0
Input:
4
-5
-1
0
8
8
Output:
3
Input:
6
1
2
3
2
1
4
2
Output:
1
Input:
1
5
5
Output:
0
Input:
1
5
10
Output:
-1","#include <stdio.h>
#include <stdlib.h>

// Function to perform linear search
int linearSearch(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}

int main() {
    int n;
    // Read the size of the array
    if (scanf(""%d"", &n) != 1 || n <= 0) {
        fprintf(stderr, ""Invalid array size.\n"");
        return 1;
    }

    int *arr = (int *)malloc(n * sizeof(int));
    if (arr == NULL) {
        fprintf(stderr, ""Memory allocation failed.\n"");
        return 1;
    }

    // Read array elements
    for (int i = 0; i < n; i++) {
        if (scanf(""%d"", &arr[i]) != 1) {
            fprintf(stderr, ""Invalid array element.\n"");
            free(arr);
            return 1;
        }
    }

    int target;
    // Read the target element
    if (scanf(""%d"", &target) != 1) {
        fprintf(stderr, ""Invalid target element.\n"");
        free(arr);
        return 1;
    }

    // Call the linear search function
    int result = linearSearch(arr, n, target);

    // Print the result
    printf(""%d\n"", result);

    free(arr); // Free allocated memory
    return 0;
}","import sys

def linear_search(arr, target):
    """"""
    Performs a linear search to find the target in the array.
    Returns the index of the target if found, otherwise -1.
    """"""
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # Target found, return its index
    return -1  # Target not found

if __name__ == ""__main__"":
    # Read the size of the array
    try:
        n = int(input())
    except ValueError:
        print(""Invalid array size."", file=sys.stderr)
        sys.exit(1)

    if n <= 0:
        print(""Invalid array size."", file=sys.stderr)
        sys.exit(1)

    arr = []
    # Read array elements one by one
    for _ in range(n):
        try:
            arr.append(int(input()))
        except ValueError:
            print(""Invalid array element."", file=sys.stderr)
            sys.exit(1)

    # Read the target element
    try:
        target = int(input())
    except ValueError:
        print(""Invalid target element."", file=sys.stderr)
        sys.exit(1)

    # Call the linear search function
    result = linear_search(arr, target)

    # Print the result
    print(result)","import java.util.Scanner;

public class Main {

    // Function to perform linear search
    public static int linearSearch(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i; // Target found, return its index
            }
        }
        return -1; // Target not found
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the size of the array
        int n = scanner.nextInt();
        if (n <= 0) {
            System.err.println(""Invalid array size."");
            scanner.close();
            return;
        }

        int[] arr = new int[n];
        // Read array elements
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        // Read the target element
        int target = scanner.nextInt();

        // Call the linear search function
        int result = linearSearch(arr, target);

        // Print the result
        System.out.println(result);

        scanner.close();
    }
}","// Function to perform linear search
function linearSearch(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}

// Main execution part for Node.js environment
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let input = [];
rl.on('line', (line) => {
    input.push(line);
}).on('close', () => {
    let lineIdx = 0;

    // Read the size of the array
    const n = parseInt(input[lineIdx++]);
    if (isNaN(n) || n <= 0) {
        console.error(""Invalid array size."");
        process.exit(1);
    }

    let arr = [];
    // Read array elements
    for (let i = 0; i < n; i++) {
        const num = parseInt(input[lineIdx++]);
        if (isNaN(num)) {
            console.error(""Invalid array element."");
            process.exit(1);
        }
        arr.push(num);
    }

    // Read the target element
    const target = parseInt(input[lineIdx++]);
    if (isNaN(target)) {
        console.error(""Invalid target element."");
        process.exit(1);
    }

    // Call the linear search function
    const result = linearSearch(arr, target);

    // Print the result
    console.log(result);
});","#include <iostream>
#include <vector>

// Function to perform linear search
int linearSearch(const std::vector<int>& arr, int target) {
    for (int i = 0; i < arr.size(); ++i) {
        if (arr[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    // Read the size of the array
    std::cin >> n;
    if (n <= 0) {
        std::cerr << ""Invalid array size.\n"";
        return 1;
    }

    std::vector<int> arr(n);
    // Read array elements
    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i];
    }

    int target;
    // Read the target element
    std::cin >> target;

    // Call the linear search function
    int result = linearSearch(arr, target);

    // Print the result
    std::cout << result << std::endl;

    return 0;
}",4
Yellow-20,Linear Search,"*   Arrays
*   Iteration (loops)
*   Conditional Statements
*   Basic Searching","You are given an array of integers and a target integer. Your task is to implement a function that finds the first occurrence of the target integer in the array. If the target is found, return its 0-based index. If the target is not present in the array, return -1.","*   `1 <= N <= 1000` (where N is the number of elements in the array)
*   `-1000 <= ` `array[i]` `<= 1000`
*   `-1000 <= ` `target` `<= 1000`","5
10 20 30 40 50
30

####","2

####","Input:
5
5 10 15 20 25
5
Output: 0
Input:
6
100 200 300 400 500 600
250
Output: -1
Input:
7
1 5 3 5 8 5 9
5
Output: 1
Input:
1
42
42
Output: 0
Input:
1
10
5
Output: -1","#include <stdio.h>
#include <stdlib.h> // Required for malloc and free

// Function to perform linear search
int linearSearch(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}

int main() {
    int n;
    // Read the number of elements
    scanf(""%d"", &n);

    // Dynamically allocate memory for the array
    int *arr = (int *)malloc(n * sizeof(int));
    if (arr == NULL) {
        return 1; // Memory allocation failed
    }

    // Read array elements
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]);
    }

    int target;
    // Read the target element
    scanf(""%d"", &target);

    // Call the linear search function
    int result = linearSearch(arr, n, target);

    // Print the result
    printf(""%d\n"", result);

    // Free the dynamically allocated memory
    free(arr);

    return 0;
}","def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # Target found, return its index
    return -1  # Target not found

if __name__ == ""__main__"":
    # Read the number of elements
    n = int(input())

    # Read array elements
    arr = list(map(int, input().split()))

    # Read the target element
    target = int(input())

    # Call the linear search function
    result = linear_search(arr, target)

    # Print the result
    print(result)","import java.util.Scanner;

public class Main {

    // Function to perform linear search
    public static int linearSearch(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i; // Target found, return its index
            }
        }
        return -1; // Target not found
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the number of elements
        int n = scanner.nextInt();

        // Create an array and read elements
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        // Read the target element
        int target = scanner.nextInt();

        // Call the linear search function
        int result = linearSearch(arr, target);

        // Print the result
        System.out.println(result);

        scanner.close();
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let input = [];

rl.on('line', (line) => {
    input.push(line);
}).on('close', () => {
    // Function to perform linear search
    function linearSearch(arr, target) {
        for (let i = 0; i < arr.length; i++) {
            if (arr[i] === target) {
                return i; // Target found, return its index
            }
        }
        return -1; // Target not found
    }

    const n = parseInt(input[0]);
    const arr = input[1].split(' ').map(Number);
    const target = parseInt(input[2]);

    const result = linearSearch(arr, target);
    console.log(result);
});","#include <iostream>
#include <vector>

// Function to perform linear search
int linearSearch(const std::vector<int>& arr, int target) {
    for (int i = 0; i < arr.size(); ++i) {
        if (arr[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}

int main() {
    int n;
    // Read the number of elements
    std::cin >> n;

    // Create a vector and read elements
    std::vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i];
    }

    int target;
    // Read the target element
    std::cin >> target;

    // Call the linear search function
    int result = linearSearch(arr, target);

    // Print the result
    std::cout << result << std::endl;

    return 0;
}",4
Yellow-21,"Singly Linked List (creation, traversal, insertion, deletion)","- Singly Linked List: Node structure, creation, traversal.
- Pointer/Reference manipulation for deletion.
- Handling edge cases such as deleting the head node or an empty list.","You are tasked with a fundamental operation on singly linked lists. Given an array of integers, you must first construct a singly linked list from these values. After the list is created, you will be given a target integer. Your goal is to find the *first occurrence* of this target value in the linked list and delete the corresponding node. If the target value is not found, the list should remain unchanged. Finally, you need to return the head of the modified linked list.","- The number of nodes in the linked list will be between 0 and 1000.
- Each node's value will be an integer between -1000 and 1000.
- The target value will be an integer between -1000 and 1000.","**
Array: `[1, 2, 3, 4, 5]`
Target to delete: `3`

**Expected","**
Linked List: `1 -> 2 -> 4 -> 5`","Input: 1 2 3 4 5
6
Output: 1 2 3 4 5
Input: 10 20 30
10
Output: 20 30
Input: 5
5
Output: Empty
Input: 1 2 2 3
2
Output: 1 2 3
Input: 
5
Output: Empty","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Definition for singly-linked list.
typedef struct ListNode {
    int val;
    struct ListNode *next;
} ListNode;

// Function to create a new node
ListNode* createNode(int val) {
    ListNode* newNode = (ListNode*)malloc(sizeof(ListNode));
    if (newNode == NULL) {
        perror(""Failed to allocate memory for node"");
        exit(EXIT_FAILURE);
    }
    newNode->val = val;
    newNode->next = NULL;
    return newNode;
}

// Function to create a linked list from an array (represented as space-separated string)
ListNode* createListFromArray(const char* input_str) {
    ListNode* head = NULL;
    ListNode* tail = NULL;
    
    // Handle empty input string for an empty list
    if (input_str == NULL || strlen(input_str) == 0 || (strlen(input_str) == 1 && input_str[0] == '\n')) {
        return NULL;
    }

    char* str_copy = strdup(input_str); // Duplicate string for strtok_r
    if (str_copy == NULL) {
        perror(""Failed to duplicate string"");
        exit(EXIT_FAILURE);
    }
    
    char* token;
    char* rest = str_copy;

    while ((token = strtok_r(rest, "" "", &rest)) != NULL) {
        int val = atoi(token);
        ListNode* newNode = createNode(val);
        if (head == NULL) {
            head = newNode;
            tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
    }
    free(str_copy);
    return head;
}

// Function to delete the first occurrence of a node with a specific value
ListNode* deleteFirstOccurrence(ListNode* head, int target) {
    if (head == NULL) {
        return NULL;
    }

    // Case 1: Head node is the target
    if (head->val == target) {
        ListNode* temp = head;
        head = head->next;
        free(temp); // Free memory of the deleted node
        return head;
    }

    // Case 2: Target is in the rest of the list
    ListNode* current = head->next;
    ListNode* previous = head;

    while (current != NULL && current->val != target) {
        previous = current;
        current = current->next;
    }

    // If target found
    if (current != NULL) {
        previous->next = current->next;
        free(current); // Free memory of the deleted node
    }

    return head;
}

// Function to print the linked list
void printList(ListNode* head) {
    if (head == NULL) {
        printf(""Empty\n"");
        return;
    }
    ListNode* current = head;
    while (current != NULL) {
        printf(""%d"", current->val);
        if (current->next != NULL) {
            printf("" "");
        }
        current = current->next;
    }
    printf(""\n"");
}

// Function to free the linked list memory
void freeList(ListNode* head) {
    ListNode* current = head;
    while (current != NULL) {
        ListNode* next = current->next;
        free(current);
        current = next;
    }
}

int main() {
    char line[4000]; // Increased buffer size for potentially large inputs
    
    // Read array input
    if (fgets(line, sizeof(line), stdin) == NULL) {
        return 1;
    }
    line[strcspn(line, ""\n"")] = 0; // Remove newline character

    ListNode* head = createListFromArray(line);

    // Read target value
    int target;
    if (scanf(""%d"", &target) != 1) {
        freeList(head);
        return 1;
    }

    head = deleteFirstOccurrence(head, target);

    printList(head);
    freeList(head); // Free all allocated memory

    return 0;
}","class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def createListFromArray(self, arr):
        if not arr:
            return None
        head = ListNode(arr[0])
        tail = head
        for i in range(1, len(arr)):
            tail.next = ListNode(arr[i])
            tail = tail.next
        return head

    def deleteFirstOccurrence(self, head: ListNode, target: int) -> ListNode:
        if not head:
            return None

        # Case 1: Head node is the target
        if head.val == target:
            return head.next

        # Case 2: Target is in the rest of the list
        current = head.next
        previous = head

        while current and current.val != target:
            previous = current
            current = current.next

        # If target found
        if current:
            previous.next = current.next
        
        return head

    def printList(self, head: ListNode):
        if not head:
            print(""Empty"")
            return
        current = head
        result = []
        while current:
            result.append(str(current.val))
            current = current.next
        print("" "".join(result))

if __name__ == ""__main__"":
    sol = Solution()

    # Read array input
    line = input()
    arr = []
    if line.strip(): # Handle empty line for empty list case
        arr = list(map(int, line.split()))

    head = sol.createListFromArray(arr)

    # Read target value
    target = int(input())

    head = sol.deleteFirstOccurrence(head, target)

    sol.printList(head)","import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

// Definition for singly-linked list.
class ListNode {
    int val;
    ListNode next;

    ListNode(int x) {
        val = x;
        next = null;
    }
}

class Solution {

    // Function to create a linked list from an array
    public ListNode createListFromArray(List<Integer> arr) {
        if (arr == null || arr.isEmpty()) {
            return null;
        }
        ListNode head = new ListNode(arr.get(0));
        ListNode tail = head;
        for (int i = 1; i < arr.size(); i++) {
            tail.next = new ListNode(arr.get(i));
            tail = tail.next;
        }
        return head;
    }

    // Function to delete the first occurrence of a node with a specific value
    public ListNode deleteFirstOccurrence(ListNode head, int target) {
        if (head == null) {
            return null;
        }

        // Case 1: Head node is the target
        if (head.val == target) {
            return head.next;
        }

        // Case 2: Target is in the rest of the list
        ListNode current = head.next;
        ListNode previous = head;

        while (current != null && current.val != target) {
            previous = current;
            current = current.next;
        }

        // If target found
        if (current != null) {
            previous.next = current.next;
        }

        return head;
    }

    // Function to print the linked list
    public void printList(ListNode head) {
        if (head == null) {
            System.out.println(""Empty"");
            return;
        }
        ListNode current = head;
        StringBuilder sb = new StringBuilder();
        while (current != null) {
            sb.append(current.val);
            if (current.next != null) {
                sb.append("" "");
            }
            current = current.next;
        }
        System.out.println(sb.toString());
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Solution sol = new Solution();

        // Read array input
        String line = scanner.nextLine();
        List<Integer> arr = new ArrayList<>();
        if (!line.trim().isEmpty()) { // Handle empty line for empty list case
            String[] numStrs = line.split("" "");
            for (String s : numStrs) {
                arr.add(Integer.parseInt(s));
            }
        }
        

        ListNode head = sol.createListFromArray(arr);

        // Read target value
        int target = scanner.nextInt();

        head = sol.deleteFirstOccurrence(head, target);

        sol.printList(head);

        scanner.close();
    }
}","// Definition for singly-linked list.
function ListNode(val, next) {
    this.val = (val === undefined ? 0 : val);
    this.next = (next === undefined ? null : next);
}

class Solution {
    createListFromArray(arr) {
        if (!arr || arr.length === 0) {
            return null;
        }
        let head = new ListNode(arr[0]);
        let tail = head;
        for (let i = 1; i < arr.length; i++) {
            tail.next = new ListNode(arr[i]);
            tail = tail.next;
        }
        return head;
    }

    deleteFirstOccurrence(head, target) {
        if (!head) {
            return null;
        }

        // Case 1: Head node is the target
        if (head.val === target) {
            return head.next;
        }

        // Case 2: Target is in the rest of the list
        let current = head.next;
        let previous = head;

        while (current && current.val !== target) {
            previous = current;
            current = current.next;
        }

        // If target found
        if (current) {
            previous.next = current.next;
        }

        return head;
    }

    printList(head) {
        if (!head) {
            console.log(""Empty"");
            return;
        }
        let current = head;
        let result = [];
        while (current) {
            result.push(current.val);
            current = current.next;
        }
        console.log(result.join("" ""));
    }
}

// Main execution for JS environment
// This part handles input/output for a typical online judge setup
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let lines = [];
rl.on('line', (line) => {
    lines.push(line);
}).on('close', () => {
    const sol = new Solution();

    // Read array input
    const arrStr = lines[0];
    let arr = [];
    if (arrStr.trim() !== '') { // Handle empty line for empty list case
        arr = arrStr.split(' ').map(Number);
    }
    
    let head = sol.createListFromArray(arr);

    // Read target value
    const target = parseInt(lines[1]);

    head = sol.deleteFirstOccurrence(head, target);

    sol.printList(head);
});","#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <limits> // Required for numeric_limits

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// Function to create a linked list from a vector
ListNode* createListFromArray(const std::vector<int>& arr) {
    if (arr.empty()) {
        return nullptr;
    }
    ListNode* head = new ListNode(arr[0]);
    ListNode* tail = head;
    for (size_t i = 1; i < arr.size(); ++i) {
        tail->next = new ListNode(arr[i]);
        tail = tail->next;
    }
    return head;
}

// Function to delete the first occurrence of a node with a specific value
ListNode* deleteFirstOccurrence(ListNode* head, int target) {
    if (head == nullptr) {
        return nullptr;
    }

    // Case 1: Head node is the target
    if (head->val == target) {
        ListNode* temp = head;
        head = head->next;
        delete temp; // Free memory of the deleted node
        return head;
    }

    // Case 2: Target is in the rest of the list
    ListNode* current = head->next;
    ListNode* previous = head;

    while (current != nullptr && current->val != target) {
        previous = current;
        current = current->next;
    }

    // If target found
    if (current != nullptr) {
        previous->next = current->next;
        delete current; // Free memory of the deleted node
    }

    return head;
}

// Function to print the linked list
void printList(ListNode* head) {
    if (head == nullptr) {
        std::cout << ""Empty"" << std::endl;
        return;
    }
    ListNode* current = head;
    while (current != nullptr) {
        std::cout << current->val;
        if (current->next != nullptr) {
            std::cout << "" "";
        }
        current = current->next;
    }
    std::cout << std::endl;
}

// Function to free the linked list memory
void freeList(ListNode* head) {
    ListNode* current = head;
    while (current != nullptr) {
        ListNode* next = current->next;
        delete current;
        current = next;
    }
}

int main() {
    std::string line;
    std::getline(std::cin, line);

    std::vector<int> arr;
    if (!line.empty()) { // Handle empty line for empty list case
        std::stringstream ss(line);
        int val;
        while (ss >> val) {
            arr.push_back(val);
        }
    }

    ListNode* head = createListFromArray(arr);

    int target;
    std::cin >> target;

    // Clear the rest of the input buffer after reading target
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

    head = deleteFirstOccurrence(head, target);

    printList(head);
    freeList(head); // Free all allocated memory

    return 0;
}",4
Yellow-22,Intro to Backtracking,"*   Backtracking
*   Recursion
*   Decision Tree
*   State Space Search","Given two positive integers `n` and `k`, return all possible combinations of `k` numbers chosen from the range `[1, n]`.

You may return the answer in any order. The combinations themselves should have their elements sorted in ascending order.",*   `1 <= k <= n <= 15`,"**

n = 4, k = 2


**","**

[
  [1,2],
  [1,3],
  [1,4],
  [2,3],
  [2,4],
  [3,4]
]","Input: 3 1
Output: [
  [1],
  [2],
  [3]
]
Input: 3 3
Output: [
  [1,2,3]
]
Input: 5 2
Output: [
  [1,2],
  [1,3],
  [1,4],
  [1,5],
  [2,3],
  [2,4],
  [2,5],
  [3,4],
  [3,5],
  [4,5]
]
Input: 6 3
Output: [
  [1,2,3],
  [1,2,4],
  [1,2,5],
  [1,2,6],
  [1,3,4],
  [1,3,5],
  [1,3,6],
  [1,4,5],
  [1,4,6],
  [1,5,6],
  [2,3,4],
  [2,3,5],
  [2,3,6],
  [2,4,5],
  [2,4,6],
  [2,5,6],
  [3,4,5],
  [3,4,6],
  [3,5,6],
  [4,5,6]
]","#include <stdio.h>
#include <stdlib.h>

// Helper function for backtracking
void backtrack(int n, int k, int start, int* current_combination, int current_size,
               int*** results, int* result_count, int** result_col_sizes) {
    // Base case: if current_combination has k elements, add it to results
    if (current_size == k) {
        // Allocate space for the new combination
        (*results) = (int**)realloc(*results, (*result_count + 1) * sizeof(int*));
        if (*results == NULL) {
            perror(""Failed to reallocate results"");
            exit(EXIT_FAILURE);
        }
        (*results)[*result_count] = (int*)malloc(k * sizeof(int));
        if ((*results)[*result_count] == NULL) {
            perror(""Failed to allocate combination"");
            exit(EXIT_FAILURE);
        }

        // Copy current_combination to results
        for (int i = 0; i < k; i++) {
            (*results)[*result_count][i] = current_combination[i];
        }

        // Store column size
        (*result_col_sizes) = (int*)realloc(*result_col_sizes, (*result_count + 1) * sizeof(int));
        if (*result_col_sizes == NULL) {
            perror(""Failed to reallocate column sizes"");
            exit(EXIT_FAILURE);
        }
        (*result_col_sizes)[*result_count] = k;

        (*result_count)++;
        return;
    }

    // Optimization: if remaining elements are not enough to form a combination
    // (n - start + 1) is the count of numbers from 'start' to 'n'
    // (k - current_size) is the number of elements we still need
    if (k - current_size > n - start + 1) {
        return;
    }

    // Recursive step: iterate from start to n
    for (int i = start; i <= n; i++) {
        // Make a choice: add i to current_combination
        current_combination[current_size] = i;

        // Recurse: explore combinations starting from i + 1
        backtrack(n, k, i + 1, current_combination, current_size + 1,
                  results, result_count, result_col_sizes);
        
        // No explicit ""undo"" needed for simple values in C arrays when working with indices
        // The next iteration or a return will overwrite/ignore this index
    }
}

// Main function to find combinations
int** combine(int n, int k, int* returnSize, int** returnColumnSizes) {
    if (k <= 0 || k > n) {
        *returnSize = 0;
        *returnColumnSizes = NULL;
        return NULL;
    }

    int** results = NULL;
    *returnSize = 0;
    *returnColumnSizes = NULL;

    // current_combination acts as a temporary buffer for elements.
    // Max k is 15, so a small fixed-size array is safe for the stack.
    // If k could be very large, this would need to be dynamic.
    int* current_combination = (int*)malloc(k * sizeof(int));
    if (current_combination == NULL) {
        perror(""Failed to allocate current_combination buffer"");
        exit(EXIT_FAILURE);
    }

    backtrack(n, k, 1, current_combination, 0, &results, returnSize, returnColumnSizes);

    free(current_combination); // Free the temporary buffer
    return results;
}

// Helper to print results for main
void printCombinations(int** combinations, int numRows, int* colSizes) {
    printf(""[\n"");
    for (int i = 0; i < numRows; i++) {
        printf(""  ["");
        for (int j = 0; j < colSizes[i]; j++) {
            printf(""%d%s"", combinations[i][j], (j == colSizes[i] - 1) ? """" : "","");
        }
        printf(""]%s\n"", (i == numRows - 1) ? """" : "","");
    }
    printf(""]\n"");
}

int main() {
    int n, k;
    if (scanf(""%d %d"", &n, &k) != 2) {
        fprintf(stderr, ""Failed to read n and k\n"");
        return 1;
    }

    int returnSize;
    int* returnColumnSizes;
    int** result = combine(n, k, &returnSize, &returnColumnSizes);

    printCombinations(result, returnSize, returnColumnSizes);

    // Free allocated memory
    for (int i = 0; i < returnSize; i++) {
        free(result[i]);
    }
    free(result);
    free(returnColumnSizes);

    return 0;
}","import sys

class Solution:
    def combine(self, n: int, k: int) -> list[list[int]]:
        all_combinations = []
        current_combination = []

        if k <= 0 or k > n:
            return all_combinations

        def backtrack(start_num: int):
            # Base case: if current_combination has k elements, add it to results
            if len(current_combination) == k:
                all_combinations.append(list(current_combination)) # Add a copy
                return

            # Optimization: if remaining elements are not enough to form a combination
            # (n - start_num + 1) is the count of numbers from 'start_num' to 'n'
            # (k - len(current_combination)) is the number of elements we still need
            if k - len(current_combination) > n - start_num + 1:
                return

            # Recursive step: iterate from start_num to n
            for i in range(start_num, n + 1):
                # Make a choice: add i to current_combination
                current_combination.append(i)

                # Recurse: explore combinations starting from i + 1
                backtrack(i + 1)

                # Undo the choice (backtrack): remove i from current_combination
                current_combination.pop()
        
        backtrack(1)
        return all_combinations

def print_combinations(combinations: list[list[int]]):
    sys.stdout.write(""["")
    if len(combinations) > 0:
        sys.stdout.write(""\n"")
    for i, combination in enumerate(combinations):
        sys.stdout.write(""  ["")
        sys.stdout.write("","".join(map(str, combination)))
        sys.stdout.write(""]"")
        if i < len(combinations) - 1:
            sys.stdout.write("","")
        sys.stdout.write(""\n"")
    sys.stdout.write(""]\n"")

if __name__ == '__main__':
    lines = sys.stdin.readlines()
    n, k = map(int, lines[0].strip().split())

    sol = Solution()
    result = sol.combine(n, k)

    print_combinations(result)","import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

class Solution {
    List<List<Integer>> allCombinations;
    List<Integer> currentCombination;

    private void backtrack(int n, int k, int startNum) {
        // Base case: if currentCombination has k elements, add it to results
        if (currentCombination.size() == k) {
            allCombinations.add(new ArrayList<>(currentCombination)); // Add a copy
            return;
        }

        // Optimization: if remaining elements are not enough to form a combination
        // (n - startNum + 1) is the count of numbers from 'startNum' to 'n'
        // (k - currentCombination.size()) is the number of elements we still need
        if (k - currentCombination.size() > n - startNum + 1) {
            return;
        }

        // Recursive step: iterate from startNum to n
        for (int i = startNum; i <= n; i++) {
            // Make a choice: add i to currentCombination
            currentCombination.add(i);

            // Recurse: explore combinations starting from i + 1
            backtrack(n, k, i + 1);

            // Undo the choice (backtrack): remove i from currentCombination
            currentCombination.remove(currentCombination.size() - 1);
        }
    }

    public List<List<Integer>> combine(int n, int k) {
        allCombinations = new ArrayList<>();
        currentCombination = new ArrayList<>();

        if (k <= 0 || k > n) {
            return allCombinations; // Return empty list
        }

        backtrack(n, k, 1);
        return allCombinations;
    }
}

public class Main {
    public static void printCombinations(List<List<Integer>> combinations) {
        System.out.println(""["");
        for (int i = 0; i < combinations.size(); i++) {
            System.out.print(""  ["");
            List<Integer> combination = combinations.get(i);
            for (int j = 0; j < combination.size(); j++) {
                System.out.print(combination.get(j));
                if (j < combination.size() - 1) {
                    System.out.print("","");
                }
            }
            System.out.print(""]"");
            if (i < combinations.size() - 1) {
                System.out.print("","");
            }
            System.out.println();
        }
        System.out.println(""]"");
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int k = scanner.nextInt();
        scanner.close();

        Solution sol = new Solution();
        List<List<Integer>> result = sol.combine(n, k);

        printCombinations(result);
    }
}","const readline = require('readline');

// The Solution class structure
class Solution {
    constructor() {
        this.allCombinations = [];
        this.currentCombination = [];
    }

    backtrack(n, k, startNum) {
        // Base case: if currentCombination has k elements, add it to results
        if (this.currentCombination.length === k) {
            this.allCombinations.push([...this.currentCombination]); // Add a copy
            return;
        }

        // Optimization: if remaining elements are not enough to form a combination
        // (n - startNum + 1) is the count of numbers from 'startNum' to 'n'
        // (k - this.currentCombination.length) is the number of elements we still need
        if (k - this.currentCombination.length > n - startNum + 1) {
            return;
        }

        // Recursive step: iterate from startNum to n
        for (let i = startNum; i <= n; i++) {
            // Make a choice: add i to currentCombination
            this.currentCombination.push(i);

            // Recurse: explore combinations starting from i + 1
            this.backtrack(n, k, i + 1);

            // Undo the choice (backtrack): remove i from currentCombination
            this.currentCombination.pop();
        }
    }

    combine(n, k) {
        this.allCombinations = []; // Clear for new calls
        this.currentCombination = []; // Clear for new calls

        if (k <= 0 || k > n) {
            return this.allCombinations; // Return empty array
        }

        this.backtrack(n, k, 1);
        return this.allCombinations;
    }
}

// Function to print combinations in the specified format
function printCombinations(combinations) {
    let output = ""["";
    if (combinations.length > 0) {
        output += ""\n"";
    }
    for (let i = 0; i < combinations.length; i++) {
        output += ""  ["";
        output += combinations[i].join("","");
        output += ""]"";
        if (i < combinations.length - 1) {
            output += "","";
        }
        output += ""\n"";
    }
    output += ""]\n"";
    console.log(output);
}

// Main execution block to handle input and output
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let inputLines = [];

rl.on('line', (line) => {
    inputLines.push(line);
}).on('close', () => {
    const [n, k] = inputLines[0].split(' ').map(Number);

    const sol = new Solution();
    const result = sol.combine(n, k);

    printCombinations(result);
});","#include <iostream>
#include <vector>
#include <algorithm> 

class Solution {
private:
    std::vector<std::vector<int>> allCombinations;
    std::vector<int> currentCombination;

    void backtrack(int n, int k, int start_num) {
        // Base case: if currentCombination has k elements, add it to results
        if (currentCombination.size() == k) {
            allCombinations.push_back(currentCombination);
            return;
        }

        // Optimization: if remaining elements are not enough to form a combination
        // (n - start_num + 1) is the count of numbers from 'start_num' to 'n'
        // (k - currentCombination.size()) is the number of elements we still need
        if (k - currentCombination.size() > n - start_num + 1) {
            return;
        }

        // Recursive step: iterate from start_num to n
        for (int i = start_num; i <= n; ++i) {
            // Make a choice: add i to currentCombination
            currentCombination.push_back(i);

            // Recurse: explore combinations starting from i + 1
            backtrack(n, k, i + 1);

            // Undo the choice (backtrack): remove i from currentCombination
            currentCombination.pop_back();
        }
    }

public:
    std::vector<std::vector<int>> combine(int n, int k) {
        allCombinations.clear(); 
        currentCombination.clear(); 

        if (k <= 0 || k > n) {
            return allCombinations; 
        }

        backtrack(n, k, 1);
        return allCombinations;
    }
};

void printCombinations(const std::vector<std::vector<int>>& combinations) {
    std::cout << ""[\n"";
    for (size_t i = 0; i < combinations.size(); ++i) {
        std::cout << ""  ["";
        for (size_t j = 0; j < combinations[i].size(); ++j) {
            std::cout << combinations[i][j] << (j == combinations[i].size() - 1 ? """" : "","");
        }
        std::cout << ""]"" << (i == combinations.size() - 1 ? """" : "","") << ""\n"";
    }
    std::cout << ""]\n"";
}

int main() {
    int n, k;
    if (!(std::cin >> n >> k)) {
        std::cerr << ""Failed to read n and k\n"";
        return 1;
    }

    Solution sol;
    std::vector<std::vector<int>> result = sol.combine(n, k);

    printCombinations(result);

    return 0;
}",4
Yellow-23,Circular Queue basics,"*   **Arrays:** Using a fixed-size array to store queue elements.
*   **Pointers/Indices:** Managing `front` and `rear` pointers (or indices) to keep track of the queue's boundaries.
*   **Modulo Operator:** Essential for wrapping around the array and implementing the circular behavior.
*   **Queue Data Structure:** Understanding the FIFO principle and basic queue operations.
*   **Edge Cases:** Handling conditions like an empty queue, a full queue, and transitions between these states.","Welcome to the Queue Carousel! Your task is to implement a `MyCircularQueue` class that supports all the standard operations of a circular queue. A circular queue, also known as a ring buffer, is a linear data structure that operates on the FIFO (First-In, First-Out) principle. Unlike a regular queue, it reuses empty spaces by connecting the rear of the queue to the front, forming a circular structure. This makes it efficient for fixed-size buffers.

You will need to implement the following methods:

*   `MyCircularQueue(k)`: Constructor, initializes the queue with a maximum capacity of `k` elements.
*   `enqueue(value)`: Inserts an element into the circular queue. Returns `true` if the operation is successful, `false` otherwise (e.g., if the queue is full).
*   `dequeue()`: Deletes an element from the circular queue. Returns `true` if the operation is successful, `false` otherwise (e.g., if the queue is empty).
*   `front()`: Gets the front item from the queue. Returns the element if the queue is not empty, otherwise returns `-1`.
*   `rear()`: Gets the last item from the queue. Returns the element if the queue is not empty, otherwise returns `-1`.
*   `isEmpty()`: Checks whether the circular queue is empty. Returns `true` if empty, `false` otherwise.
*   `isFull()`: Checks whether the circular queue is full. Returns `true` if full, `false` otherwise.","*   `1 <= k <= 1000` (The capacity of the queue)
*   `0 <= value <= 1000` (The value to enqueue)
*   At most `3000` calls will be made to `enqueue`, `dequeue`, `front`, `rear`, `isEmpty`, and `isFull`.
*   All values returned by `front()` and `rear()` for an empty queue should be `-1`.","**

3
MyCircularQueue enqueue 1
MyCircularQueue enqueue 2
MyCircularQueue enqueue 3
MyCircularQueue isFull
MyCircularQueue dequeue
MyCircularQueue enqueue 4
MyCircularQueue front
MyCircularQueue rear
MyCircularQueue isEmpty
MyCircularQueue dequeue
MyCircularQueue dequeue
MyCircularQueue dequeue
MyCircularQueue isEmpty
MyCircularQueue front
MyCircularQueue enqueue 5
MyCircularQueue rear


**","**

true
true
true
true
1
3
false
true
true
true
-1
5","Input: 1
MyCircularQueue enqueue 10
MyCircularQueue isFull
MyCircularQueue front
MyCircularQueue rear
MyCircularQueue dequeue
MyCircularQueue isEmpty
MyCircularQueue enqueue 20
MyCircularQueue front
Output: true
true
10
10
true
false
20

Input: 2
MyCircularQueue enqueue 1
MyCircularQueue enqueue 2
MyCircularQueue isFull
MyCircularQueue enqueue 3
MyCircularQueue front
MyCircularQueue rear
MyCircularQueue dequeue
MyCircularQueue dequeue
MyCircularQueue isEmpty
MyCircularQueue dequeue
MyCircularQueue front
Output: true
true
true
false
1
2
true
true
true
false
-1

Input: 5
MyCircularQueue front
MyCircularQueue rear
MyCircularQueue isEmpty
MyCircularQueue dequeue
MyCircularQueue enqueue 10
MyCircularQueue enqueue 20
MyCircularQueue enqueue 30
MyCircularQueue front
MyCircularQueue rear
MyCircularQueue isEmpty
MyCircularQueue isFull
MyCircularQueue dequeue
MyCircularQueue enqueue 40
MyCircularQueue rear
MyCircularQueue front
Output: -1
-1
true
false
true
true
true
10
30
false
false
true
true
40
20","#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

typedef struct {
    int* data;
    int front;
    int rear;
    int capacity;
    int currentSize;
} MyCircularQueue;

MyCircularQueue* myCircularQueueCreate(int k) {
    MyCircularQueue* obj = (MyCircularQueue*)malloc(sizeof(MyCircularQueue));
    obj->data = (int*)malloc(sizeof(int) * k);
    obj->capacity = k;
    obj->front = 0;
    obj->rear = -1; // -1 indicates an empty queue, rear will become 0 upon first enqueue
    obj->currentSize = 0;
    return obj;
}

bool myCircularQueueIsEmpty(MyCircularQueue* obj) {
    return obj->currentSize == 0;
}

bool myCircularQueueIsFull(MyCircularQueue* obj) {
    return obj->currentSize == obj->capacity;
}

bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) {
    if (myCircularQueueIsFull(obj)) {
        return false;
    }
    obj->rear = (obj->rear + 1) % obj->capacity;
    obj->data[obj->rear] = value;
    obj->currentSize++;
    return true;
}

bool myCircularQueueDeQueue(MyCircularQueue* obj) {
    if (myCircularQueueIsEmpty(obj)) {
        return false;
    }
    obj->front = (obj->front + 1) % obj->capacity;
    obj->currentSize--;
    return true;
}

int myCircularQueueFront(MyCircularQueue* obj) {
    if (myCircularQueueIsEmpty(obj)) {
        return -1;
    }
    return obj->data[obj->front];
}

int myCircularQueueRear(MyCircularQueue* obj) {
    if (myCircularQueueIsEmpty(obj)) {
        return -1;
    }
    return obj->data[obj->rear];
}

void myCircularQueueFree(MyCircularQueue* obj) {
    free(obj->data);
    free(obj);
}

int main() {
    int k;
    scanf(""%d"", &k);

    MyCircularQueue* obj = myCircularQueueCreate(k);

    char command[50];
    char operation[20];
    int value;

    while (scanf(""%s"", command) != EOF) {
        scanf(""%s"", operation);
        if (strcmp(operation, ""enqueue"") == 0) {
            scanf(""%d"", &value);
            printf(""%s\n"", myCircularQueueEnQueue(obj, value) ? ""true"" : ""false"");
        } else if (strcmp(operation, ""dequeue"") == 0) {
            printf(""%s\n"", myCircularQueueDeQueue(obj) ? ""true"" : ""false"");
        } else if (strcmp(operation, ""front"") == 0) {
            printf(""%d\n"", myCircularQueueFront(obj));
        } else if (strcmp(operation, ""rear"") == 0) {
            printf(""%d\n"", myCircularQueueRear(obj));
        } else if (strcmp(operation, ""isEmpty"") == 0) {
            printf(""%s\n"", myCircularQueueIsEmpty(obj) ? ""true"" : ""false"");
        } else if (strcmp(operation, ""isFull"") == 0) {
            printf(""%s\n"", myCircularQueueIsFull(obj) ? ""true"" : ""false"");
        }
    }

    myCircularQueueFree(obj);

    return 0;
}","import sys

class MyCircularQueue:

    def __init__(self, k: int):
        self.data = [0] * k
        self.capacity = k
        self.front = 0
        self.rear = -1  # -1 indicates an empty queue, rear will become 0 upon first enqueue
        self.current_size = 0

    def enQueue(self, value: int) -> bool:
        if self.isFull():
            return False
        self.rear = (self.rear + 1) % self.capacity
        self.data[self.rear] = value
        self.current_size += 1
        return True

    def deQueue(self) -> bool:
        if self.isEmpty():
            return False
        self.front = (self.front + 1) % self.capacity
        self.current_size -= 1
        return True

    def Front(self) -> int:
        if self.isEmpty():
            return -1
        return self.data[self.front]

    def Rear(self) -> int:
        if self.isEmpty():
            return -1
        return self.data[self.rear]

    def isEmpty(self) -> bool:
        return self.current_size == 0

    def isFull(self) -> bool:
        return self.current_size == self.capacity

def main():
    k = int(sys.stdin.readline().strip())
    obj = MyCircularQueue(k)

    for line in sys.stdin:
        parts = line.strip().split()
        # The problem statement example has 'MyCircularQueue' prefix, ignore it.
        operation = parts[1]

        if operation == ""enqueue"":
            value = int(parts[2])
            print(str(obj.enQueue(value)).lower())
        elif operation == ""dequeue"":
            print(str(obj.deQueue()).lower())
        elif operation == ""front"":
            print(obj.Front())
        elif operation == ""rear"":
            print(obj.Rear())
        elif operation == ""isEmpty"":
            print(str(obj.isEmpty()).lower())
        elif operation == ""isFull"":
            print(str(obj.isFull()).lower())

if __name__ == '__main__':
    main()","import java.util.Scanner;

class MyCircularQueue {
    private int[] data;
    private int front;
    private int rear;
    private int capacity;
    private int currentSize;

    public MyCircularQueue(int k) {
        data = new int[k];
        capacity = k;
        front = 0;
        rear = -1; // -1 indicates an empty queue, rear will become 0 upon first enqueue
        currentSize = 0;
    }

    public boolean enQueue(int value) {
        if (isFull()) {
            return false;
        }
        rear = (rear + 1) % capacity;
        data[rear] = value;
        currentSize++;
        return true;
    }

    public boolean deQueue() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        currentSize--;
        return true;
    }

    public int Front() {
        if (isEmpty()) {
            return -1;
        }
        return data[front];
    }

    public int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return data[rear];
    }

    public boolean isEmpty() {
        return currentSize == 0;
    }

    public boolean isFull() {
        return currentSize == capacity;
    }
}

public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int k = scanner.nextInt();
        scanner.nextLine(); // Consume the newline

        MyCircularQueue obj = new MyCircularQueue(k);

        while (scanner.hasNextLine()) {
            String line = scanner.nextLine().trim();
            if (line.isEmpty()) {
                continue;
            }
            String[] parts = line.split("" "");
            String operation = parts[1];

            switch (operation) {
                case ""enqueue"":
                    int value = Integer.parseInt(parts[2]);
                    System.out.println(obj.enQueue(value) ? ""true"" : ""false"");
                    break;
                case ""dequeue"":
                    System.out.println(obj.deQueue() ? ""true"" : ""false"");
                    break;
                case ""front"":
                    System.out.println(obj.Front());
                    break;
                case ""rear"":
                    System.out.println(obj.Rear());
                    break;
                case ""isEmpty"":
                    System.out.println(obj.isEmpty() ? ""true"" : ""false"");
                    break;
                case ""isFull"":
                    System.out.println(obj.isFull() ? ""true"" : ""false"");
                    break;
            }
        }
        scanner.close();
    }
}","class MyCircularQueue {
    /**
     * @param {number} k
     */
    constructor(k) {
        this.data = new Array(k);
        this.capacity = k;
        this.front = 0;
        this.rear = -1; // -1 indicates an empty queue, rear will become 0 upon first enqueue
        this.currentSize = 0;
    }

    /**
     * @param {number} value
     * @return {boolean}
     */
    enQueue(value) {
        if (this.isFull()) {
            return false;
        }
        this.rear = (this.rear + 1) % this.capacity;
        this.data[this.rear] = value;
        this.currentSize++;
        return true;
    }

    /**
     * @return {boolean}
     */
    deQueue() {
        if (this.isEmpty()) {
            return false;
        }
        this.front = (this.front + 1) % this.capacity;
        this.currentSize--;
        return true;
    }

    /**
     * @return {number}
     */
    Front() {
        if (this.isEmpty()) {
            return -1;
        }
        return this.data[this.front];
    }

    /**
     * @return {number}
     */
    Rear() {
        if (this.isEmpty()) {
            return -1;
        }
        return this.data[this.rear];
    }

    /**
     * @return {boolean}
     */
    isEmpty() {
        return this.currentSize === 0;
    }

    /**
     * @return {boolean}
     */
    isFull() {
        return this.currentSize === this.capacity;
    }
}

function processInput() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let k = -1;
    let circularQueue = null;
    let lineCount = 0;

    rl.on('line', (line) => {
        if (line.trim() === '') return;

        if (lineCount === 0) {
            k = parseInt(line.trim());
            circularQueue = new MyCircularQueue(k);
        } else {
            const parts = line.trim().split(' ');
            const operation = parts[1];

            let result;
            switch (operation) {
                case 'enqueue':
                    const value = parseInt(parts[2]);
                    result = circularQueue.enQueue(value);
                    console.log(result ? 'true' : 'false');
                    break;
                case 'dequeue':
                    result = circularQueue.deQueue();
                    console.log(result ? 'true' : 'false');
                    break;
                case 'front':
                    result = circularQueue.Front();
                    console.log(result);
                    break;
                case 'rear':
                    result = circularQueue.Rear();
                    console.log(result);
                    break;
                case 'isEmpty':
                    result = circularQueue.isEmpty();
                    console.log(result ? 'true' : 'false');
                    break;
                case 'isFull':
                    result = circularQueue.isFull();
                    console.log(result ? 'true' : 'false');
                    break;
            }
        }
        lineCount++;
    });

    rl.on('close', () => {
        // All input processed
    });
}

processInput();","#include <iostream>
#include <vector>
#include <string>

class MyCircularQueue {
private:
    std::vector<int> data;
    int front;
    int rear;
    int capacity;
    int currentSize;

public:
    MyCircularQueue(int k) {
        data.resize(k);
        capacity = k;
        front = 0;
        rear = -1; // -1 indicates an empty queue, rear will become 0 upon first enqueue
        currentSize = 0;
    }

    bool enQueue(int value) {
        if (isFull()) {
            return false;
        }
        rear = (rear + 1) % capacity;
        data[rear] = value;
        currentSize++;
        return true;
    }

    bool deQueue() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        currentSize--;
        return true;
    }

    int Front() {
        if (isEmpty()) {
            return -1;
        }
        return data[front];
    }

    int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return data[rear];
    }

    bool isEmpty() {
        return currentSize == 0;
    }

    bool isFull() {
        return currentSize == capacity;
    }
};

int main() {
    int k;
    std::cin >> k;

    MyCircularQueue* obj = new MyCircularQueue(k);

    std::string command_prefix; // To consume 'MyCircularQueue'
    std::string operation;
    int value;

    while (std::cin >> command_prefix >> operation) {
        if (operation == ""enqueue"") {
            std::cin >> value;
            std::cout << (obj->enQueue(value) ? ""true"" : ""false"") << std::endl;
        } else if (operation == ""dequeue"") {
            std::cout << (obj->deQueue() ? ""true"" : ""false"") << std::endl;
        } else if (operation == ""front"") {
            std::cout << obj->Front() << std::endl;
        } else if (operation == ""rear"") {
            std::cout << obj->Rear() << std::endl;
        } else if (operation == ""isEmpty"") {
            std::cout << (obj->isEmpty() ? ""true"" : ""false"") << std::endl;
        } else if (operation == ""isFull"") {
            std::cout << (obj->isFull() ? ""true"" : ""false"") << std::endl;
        }
    }

    delete obj;

    return 0;
}",4
Yellow-24,LeetCode,"- **Matrix Traversal**: Iterating through elements of a 2D array.
- **In-place Modification**: Changing the input data directly without creating a new data structure to store the result.
- **Space Optimization**: Finding ways to solve a problem using minimal additional memory.
- **Conditional Logic**: Using `if` statements to make decisions based on element values.
- **Two-Pass Approach**: Solving the problem by iterating through the data multiple times, each pass performing a specific step.
- **Edge Cases**: Handling scenarios like matrices with only one row/column, or matrices where the first row/column contains a zero.","You are given an `m x n` integer matrix. Your task is to modify the matrix *in-place*. If any element in the matrix is `0`, its entire row and its entire column must be set to `0`s. This modification should happen simultaneously, meaning if a `0` at `(r, c)` causes `(r, c')` to become `0`, and then `(r, c')` in turn causes its column to become `0`, this is *not* the intended behavior. Instead, consider all original `0`s, and based on their positions, determine which rows and columns should be zeroed out.

Your solution should aim to be space-efficient, ideally using only constant extra space.","- `m == matrix.length`
- `n == matrix[0].length`
- `1 <= m, n <= 200`
- `-10^9 <= matrix[i][j] <= 10^9`","[[1,1,1],
 [1,0,1],
 [1,1,1]]","[[1,0,1],
 [0,0,0],
 [1,0,1]]

**","Input: 3 3
1 1 1
1 0 1
1 1 1
Output: 1 0 1
0 0 0
1 0 1,Input: 3 4
0 1 2 0
3 4 5 2
1 3 1 5
Output: 0 0 0 0
0 4 5 0
0 3 1 0,Input: 2 2
1 0
1 1
Output: 0 0
1 0,Input: 2 2
1 2
3 4
Output: 1 2
3 4,Input: 1 3
1 0 1
Output: 0 0 0","#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

// Function to set matrix zeroes in-place with O(1) extra space
void setZeroes(int** matrix, int matrixSize, int* matrixColSize) {
    if (matrixSize == 0 || *matrixColSize == 0) {
        return;
    }

    int m = matrixSize;
    int n = *matrixColSize;

    bool firstRowHasZero = false;
    bool firstColHasZero = false;

    // Check if first row has any zero
    for (int j = 0; j < n; j++) {
        if (matrix[0][j] == 0) {
            firstRowHasZero = true;
            break;
        }
    }

    // Check if first column has any zero
    for (int i = 0; i < m; i++) {
        if (matrix[i][0] == 0) {
            firstColHasZero = true;
            break;
        }
    }

    // Use first row and first column as markers
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            if (matrix[i][j] == 0) {
                matrix[i][0] = 0; // Mark row i
                matrix[0][j] = 0; // Mark column j
            }
        }
    }

    // Zero out cells based on markers in first row/col
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                matrix[i][j] = 0;
            }
        }
    }

    // Zero out first row if needed
    if (firstRowHasZero) {
        for (int j = 0; j < n; j++) {
            matrix[0][j] = 0;
        }
    }

    // Zero out first column if needed
    if (firstColHasZero) {
        for (int i = 0; i < m; i++) {
            matrix[i][0] = 0;
        }
    }
}

int main() {
    int m, n;
    scanf(""%d %d"", &m, &n);

    // Dynamically allocate matrix
    int** matrix = (int**)malloc(m * sizeof(int*));
    int* matrixColSizes = (int*)malloc(m * sizeof(int)); // To pass to setZeroes

    for (int i = 0; i < m; i++) {
        matrix[i] = (int*)malloc(n * sizeof(int));
        matrixColSizes[i] = n; // All rows have 'n' columns
        for (int j = 0; j < n; j++) {
            scanf(""%d"", &matrix[i][j]);
        }
    }

    setZeroes(matrix, m, &matrixColSizes[0]); // Pass the size of one column, as all are same

    // Print the modified matrix
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            printf(""%d%c"", matrix[i][j], (j == n - 1) ? '\n' : ' ');
        }
    }

    // Free allocated memory
    for (int i = 0; i < m; i++) {
        free(matrix[i]);
    }
    free(matrix);
    free(matrixColSizes);

    return 0;
}","class Solution:
    def setZeroes(self, matrix: list[list[int]]) -> None:
        """"""
        Do not return anything, modify matrix in-place instead.
        """"""
        if not matrix or not matrix[0]:
            return

        m = len(matrix)
        n = len(matrix[0])

        first_row_has_zero = False
        first_col_has_zero = False

        # Check if first row has any zero
        for j in range(n):
            if matrix[0][j] == 0:
                first_row_has_zero = True
                break
        
        # Check if first column has any zero
        for i in range(m):
            if matrix[i][0] == 0:
                first_col_has_zero = True
                break
        
        # Use first row and first column as markers
        # Iterate from (1,1) to avoid confusing markers with actual zeros in first row/col
        for i in range(1, m):
            for j in range(1, n):
                if matrix[i][j] == 0:
                    matrix[i][0] = 0  # Mark row i
                    matrix[0][j] = 0  # Mark column j
        
        # Zero out cells based on markers in first row/col
        # Iterate from (1,1) again
        for i in range(1, m):
            for j in range(1, n):
                if matrix[i][0] == 0 or matrix[0][j] == 0:
                    matrix[i][j] = 0
        
        # Zero out first row if needed
        if first_row_has_zero:
            for j in range(n):
                matrix[0][j] = 0
        
        # Zero out first column if needed
        if first_col_has_zero:
            for i in range(m):
                matrix[i][0] = 0

def main():
    m, n = map(int, input().split())
    matrix = []
    for _ in range(m):
        matrix.append(list(map(int, input().split())))
    
    sol = Solution()
    sol.setZeroes(matrix)
    
    for i in range(m):
        print(*(matrix[i]))

if __name__ == '__main__':
    main()","import java.util.Scanner;

class Solution {
    public void setZeroes(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return;
        }

        int m = matrix.length;
        int n = matrix[0].length;

        boolean firstRowHasZero = false;
        boolean firstColHasZero = false;

        // Check if first row has any zero
        for (int j = 0; j < n; j++) {
            if (matrix[0][j] == 0) {
                firstRowHasZero = true;
                break;
            }
        }

        // Check if first column has any zero
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                firstColHasZero = true;
                break;
            }
        }

        // Use first row and first column as markers
        // Iterate from (1,1) to avoid confusing markers with actual zeros in first row/col
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0; // Mark row i
                    matrix[0][j] = 0; // Mark column j
                }
            }
        }

        // Zero out cells based on markers in first row/col
        // Iterate from (1,1) again
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }

        // Zero out first row if needed
        if (firstRowHasZero) {
            for (int j = 0; j < n; j++) {
                matrix[0][j] = 0;
            }
        }

        // Zero out first column if needed
        if (firstColHasZero) {
            for (int i = 0; i < m; i++) {
                matrix[i][0] = 0;
            }
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int m = scanner.nextInt();
        int n = scanner.nextInt();

        int[][] matrix = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = scanner.nextInt();
            }
        }

        Solution sol = new Solution();
        sol.setZeroes(matrix);

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(matrix[i][j] + (j == n - 1 ? """" : "" ""));
            }
            System.out.println();
        }

        scanner.close();
    }
}","// Function to set matrix zeroes in-place with O(1) extra space
var setZeroes = function(matrix) {
    if (!matrix || matrix.length === 0 || matrix[0].length === 0) {
        return;
    }

    let m = matrix.length;
    let n = matrix[0].length;

    let firstRowHasZero = false;
    let firstColHasZero = false;

    // Check if first row has any zero
    for (let j = 0; j < n; j++) {
        if (matrix[0][j] === 0) {
            firstRowHasZero = true;
            break;
        }
    }

    // Check if first column has any zero
    for (let i = 0; i < m; i++) {
        if (matrix[i][0] === 0) {
            firstColHasZero = true;
            break;
        }
    }

    // Use first row and first column as markers
    // Iterate from (1,1) to avoid confusing markers with actual zeros in first row/col
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            if (matrix[i][j] === 0) {
                matrix[i][0] = 0; // Mark row i
                matrix[0][j] = 0; // Mark column j
            }
        }
    }

    // Zero out cells based on markers in first row/col
    // Iterate from (1,1) again
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            if (matrix[i][0] === 0 || matrix[0][j] === 0) {
                matrix[i][j] = 0;
            }
        }
    }

    // Zero out first row if needed
    if (firstRowHasZero) {
        for (let j = 0; j < n; j++) {
            matrix[0][j] = 0;
        }
    }

    // Zero out first column if needed
    if (firstColHasZero) {
        for (let i = 0; i < m; i++) {
            matrix[i][0] = 0;
        }
    }
    // No return value, matrix is modified in-place.
};

// Main function for I/O handling
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let lines = [];
    rl.on('line', (line) => {
        lines.push(line);
    }).on('close', () => {
        const [m, n] = lines[0].split(' ').map(Number);
        let matrix = [];
        for (let i = 1; i <= m; i++) {
            matrix.push(lines[i].split(' ').map(Number));
        }

        setZeroes(matrix);

        for (let i = 0; i < m; i++) {
            console.log(matrix[i].join(' '));
        }
    });
}

main();","#include <iostream>
#include <vector>

// Function to set matrix zeroes in-place with O(1) extra space
void setZeroes(std::vector<std::vector<int>>& matrix) {
    if (matrix.empty() || matrix[0].empty()) {
        return;
    }

    int m = matrix.size();
    int n = matrix[0].size();

    bool firstRowHasZero = false;
    bool firstColHasZero = false;

    // Check if first row has any zero
    for (int j = 0; j < n; ++j) {
        if (matrix[0][j] == 0) {
            firstRowHasZero = true;
            break;
        }
    }

    // Check if first column has any zero
    for (int i = 0; i < m; ++i) {
        if (matrix[i][0] == 0) {
            firstColHasZero = true;
            break;
        }
    }

    // Use first row and first column as markers
    // Iterate from (1,1) to avoid confusing markers with actual zeros in first row/col
    for (int i = 1; i < m; ++i) {
        for (int j = 1; j < n; ++j) {
            if (matrix[i][j] == 0) {
                matrix[i][0] = 0; // Mark row i
                matrix[0][j] = 0; // Mark column j
            }
        }
    }

    // Zero out cells based on markers in first row/col
    // Iterate from (1,1) again
    for (int i = 1; i < m; ++i) {
        for (int j = 1; j < n; ++j) {
            if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                matrix[i][j] = 0;
            }
        }
    }

    // Zero out first row if needed
    if (firstRowHasZero) {
        for (int j = 0; j < n; ++j) {
            matrix[0][j] = 0;
        }
    }

    // Zero out first column if needed
    if (firstColHasZero) {
        for (int i = 0; i < m; ++i) {
            matrix[i][0] = 0;
        }
    }
}

int main() {
    int m, n;
    std::cin >> m >> n;

    std::vector<std::vector<int>> matrix(m, std::vector<int>(n));
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            std::cin >> matrix[i][j];
        }
    }

    setZeroes(matrix);

    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            std::cout << matrix[i][j] << (j == n - 1 ? """" : "" "");
        }
        std::cout << std::endl;
    }

    return 0;
}",4
White-97,Modulo Arithmetic,"* Modulo Arithmetic
* Basic Integer Operations","Imagine a circular track with a specific number of positions, labeled from 0 up to `N-1`. You start at position 0. If you take `K` steps clockwise around the track, what will be your final position?

Your task is to write a program that takes the total number of positions `N` and the number of steps `K` as input, and returns the final position.","* `1 <= N <= 1000` (Total number of positions)
* `0 <= K <= 10000` (Number of steps taken)","N = 5
K = 7

####","2

####","Input: 10
3
Output: 3
Input: 7
14
Output: 0
Input: 1
5
Output: 0
Input: 100
0
Output: 0
Input: 13
20
Output: 7","#include <stdio.h>

// Function to calculate the final position on a circular track
int calculateFinalPosition(int n, int k) {
    // The modulo operator (%) naturally handles the wrap-around behavior.
    // If K steps are taken on a track with N positions (0 to N-1)
    // starting from 0, the final position is K % N.
    return k % n;
}

int main() {
    int n, k;

    // Read input for N (total positions) and K (steps taken)
    if (scanf(""%d"", &n) != 1) return 1;
    if (scanf(""%d"", &k) != 1) return 1;

    // Calculate the final position
    int finalPosition = calculateFinalPosition(n, k);

    // Print the result
    printf(""%d\n"", finalPosition);

    return 0;
}","def calculate_final_position(n: int, k: int) -> int:
    # The modulo operator (%) naturally handles the wrap-around behavior.
    # If K steps are taken on a track with N positions (0 to N-1)
    # starting from 0, the final position is K % N.
    return k % n

if __name__ == ""__main__"":
    # Read input for N (total positions) and K (steps taken)
    n = int(input())
    k = int(input())

    # Calculate the final position
    final_position = calculate_final_position(n, k)

    # Print the result
    print(final_position)","import java.util.Scanner;

public class Solution {

    // Function to calculate the final position on a circular track
    public static int calculateFinalPosition(int n, int k) {
        // The modulo operator (%) naturally handles the wrap-around behavior.
        // If K steps are taken on a track with N positions (0 to N-1)
        // starting from 0, the final position is K % N.
        return k % n;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read input for N (total positions) and K (steps taken)
        int n = scanner.nextInt();
        int k = scanner.nextInt();

        // Calculate the final position
        int finalPosition = calculateFinalPosition(n, k);

        // Print the result
        System.out.println(finalPosition);

        scanner.close();
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let input = [];

rl.on('line', (line) => {
    input.push(parseInt(line));
});

rl.on('close', () => {
    const n = input[0];
    const k = input[1];

    // Function to calculate the final position on a circular track
    function calculateFinalPosition(n, k) {
        // The modulo operator (%) naturally handles the wrap-around behavior.
        // If K steps are taken on a track with N positions (0 to N-1)
        // starting from 0, the final position is K % N.
        return k % n;
    }

    // Calculate the final position
    const finalPosition = calculateFinalPosition(n, k);

    // Print the result
    console.log(finalPosition);
});","#include <iostream>

// Function to calculate the final position on a circular track
int calculateFinalPosition(int n, int k) {
    // The modulo operator (%) naturally handles the wrap-around behavior.
    // If K steps are taken on a track with N positions (0 to N-1)
    // starting from 0, the final position is K % N.
    return k % n;
}

int main() {
    int n, k;

    // Read input for N (total positions) and K (steps taken)
    std::cin >> n >> k;

    // Calculate the final position
    int finalPosition = calculateFinalPosition(n, k);

    // Print the result
    std::cout << finalPosition << std::endl;

    return 0;
}",4
White-98,Modulo Arithmetic,"*   Modulo Operator
*   Basic Arithmetic Operations","Imagine a standard 12-hour clock. You are given the current hour and a certain number of hours that have passed. Your task is to determine what hour it will be after those hours have elapsed. Remember that a 12-hour clock cycles from 1 to 12.

For example, if it's 3 o'clock and 5 hours pass, it will be 8 o'clock. If it's 10 o'clock and 4 hours pass, it will be 2 o'clock (because 10 + 4 = 14, and on a 12-hour clock, 14 hours past 12 is 2).","*   `1 <= startHour <= 12` (The starting hour is between 1 and 12, inclusive)
*   `0 <= hoursPassed <= 1000` (The number of hours passed is non-negative)","**

startHour = 10
hoursPassed = 4


**","**

2


**","Input: 1
0
Output: 1
Input: 12
0
Output: 12
Input: 5
12
Output: 5
Input: 1
11
Output: 12
Input: 7
1000
Output: 11","#include <stdio.h>

// Function to calculate the new hour on a 12-hour clock
int calculateNewHour(int startHour, int hoursPassed) {
    // Adjust startHour to be 0-indexed (0-11) for easier modulo calculation
    int zeroIndexedStartHour = startHour - 1;

    // Calculate total hours passed in a 0-indexed system
    int totalZeroIndexedHours = zeroIndexedStartHour + hoursPassed;

    // Apply modulo 12 to find the new 0-indexed hour
    int newZeroIndexedHour = totalZeroIndexedHours % 12;

    // Convert back to 1-indexed (1-12) clock hour
    int newHour = newZeroIndexedHour + 1;

    return newHour;
}

int main() {
    int startHour, hoursPassed;

    // Read input
    if (scanf(""%d"", &startHour) != 1) return 1;
    if (scanf(""%d"", &hoursPassed) != 1) return 1;

    // Calculate and print the result
    int result = calculateNewHour(startHour, hoursPassed);
    printf(""%d\n"", result);

    return 0;
}","def calculate_new_hour(start_hour: int, hours_passed: int) -> int:
    """"""
    Calculates the new hour on a 12-hour clock after a certain number of hours have passed.

    Args:
        start_hour (int): The starting hour (1-12).
        hours_passed (int): The number of hours that have passed (non-negative).

    Returns:
        int: The new hour on the 12-hour clock (1-12).
    """"""
    # Adjust start_hour to be 0-indexed (0-11) for easier modulo calculation
    zero_indexed_start_hour = start_hour - 1

    # Calculate total hours passed in a 0-indexed system
    total_zero_indexed_hours = zero_indexed_start_hour + hours_passed

    # Apply modulo 12 to find the new 0-indexed hour
    new_zero_indexed_hour = total_zero_indexed_hours % 12

    # Convert back to 1-indexed (1-12) clock hour
    new_hour = new_zero_indexed_hour + 1

    return new_hour

if __name__ == ""__main__"":
    start_hour = int(input())
    hours_passed = int(input())

    result = calculate_new_hour(start_hour, hours_passed)
    print(result)","import java.util.Scanner;

public class Solution {

    // Function to calculate the new hour on a 12-hour clock
    public static int calculateNewHour(int startHour, int hoursPassed) {
        // Adjust startHour to be 0-indexed (0-11) for easier modulo calculation
        int zeroIndexedStartHour = startHour - 1;

        // Calculate total hours passed in a 0-indexed system
        int totalZeroIndexedHours = zeroIndexedStartHour + hoursPassed;

        // Apply modulo 12 to find the new 0-indexed hour
        int newZeroIndexedHour = totalZeroIndexedHours % 12;

        // Convert back to 1-indexed (1-12) clock hour
        int newHour = newZeroIndexedHour + 1;

        return newHour;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read input
        int startHour = scanner.nextInt();
        int hoursPassed = scanner.nextInt();

        // Calculate and print the result
        int result = calculateNewHour(startHour, hoursPassed);
        System.out.println(result);

        scanner.close();
    }
}","/**
 * Calculates the new hour on a 12-hour clock after a certain number of hours have passed.
 * @param {number} startHour The starting hour (1-12).
 * @param {number} hoursPassed The number of hours that have passed (non-negative).
 * @returns {number} The new hour on the 12-hour clock (1-12).
 */
function calculateNewHour(startHour, hoursPassed) {
    // Adjust startHour to be 0-indexed (0-11) for easier modulo calculation
    let zeroIndexedStartHour = startHour - 1;

    // Calculate total hours passed in a 0-indexed system
    let totalZeroIndexedHours = zeroIndexedStartHour + hoursPassed;

    // Apply modulo 12 to find the new 0-indexed hour
    let newZeroIndexedHour = totalZeroIndexedHours % 12;

    // Convert back to 1-indexed (1-12) clock hour
    let newHour = newZeroIndexedHour + 1;

    return newHour;
}

// Node.js specific input/output handling
// For competitive programming platforms, this part might need adjustment
// depending on how they provide input (e.g., process.argv, specific readline libraries)

const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let inputLines = [];
rl.on('line', (line) => {
    inputLines.push(parseInt(line));
});

rl.on('close', () => {
    const startHour = inputLines[0];
    const hoursPassed = inputLines[1];
    const result = calculateNewHour(startHour, hoursPassed);
    console.log(result);
});","#include <iostream>

// Function to calculate the new hour on a 12-hour clock
int calculateNewHour(int startHour, int hoursPassed) {
    // Adjust startHour to be 0-indexed (0-11) for easier modulo calculation
    int zeroIndexedStartHour = startHour - 1;

    // Calculate total hours passed in a 0-indexed system
    int totalZeroIndexedHours = zeroIndexedStartHour + hoursPassed;

    // Apply modulo 12 to find the new 0-indexed hour
    int newZeroIndexedHour = totalZeroIndexedHours % 12;

    // Convert back to 1-indexed (1-12) clock hour
    int newHour = newZeroIndexedHour + 1;

    return newHour;
}

int main() {
    int startHour, hoursPassed;

    // Read input
    std::cin >> startHour >> hoursPassed;

    // Calculate and print the result
    int result = calculateNewHour(startHour, hoursPassed);
    std::cout << result << std::endl;

    return 0;
}",4.4
White-99,Modulo Arithmetic,"*   Modulo Operator (`%`)
*   Integer Division
*   Basic Arithmetic Operations
*   Conditional Logic","You are given two positive integers, `N` and `K`. Your task is to find the smallest integer `X` such that `X` is greater than or equal to `N` and `X` is perfectly divisible by `K`.","*   `1 <= N <= 1000`
*   `1 <= K <= 100`","N = 10
K = 3",12,"Input: 7 5
Output: 10
Input: 20 4
Output: 20
Input: 1 10
Output: 10
Input: 99 11
Output: 99
Input: 42 8
Output: 48","#include <stdio.h>

// Function to find the nearest multiple
int findNearestMultiple(int n, int k) {
    // Constraints state 1 <= K <= 100, so k will never be 0.
    int remainder = n % k;
    if (remainder == 0) {
        return n;
    } else {
        return n + (k - remainder);
    }
}

int main() {
    int n, k;
    // Assuming N and K are provided on separate lines or space-separated on one line
    if (scanf(""%d %d"", &n, &k) != 2) {
        // Handle potential input error
        return 1; 
    }
    int result = findNearestMultiple(n, k);
    printf(""%d\n"", result);
    return 0;
}","def find_nearest_multiple(n, k):
    # Constraints state 1 <= K <= 100, so k will never be 0.
    remainder = n % k
    if remainder == 0:
        return n
    else:
        return n + (k - remainder)

def main():
    # Assuming N and K are provided on separate lines
    n = int(input())
    k = int(input())
    result = find_nearest_multiple(n, k)
    print(result)

if __name__ == ""__main__"":
    main()","import java.util.Scanner;

public class Main {

    // Function to find the nearest multiple
    public static int findNearestMultiple(int n, int k) {
        // Constraints state 1 <= K <= 100, so k will never be 0.
        int remainder = n % k;
        if (remainder == 0) {
            return n;
        } else {
            return n + (k - remainder);
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int k = scanner.nextInt();
        int result = findNearestMultiple(n, k);
        System.out.println(result);
        scanner.close();
    }
}","// Function to find the nearest multiple
function findNearestMultiple(n, k) {
    // Constraints state 1 <= K <= 100, so k will never be 0.
    let remainder = n % k;
    if (remainder === 0) {
        return n;
    } else {
        return n + (k - remainder);
    }
}

// Main function to handle input/output
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let inputLines = [];
    rl.on('line', (line) => {
        inputLines.push(line);
    }).on('close', () => {
        const n = parseInt(inputLines[0]);
        const k = parseInt(inputLines[1]);
        const result = findNearestMultiple(n, k);
        console.log(result);
    });
}

main();","#include <iostream>

// Function to find the nearest multiple
int findNearestMultiple(int n, int k) {
    // Constraints state 1 <= K <= 100, so k will never be 0.
    int remainder = n % k;
    if (remainder == 0) {
        return n;
    } else {
        return n + (k - remainder);
    }
}

int main() {
    int n, k;
    std::cin >> n >> k;
    int result = findNearestMultiple(n, k);
    std::cout << result << std::endl;
    return 0;
}",4.2
White-100,Basic String Manipulation,"- String iteration (looping through characters)
- Conditional logic (if statements)
- String building / concatenation
- Basic I/O (reading strings and characters)","Write a program that reads a string and a single character from the input. Your task is to create a new string by removing all occurrences of that specific character from the original string. Finally, print the modified string.","- The input string will contain only lowercase English letters.
- The length of the input string will be between 1 and 100 characters.
- The character to be removed will be a single lowercase English letter.
- The output string should not contain the specified character.","hello
l",heo,"Input:
programming
g
Output:
programmin
Input:
apple
p
Output:
ale
Input:
banana
a
Output:
bnn
Input:
test
x
Output:
test","#include <stdio.h>
#include <string.h>

// Function to remove all occurrences of a character from a string
void filterString(const char *original, char charToRemove, char *result) {
    int i = 0;
    int j = 0;
    while (original[i] != '\0') {
        if (original[i] != charToRemove) {
            result[j] = original[i];
            j++;
        }
        i++;
    }
    result[j] = '\0'; // Null-terminate the new string
}

int main() {
    char inputString[101]; // Max 100 chars + null terminator
    char charToRemove;
    char filteredString[101];

    // Read the input string
    scanf(""%s"", inputString);

    // Read the character to remove (note the space before %c to consume newline)
    scanf("" %c"", &charToRemove);

    // Call the logic function
    filterString(inputString, charToRemove, filteredString);

    // Print the result
    printf(""%s\n"", filteredString);

    return 0;
}","def filter_string(original_string, char_to_remove):
    """"""
    Removes all occurrences of a specific character from a string.
    """"""
    result = [] # Using a list of characters for efficient building, then join
    for char in original_string:
        if char != char_to_remove:
            result.append(char)
    return """".join(result)

def main():
    # Read the input string
    input_string = input()

    # Read the character to remove
    # input() reads a string, take the first character
    char_to_remove = input()[0]

    # Call the logic function
    filtered_string = filter_string(input_string, char_to_remove)

    # Print the result
    print(filtered_string)

if __name__ == ""__main__"":
    main()","import java.util.Scanner;

public class Main {

    // Function to remove all occurrences of a character from a string
    public static String filterString(String original, char charToRemove) {
        StringBuilder result = new StringBuilder();
        for (char c : original.toCharArray()) {
            if (c != charToRemove) {
                result.append(c);
            }
        }
        return result.toString();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the input string
        String inputString = scanner.next();

        // Read the character to remove
        char charToRemove = scanner.next().charAt(0);

        // Call the logic function
        String filteredString = filterString(inputString, charToRemove);

        // Print the result
        System.out.println(filteredString);

        scanner.close();
    }
}","// For Node.js environment
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let inputLines = [];

rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    main();
});

// Function to remove all occurrences of a character from a string
function filterString(original, charToRemove) {
    let result = '';
    for (let i = 0; i < original.length; i++) {
        if (original[i] !== charToRemove) {
            result += original[i];
        }
    }
    return result;
}

function main() {
    const inputString = inputLines[0];
    // charToRemove will be the first character of the second input line
    const charToRemove = inputLines[1][0]; 

    // Call the logic function
    const filteredString = filterString(inputString, charToRemove);

    // Print the result
    console.log(filteredString);
}","#include <iostream>
#include <string>

// Function to remove all occurrences of a character from a string
std::string filterString(const std::string& original, char charToRemove) {
    std::string result = """"; // Initialize an empty string
    for (char c : original) {
        if (c != charToRemove) {
            result += c; // Append character if it's not the one to remove
        }
    }
    return result;
}

int main() {
    std::string inputString;
    char charToRemove;

    // Read the input string
    std::cin >> inputString;

    // Read the character to remove
    std::cin >> charToRemove;

    // Call the logic function
    std::string filteredString = filterString(inputString, charToRemove);

    // Print the result
    std::cout << filteredString << std::endl;

    return 0;
}",4.2
Yellow-25,Frequency Count / Anagrams,"*   Frequency Counting (using arrays as hash maps)
*   String Manipulation
*   Basic Algorithm Design
*   Conditional Logic","Given two strings, `s1` and `s2`, determine if `s2` is an anagram of `s1`. An anagram is a word or phrase formed by rearranging the letters of another, using all the original letters exactly once. For example, ""listen"" and ""silent"" are anagrams. The comparison should be case-sensitive and assume strings consist only of lowercase English letters.","*   `s1` and `s2` will consist of lowercase English letters ('a'-'z') only.
*   The length of both `s1` and `s2` will be between 1 and 1000 characters, inclusive.","**
s1 = ""listen""
s2 = ""silent""

**","**
true

**","Input: hello
olleh
Output: true
Input: programming
gramproingm
Output: false
Input: race
care
Output: true
Input: cat
actt
Output: false
Input: a
a
Output: true","#include <stdio.h>
#include <string.h>
#include <stdbool.h>

// Core logic function
bool areAnagrams(const char* s1, const char* s2) {
    int len1 = strlen(s1);
    int len2 = strlen(s2);

    if (len1 != len2) {
        return false;
    }

    int freq[26] = {0}; // Initialize all counts to 0

    // Count characters in s1
    for (int i = 0; i < len1; i++) {
        freq[s1[i] - 'a']++;
    }

    // Decrement counts for characters in s2
    for (int i = 0; i < len2; i++) {
        freq[s2[i] - 'a']--;
    }

    // Check if all counts are zero
    for (int i = 0; i < 26; i++) {
        if (freq[i] != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    char s1[1001]; // Max length 1000 + null terminator
    char s2[1001];

    // Read input strings
    if (scanf(""%s"", s1) != 1) return 1;
    if (scanf(""%s"", s2) != 1) return 1;

    // Call the core logic function
    bool result = areAnagrams(s1, s2);

    // Print the result
    if (result) {
        printf(""true\n"");
    } else {
        printf(""false\n"");
    }

    return 0;
}","import sys

def areAnagrams(s1: str, s2: str) -> bool:
    if len(s1) != len(s2):
        return False

    freq = [0] * 26 # Initialize all counts to 0

    # Count characters in s1
    for char_code in map(ord, s1):
        freq[char_code - ord('a')] += 1

    # Decrement counts for characters in s2
    for char_code in map(ord, s2):
        freq[char_code - ord('a')] -= 1

    # Check if all counts are zero
    for count in freq:
        if count != 0:
            return False

    return True

if __name__ == ""__main__"":
    # Read input strings from stdin
    s1 = sys.stdin.readline().strip()
    s2 = sys.stdin.readline().strip()

    # Call the core logic function
    result = areAnagrams(s1, s2)

    # Print the result as lowercase 'true' or 'false'
    print(str(result).lower())","import java.util.Scanner;

public class Solution {

    // Core logic function
    public boolean areAnagrams(String s1, String s2) {
        if (s1.length() != s2.length()) {
            return false;
        }

        int[] freq = new int[26]; // All elements initialized to 0 by default

        // Count characters in s1
        for (char c : s1.toCharArray()) {
            freq[c - 'a']++;
        }

        // Decrement counts for characters in s2
        for (char c : s2.toCharArray()) {
            freq[c - 'a']--;
        }

        // Check if all counts are zero
        for (int count : freq) {
            if (count != 0) {
                return false;
            }
        }

        return true;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read input strings
        String s1 = scanner.next();
        String s2 = scanner.next();

        // Create an instance of the Solution class to call the non-static method
        Solution sol = new Solution();
        boolean result = sol.areAnagrams(s1, s2);

        // Print the result
        System.out.println(result);

        scanner.close();
    }
}","// Core logic function
function areAnagrams(s1, s2) {
    if (s1.length !== s2.length) {
        return false;
    }

    const freq = new Array(26).fill(0); // Initialize all counts to 0

    // Count characters in s1
    for (let i = 0; i < s1.length; i++) {
        freq[s1.charCodeAt(i) - 'a'.charCodeAt(0)]++;
    }

    // Decrement counts for characters in s2
    for (let i = 0; i < s2.length; i++) {
        freq[s2.charCodeAt(i) - 'a'.charCodeAt(0)]--;
    }

    // Check if all counts are zero
    for (let i = 0; i < freq.length; i++) {
        if (freq[i] !== 0) {
            return false;
        }
    }

    return true;
}

// Main function to handle I/O
function main() {
    // Node.js specific way to read input from stdin
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let lines = [];
    rl.on('line', (line) => {
        lines.push(line);
    });

    rl.on('close', () => {
        const s1 = lines[0];
        const s2 = lines[1];

        // Call the core logic function
        const result = areAnagrams(s1, s2);

        // Print the result
        console.log(result);
    });
}

main();","#include <iostream>
#include <string>
#include <vector>
#include <numeric>

// Core logic function
bool areAnagrams(const std::string& s1, const std::string& s2) {
    if (s1.length() != s2.length()) {
        return false;
    }

    std::vector<int> freq(26, 0); // Initialize all counts to 0

    // Count characters in s1
    for (char c : s1) {
        freq[c - 'a']++;
    }

    // Decrement counts for characters in s2
    for (char c : s2) {
        freq[c - 'a']--;
    }

    // Check if all counts are zero
    for (int count : freq) {
        if (count != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    std::string s1, s2;

    // Read input strings
    std::cin >> s1 >> s2;

    // Call the core logic function
    bool result = areAnagrams(s1, s2);

    // Print the result
    if (result) {
        std::cout << ""true\n"";
    } else {
        std::cout << ""false\n"";
    }

    return 0;
}",4.4
Yellow-26,Linear Search,"- Arrays
- Iteration (Loops)
- Conditional Statements
- Basic Search Algorithms (Linear Search)","You are given an array of integers `arr` and a target integer `target`. Your task is to implement a function that finds the first occurrence of the `target` integer in the `arr` and returns its index. If the `target` is not found anywhere in the array, the function should return -1.","- `1 <= arr.length <= 1000`
- `-10^9 <= arr[i] <= 10^9`
- `-10^9 <= target <= 10^9`","6
4 2 7 1 9 3
1

Explanation:
- The first line `6` indicates the size of the array.
- The second line `4 2 7 1 9 3` represents the elements of the array.
- The third line `1` is the target element to search for.

####",3,"Input:
5
10 20 30 40 50
10
Output: 0
Input:
6
1 5 9 13 17 21
21
Output: 5
Input:
4
100 200 300 400
150
Output: -1
Input:
7
5 8 12 8 20 3 8
8
Output: 1
Input:
1
42
42
Output: 0","#include <stdio.h>
#include <stdlib.h>

// Function to perform linear search
int findElement(int arr[], int size, int target) {
    for (int i = 0; i < size; i++) {
        if (arr[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}

int main() {
    int N;
    // Read the size of the array
    if (scanf(""%d"", &N) != 1) {
        return 1; // Error reading N
    }

    // Allocate memory for the array
    int *arr = (int *)malloc(N * sizeof(int));
    if (arr == NULL) {
        return 1; // Memory allocation failed
    }

    // Read array elements
    for (int i = 0; i < N; i++) {
        if (scanf(""%d"", &arr[i]) != 1) {
            free(arr); // Free allocated memory before exiting
            return 1; // Error reading array element
        }
    }

    int target;
    // Read the target element
    if (scanf(""%d"", &target) != 1) {
        free(arr); // Free allocated memory before exiting
        return 1; // Error reading target
    }

    // Call the linear search function
    int result = findElement(arr, N, target);

    // Print the result
    printf(""%d\n"", result);

    // Free allocated memory
    free(arr);

    return 0;
}","def find_element(arr, target):
    """"""
    Performs a linear search to find the first occurrence of the target in the array.

    Args:
        arr (list): A list of integers.
        target (int): The integer to search for.

    Returns:
        int: The index of the first occurrence of the target, or -1 if not found.
    """"""
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # Target found, return its index
    return -1  # Target not found

if __name__ == ""__main__"":
    # Read the size of the array (not strictly necessary for Python list, but good practice for consistency)
    N = int(input())

    # Read array elements
    arr = list(map(int, input().split()))

    # Read the target element
    target = int(input())

    # Call the linear search function
    result = find_element(arr, target)

    # Print the result
    print(result)","import java.util.Scanner;

public class Solution {

    // Function to perform linear search
    public int findElement(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i; // Target found, return its index
            }
        }
        return -1; // Target not found
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the size of the array
        int N = scanner.nextInt();

        int[] arr = new int[N];
        // Read array elements
        for (int i = 0; i < N; i++) {
            arr[i] = scanner.nextInt();
        }

        // Read the target element
        int target = scanner.nextInt();

        // Create an instance of the Solution class
        Solution sol = new Solution();

        // Call the linear search function
        int result = sol.findElement(arr, target);

        // Print the result
        System.out.println(result);

        scanner.close();
    }
}","// For competitive programming environments, input usually comes from stdin
// using the 'readline' module or similar.
// This example assumes a setup where input is read line by line.

let input = """";
process.stdin.on('data', data => {
    input += data;
});

process.stdin.on('end', () => {
    const lines = input.trim().split('\n');

    // The first line is N (size of array), though not strictly used in JS like C/Java
    // const N = parseInt(lines[0]); 

    // The second line contains the array elements
    const arr = lines[1].split(' ').map(Number);

    // The third line contains the target
    const target = parseInt(lines[2]);

    // Call the function and print the result
    console.log(findElement(arr, target));
});

/**
 * Performs a linear search to find the first occurrence of the target in the array.
 * @param {number[]} arr The array of numbers to search in.
 * @param {number} target The number to search for.
 * @returns {number} The index of the first occurrence of the target, or -1 if not found.
 */
function findElement(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}","#include <iostream>
#include <vector>

// Function to perform linear search
int findElement(const std::vector<int>& arr, int target) {
    for (int i = 0; i < arr.size(); ++i) {
        if (arr[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int N;
    // Read the size of the array
    std::cin >> N;

    std::vector<int> arr(N);
    // Read array elements
    for (int i = 0; i < N; ++i) {
        std::cin >> arr[i];
    }

    int target;
    // Read the target element
    std::cin >> target;

    // Call the linear search function
    int result = findElement(arr, target);

    // Print the result
    std::cout << result << std::endl;

    return 0;
}",4.3
Yellow-27,Kadane’s Algorithm,"*   Kadane's Algorithm
*   Dynamic Programming (implicitly)
*   Array Traversal
*   Handling negative numbers in sums","You're given an array of integers, which can contain both positive and negative numbers. Your task is to find the contiguous subarray (a sequence of elements that are adjacent in the array) that has the largest possible sum. You need to return this maximum sum. If all numbers are negative, you should return the largest single negative number.","*   `1 <= nums.length <= 10^5`
*   `-10^4 <= nums[i] <= 10^4`","**
`[-2, 1, -3, 4, -1, 2, 1, -5, 4]`

**","**
`6`

**","Input: 1
1
Output: 1
Input: 3
-1 -2 -3
Output: -1
Input: 5
5 4 -1 7 8
Output: 23
Input: 8
-2 -3 4 -1 -2 1 5 -3
Output: 7
Input: 1
10
Output: 10","#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

// Function to find the maximum of two integers
int max(int a, int b) {
    return (a > b) ? a : b;
}

// Function implementing Kadane's Algorithm
int maxSubArraySum(int* nums, int numsSize) {
    if (numsSize == 0) {
        return 0; // Or handle as an error, based on specific requirements
    }

    int max_so_far = nums[0];
    int current_max = nums[0];

    for (int i = 1; i < numsSize; i++) {
        current_max = max(nums[i], current_max + nums[i]);
        max_so_far = max(max_so_far, current_max);
    }

    return max_so_far;
}

int main() {
    int n;
    // Read the number of elements
    if (scanf(""%d"", &n) != 1) {
        return 1;
    }

    if (n <= 0) {
        printf(""0\n""); // Constraints say 1 <= n
        return 0;
    }

    int* nums = (int*)malloc(n * sizeof(int));
    if (nums == NULL) {
        return 1; // Malloc failed
    }

    // Read the array elements
    for (int i = 0; i < n; i++) {
        if (scanf(""%d"", &nums[i]) != 1) {
            free(nums);
            return 1;
        }
    }

    // Calculate and print the result
    int result = maxSubArraySum(nums, n);
    printf(""%d\n"", result);

    free(nums);
    return 0;
}","import sys

def max_subarray_sum(nums: list[int]) -> int:
    if not nums:
        return 0 # Constraints say 1 <= n

    max_so_far = nums[0]
    current_max = nums[0]

    for i in range(1, len(nums)):
        current_max = max(nums[i], current_max + nums[i])
        max_so_far = max(max_so_far, current_max)

    return max_so_far

if __name__ == '__main__':
    # Read the number of elements
    n = int(sys.stdin.readline())

    if n <= 0:
        print(0) # Constraints say 1 <= n
    else:
        # Read the array elements
        # Assuming elements are space-separated on a single line
        nums_str = sys.stdin.readline().strip().split()
        nums = [int(x) for x in nums_str]

        # Calculate and print the result
        result = max_subarray_sum(nums)
        print(result)","import java.util.Scanner;

public class Solution {

    // Function implementing Kadane's Algorithm
    public static int maxSubArraySum(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0; // Or throw an exception, based on specific requirements
        }

        int maxSoFar = nums[0];
        int currentMax = nums[0];

        for (int i = 1; i < nums.length; i++) {
            currentMax = Math.max(nums[i], currentMax + nums[i]);
            maxSoFar = Math.max(maxSoFar, currentMax);
        }

        return maxSoFar;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the number of elements
        int n = scanner.nextInt();

        if (n <= 0) {
            System.out.println(0); // Constraints say 1 <= n
            scanner.close();
            return;
        }

        int[] nums = new int[n];
        // Read the array elements
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }

        // Calculate and print the result
        int result = maxSubArraySum(nums);
        System.out.println(result);

        scanner.close();
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

// Function implementing Kadane's Algorithm
function maxSubarraySum(nums) {
    if (!nums || nums.length === 0) {
        return 0; // Or handle as an error, based on specific requirements
    }

    let maxSoFar = nums[0];
    let currentMax = nums[0];

    for (let i = 1; i < nums.length; i++) {
        currentMax = Math.max(nums[i], currentMax + nums[i]);
        maxSoFar = Math.max(maxSoFar, currentMax);
    }

    return maxSoFar;
}

let inputLines = [];
rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    const n = parseInt(inputLines[0], 10);

    if (n <= 0) {
        console.log(0); // Constraints say 1 <= n
        return;
    }

    // Assuming elements are space-separated on the second line
    const nums = inputLines[1].split(' ').map(Number);

    // Calculate and print the result
    const result = maxSubarraySum(nums);
    console.log(result);
});","#include <iostream>
#include <vector>
#include <algorithm> // Required for std::max
#include <limits>    // Required for std::numeric_limits

// Function implementing Kadane's Algorithm
int maxSubArraySum(const std::vector<int>& nums) {
    if (nums.empty()) {
        return 0; // Or throw an exception, based on specific requirements
    }

    int max_so_far = nums[0];
    int current_max = nums[0];

    for (size_t i = 1; i < nums.size(); ++i) {
        current_max = std::max(nums[i], current_max + nums[i]);
        max_so_far = std::max(max_so_far, current_max);
    }

    return max_so_far;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    // Read the number of elements
    std::cin >> n;

    if (n <= 0) {
        std::cout << 0 << std::endl; // Constraints say 1 <= n
        return 0;
    }

    std::vector<int> nums(n);
    // Read the array elements
    for (int i = 0; i < n; ++i) {
        std::cin >> nums[i];
    }

    // Calculate and print the result
    int result = maxSubArraySum(nums);
    std::cout << result << std::endl;

    return 0;
}",4.4
Yellow-28,"Singly Linked List (creation, traversal, insertion, deletion)","*   Singly Linked List structure
*   Node creation and manipulation
*   Traversal through a linked list
*   Insertion of a node at the end
*   Deletion of a specific node by value","A singly linked list is a fundamental data structure consisting of a sequence of nodes, where each node contains data and a pointer (or reference) to the next node in the sequence. The last node points to `NULL` (or `None`).

Your task is to implement a basic singly linked list and perform common operations on it:
1.  **Insertion at the End**: Add a new node with a given value to the end of the list.
2.  **Deletion of a Specific Node**: Remove the first occurrence of a node with a given value from the list. If the value is not found, the list remains unchanged.
3.  **Traversal and Printing**: Print all elements of the list, separated by spaces. If the list is empty, print nothing.

You will receive a series of commands:
*   `insert <value>`: Inserts `value` at the end of the list.
*   `delete <value>`: Deletes the first node found with `value`.
*   `print`: Prints the current state of the list.","*   The number of operations `N` will be between 1 and 100.
*   Node values will be integers between -1000 and 1000.
*   The `delete` command may target a value that does not exist in the list.
*   An empty line will be considered as an empty list for `print` command.","insert 5
insert 10
print
delete 5
insert 20
print
delete 100
print","5 10
10 20
10 20","Input:
insert 1
insert 2
insert 3
print
delete 2
print
delete 1
print
delete 3
print
Output:
1 2 3
1 3
3

Input:
insert 100
delete 50
print
insert 200
delete 100
print
delete 200
print
Output:
100
200

Input:
insert 1
insert 1
insert 2
print
delete 1
print
insert 3
delete 1
print
Output:
1 1 2
1 2
2 3

Input:
print
insert 7
print
delete 7
print
delete 5
print
Output:

7
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define Node structure
typedef struct Node {
    int value;
    struct Node* next;
} Node;

// Define LinkedList structure
typedef struct LinkedList {
    Node* head;
} LinkedList;

// Function to create a new Node
Node* createNode(int value) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    if (newNode == NULL) {
        fprintf(stderr, ""Memory allocation failed\n"");
        exit(EXIT_FAILURE);
    }
    newNode->value = value;
    newNode->next = NULL;
    return newNode;
}

// Function to initialize a LinkedList
void initLinkedList(LinkedList* list) {
    list->head = NULL;
}

// Function to insert a node at the end of the list
void insertAtEnd(LinkedList* list, int value) {
    Node* newNode = createNode(value);
    if (list->head == NULL) {
        list->head = newNode;
    } else {
        Node* current = list->head;
        while (current->next != NULL) {
            current = current->next;
        }
        current->next = newNode;
    }
}

// Function to delete the first occurrence of a node with a given value
void deleteNode(LinkedList* list, int value) {
    Node* current = list->head;
    Node* previous = NULL;

    // If head node itself holds the value to be deleted
    if (current != NULL && current->value == value) {
        list->head = current->next; // Changed head
        free(current);             // Free old head
        return;
    }

    // Search for the value to be deleted, keep track of the previous node
    while (current != NULL && current->value != value) {
        previous = current;
        current = current->next;
    }

    // If value was not present in the list
    if (current == NULL) {
        return;
    }

    // Unlink the node from the linked list
    previous->next = current->next;
    free(current); // Free memory
}

// Function to print the linked list
void printList(LinkedList* list) {
    Node* current = list->head;
    if (current == NULL) {
        printf(""\n""); // Print newline for empty list
        return;
    }
    while (current != NULL) {
        printf(""%d"", current->value);
        current = current->next;
        if (current != NULL) {
            printf("" "");
        }
    }
    printf(""\n"");
}

// Function to free all nodes in the list (destructor equivalent)
void freeList(LinkedList* list) {
    Node* current = list->head;
    Node* next;
    while (current != NULL) {
        next = current->next;
        free(current);
        current = next;
    }
    list->head = NULL;
}

int main() {
    LinkedList mylist;
    initLinkedList(&mylist);

    char command[10];
    int value;

    while (scanf(""%s"", command) != EOF) {
        if (strcmp(command, ""insert"") == 0) {
            scanf(""%d"", &value);
            insertAtEnd(&mylist, value);
        } else if (strcmp(command, ""delete"") == 0) {
            scanf(""%d"", &value);
            deleteNode(&mylist, value);
        } else if (strcmp(command, ""print"") == 0) {
            printList(&mylist);
        }
    }

    freeList(&mylist); // Clean up allocated memory
    return 0;
}","class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def insertAtEnd(self, value):
        new_node = Node(value)
        if self.head is None:
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node

    def deleteNode(self, value):
        current = self.head
        previous = None

        # If head node itself holds the value to be deleted
        if current is not None and current.value == value:
            self.head = current.next
            return

        # Search for the value to be deleted, keep track of the previous node
        while current is not None and current.value != value:
            previous = current
            current = current.next

        # If value was not present in the list
        if current is None:
            return

        # Unlink the node from the linked list
        previous.next = current.next

    def printList(self):
        current = self.head
        elements = []
        while current:
            elements.append(str(current.value))
            current = current.next
        print("" "".join(elements))

if __name__ == '__main__':
    mylist = LinkedList()
    
    import sys
    for line in sys.stdin:
        parts = line.strip().split()
        command = parts[0]

        if command == ""insert"":
            value = int(parts[1])
            mylist.insertAtEnd(value);
        elif command == ""delete"":
            value = int(parts[1])
            mylist.deleteNode(value)
        elif command == ""print"":
            mylist.printList()","import java.util.Scanner;

// Define Node class
class Node {
    int value;
    Node next;

    Node(int val) {
        value = val;
        next = null;
    }
}

// Define LinkedList class
class LinkedList {
    Node head;

    public LinkedList() {
        head = null;
    }

    // Function to insert a node at the end of the list
    public void insertAtEnd(int value) {
        Node newNode = new Node(value);
        if (head == null) {
            head = newNode;
        } else {
            Node current = head;
            while (current.next != null) {
                current = current.next;
            }
            current.next = newNode;
        }
    }

    // Function to delete the first occurrence of a node with a given value
    public void deleteNode(int value) {
        Node current = head;
        Node previous = null;

        // If head node itself holds the value to be deleted
        if (current != null && current.value == value) {
            head = current.next; // Changed head
            return;
        }

        // Search for the value to be deleted, keep track of the previous node
        while (current != null && current.value != value) {
            previous = current;
            current = current.next;
        }

        // If value was not present in the list
        if (current == null) {
            return;
        }

        // Unlink the node from the linked list
        previous.next = current.next;
    }

    // Function to print the linked list
    public void printList() {
        Node current = head;
        if (current == null) {
            System.out.println();
            return;
        }
        StringBuilder sb = new StringBuilder();
        while (current != null) {
            sb.append(current.value);
            current = current.next;
            if (current != null) {
                sb.append("" "");
            }
        }
        System.out.println(sb.toString());
    }
}

public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        LinkedList mylist = new LinkedList();

        while (scanner.hasNext()) {
            String command = scanner.next();
            if (command.equals(""insert"")) {
                int value = scanner.nextInt();
                mylist.insertAtEnd(value);
            } else if (command.equals(""delete"")) {
                int value = scanner.nextInt();
                mylist.deleteNode(value);
            } else if (command.equals(""print"")) {
                mylist.printList();
            }
        }
        scanner.close();
    }
}","class Node {
    constructor(value) {
        this.value = value;
        this.next = null;
    }
}

class LinkedList {
    constructor() {
        this.head = null;
    }

    // Function to insert a node at the end of the list
    insertAtEnd(value) {
        const newNode = new Node(value);
        if (this.head === null) {
            this.head = newNode;
        } else {
            let current = this.head;
            while (current.next !== null) {
                current = current.next;
            }K
            current.next = newNode;
        }
    }

    // Function to delete the first occurrence of a node with a given value
    deleteNode(value) {
        let current = this.head;
        let previous = null;

        // If head node itself holds the value to be deleted
        if (current !== null && current.value === value) {
            this.head = current.next; // Changed head
            return;
        }

        // Search for the value to be deleted, keep track of the previous node
        while (current !== null && current.value !== value) {
            previous = current;
            current = current.next;
        }

        // If value was not present in the list
        if (current === null) {
            return;
        }

        // Unlink the node from the linked list
        previous.next = current.next;
    }

    // Function to print the linked list
    printList() {
        let current = this.head;
        const elements = [];
        while (current !== null) {
            elements.push(current.value);
            current = current.next;
        }
        console.log(elements.join("" ""));
    }
}

// Main execution logic to handle input/output
function main() {
    const mylist = new LinkedList();
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
        terminal: false
    });

    rl.on('line', (line) => {
        const parts = line.trim().split(' ');
        const command = parts[0];

        if (command === ""insert"") {
            const value = parseInt(parts[1], 10);
            mylist.insertAtEnd(value);
        } else if (command === ""delete"") {
            const value = parseInt(parts[1], 10);
            mylist.deleteNode(value);
        } else if (command === ""print"") {
            mylist.printList();
        }
    });

    // Handle end of input for cases where rl.on('close') might be needed for a final print or cleanup
    // For this problem, commands are processed line by line, so no explicit 'close' handling is strictly necessary
    // for functional correctness if input ends after the last command.
}

main();","#include <iostream>
#include <string>
#include <sstream>

// Define Node structure
struct Node {
    int value;
    Node* next;

    Node(int val) : value(val), next(nullptr) {}
};

// Define LinkedList class
class LinkedList {
public:
    Node* head;

    LinkedList() : head(nullptr) {}

    ~LinkedList() {
        Node* current = head;
        Node* nextNode;
        while (current != nullptr) {
            nextNode = current->next;
            delete current;
            current = nextNode;
        }
        head = nullptr; // Ensure head is null after destruction
    }

    // Function to insert a node at the end of the list
    void insertAtEnd(int value) {
        Node* newNode = new Node(value);
        if (head == nullptr) {
            head = newNode;
        } else {
            Node* current = head;
            while (current->next != nullptr) {
                current = current->next;
            }
            current->next = newNode;
        }
    }

    // Function to delete the first occurrence of a node with a given value
    void deleteNode(int value) {
        Node* current = head;
        Node* previous = nullptr;

        // If head node itself holds the value to be deleted
        if (current != nullptr && current->value == value) {
            head = current->next; // Changed head
            delete current;       // Free old head
            return;
        }

        // Search for the value to be deleted, keep track of the previous node
        while (current != nullptr && current->value != value) {
            previous = current;
            current = current->next;
        }

        // If value was not present in the list
        if (current == nullptr) {
            return;
        }

        // Unlink the node from the linked list
        previous->next = current->next;
        delete current; // Free memory
    }

    // Function to print the linked list
    void printList() {
        Node* current = head;
        if (current == nullptr) {
            std::cout << std::endl;
            return;
        }
        while (current != nullptr) {
            std::cout << current->value;
            current = current->next;
            if (current != nullptr) {
                std::cout << "" "";
            }
        }
        std::cout << std::endl;
    }
};

int main() {
    LinkedList mylist;
    std::string line;
    std::string command;
    int value;

    while (std::cin >> command) {
        if (command == ""insert"") {
            std::cin >> value;
            mylist.insertAtEnd(value);
        } else if (command == ""delete"") {
            std::cin >> value;
            mylist.deleteNode(value);
        } else if (command == ""print"") {
            mylist.printList();
        }
    }

    return 0;
}",4.1
Yellow-29,"Singly Linked List (creation, traversal, insertion, deletion)","*   Singly Linked List structure (Node, head pointer)
*   Linked List Traversal
*   Node Insertion (specifically at the end)
*   Node Deletion (at a specific index, handling head deletion)","You are tasked with implementing a basic singly linked list and performing a series of operations on it. Your program should be able to:
1.  **Insert a node at the end** of the list.
2.  **Delete a node at a specific 0-indexed position**. If the index is out of bounds, no deletion should occur.
3.  **Print the current state of the linked list**. If the list is empty, print ""List is empty.""

Your program will receive a sequence of commands. Each command starts with a character indicating the operation:
*   `I <value>`: Insert `value` at the end of the list.
*   `D <index>`: Delete the node at `index`.
*   `P`: Print the current list.","*   The number of operations `N` will be between 1 and 20.
*   Values inserted will be integers between 0 and 100.
*   Indices for deletion will be between 0 and `N-1` (where N is current list size).
*   The list will not contain duplicate values (for simplicity, not an implementation constraint).
*   The list size will not exceed 20 elements at any point.","I 10
I 20
P
I 30
D 1
P
D 5
P


####","10 20
10 30
10","Input: P
I 5
P
D 0
P
I 100
D 1
P
Output: List is empty.
5
List is empty.
100

Input: I 1
I 2
I 3
I 4
P
D 2
P
D 2
P
D 0
P
Output: 1 2 3 4
1 2 4
1 2
2

Input: I 10
I 20
P
D 0
D 0
P
D 0
P
I 5
I 15
I 25
P
D 1
P
D 1
P
D 1
P
D 0
P
Output: 10 20
List is empty.
List is empty.
5 15 25
5 25
5
5
List is empty.","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Node structure for singly linked list
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (newNode == NULL) {
        perror(""Failed to allocate memory for new node"");
        exit(EXIT_FAILURE);
    }
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to insert a node at the end of the list
struct Node* insertEnd(struct Node* head, int data) {
    struct Node* newNode = createNode(data);
    if (head == NULL) {
        return newNode; // New node becomes the head
    } else {
        struct Node* current = head;
        while (current->next != NULL) {
            current = current->next;
        }
        current->next = newNode;
        return head;
    }
}

// Function to delete a node at a specific index
struct Node* deleteAtIndex(struct Node* head, int index) {
    if (head == NULL) {
        return NULL; // List is empty
    }

    if (index == 0) {
        struct Node* temp = head;
        head = head->next;
        free(temp); // Free the old head
        return head;
    }

    struct Node* current = head;
    struct Node* prev = NULL;
    int count = 0;

    while (current != NULL && count < index) {
        prev = current;
        current = current->next;
        count++;
    }

    if (current == NULL) {
        // Index out of bounds
        return head;
    }

    // current is the node to be deleted
    prev->next = current->next;
    free(current);
    return head;
}

// Function to print the linked list
void printList(struct Node* head) {
    if (head == NULL) {
        printf(""List is empty.\n"");
        return;
    }
    struct Node* current = head;
    while (current != NULL) {
        printf(""%d"", current->data);
        current = current->next;
        if (current != NULL) {
            printf("" "");
        }
    }
    printf(""\n"");
}

// Function to free all nodes in the list
void freeList(struct Node* head) {
    struct Node* current = head;
    struct Node* next;
    while (current != NULL) {
        next = current->next;
        free(current);
        current = next;
    }
}

int main() {
    struct Node* head = NULL;
    char command[10];
    int value, index;

    while (scanf(""%s"", command) != EOF) {
        if (strcmp(command, ""I"") == 0) {
            scanf(""%d"", &value);
            head = insertEnd(head, value);
        } else if (strcmp(command, ""D"") == 0) {
            scanf(""%d"", &index);
            head = deleteAtIndex(head, index);
        } else if (strcmp(command, ""P"") == 0) {
            printList(head);
        } else {
            break; // Unknown command or end of input stream
        }
    }

    freeList(head); // Clean up memory
    return 0;
}","import sys

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class SinglyLinkedList:
    def __init__(self):
        self.head = None

    def insert_end(self, data):
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
        else:
            current = self.head
            while current.next is not None:
                current = current.next
            current.next = new_node

    def delete_at_index(self, index):
        if self.head is None:
            return # List is empty

        if index == 0:
            self.head = self.head.next
            return

        current = self.head
        prev = None
        count = 0

        while current is not None and count < index:
            prev = current
            current = current.next
            count += 1

        if current is None:
            # Index out of bounds
            return

        # current is the node to be deleted
        prev.next = current.next

    def print_list(self):
        if self.head is None:
            print(""List is empty."")
            return
        
        elements = []
        current = self.head
        while current is not None:
            elements.append(str(current.data))
            current = current.next
        print("" "".join(elements))

# Main logic for reading input and executing commands
def main():
    list_obj = SinglyLinkedList()

    for line in sys.stdin:
        parts = line.strip().split()
        if not parts:
            continue
        
        command = parts[0]
        if command == 'I':
            value = int(parts[1])
            list_obj.insert_end(value)
        elif command == 'D':
            index = int(parts[1])
            list_obj.delete_at_index(index)
        elif command == 'P':
            list_obj.print_list()
        else:
            break # Unknown command or end of input

if __name__ == ""__main__"":
    main()","import java.util.Scanner;

// Node class for singly linked list
class Node {
    int data;
    Node next;

    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}

// LinkedList class to manage operations
class SinglyLinkedList {
    Node head;

    public SinglyLinkedList() {
        this.head = null;
    }

    // Method to insert a node at the end of the list
    public void insertEnd(int data) {
        Node newNode = new Node(data);
        if (this.head == null) {
            this.head = newNode;
        } else {
            Node current = this.head;
            while (current.next != null) {
                current = current.next;
            }
            current.next = newNode;
        }
    }

    // Method to delete a node at a specific index
    public void deleteAtIndex(int index) {
        if (this.head == null) {
            return; // List is empty
        }

        if (index == 0) {
            this.head = this.head.next;
            return;
        }

        Node current = this.head;
        Node prev = null;
        int count = 0;

        while (current != null && count < index) {
            prev = current;
            current = current.next;
            count++;
        }

        if (current == null) {
            // Index out of bounds
            return;
        }

        // current is the node to be deleted
        prev.next = current.next;
    }

    // Method to print the linked list
    public void printList() {
        if (this.head == null) {
            System.out.println(""List is empty."");
            return;
        }
        Node current = this.head;
        StringBuilder sb = new StringBuilder();
        while (current != null) {
            sb.append(current.data);
            current = current.next;
            if (current != null) {
                sb.append("" "");
            }
        }
        System.out.println(sb.toString());
    }
}

public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        SinglyLinkedList list = new SinglyLinkedList();

        while (scanner.hasNext()) {
            String command = scanner.next();
            if (command.equals(""I"")) {
                int value = scanner.nextInt();
                list.insertEnd(value);
            } else if (command.equals(""D"")) {
                int index = scanner.nextInt();
                list.deleteAtIndex(index);
            } else if (command.equals(""P"")) {
                list.printList();
            } else {
                break; // Unknown command or end of input stream
            }
        }
        scanner.close();
    }
}","// Node class for singly linked list
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

// LinkedList class to manage operations
class SinglyLinkedList {
    constructor() {
        this.head = null;
    }

    // Method to insert a node at the end of the list
    insertEnd(data) {
        const newNode = new Node(data);
        if (this.head === null) {
            this.head = newNode;
        } else {
            let current = this.head;
            while (current.next !== null) {
                current = current.next;
            }
            current.next = newNode;
        }
    }

    // Method to delete a node at a specific index
    deleteAtIndex(index) {
        if (this.head === null) {
            return; // List is empty
        }

        if (index === 0) {
            this.head = this.head.next;
            return;
        }

        let current = this.head;
        let prev = null;
        let count = 0;

        while (current !== null && count < index) {
            prev = current;
            current = current.next;
            count++;
        }

        if (current === null) {
            // Index out of bounds
            return;
        }

        // current is the node to be deleted
        prev.next = current.next;
    }

    // Method to print the linked list
    printList() {
        if (this.head === null) {
            console.log(""List is empty."");
            return;
        }
        let elements = [];
        let current = this.head;
        while (current !== null) {
            elements.push(current.data);
            current = current.next;
        }
        console.log(elements.join("" ""));
    }
}

// Main logic for reading input and executing commands
function main() {
    const list = new SinglyLinkedList();
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
        terminal: false
    });

    rl.on('line', (line) => {
        const parts = line.trim().split(' ');
        if (parts.length === 0) {
            return;
        }

        const command = parts[0];
        if (command === 'I') {
            const value = parseInt(parts[1], 10);
            list.insertEnd(value);
        } else if (command === 'D') {
            const index = parseInt(parts[1], 10);
            list.deleteAtIndex(index);
        } else if (command === 'P') {
            list.printList();
        }
    });

    rl.on('close', () => {
        // Any final cleanup if needed
    });
}

// Call the main function to start execution
main();","#include <iostream>
#include <string>

// Node structure for singly linked list
struct Node {
    int data;
    Node* next;

    Node(int val) : data(val), next(nullptr) {}
};

// Function to insert a node at the end of the list
Node* insertEnd(Node* head, int data) {
    Node* newNode = new Node(data);
    if (head == nullptr) {
        return newNode; // New node becomes the head
    } else {
        Node* current = head;
        while (current->next != nullptr) {
            current = current->next;
        }
        current->next = newNode;
        return head;
    }
}

// Function to delete a node at a specific index
Node* deleteAtIndex(Node* head, int index) {
    if (head == nullptr) {
        return nullptr; // List is empty
    }

    if (index == 0) {
        Node* temp = head;
        head = head->next;
        delete temp; // Free the old head
        return head;
    }

    Node* current = head;
    Node* prev = nullptr;
    int count = 0;

    while (current != nullptr && count < index) {
        prev = current;
        current = current->next;
        count++;
    }

    if (current == nullptr) {
        // Index out of bounds
        return head;
    }

    // current is the node to be deleted
    prev->next = current->next;
    delete current;
    return head;
}

// Function to print the linked list
void printList(Node* head) {
    if (head == nullptr) {
        std::cout << ""List is empty."" << std::endl;
        return;
    }
    Node* current = head;
    while (current != nullptr) {
        std::cout << current->data;
        current = current->next;
        if (current != nullptr) {
            std::cout << "" "";
        }
    }
    std::cout << std::endl;
}

// Function to free all nodes in the list
void freeList(Node* head) {
    Node* current = head;
    Node* next;
    while (current != nullptr) {
        next = current->next;
        delete current;
        current = next;
    }
}

int main() {
    Node* head = nullptr;
    std::string command;
    int value, index;

    while (std::cin >> command) {
        if (command == ""I"") {
            std::cin >> value;
            head = insertEnd(head, value);
        } else if (command == ""D"") {
            std::cin >> index;
            head = deleteAtIndex(head, index);
        } else if (command == ""P"") {
            printList(head);
        } else {
            break; // Unknown command or end of input stream
        }
    }

    freeList(head); // Clean up memory
    return 0;
}",4.2
Yellow-30,Kadane’s Algorithm,"*   Dynamic Programming
*   Greedy Approach
*   Kadane's Algorithm
*   Array Traversal","You are given an array of integers, `nums`. Your task is to find the sum of a contiguous subarray (a subarray that occupies consecutive positions within the original array) which has the largest sum. This subarray must contain at least one number.

For example, if the array is `[-2, 1, -3, 4, -1, 2, 1, -5, 4]`, the contiguous subarray `[4, -1, 2, 1]` has the largest sum, which is `6`.","* `1 <= nums.length <= 10^5`
* `-100 <= nums[i] <= 100`",-2 1 -3 4 -1 2 1 -5 4,6,"Input: 1
Output: 1
Input: -1
Output: -1
Input: -5 -1 -3
Output: -1
Input: 1 2 3 -2 5
Output: 9
Input: 5 4 -1 7 8
Output: 23","#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

// Function to find the maximum of two integers
int max(int a, int b) {
    return (a > b) ? a : b;
}

// Function to find the maximum subarray sum using Kadane's Algorithm
int maxSubArraySum(int* nums, int numsSize) {
    if (numsSize == 0) {
        return 0; // Or handle error as per problem constraints
    }

    int max_so_far = nums[0];
    int current_max = nums[0];

    for (int i = 1; i < numsSize; i++) {
        current_max = max(nums[i], current_max + nums[i]);
        max_so_far = max(max_so_far, current_max);
    }

    return max_so_far;
}

int main() {
    int* nums = NULL;
    int capacity = 10; // Initial capacity
    int numsSize = 0;
    int num;

    nums = (int*)malloc(capacity * sizeof(int));
    if (nums == NULL) {
        return 1; // Malloc failed
    }

    // Read space-separated integers from stdin until newline or EOF
    while (scanf(""%d"", &num) == 1) {
        if (numsSize == capacity) {
            capacity *= 2;
            int* temp = (int*)realloc(nums, capacity * sizeof(int));
            if (temp == NULL) {
                free(nums);
                return 1; // Realloc failed
            }
            nums = temp;
        }
        nums[numsSize++] = num;

        // Check for newline character, assuming input is on a single line
        char next_char = getchar();
        if (next_char == '\n' || next_char == EOF) {
            ungetc(next_char, stdin); // Put it back if it's EOF for potential future reads (though not needed here)
            break;
        }
        ungetc(next_char, stdin); // Put back any non-space/non-digit character to be re-read if it's not a separator
    }

    // Consume the rest of the line to clear buffer if any chars are left (like a final newline not caught by scanf)
    while (getchar() != '\n' && !feof(stdin));

    printf(""%d\n"", maxSubArraySum(nums, numsSize));

    free(nums);
    return 0;
}","import sys

def max_sub_array_sum(nums: list[int]) -> int:
    if not nums:
        return 0 # Or handle error as per problem constraints

    max_so_far = nums[0]
    current_max = nums[0]

    for i in range(1, len(nums)):
        current_max = max(nums[i], current_max + nums[i])
        max_so_far = max(max_so_far, current_max)
    
    return max_so_far

if __name__ == '__main__':
    # Read space-separated integers from stdin
    line = sys.stdin.readline().strip()
    nums = list(map(int, line.split()))
    
    result = max_sub_array_sum(nums)
    print(result)","import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

public class Solution {

    // Function to find the maximum subarray sum using Kadane's Algorithm
    public int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0; // Or handle error as per problem constraints
        }

        int maxSoFar = nums[0];
        int currentMax = nums[0];

        for (int i = 1; i < nums.length; i++) {
            currentMax = Math.max(nums[i], currentMax + nums[i]);
            maxSoFar = Math.max(maxSoFar, currentMax);
        }

        return maxSoFar;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        List<Integer> numList = new ArrayList<>();

        String line = scanner.nextLine();
        String[] strNums = line.trim().split(""\\s+""); // Split by one or more spaces

        for (String strNum : strNums) {
            if (!strNum.isEmpty()) {
                numList.add(Integer.parseInt(strNum));
            }
        }

        int[] nums = new int[numList.size()];
        for (int i = 0; i < numList.size(); i++) {
            nums[i] = numList.get(i);
        }

        Solution sol = new Solution();
        System.out.println(sol.maxSubArray(nums));

        scanner.close();
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

// Function to find the maximum subarray sum using Kadane's Algorithm
function maxSubArraySum(nums) {
    if (nums.length === 0) {
        return 0; // Or handle error as per problem constraints
    }

    let maxSoFar = nums[0];
    let currentMax = nums[0];

    for (let i = 1; i < nums.length; i++) {
        currentMax = Math.max(nums[i], currentMax + nums[i]);
        maxSoFar = Math.max(maxSoFar, currentMax);
    }

    return maxSoFar;
}

rl.on('line', (line) => {
    const nums = line.split(' ').map(Number);
    const result = maxSubArraySum(nums);
    console.log(result);
    rl.close();
});","#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <sstream>

// Function to find the maximum subarray sum using Kadane's Algorithm
int maxSubArraySum(const std::vector<int>& nums) {
    if (nums.empty()) {
        return 0; // Or handle error as per problem constraints
    }

    int max_so_far = nums[0];
    int current_max = nums[0];

    for (size_t i = 1; i < nums.size(); ++i) {
        current_max = std::max(nums[i], current_max + nums[i]);
        max_so_far = std::max(max_so_far, current_max);
    }

    return max_so_far;
}

int main() {
    std::string line;
    std::getline(std::cin, line);
    std::stringstream ss(line);
    std::vector<int> nums;
    int num;

    while (ss >> num) {
        nums.push_back(num);
    }

    std::cout << maxSubArraySum(nums) << std::endl;

    return 0;
}",4.5
Yellow-31,Prefix & Suffix Sums,"*   Arrays
*   Prefix Sums (Cumulative Sums)
*   Time Complexity Optimization
*   Basic I/O","You're the commander of a data analysis unit, and your team has collected a long sequence of numbers. You need to process various queries asking for the sum of elements within specific ranges (segments) of this sequence. A naive approach of summing elements for each query would be too slow given the potentially large number of queries and the sequence length. Your mission is to implement an efficient system that can quickly respond to these range sum queries.

Given an array of `n` integers and `q` queries, each query consists of two indices, `L` and `R` (0-indexed). For each query, you must find the sum of all elements in the array from index `L` to `R`, inclusive.","*   `1 <= n <= 10^5` (size of the array)
*   `1 <= q <= 10^5` (number of queries)
*   `-10^9 <= arr[i] <= 10^9` (value of array elements)
*   `0 <= L <= R < n` (query indices are valid)
*   The sum of elements in a range can exceed the capacity of a 32-bit integer, so use a 64-bit integer type (e.g., `long long` in C++/C, `long` in Java, standard integers in Python/JS).","**

5
1 2 3 4 5
2
0 2
2 4


**","**

6
12


**","Input:
1
100
1
0 0
Output:
100
Input:
7
-5 2 -10 8 1 3 -7
3
0 6
1 3
4 5
Output:
-8
0
4
Input:
10
1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000
2
0 9
5 5
Output:
10000000000
1000000000
Input:
6
0 0 0 0 0 0
2
0 5
2 3
Output:
0
0","#include <stdio.h>
#include <stdlib.h>

// Function to calculate prefix sums and handle queries
void solve() {
    int n;
    scanf(""%d"", &n);

    long long *arr = (long long *)malloc(n * sizeof(long long));
    long long *prefix_sum = (long long *)malloc((n + 1) * sizeof(long long));

    if (arr == NULL || prefix_sum == NULL) {
        // Handle memory allocation failure
        if (arr) free(arr);
        if (prefix_sum) free(prefix_sum);
        return;
    }

    prefix_sum[0] = 0;
    for (int i = 0; i < n; i++) {
        scanf(""%lld"", &arr[i]);
        prefix_sum[i + 1] = prefix_sum[i] + arr[i];
    }

    int q;
    scanf(""%d"", &q);

    for (int k = 0; k < q; k++) {
        int L, R;
        scanf(""%d %d"", &L, &R);
        long long range_sum = prefix_sum[R + 1] - prefix_sum[L];
        printf(""%lld\n"", range_sum);
    }

    free(arr);
    free(prefix_sum);
}

int main() {
    solve();
    return 0;
}","def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    # Python integers handle arbitrary size, so no explicit long long equivalent is needed.
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + arr[i]

    q = int(input())

    results = []
    for _ in range(q):
        L, R = map(int, input().split())
        range_sum = prefix_sum[R + 1] - prefix_sum[L]
        results.append(str(range_sum))
    
    # Print all results at once for potentially faster output with many queries.
    print(""\n"".join(results))

if __name__ == ""__main__"":
    solve()","import java.util.Scanner;

public class Solution {

    // Function to calculate prefix sums and handle queries
    public static void solve() {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        // Using long for array elements and prefix sums to prevent overflow
        // as elements can be 10^9 and N can be 10^5, sum can be 10^14.
        long[] arr = new long[n];
        long[] prefixSum = new long[n + 1];

        prefixSum[0] = 0;
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextLong();
            prefixSum[i + 1] = prefixSum[i] + arr[i];
        }

        int q = scanner.nextInt();

        for (int k = 0; k < q; k++) {
            int L = scanner.nextInt();
            int R = scanner.nextInt();
            long rangeSum = prefixSum[R + 1] - prefixSum[L];
            System.out.println(rangeSum);
        }

        scanner.close();
    }

    public static void main(String[] args) {
        solve();
    }
}","function solve() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let lines = [];
    rl.on('line', (line) => {
        lines.push(line);
    }).on('close', () => {
        let lineIndex = 0;

        const n = parseInt(lines[lineIndex++]);
        const arr = lines[lineIndex++].split(' ').map(Number);

        // JavaScript numbers can represent large integers accurately up to 2^53 - 1.
        // 10^14 is within this safe integer limit, so standard Numbers are fine.
        const prefixSum = new Array(n + 1).fill(0);
        for (let i = 0; i < n; i++) {
            prefixSum[i + 1] = prefixSum[i] + arr[i];
        }

        const q = parseInt(lines[lineIndex++]);
        const results = [];

        for (let k = 0; k < q; k++) {
            const [L, R] = lines[lineIndex++].split(' ').map(Number);
            const rangeSum = prefixSum[R + 1] - prefixSum[L];
            results.push(rangeSum);
        }
        console.log(results.join('\n'));
    });
}

solve(); // Call the main solve function","#include <iostream>
#include <vector>

// Function to calculate prefix sums and handle queries
void solve() {
    int n;
    std::cin >> n;

    // Using long long for array elements and prefix sums to prevent overflow
    // as elements can be 10^9 and N can be 10^5, sum can be 10^14.
    std::vector<long long> arr(n);
    std::vector<long long> prefix_sum(n + 1, 0); // Initialize with 0s

    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i];
        prefix_sum[i + 1] = prefix_sum[i] + arr[i];
    }

    int q;
    std::cin >> q;

    for (int k = 0; k < q; ++k) {
        int L, R;
        std::cin >> L >> R;
        long long range_sum = prefix_sum[R + 1] - prefix_sum[L];
        std::cout << range_sum << ""\n"";
    }
}

int main() {
    // Optimize C++ standard streams for faster input/output.
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    solve();
    return 0;
}",3.9
White-101,Modulo Arithmetic,"*   Modulo Arithmetic
*   Integer Arithmetic","You are given a starting day of the week (represented by a number from 0 for Monday to 6 for Sunday) and a number of days that have passed. Your task is to calculate and return the day of the week it will be after those days have passed.

For example, if today is Wednesday (day 2) and 3 days pass, it will be Saturday (day 5).
If today is Friday (day 4) and 4 days pass, it will be Tuesday (day 1).","*   `0 <= startDay <= 6` (representing Monday to Sunday)
*   `0 <= daysPassed <= 1000`","2
5

(startDay = 2, daysPassed = 5)

####",0,"Input: 0
0
Output: 0
Input: 6
1
Output: 0
Input: 3
7
Output: 3
Input: 2
15
Output: 3
Input: 5
1000
Output: 6","#include <stdio.h>

// Function to calculate the future day of the week
int calculateFutureDay(int startDay, int daysPassed) {
    // Calculate the total number of days from Monday (day 0)
    // Then use modulo 7 to find the equivalent day in the 0-6 range
    return (startDay + daysPassed) % 7;
}

int main() {
    int startDay, daysPassed;

    // Read the starting day from stdin
    scanf(""%d"", &startDay);

    // Read the number of days passed from stdin
    scanf(""%d"", &daysPassed);

    // Calculate the future day
    int futureDay = calculateFutureDay(startDay, daysPassed);

    // Print the result to stdout
    printf(""%d\n"", futureDay);

    return 0;
}","def calculate_future_day(start_day, days_passed):
    # Calculate the total number of days from Monday (day 0)
    # Then use modulo 7 to find the equivalent day in the 0-6 range
    return (start_day + days_passed) % 7

if __name__ == ""__main__"":
    # Read the starting day from stdin
    start_day = int(input())

    # Read the number of days passed from stdin
    days_passed = int(input())

    # Calculate the future day
    future_day = calculate_future_day(start_day, days_passed)

    # Print the result to stdout
    print(future_day)","import java.util.Scanner;

public class Solution {

    // Function to calculate the future day of the week
    public static int calculateFutureDay(int startDay, int daysPassed) {
        // Calculate the total number of days from Monday (day 0)
        // Then use modulo 7 to find the equivalent day in the 0-6 range
        return (startDay + daysPassed) % 7;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the starting day from stdin
        int startDay = scanner.nextInt();

        // Read the number of days passed from stdin
        int daysPassed = scanner.nextInt();

        // Calculate the future day
        int futureDay = calculateFutureDay(startDay, daysPassed);

        // Print the result to stdout
        System.out.println(futureDay);

        scanner.close();
    }
}","function calculateFutureDay(startDay, daysPassed) {
    // Calculate the total number of days from Monday (day 0)
    // Then use modulo 7 to find the equivalent day in the 0-6 range
    return (startDay + daysPassed) % 7;
}

// Read input from stdin
// For typical competitive programming environments in JS, input is often read line by line.
// This example assumes two lines of input, one for startDay and one for daysPassed.
let input = '';
process.stdin.on('data', data => {
    input += data;
});

process.stdin.on('end', () => {
    const lines = input.trim().split('\n');
    const startDay = parseInt(lines[0], 10);
    const daysPassed = parseInt(lines[1], 10);

    const futureDay = calculateFutureDay(startDay, daysPassed);
    console.log(futureDay);
});","#include <iostream>

// Function to calculate the future day of the week
int calculateFutureDay(int startDay, int daysPassed) {
    // Calculate the total number of days from Monday (day 0)
    // Then use modulo 7 to find the equivalent day in the 0-6 range
    return (startDay + daysPassed) % 7;
}

int main() {
    int startDay, daysPassed;

    // Read the starting day from stdin
    std::cin >> startDay;

    // Read the number of days passed from stdin
    std::cin >> daysPassed;

    // Calculate the future day
    int futureDay = calculateFutureDay(startDay, daysPassed);

    // Print the result to stdout
    std::cout << futureDay << std::endl;

    return 0;
}",4
Yellow-32,Intro to Backtracking,"-   **Backtracking:** A general algorithm for finding all (or some) solutions to computational problems, that incrementally builds candidates to the solutions, and abandons a candidate (""backtracks"") as soon as it determines that the candidate cannot possibly be completed to a valid solution.
-   **Recursion:** A function calling itself to solve smaller instances of the same problem.
-   **Power Set:** The set of all possible subsets of a given set, including the empty set and the set itself.","Given an integer array `nums` that contains distinct elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. The order of subsets and the order of elements within a subset can be arbitrary.","- `0 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`
- All the elements of `nums` are unique.","`nums = [1,2,3]`","[]
[1]
[1 2]
[1 2 3]
[1 3]
[2]
[2 3]
[3]

(The order of subsets and elements within subsets shown above is just one possible valid output based on the provided solution.)","Input: 1 2 3
Output: [] [1] [1 2] [1 2 3] [1 3] [2] [2 3] [3]
Input: 4 5
Output: [] [4] [4 5] [5]
Input: -1
Output: [] [-1]
Input: 
Output: []
Input: 10 -5 0
Output: [] [10] [10 -5] [10 -5 0] [10 0] [-5] [-5 0] [0]","#include <stdio.h>
#include <stdlib.h> // For malloc, free, atoi
#include <string.h> // For strtok

// Global variables for the current subset and its size for simpler C management.
// This is a common simplification for Yellow Belt C problems with recursion
// that would otherwise require complex dynamic array management.
// For a production system, these would typically be passed as parameters or use a struct.
int currentSubset_c[10]; // Max subset size based on constraints
int currentSubsetSize_c = 0;

// Helper function to print a subset
void printSubset_c(int* subset, int size) {
    printf(""["");
    for (int i = 0; i < size; i++) {
        printf(""%d"", subset[i]);
        if (i < size - 1) {
            printf("" "");
        }
    }
    printf(""]\n"");
}

// Core logic: Backtracking function to generate and print all subsets
void generateSubsetsRecursive_c(int* nums, int numsSize, int startIndex) {
    // Base Case: Add the current subset to the result (print it)
    printSubset_c(currentSubset_c, currentSubsetSize_c);

    // Recursive Step: Explore choices
    for (int i = startIndex; i < numsSize; i++) {
        // Include nums[i]
        currentSubset_c[currentSubsetSize_c++] = nums[i];

        // Recurse with the next element
        generateSubsetsRecursive_c(nums, numsSize, i + 1);

        // Backtrack: Remove nums[i]
        currentSubsetSize_c--;
    }
}

// Main function to initiate the process
void findAllSubsets_c(int* nums, int numsSize) {
    currentSubsetSize_c = 0; // Reset for each call to findAllSubsets
    generateSubsetsRecursive_c(nums, numsSize, 0);
}

int main() {
    int nums[10]; // Max 10 elements based on constraints
    int count = 0;
    char line[100]; // Buffer to read a line, max length for 10 elements and spaces/signs

    // Read input line (space-separated integers) from stdin
    if (fgets(line, sizeof(line), stdin) != NULL) {
        // Remove trailing newline character if present
        line[strcspn(line, ""\n"")] = 0;

        // Tokenize the string to extract numbers
        char *token = strtok(line, "" "");
        while (token != NULL && count < 10) {
            nums[count++] = atoi(token);
            token = strtok(NULL, "" "");
        }
    }

    findAllSubsets_c(nums, count);

    return 0;
}","import sys

class Solution:
    def _generate_subsets_recursive(self, result, current_subset, nums, start_index):
        # Base Case: Add a copy of the current subset to the result
        result.append(list(current_subset))

        # Recursive Step: Explore choices
        for i in range(start_index, len(nums)):
            # Include nums[i]
            current_subset.append(nums[i])

            # Recurse with the next element
            self._generate_subsets_recursive(result, current_subset, nums, i + 1)

            # Backtrack: Remove nums[i]
            current_subset.pop()

    def find_all_subsets(self, nums):
        result = []
        current_subset = []
        self._generate_subsets_recursive(result, current_subset, nums, 0)
        return result

def main():
    line = sys.stdin.readline().strip()
    
    nums = []
    if line: # Handle empty line for an empty array
        nums = list(map(int, line.split()))

    sol = Solution()
    subsets = sol.find_all_subsets(nums)

    # Print the results
    for subset in subsets:
        print(""["", end="""")
        print(*subset, sep="" "", end="""") # Pythonic way to print list elements space-separated
        print(""]"")

if __name__ == ""__main__"":
    main()","import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
// import java.util.Arrays; // Not strictly needed, but common for array operations

public class Solution {

    // Core logic: Backtracking function to generate all subsets
    private void generateSubsetsRecursive(List<List<Integer>> result,
                                          List<Integer> currentSubset,
                                          int[] nums,
                                          int startIndex) {
        // Base Case: Add a copy of the current subset to the result
        result.add(new ArrayList<>(currentSubset));

        // Recursive Step: Explore choices
        for (int i = startIndex; i < nums.length; i++) {
            // Include nums[i]
            currentSubset.add(nums[i]);

            // Recurse with the next element
            generateSubsetsRecursive(result, currentSubset, nums, i + 1);

            // Backtrack: Remove nums[i]
            currentSubset.remove(currentSubset.size() - 1);
        }
    }

    // Main function to initiate the process and return all subsets
    public List<List<Integer>> findAllSubsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();
        generateSubsetsRecursive(result, currentSubset, nums, 0);
        return result;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String line = scanner.nextLine();
        scanner.close();

        // Parse input string into an array of integers
        int[] nums;
        if (line.trim().isEmpty()) {
            nums = new int[0];
        } else {
            String[] numStrings = line.trim().split("" "");
            nums = new int[numStrings.length];
            for (int i = 0; i < numStrings.length; i++) {
                nums[i] = Integer.parseInt(numStrings[i]);
            }
        }

        Solution sol = new Solution();
        List<List<Integer>> subsets = sol.findAllSubsets(nums);

        // Print the results
        for (List<Integer> subset : subsets) {
            System.out.print(""["");
            for (int i = 0; i < subset.size(); i++) {
                System.out.print(subset.get(i));
                if (i < subset.size() - 1) {
                    System.out.print("" "");
                }
            }
            System.out.println(""]"");
        }
    }
}","const readline = require('readline');

// Core logic: Backtracking function to generate all subsets
function generateSubsetsRecursive(result, currentSubset, nums, startIndex) {
    // Base Case: Add a copy of the current subset to the result
    result.push([...currentSubset]); // Use spread operator for shallow copy

    // Recursive Step: Explore choices
    for (let i = startIndex; i < nums.length; i++) {
        // Include nums[i]
        currentSubset.push(nums[i]);

        // Recurse with the next element
        generateSubsetsRecursive(result, currentSubset, nums, i + 1);

        // Backtrack: Remove nums[i]
        currentSubset.pop();
    }
}

// Main function to initiate the process and return all subsets
function findAllSubsets(nums) {
    const result = [];
    const currentSubset = [];
    generateSubsetsRecursive(result, currentSubset, nums, 0);
    return result;
}

// Set up readline interface for input
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.on('line', (line) => {
    let nums = [];
    if (line.trim() !== """") {
        nums = line.split(' ').map(Number);
    }

    const subsets = findAllSubsets(nums);

    // Print the results
    for (const subset of subsets) {
        console.log(`[${subset.join(' ')}]`);
    }

    rl.close();
});","#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <algorithm> // Not strictly needed, but common for array operations

// Core logic: Backtracking function to generate all subsets
void generateSubsetsRecursive(std::vector<std::vector<int>>& result,
                               std::vector<int>& currentSubset,
                               const std::vector<int>& nums,
                               int startIndex) {
    // Base Case: Add a copy of the current subset to the result
    result.push_back(currentSubset);

    // Recursive Step: Explore choices
    for (int i = startIndex; i < nums.size(); ++i) {
        // Include nums[i]
        currentSubset.push_back(nums[i]);

        // Recurse with the next element
        generateSubsetsRecursive(result, currentSubset, nums, i + 1);

        // Backtrack: Remove nums[i]
        currentSubset.pop_back();
    }
}

// Main function to initiate the process and return all subsets
std::vector<std::vector<int>> findAllSubsets(const std::vector<int>& nums) {
    std::vector<std::vector<int>> result;
    std::vector<int> currentSubset;
    generateSubsetsRecursive(result, currentSubset, nums, 0);
    return result;
}

int main() {
    std::vector<int> nums;
    std::string line;
    
    // Read the entire line from stdin
    std::getline(std::cin, line);
    
    // Use stringstream to parse space-separated integers
    std::stringstream ss(line);
    int number;
    while (ss >> number) {
        nums.push_back(number);
    }

    std::vector<std::vector<int>> subsets = findAllSubsets(nums);

    // Print the results
    for (const auto& subset : subsets) {
        std::cout << ""["";
        for (size_t i = 0; i < subset.size(); ++i) {
            std::cout << subset[i];
            if (i < subset.size() - 1) {
                std::cout << "" "";
            }
        }
        std::cout << ""]"" << std::endl;
    }

    return 0;
}",4.2
White-102,Basic String Manipulation,"- String iteration (looping through characters)
- Character comparison
- Counter variable
- Basic I/O (reading string and char)",Write a program that reads a string and a single character from the input. Your task is to count how many times that specific character appears in the given string. The comparison should be case-sensitive.,"- The string will contain only ASCII characters.
- The string length will be between 1 and 1000 characters.
- The target character will be a single ASCII character.","**
Hello World
o

**","**
2","Input: Programming
x
Output: 0
Input: banana
a
Output: 3
Input: Apple
a
Output: 0
Input: Hello World!
!
Output: 1","#include <stdio.h>
#include <string.h>

// Function to count occurrences of a character in a string
int countChar(const char* str, char target) {
    int count = 0;
    for (int i = 0; str[i] != '\0'; i++) {
        if (str[i] == target) {
            count++;
        }
    }
    return count;
}

int main() {
    char inputString[1001]; // Max length 1000 + null terminator
    char targetChar;

    // Read the string
    // Using fgets to read the whole line including spaces
    if (fgets(inputString, sizeof(inputString), stdin) == NULL) {
        return 1; // Error reading input
    }

    // Remove the trailing newline character if present
    inputString[strcspn(inputString, ""\n"")] = 0;

    // Read the target character
    if (scanf("" %c"", &targetChar) != 1) { // Space before %c to consume any leftover newline
        return 1; // Error reading input
    }

    // Call the core logic function
    int occurrences = countChar(inputString, targetChar);

    // Print the result
    printf(""%d\n"", occurrences);

    return 0;
}","def count_char(s: str, target: str) -> int:
    """"""
    Counts the occurrences of a target character in a string.
    """"""
    count = 0
    for char in s:
        if char == target:
            count += 1
    return count

if __name__ == ""__main__"":
    # Read the string
    input_string = input()

    # Read the target character
    target_char = input()

    # Call the core logic function
    occurrences = count_char(input_string, target_char)

    # Print the result
    print(occurrences)","import java.util.Scanner;

public class Main {

    // Function to count occurrences of a character in a string
    public static int countChar(String str, char target) {
        int count = 0;
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == target) {
                count++;
            }
        }
        return count;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the string
        String inputString = scanner.nextLine();

        // Read the target character
        // Read next token and get its first character
        char targetChar = scanner.next().charAt(0);

        // Call the core logic function
        int occurrences = countChar(inputString, targetChar);

        // Print the result
        System.out.println(occurrences);

        scanner.close();
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let inputLines = [];

// Function to count occurrences of a character in a string
function countChar(str, target) {
    let count = 0;
    for (let i = 0; i < str.length; i++) {
        if (str[i] === target) {
            count++;
        }
    }
    return count;
}

rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    const inputString = inputLines[0];
    const targetChar = inputLines[1];

    // Call the core logic function
    const occurrences = countChar(inputString, targetChar);

    // Print the result
    console.log(occurrences);
});","#include <iostream>
#include <string>

// Function to count occurrences of a character in a string
int countChar(const std::string& str, char target) {
    int count = 0;
    for (char c : str) {
        if (c == target) {
            count++;
        }
    }
    return count;
}

int main() {
    std::string inputString;
    char targetChar;

    // Read the string (can contain spaces)
    std::getline(std::cin, inputString);

    // Read the target character
    std::cin >> targetChar;

    // Call the core logic function
    int occurrences = countChar(inputString, targetChar);

    // Print the result
    std::cout << occurrences << std::endl;

    return 0;
}",3.9
Orange-1,"Binary Search on Answer (Aggressive Cows, Book Allocation)","- Binary Search
- Predicate Function (or Check Function)
- Search Space Definition (Lower Bound, Upper Bound)","You are given an array of integers `tasks` representing the complexity or size of `n` tasks, and an integer `k` representing the number of workers available. Your goal is to assign all tasks to these `k` workers. The tasks must be assigned contiguously, meaning if `tasks` is split into `k` contiguous segments, each segment is assigned to one worker. You need to find a way to assign tasks such that the maximum total complexity assigned to any single worker is minimized. Return this minimum possible maximum complexity.","- `1 <= n (length of tasks) <= 10^5`
- `1 <= tasks[i] <= 10^9`
- `1 <= k <= n`
- The sum of `tasks` can exceed `2^31 - 1`, so use 64-bit integers for sums where applicable.","tasks = [10, 20, 30, 40]
k = 2",60,"Input:
5
1 2 3 4 5
1
Output:
15
Input:
4
100 200 50 300
4
Output:
300
Input:
3
1000000000 1000000000 1000000000
2
Output:
2000000000
Input:
5
50 50 50 50 50
3
Output:
100
Input:
1
77
1
Output:
77","#include <stdio.h>
#include <stdlib.h> // For malloc, free

// Function to check if it's possible to distribute tasks such that no worker's load exceeds max_load_limit
int canDistribute(const int* tasks, int n, int k, long long max_load_limit) {
    long long current_worker_load = 0;
    int workers_needed = 1;

    for (int i = 0; i < n; ++i) {
        // If adding the current task exceeds the limit, assign it to a new worker
        if (current_worker_load + tasks[i] > max_load_limit) {
            workers_needed++;
            current_worker_load = tasks[i];
        } else {
            current_worker_load += tasks[i];
        }
    }
    return workers_needed <= k;
}

// Main logic function
long long minimalMaxLoad(const int* tasks, int n, int k) {
    if (n == 0) {
        return 0;
    }

    long long low = 0;
    long long high = 0;
    
    // Calculate initial low (max individual task) and high (total sum of tasks)
    for (int i = 0; i < n; ++i) {
        if (tasks[i] > low) { // find max task
            low = tasks[i];
        }
        high += tasks[i]; // sum of all tasks
    }

    long long ans = high; // Initialize answer with the maximum possible load (sum of all tasks)

    // Binary search for the minimal possible maximum load
    while (low <= high) {
        long long mid = low + (high - low) / 2; // Prevent overflow for large low, high
        if (canDistribute(tasks, n, k, mid)) {
            ans = mid; // mid is a possible answer, try for a smaller one in the left half
            high = mid - 1;
        } else {
            low = mid + 1; // mid is too small, need a larger limit, search in the right half
        }
    }
    return ans;
}

int main() {
    int n;
    scanf(""%d"", &n); // Read number of tasks

    int* tasks = (int*)malloc(n * sizeof(int));
    if (tasks == NULL) {
        return 1; // Error handling for memory allocation
    }

    for (int i = 0; i < n; ++i) {
        scanf(""%d"", &tasks[i]); // Read task complexities
    }

    int k;
    scanf(""%d"", &k); // Read number of workers

    long long result = minimalMaxLoad(tasks, n, k);
    printf(""%lld\n"", result);

    free(tasks); // Free allocated memory
    return 0;
}","import sys

def can_distribute(tasks, k, max_load_limit):
    current_worker_load = 0
    workers_needed = 1

    for task in tasks:
        # If adding the current task exceeds the limit, assign it to a new worker
        if current_worker_load + task > max_load_limit:
            workers_needed += 1
            current_worker_load = task
        else:
            current_worker_load += task
    return workers_needed <= k

def minimal_max_load(tasks, k):
    if not tasks:
        return 0

    low = 0
    high = 0
    
    # Calculate initial low (max individual task) and high (total sum of tasks)
    for task in tasks:
        low = max(low, task) # Max individual task
        high += task # Sum of all tasks

    ans = high # Initialize answer with the maximum possible load (sum of all tasks)

    # Binary search for the minimal possible maximum load
    while low <= high:
        mid = low + (high - low) // 2 # Prevent overflow for large low, high
        if can_distribute(tasks, k, mid):
            ans = mid # mid is a possible answer, try for a smaller one in the left half
            high = mid - 1
        else:
            low = mid + 1 # mid is too small, need a larger limit, search in the right half
    return ans

if __name__ == ""__main__"":
    n = int(sys.stdin.readline()) # Read number of tasks
    tasks = list(map(int, sys.stdin.readline().split())) # Read task complexities

    k = int(sys.stdin.readline()) # Read number of workers

    result = minimal_max_load(tasks, k)
    sys.stdout.write(str(result) + ""\n"")","import java.util.Scanner;
import java.util.Arrays;

public class Main {

    // Function to check if it's possible to distribute tasks such that no worker's load exceeds max_load_limit
    public static boolean canDistribute(int[] tasks, int k, long max_load_limit) {
        long current_worker_load = 0;
        int workers_needed = 1;

        for (int task : tasks) {
            // If adding the current task exceeds the limit, assign it to a new worker
            if (current_worker_load + task > max_load_limit) {
                workers_needed++;
                current_worker_load = task;
            } else {
                current_worker_load += task;
            }
        }
        return workers_needed <= k;
    }

    // Main logic function
    public static long minimalMaxLoad(int[] tasks, int k) {
        if (tasks.length == 0) {
            return 0;
        }

        long low = 0;
        long high = 0;
        
        // Calculate initial low (max individual task) and high (total sum of tasks)
        for (int task : tasks) {
            low = Math.max(low, (long)task); // Max individual task
            high += task; // Sum of all tasks
        }

        long ans = high; // Initialize answer with the maximum possible load (sum of all tasks)

        // Binary search for the minimal possible maximum load
        while (low <= high) {
            long mid = low + (high - low) / 2; // Prevent overflow for large low, high
            if (canDistribute(tasks, k, mid)) {
                ans = mid; // mid is a possible answer, try for a smaller one in the left half
                high = mid - 1;
            } else {
                low = mid + 1; // mid is too small, need a larger limit, search in the right half
            }
        }
        return ans;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt(); // Read number of tasks
        int[] tasks = new int[n];
        for (int i = 0; i < n; ++i) {
            tasks[i] = scanner.nextInt(); // Read task complexities
        }

        int k = scanner.nextInt(); // Read number of workers

        long result = minimalMaxLoad(tasks, k);
        System.out.println(result);

        scanner.close();
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

// Function to check if it's possible to distribute tasks such that no worker's load exceeds max_load_limit
function canDistribute(tasks, k, maxLoadLimit) {
    let currentWorkerLoad = 0;
    let workersNeeded = 1;

    for (let i = 0; i < tasks.length; i++) {
        const task = tasks[i];
        // If adding the current task exceeds the limit, assign it to a new worker
        if (currentWorkerLoad + task > maxLoadLimit) {
            workersNeeded++;
            currentWorkerLoad = task;
        } else {
            currentWorkerLoad += task;
        }
    }
    return workersNeeded <= k;
}

// Main logic function
function minimalMaxLoad(tasks, k) {
    if (tasks.length === 0) {
        return 0;
    }

    let low = 0;
    let high = 0;
    
    // Calculate initial low (max individual task) and high (total sum of tasks)
    for (let i = 0; i < tasks.length; i++) {
        low = Math.max(low, tasks[i]); // Max individual task
        high += tasks[i]; // Sum of all tasks
    }

    let ans = high; // Initialize answer with the maximum possible load (sum of all tasks)

    // Binary search for the minimal possible maximum load
    while (low <= high) {
        let mid = Math.floor(low + (high - low) / 2); // Prevent overflow for large low, high
        if (canDistribute(tasks, k, mid)) {
            ans = mid; // mid is a possible answer, try for a smaller one in the left half
            high = mid - 1;
        } else {
            low = mid + 1; // mid is too small, need a larger limit, search in the right half
        }
    }
    return ans;
}

let inputLines = [];
rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    const n = parseInt(inputLines[0]);
    const tasks = inputLines[1].split(' ').map(Number);
    const k = parseInt(inputLines[2]);

    const result = minimalMaxLoad(tasks, k);
    console.log(result);
});","#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>

// Function to check if it's possible to distribute tasks such that no worker's load exceeds max_load_limit
bool canDistribute(const std::vector<int>& tasks, int k, long long max_load_limit) {
    long long current_worker_load = 0;
    int workers_needed = 1;

    for (int task : tasks) {
        // If adding the current task exceeds the limit, assign it to a new worker
        if (current_worker_load + task > max_load_limit) {
            workers_needed++;
            current_worker_load = task;
        } else {
            current_worker_load += task;
        }
    }
    return workers_needed <= k;
}

// Main logic function
long long minimalMaxLoad(const std::vector<int>& tasks, int k) {
    if (tasks.empty()) {
        return 0;
    }

    long long low = 0;
    long long high = 0;
    
    // Calculate initial low (max individual task) and high (total sum of tasks)
    for (int task : tasks) {
        low = std::max(low, (long long)task); // Max individual task
        high += task; // Sum of all tasks
    }

    long long ans = high; // Initialize answer with the maximum possible load (sum of all tasks)

    // Binary search for the minimal possible maximum load
    while (low <= high) {
        long long mid = low + (high - low) / 2; // Prevent overflow for large low, high
        if (canDistribute(tasks, k, mid)) {
            ans = mid; // mid is a possible answer, try for a smaller one in the left half
            high = mid - 1;
        } else {
            low = mid + 1; // mid is too small, need a larger limit, search in the right half
        }
    }
    return ans;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n; // Read number of tasks

    std::vector<int> tasks(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> tasks[i]; // Read task complexities
    }

    int k;
    std::cin >> k; // Read number of workers

    long long result = minimalMaxLoad(tasks, k);
    std::cout << result << std::endl;

    return 0;
}",4
Yellow-33,Recursive Fibonacci,"*   Recursion
*   Base Cases
*   Recursive Step
*   Mathematical Sequences","The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. The sequence begins: 0, 1, 1, 2, 3, 5, 8, 13, 21, and so on.

Your task is to write a recursive function that calculates the Nth number in the Fibonacci sequence. The sequence starts at index 0 (so F(0) = 0, F(1) = 1, F(2) = 1, etc.).",*   `0 <= N <= 20` (N is a non-negative integer),"**
`N = 5`

**","**
`5`

**","Input: 0
Output: 0
Input: 1
Output: 1
Input: 2
Output: 1
Input: 6
Output: 8
Input: 10
Output: 55
Input: 15
Output: 610
Input: 20
Output: 6765","#include <stdio.h>

// Function to calculate the Nth Fibonacci number recursively
long long fibonacci(int n) {
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

int main() {
    int n;
    // Read input from stdin
    scanf(""%d"", &n);

    // Calculate and print the Nth Fibonacci number
    printf(""%lld\n"", fibonacci(n));

    return 0;
}","import sys

# Function to calculate the Nth Fibonacci number recursively
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)

if __name__ == '__main__':
    # Read input from stdin
    n = int(sys.stdin.readline().strip())

    # Calculate and print the Nth Fibonacci number
    print(fibonacci(n))","import java.util.Scanner;

public class Solution {

    // Function to calculate the Nth Fibonacci number recursively
    public static long fibonacci(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        } else {
            return fibonacci(n - 1) + fibonacci(n - 2);
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // Read input from stdin
        int n = scanner.nextInt();
        scanner.close();

        // Calculate and print the Nth Fibonacci number
        System.out.println(fibonacci(n));
    }
}","// Function to calculate the Nth Fibonacci number recursively
function fibonacci(n) {
    if (n === 0) {
        return 0;
    } else if (n === 1) {
        return 1;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

// Read input from stdin (Node.js environment)
let input = '';
process.stdin.on('data', chunk => {
    input += chunk;
});

process.stdin.on('end', () => {
    const n = parseInt(input.trim(), 10);
    // Calculate and print the Nth Fibonacci number
    console.log(fibonacci(n));
});","#include <iostream>

// Function to calculate the Nth Fibonacci number recursively
long long fibonacci(int n) {
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

int main() {
    int n;
    // Read input from stdin
    std::cin >> n;

    // Calculate and print the Nth Fibonacci number
    std::cout << fibonacci(n) << std::endl;

    return 0;
}",4.1
Yellow-34,Kadane’s Algorithm,"- Kadane's Algorithm
- Dynamic Programming (implicitly greedy approach)
- Iteration
- Tracking maximum values","You are given an integer array `nums`. Your task is to find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

A contiguous subarray is a sequence of elements that are adjacent in the original array.","- `1 <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`","9
-2 1 -3 4 -1 2 1 -5 4",6,"Input: 5
1 2 3 -2 5
Output: 9
Input: 1
-100
Output: -100
Input: 7
-2 -3 -1 -5 -4 -6 -7
Output: -1
Input: 3
5 0 -3
Output: 5
Input: 8
1 2 -3 4 -1 2 1 -5
Output: 7","#include <stdio.h>
#include <limits.h>

// Function to find the maximum of two integers
int max(int a, int b) {
    return (a > b) ? a : b;
}

// Function to find the maximum subarray sum using Kadane's algorithm
int maxSubArray(int* nums, int numsSize) {
    if (numsSize == 0) {
        return 0; // Or handle as an error, depending on constraints. Constraints say numsSize >= 1.
    }

    int current_max = nums[0];
    int global_max = nums[0];

    for (int i = 1; i < numsSize; i++) {
        current_max = max(nums[i], current_max + nums[i]);
        global_max = max(global_max, current_max);
    }

    return global_max;
}

int main() {
    int numsSize;
    scanf(""%d"", &numsSize);

    int nums[numsSize]; // VLA for dynamic array, C99 standard
    for (int i = 0; i < numsSize; i++) {
        scanf(""%d"", &nums[i]);
    }

    int result = maxSubArray(nums, numsSize);
    printf(""%d\n"", result);

    return 0;
}","import sys

def max_sub_array(nums: list[int]) -> int:
    if not nums:
        return 0  # Constraints state nums.length >= 1, but good practice.

    current_max = nums[0]
    global_max = nums[0]

    for i in range(1, len(nums)):
        current_max = max(nums[i], current_max + nums[i])
        global_max = max(global_max, current_max)

    return global_max

if __name__ == '__main__':
    n = int(sys.stdin.readline())
    nums = list(map(int, sys.stdin.readline().split()))

    result = max_sub_array(nums)
    sys.stdout.write(str(result) + ""\n"")","import java.util.Scanner;

public class Solution {

    // Function to find the maximum subarray sum using Kadane's algorithm
    public int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0; // Constraints state nums.length >= 1, but good practice.
        }

        int currentMax = nums[0];
        int globalMax = nums[0];

        for (int i = 1; i < nums.length; i++) {
            currentMax = Math.max(nums[i], currentMax + nums[i]);
            globalMax = Math.max(globalMax, currentMax);
        }

        return globalMax;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }
        scanner.close();

        Solution sol = new Solution();
        int result = sol.maxSubArray(nums);
        System.out.println(result);
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
function maxSubArray(nums) {
    if (nums.length === 0) {
        return 0; // Constraints state nums.length >= 1, but good practice.
    }

    let currentMax = nums[0];
    let globalMax = nums[0];

    for (let i = 1; i < nums.length; i++) {
        currentMax = Math.max(nums[i], currentMax + nums[i]);
        globalMax = Math.max(globalMax, currentMax);
    }

    return globalMax;
}

// Handle input and output for competitive programming environment
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let inputLines = [];
rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    const n = parseInt(inputLines[0]);
    const nums = inputLines[1].split(' ').map(Number);
    
    const result = maxSubArray(nums);
    console.log(result);
});","#include <iostream>
#include <vector>
#include <algorithm> // For std::max

// Function to find the maximum subarray sum using Kadane's algorithm
int maxSubArray(const std::vector<int>& nums) {
    if (nums.empty()) {
        return 0; // Constraints state nums.length >= 1, but good practice.
    }

    int current_max = nums[0];
    int global_max = nums[0];

    for (size_t i = 1; i < nums.size(); ++i) {
        current_max = std::max(nums[i], current_max + nums[i]);
        global_max = std::max(global_max, current_max);
    }

    return global_max;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    std::vector<int> nums(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> nums[i];
    }

    int result = maxSubArray(nums);
    std::cout << result << std::endl;

    return 0;
}",4.2
Yellow-35,Infix to Postfix Conversion,"*   Stacks
*   Operator Precedence
*   Associativity Rules
*   String Manipulation
*   Algorithm Design","In mathematics and computer science, expressions can be written in different notations. The most common is **infix notation**, where operators are placed between their operands (e.g., `A + B`). However, for easier parsing and evaluation by computers, **postfix notation** (also known as Reverse Polish Notation or RPN) is often preferred, where operators follow their operands (e.g., `AB+`).

Your task is to convert a given infix expression into its equivalent postfix expression. This involves understanding operator precedence (which operations are performed first) and associativity (how operators of the same precedence are grouped).","*   The input string `infix_expr` will contain only:
    *   Uppercase English letters (`A-Z`) and digits (`0-9`) as operands.
    *   Operators: `+`, `-`, `*`, `/`, `^`.
    *   Parentheses: `(`, `)`.
*   The input string will be a valid infix expression.
*   There will be no spaces in the input string.
*   The length of the `infix_expr` will be between 1 and 100 characters, inclusive.
*   Operator Precedence (from highest to lowest):
    1.  `^` (Exponentiation)
    2.  `*`, `/` (Multiplication, Division)
    3.  `+`, `-` (Addition, Subtraction)
*   Associativity:
    *   `^` is right-associative (e.g., `A^B^C` is `A^(B^C)`).
    *   `+`, `-`, `*`, `/` are left-associative.","** `A+B*C`
**",** `ABC*+`,"Input: (A+B)*C
Output: AB+C*
Input: A*(B-C)/D
Output: ABC-*D/
Input: P+Q-R*S/T
Output: PQ+RS*T/-
Input: X^Y^Z
Output: XYZ^^
Input: (A+B*C)/(D-E)
Output: ABC*+DE-/","#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// Simple Stack implementation for characters
#define MAX_STACK_SIZE 101
char operatorStack[MAX_STACK_SIZE];
int stackTop = -1;

void push(char c) {
    if (stackTop < MAX_STACK_SIZE - 1) {
        operatorStack[++stackTop] = c;
    }
}

char pop() {
    if (stackTop != -1) {
        return operatorStack[stackTop--];
    }
    return '\0'; // Indicates stack underflow or empty
}

char peek() {
    if (stackTop != -1) {
        return operatorStack[stackTop];
    }
    return '\0'; // Indicates stack empty
}

int isEmpty() {
    return stackTop == -1;
}

// Function to check if a character is an operand (letter or digit)
int isOperand(char c) {
    return isalnum(c); // isalnum checks for alphabetic or numeric
}

// Function to check if a character is an operator
int isOperator(char c) {
    return (c == '+' || c == '-' || c == '*' || c == '/' || c == '^');
}

// Function to get the precedence of an operator
int getPrecedence(char op) {
    switch (op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        case '^':
            return 3;
        default:
            return 0; // For '(' or other non-operators/invalid chars
    }
}

// Function to check associativity of an operator
// Returns 1 for left-associative, 0 for right-associative
int isLeftAssociative(char op) {
    return (op == '+' || op == '-' || op == '*' || op == '/');
}

// Main function to convert infix to postfix
char* infixToPostfix(const char* infix) {
    int len = strlen(infix);
    char* postfix = (char*)malloc(sizeof(char) * (len + 1));
    if (postfix == NULL) {
        perror(""Failed to allocate memory for postfix expression"");
        exit(EXIT_FAILURE);
    }
    int j = 0; // Index for postfix expression
    
    // Reset stack for each conversion
    stackTop = -1; 

    for (int i = 0; i < len; i++) {
        char currentChar = infix[i];

        if (isOperand(currentChar)) {
            postfix[j++] = currentChar;
        } else if (currentChar == '(') {
            push(currentChar);
        } else if (currentChar == ')') {
            while (!isEmpty() && peek() != '(') {
                postfix[j++] = pop();
            }
            if (!isEmpty() && peek() == '(') { // Discard '('
                pop();
            } else {
                // Mismatched parentheses, handle error or assume valid input
                // For this problem, we assume valid input
            }
        } else if (isOperator(currentChar)) {
            while (!isEmpty() && peek() != '(' && 
                   (getPrecedence(peek()) > getPrecedence(currentChar) || 
                    (getPrecedence(peek()) == getPrecedence(currentChar) && isLeftAssociative(currentChar)))) {
                postfix[j++] = pop();
            }
            push(currentChar);
        }
    }

    // Pop any remaining operators from the stack
    while (!isEmpty()) {
        postfix[j++] = pop();
    }
    postfix[j] = '\0'; // Null-terminate the postfix string

    return postfix;
}

int main() {
    char infixExpr[101];
    if (scanf(""%s"", infixExpr) != 1) {
        fprintf(stderr, ""Failed to read input.\n"");
        return 1;
    }

    char* postfixExpr = infixToPostfix(infixExpr);
    printf(""%s\n"", postfixExpr);
    
    free(postfixExpr); // Free dynamically allocated memory
    
    return 0;
}","import sys

def is_operand(char):
    return '0' <= char <= '9' or 'A' <= char <= 'Z' or 'a' <= char <= 'z'

def get_precedence(op):
    if op == '+' or op == '-':
        return 1
    elif op == '*' or op == '/':
        return 2
    elif op == '^':
        return 3
    return 0 # For '(' or other non-operators

def is_left_associative(op):
    return op in {'+', '-', '*', '/'}

def infix_to_postfix(infix_expr):
    postfix_expr = []
    operator_stack = []

    for char in infix_expr:
        if is_operand(char):
            postfix_expr.append(char)
        elif char == '(':
            operator_stack.append(char)
        elif char == ')':
            while operator_stack and operator_stack[-1] != '(':
                postfix_expr.append(operator_stack.pop())
            if operator_stack and operator_stack[-1] == '(':
                operator_stack.pop() # Discard '('
            # else: Mismatched parentheses error, assuming valid input
        elif char in {'+', '-', '*', '/', '^'}: # It's an operator
            while (operator_stack and operator_stack[-1] != '(' and
                   (get_precedence(operator_stack[-1]) > get_precedence(char) or
                    (get_precedence(operator_stack[-1]) == get_precedence(char) and is_left_associative(char)))):
                postfix_expr.append(operator_stack.pop())
            operator_stack.append(char)
    
    # Pop any remaining operators from the stack
    while operator_stack:
        postfix_expr.append(operator_stack.pop())
            
    return """".join(postfix_expr)

def main():
    infix_expr = sys.stdin.readline().strip()
    postfix_expr = infix_to_postfix(infix_expr)
    sys.stdout.write(postfix_expr + ""\n"")

if __name__ == '__main__':
    main()","import java.util.Scanner;
import java.util.Stack;

public class Solution {

    // Function to check if a character is an operand (letter or digit)
    private static boolean isOperand(char c) {
        return Character.isLetterOrDigit(c);
    }

    // Function to get the precedence of an operator
    private static int getPrecedence(char op) {
        switch (op) {
            case '+':
            case '-':
                return 1;
            case '*':
            case '/':
                return 2;
            case '^':
                return 3;
            default:
                return 0; // For '(' or other non-operators/invalid chars
        }
    }

    // Function to check associativity of an operator
    // Returns true for left-associative, false for right-associative
    private static boolean isLeftAssociative(char op) {
        return (op == '+' || op == '-' || op == '*' || op == '/');
    }

    // Main function to convert infix to postfix
    public static String infixToPostfix(String infix) {
        StringBuilder postfix = new StringBuilder();
        Stack<Character> operatorStack = new Stack<>();

        for (int i = 0; i < infix.length(); i++) {
            char currentChar = infix.charAt(i);

            if (isOperand(currentChar)) {
                postfix.append(currentChar);
            } else if (currentChar == '(') {
                operatorStack.push(currentChar);
            } else if (currentChar == ')') {
                while (!operatorStack.isEmpty() && operatorStack.peek() != '(') {
                    postfix.append(operatorStack.pop());
                }
                if (!operatorStack.isEmpty() && operatorStack.peek() == '(') {
                    operatorStack.pop(); // Discard '('
                }
            } else { // It's an operator
                while (!operatorStack.isEmpty() && operatorStack.peek() != '(' &&
                       (getPrecedence(operatorStack.peek()) > getPrecedence(currentChar) ||
                        (getPrecedence(operatorStack.peek()) == getPrecedence(currentChar) && isLeftAssociative(currentChar)))) {
                    postfix.append(operatorStack.pop());
                }
                operatorStack.push(currentChar);
            }
        }

        // Pop any remaining operators from the stack
        while (!operatorStack.isEmpty()) {
            postfix.append(operatorStack.pop());
        }

        return postfix.toString();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String infixExpr = scanner.next(); // Reads a single token (no spaces)
        scanner.close();
        
        String postfixExpr = infixToPostfix(infixExpr);
        System.out.println(postfixExpr);
    }
}","function isOperand(char) {
    return (char >= '0' && char <= '9') || (char >= 'A' && char <= 'Z') || (char >= 'a' && char <= 'z');
}

function getPrecedence(op) {
    switch (op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        case '^':
            return 3;
        default:
            return 0; // For '(' or other non-operators
    }
}

function isLeftAssociative(op) {
    return ['+', '-', '*', '/'].includes(op);
}

function infixToPostfix(infixExpr) {
    let postfixExpr = [];
    let operatorStack = [];

    for (let i = 0; i < infixExpr.length; i++) {
        let currentChar = infixExpr[i];

        if (isOperand(currentChar)) {
            postfixExpr.push(currentChar);
        } else if (currentChar === '(') {
            operatorStack.push(currentChar);
        } else if (currentChar === ')') {
            while (operatorStack.length > 0 && operatorStack[operatorStack.length - 1] !== '(') {
                postfixExpr.push(operatorStack.pop());
            }
            if (operatorStack.length > 0 && operatorStack[operatorStack.length - 1] === '(') {
                operatorStack.pop(); // Discard '('
            }
            // else: Mismatched parentheses error, assuming valid input
        } else { // It's an operator
            while (operatorStack.length > 0 && operatorStack[operatorStack.length - 1] !== '(' &&
                   (getPrecedence(operatorStack[operatorStack.length - 1]) > getPrecedence(currentChar) ||
                    (getPrecedence(operatorStack[operatorStack.length - 1]) === getPrecedence(currentChar) && isLeftAssociative(currentChar)))) {
                postfixExpr.push(operatorStack.pop());
            }
            operatorStack.push(currentChar);
        }
    }

    // Pop any remaining operators from the stack
    while (operatorStack.length > 0) {
        postfixExpr.push(operatorStack.pop());
    }

    return postfixExpr.join('');
}

// Node.js specific input/output handling
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

rl.on('line', (line) => {
  const infixExpr = line.trim();
  const postfixExpr = infixToPostfix(infixExpr);
  console.log(postfixExpr);
  rl.close();
});","#include <iostream>
#include <string>
#include <stack>
#include <cctype> // For isalnum

// Function to check if a character is an operand (letter or digit)
bool isOperand(char c) {
    return isalnum(c);
}

// Function to get the precedence of an operator
int getPrecedence(char op) {
    switch (op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        case '^':
            return 3;
        default:
            return 0; // For '(' or other non-operators/invalid chars
    }
}

// Function to check associativity of an operator
// Returns true for left-associative, false for right-associative
bool isLeftAssociative(char op) {
    return (op == '+' || op == '-' || op == '*' || op == '/');
}

// Main function to convert infix to postfix
std::string infixToPostfix(const std::string& infix) {
    std::string postfix = """";
    std::stack<char> operatorStack;

    for (char currentChar : infix) {
        if (isOperand(currentChar)) {
            postfix += currentChar;
        } else if (currentChar == '(') {
            operatorStack.push(currentChar);
        } else if (currentChar == ')') {
            while (!operatorStack.empty() && operatorStack.top() != '(') {
                postfix += operatorStack.top();
                operatorStack.pop();
            }
            if (!operatorStack.empty() && operatorStack.top() == '(') {
                operatorStack.pop(); // Discard '('
            }
            // For invalid input (mismatched parentheses), this might leave '(' on stack
            // or try to pop from empty stack. Assuming valid infix for this problem.
        } else { // It's an operator
            while (!operatorStack.empty() && operatorStack.top() != '(' &&
                   (getPrecedence(operatorStack.top()) > getPrecedence(currentChar) ||
                    (getPrecedence(operatorStack.top()) == getPrecedence(currentChar) && isLeftAssociative(currentChar)))) {
                postfix += operatorStack.top();
                operatorStack.pop();
            }
            operatorStack.push(currentChar);
        }
    }

    // Pop any remaining operators from the stack
    while (!operatorStack.empty()) {
        postfix += operatorStack.top();
        operatorStack.pop();
    }

    return postfix;
}

int main() {
    std::string infixExpr;
    std::cin >> infixExpr;
    
    std::string postfixExpr = infixToPostfix(infixExpr);
    std::cout << postfixExpr << std::endl;
    
    return 0;
}",4.3
Yellow-36,"Singly Linked List (creation, traversal, insertion, deletion)","- Singly Linked List Structure
- Linked List Traversal
- Node Deletion (handling head, middle, and tail scenarios)
- Pointer Manipulation","You are given the head of a singly linked list and an integer `val`. Your task is to delete all the nodes of the linked list that have `Node.val == val` and return the new head of the modified linked list.

This problem tests your understanding of linked list traversal, manipulation, and the crucial aspects of node deletion, including handling edge cases such as deleting the head, nodes in the middle, and the tail of the list, as well as an empty list.","- The number of nodes in the list is in the range `[0, 1000]`.
- Node values are integers in the range `[-1000, 1000]`.
- The target value `val` is an integer in the range `[-1000, 1000]`.","**

1 2 6 3 4 5 6
6

**","**

1 2 3 4 5


**","Input: 7 7 7 7
7
Output: 
Input: 1 2 3 4 5
6
Output: 1 2 3 4 5
Input: 8 1 8 2 8 3 8
8
Output: 1 2 3
Input: 
5
Output: 
Input: 42
100
Output: 42","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Definition for singly-linked list.
struct ListNode {
    int val;
    struct ListNode *next;
};

// Function to delete nodes with a specific value
struct ListNode* deleteNodesWithValue(struct ListNode* head, int val) {
    // Handle deletions at the head
    while (head != NULL && head->val == val) {
        struct ListNode* temp = head;
        head = head->next;
        free(temp); // Free memory
    }
    
    struct ListNode* current = head;
    struct ListNode* prev = NULL;

    while (current != NULL) {
        if (current->val == val) {
            // Bypass current node
            if (prev != NULL) {
                prev->next = current->next;
            }
            // Free memory for the deleted node
            struct ListNode* temp = current;
            current = current->next; // Move current before deleting temp
            free(temp);
        } else {
            prev = current;
            current = current->next;
        }
    }
    
    return head;
}

// Function to create a linked list from an array of integers
struct ListNode* createLinkedList(int* arr, int size) {
    if (size == 0) {
        return NULL;
    }
    struct ListNode* head = (struct ListNode*)malloc(sizeof(struct ListNode));
    head->val = arr[0];
    head->next = NULL;
    struct ListNode* current = head;
    for (int i = 1; i < size; ++i) {
        current->next = (struct ListNode*)malloc(sizeof(struct ListNode));
        current = current->next;
        current->val = arr[i];
        current->next = NULL;
    }
    return head;
}

// Function to print a linked list and free memory
void printAndFreeLinkedList(struct ListNode* head) {
    struct ListNode* current = head;
    while (current != NULL) {
        printf(""%d"", current->val);
        if (current->next != NULL) {
            printf("" "");
        }
        struct ListNode* temp = current;
        current = current->next;
        free(temp); // Free memory
    }
    printf(""\n"");
}

int main() {
    char line[4000]; // Assuming max chars for input line (e.g., 1000 nodes * 5 digits + spaces)
    if (fgets(line, sizeof(line), stdin) == NULL) {
        // Handle empty input or error
        printAndFreeLinkedList(NULL); 
        return 0;
    }

    int nodeValues[1000]; // Assuming max 1000 nodes
    int count = 0;
    
    // Remove trailing newline character if present
    line[strcspn(line, ""\n"")] = 0; 

    if (strlen(line) > 0) {
        char *token = strtok(line, "" "");
        while (token != NULL) {
            nodeValues[count++] = atoi(token);
            token = strtok(NULL, "" "");
        }
    }

    int targetVal;
    // Check if scanf reads an integer successfully
    if (scanf(""%d"", &targetVal) != 1) {
        // If target value is not provided (e.g. only empty list line), handle it.
        // For this problem, it's assumed targetVal will always be provided.
        printAndFreeLinkedList(NULL);
        return 0;
    }

    struct ListNode* head = createLinkedList(nodeValues, count);
    struct ListNode* resultHead = deleteNodesWithValue(head, targetVal);
    printAndFreeLinkedList(resultHead);

    return 0;
}","class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def deleteNodesWithValue(head: ListNode, val: int) -> ListNode:
    # Handle deletions at the head
    while head and head.val == val:
        head = head.next
    
    current = head
    prev = None

    while current:
        if current.val == val:
            # Bypass current node
            if prev:
                prev.next = current.next
            # No else needed, if current is head and has target value, it's handled by first while loop.
        else:
            prev = current
        current = current.next
    
    return head

def create_linked_list(arr):
    if not arr:
        return None
    head = ListNode(arr[0])
    current = head
    for i in range(1, len(arr)):
        current.next = ListNode(arr[i])
        current = current.next
    return head

def print_linked_list(head):
    nodes = []
    current = head
    while current:
        nodes.append(str(current.val))
        current = current.next
    print("" "".join(nodes))

if __name__ == ""__main__"":
    try:
        input_line = input()
        if input_line.strip() == """":
            arr_str = []
        else:
            arr_str = input_line.split()
        
        node_values = [int(x) for x in arr_str]
        
        target_val = int(input())

        head = create_linked_list(node_values)
        result_head = deleteNodesWithValue(head, target_val)
        print_linked_list(result_head)
    except EOFError:
        # For empty list, input_line will be empty, correctly handled. 
        # If target_val input also missing due to specific test case setup, this catches it.
        # Generally, target_val is expected after list input.
        print_linked_list(None) # Print empty line for empty list (e.g. all nodes deleted)","import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

// Definition for singly-linked list.
class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

public class Solution {
    public ListNode deleteNodesWithValue(ListNode head, int val) {
        // Handle deletions at the head
        while (head != null && head.val == val) {
            head = head.next;
        }
        
        ListNode current = head;
        ListNode prev = null;

        while (current != null) {
            if (current.val == val) {
                // Bypass current node
                if (prev != null) {
                    prev.next = current.next;
                }
                // No else needed, if current is head and has target value, it's handled by first while loop.
            } else {
                prev = current;
            }
            current = current.next;
        }
        
        return head;
    }

    // Function to create a linked list from a list of integers
    public ListNode createLinkedList(List<Integer> arr) {
        if (arr == null || arr.isEmpty()) {
            return null;
        }
        ListNode head = new ListNode(arr.get(0));
        ListNode current = head;
        for (int i = 1; i < arr.size(); ++i) {
            current.next = new ListNode(arr.get(i));
            current = current.next;
        }
        return head;
    }

    // Function to print a linked list
    public void printLinkedList(ListNode head) {
        StringBuilder sb = new StringBuilder();
        ListNode current = head;
        while (current != null) {
            sb.append(current.val);
            if (current.next != null) {
                sb.append("" "");
            }
            current = current.next;
        }
        System.out.println(sb.toString());
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Solution sol = new Solution();

        String line = scanner.nextLine();
        List<Integer> nodeValues = new ArrayList<>();
        if (!line.trim().isEmpty()) {
            String[] arrStr = line.split("" "");
            for (String s : arrStr) {
                nodeValues.add(Integer.parseInt(s));
            }
        }
        
        int targetVal = scanner.nextInt();

        ListNode head = sol.createLinkedList(nodeValues);
        ListNode resultHead = sol.deleteNodesWithValue(head, targetVal);
        sol.printLinkedList(resultHead);

        scanner.close();
    }
}","// Definition for singly-linked list.
function ListNode(val, next) {
    this.val = (val===undefined ? 0 : val)
    this.next = (next===undefined ? null : next)
}

/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
function deleteNodesWithValue(head, val) {
    // Handle deletions at the head
    while (head !== null && head.val === val) {
        head = head.next;
    }
    
    let current = head;
    let prev = null;

    while (current !== null) {
        if (current.val === val) {
            // Bypass current node
            if (prev !== null) {
                prev.next = current.next;
            }
            // No explicit memory management like C++/C in JS
        } else {
            prev = current;
        }
        current = current.next;
    }
    
    return head;
}

// Function to create a linked list from an array
function createLinkedList(arr) {
    if (!arr || arr.length === 0) {
        return null;
    }
    let head = new ListNode(arr[0]);
    let current = head;
    for (let i = 1; i < arr.length; ++i) {
        current.next = new ListNode(arr[i]);
        current = current.next;
    }
    return head;
}

// Function to print a linked list
function printLinkedList(head) {
    let nodes = [];
    let current = head;
    while (current !== null) {
        nodes.push(current.val);
        current = current.next;
    }
    console.log(nodes.join("" ""));
}

// Main execution for handling input/output
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let lines = [];
    rl.on('line', (line) => {
        lines.push(line);
    }).on('close', () => {
        let nodeValuesStr = lines[0].trim();
        let nodeValues = [];
        if (nodeValuesStr !== """") {
            nodeValues = nodeValuesStr.split(' ').map(Number);
        }
        
        let targetVal = parseInt(lines[1]);

        let head = createLinkedList(nodeValues);
        let resultHead = deleteNodesWithValue(head, targetVal);
        printLinkedList(resultHead);
    });
}

main();","#include <iostream>
#include <vector>
#include <string>
#include <sstream>

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* deleteNodesWithValue(ListNode* head, int val) {
    // Handle deletions at the head
    while (head != nullptr && head->val == val) {
        ListNode* temp = head;
        head = head->next;
        delete temp; // Free memory
    }
    
    ListNode* current = head;
    ListNode* prev = nullptr;

    while (current != nullptr) {
        if (current->val == val) {
            // Bypass current node
            if (prev != nullptr) {
                prev->next = current->next;
            }
            // Free memory for the deleted node
            ListNode* temp = current;
            current = current->next; // Move current before deleting temp
            delete temp;
        } else {
            prev = current;
            current = current->next;
        }
    }
    
    return head;
}

// Function to create a linked list from a vector
ListNode* createLinkedList(const std::vector<int>& arr) {
    if (arr.empty()) {
        return nullptr;
    }
    ListNode* head = new ListNode(arr[0]);
    ListNode* current = head;
    for (size_t i = 1; i < arr.size(); ++i) {
        current->next = new ListNode(arr[i]);
        current = current->next;
    }
    return head;
}

// Function to print a linked list and free memory
void printAndFreeLinkedList(ListNode* head) {
    ListNode* current = head;
    while (current != nullptr) {
        std::cout << current->val;
        if (current->next != nullptr) {
            std::cout << "" "";
        }
        ListNode* temp = current;
        current = current->next;
        delete temp; // Free memory
    }
    std::cout << std::endl;
}

int main() {
    std::string line;
    std::getline(std::cin, line);
    std::vector<int> nodeValues;
    if (!line.empty()) {
        std::stringstream ss(line);
        std::string segment;
        while (std::getline(ss, segment, ' ')) {
            nodeValues.push_back(std::stoi(segment));
        }
    }

    int targetVal;
    std::cin >> targetVal;

    ListNode* head = createLinkedList(nodeValues);
    ListNode* resultHead = deleteNodesWithValue(head, targetVal);
    printAndFreeLinkedList(resultHead);

    return 0;
}",4.4
Yellow-37,Recursive Fibonacci,"- Recursion
- Base Cases
- Recursive Step
- Function Call Stack","The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. The sequence begins: 0, 1, 1, 2, 3, 5, 8, 13, 21, and so on.

Your task is to write a recursive function that calculates the Nth Fibonacci number. Given a non-negative integer `n`, return the `n`-th Fibonacci number.

For example:
- `fib(0) = 0`
- `fib(1) = 1`
- `fib(2) = fib(1) + fib(0) = 1 + 0 = 1`
- `fib(3) = fib(2) + fib(1) = 1 + 1 = 2`",- `0 <= n <= 20` (The recursion depth and computation time grow very quickly for larger `n` with a naive recursive approach),"**
`n = 5`

**","**
`5`

**","Input: 0
Output: 0
Input: 1
Output: 1
Input: 2
Output: 1
Input: 7
Output: 13
Input: 15
Output: 610","#include <stdio.h>

// Function to calculate the Nth Fibonacci number recursively
int fibonacci(int n) {
    // Base cases
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    // Recursive step
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    int n;

    // Read input from stdin
    if (scanf(""%d"", &n) != 1) {
        // Handle error if input is not a valid integer
        return 1;
    }

    // Calculate and print the Nth Fibonacci number
    int result = fibonacci(n);
    printf(""%d\n"", result);

    return 0;
}","def fibonacci(n: int) -> int:
    """"""
    Calculates the Nth Fibonacci number recursively.
    """"""
    # Base cases
    if n == 0:
        return 0
    if n == 1:
        return 1
    # Recursive step
    return fibonacci(n - 1) + fibonacci(n - 2)

if __name__ == ""__main__"":
    # Read input from stdin
    n = int(input())
    
    # Calculate and print the Nth Fibonacci number
    result = fibonacci(n)
    print(result)","import java.util.Scanner;

public class Solution {

    // Function to calculate the Nth Fibonacci number recursively
    public int fibonacci(int n) {
        // Base cases
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        // Recursive step
        return fibonacci(n - 1) + fibonacci(n - 2);
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Read input from stdin
        int n = scanner.nextInt();
        
        // Create an instance of the Solution class to call the non-static method
        Solution sol = new Solution();
        
        // Calculate and print the Nth Fibonacci number
        int result = sol.fibonacci(n);
        System.out.println(result);
        
        scanner.close();
    }
}","// Function to calculate the Nth Fibonacci number recursively
function fibonacci(n) {
    // Base cases
    if (n === 0) {
        return 0;
    }
    if (n === 1) {
        return 1;
    }
    // Recursive step
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// Read input from stdin and print output to stdout
// This setup is common for competitive programming environments in Node.js
process.stdin.resume();
process.stdin.setEncoding('utf8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', chunk => {
    inputString += chunk;
});

process.stdin.on('end', _ => {
    inputString = inputString.trim().split('\n').map(str => str.trim());
    main();
});

function readLine() {
    return inputString[currentLine++];
}

function main() {
    const n = parseInt(readLine(), 10);
    
    const result = fibonacci(n);
    console.log(result);
}","#include <iostream>

// Function to calculate the Nth Fibonacci number recursively
int fibonacci(int n) {
    // Base cases
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    // Recursive step
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    int n;

    // Read input from stdin
    std::cin >> n;

    // Calculate and print the Nth Fibonacci number
    int result = fibonacci(n);
    std::cout << result << std::endl;

    return 0;
}",3.9
Orange-2,Hash Tables & Hash Maps,"*   Hash Tables / Hash Maps
*   String Iteration
*   Frequency Counting","You are given a string `s` consisting of lowercase English letters. Your task is to count the frequency of each character in the string and return them. The output should be a list of character-frequency pairs, sorted alphabetically by character.","*   1 <= `s.length` <= 1000
*   The string `s` consists only of lowercase English letters ('a'-'z').","""apple""","a:1, e:1, l:1, p:2","Input: hello
Output: e:1, h:1, l:2, o:1
Input: zzzzaac
Output: a:2, c:1, z:4
Input: codingchallenge
Output: c:3, d:1, e:2, g:1, h:1, i:1, l:2, n:1, o:1
Input: programming
Output: a:1, g:2, i:1, m:2, n:1, o:1, p:1, r:2","#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// Function to count character frequencies
void countCharacterFrequencies(const char* s) {
    int frequencies[26] = {0}; // Initialize all counts to 0
    int len = strlen(s);

    // Populate frequencies array
    for (int i = 0; i < len; i++) {
        // The constraint guarantees 'a'-'z', so this check is technically not strictly needed
        // but good for robustness.
        if (s[i] >= 'a' && s[i] <= 'z') {
            frequencies[s[i] - 'a']++;
        }
    }

    // Print frequencies in alphabetical order
    int first_printed = 0;
    for (int i = 0; i < 26; i++) {
        if (frequencies[i] > 0) {
            if (first_printed) {
                printf("", "");
            }
            printf(""%c:%d"", (char)('a' + i), frequencies[i]);
            first_printed = 1;
        }
    }
    printf(""\n"");
}

int main() {
    char s[1001]; // Max length 1000 + null terminator

    // Read input string
    if (fgets(s, sizeof(s), stdin) != NULL) {
        // Remove trailing newline character if present
        s[strcspn(s, ""\n"")] = 0;
        countCharacterFrequencies(s);
    }

    return 0;
}","import sys

def count_character_frequencies(s):
    frequencies = {} # Python dictionary acts as a hash map

    # Populate frequencies dictionary
    for char_code in s:
        # The constraint guarantees 'a'-'z', so this check is technically not strictly needed
        # but good for robustness.
        if 'a' <= char_code <= 'z':
            frequencies[char_code] = frequencies.get(char_code, 0) + 1

    # Sort keys and print frequencies
    sorted_chars = sorted(frequencies.keys())
    
    result_parts = []
    for char_code in sorted_chars:
        result_parts.append(f""{char_code}:{frequencies[char_code]}"")
    
    print("", "".join(result_parts))

if __name__ == ""__main__"":
    s = sys.stdin.readline().strip() # Read input string
    count_character_frequencies(s)","import java.util.Scanner;
import java.util.Map;
import java.util.TreeMap; // TreeMap keeps keys sorted automatically

public class Solution {

    // Function to count character frequencies
    public void countCharacterFrequencies(String s) {
        Map<Character, Integer> frequencies = new TreeMap<>(); // TreeMap automatically sorts by key

        // Populate frequencies map
        for (char c : s.toCharArray()) {
            // The constraint guarantees 'a'-'z', so this check is technically not strictly needed
            // but good for robustness.
            if (c >= 'a' && c <= 'z') {
                frequencies.put(c, frequencies.getOrDefault(c, 0) + 1);
            }
        }

        // Print frequencies in alphabetical order
        StringBuilder result = new StringBuilder();
        boolean firstPrinted = false;
        for (Map.Entry<Character, Integer> entry : frequencies.entrySet()) {
            if (firstPrinted) {
                result.append("", "");
            }
            result.append(entry.getKey()).append("":"").append(entry.getValue());
            firstPrinted = true;
        }
        System.out.println(result.toString());
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine(); // Read input string
        scanner.close();

        Solution sol = new Solution();
        sol.countCharacterFrequencies(s);
    }
}","function countCharacterFrequencies(s) {
    const frequencies = new Map(); // JavaScript Map acts as a hash map

    // Populate frequencies map
    for (const char of s) {
        // The constraint guarantees 'a'-'z', so this check is technically not strictly needed
        // but good for robustness.
        if (char >= 'a' && char <= 'z') {
            frequencies.set(char, (frequencies.get(char) || 0) + 1);
        }
    }

    // Sort keys and print frequencies
    const sortedChars = Array.from(frequencies.keys()).sort();
    
    const resultParts = [];
    for (const char of sortedChars) {
        resultParts.push(`${char}:${frequencies.get(char)}`);
    }
    
    console.log(resultParts.join("", ""));
}

// Read input from stdin
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.on('line', (line) => {
    countCharacterFrequencies(line);
    rl.close();
});","#include <iostream>
#include <string>
#include <map>

// Function to count character frequencies
void countCharacterFrequencies(const std::string& s) {
    std::map<char, int> frequencies; // std::map keeps keys sorted automatically

    // Populate frequencies map
    for (char c : s) {
        // The constraint guarantees 'a'-'z', so this check is technically not strictly needed
        // but good for robustness.
        if (c >= 'a' && c <= 'z') {
            frequencies[c]++;
        }
    }

    // Print frequencies in alphabetical order
    bool firstPrinted = false;
    for (const auto& pair : frequencies) {
        if (firstPrinted) {
            std::cout << "", "";
        }
        std::cout << pair.first << "":"" << pair.second;
        firstPrinted = true;
    }
    std::cout << std::endl;
}

int main() {
    std::string s;
    // Read input string
    std::getline(std::cin, s);

    countCharacterFrequencies(s);

    return 0;
}",4
Yellow-38,Circular Queue basics,"- Array/Vector Data Structure
- Queue Data Structure Principles (FIFO)
- Modulo Arithmetic
- Pointer Management (front, rear indices)
- Fixed-Size Buffer","A circular queue is a linear data structure that operates in a First-In, First-Out (FIFO) manner, similar to a regular queue. However, it handles the `rear` and `front` pointers in a way that allows it to reuse empty spaces from the front of the queue, effectively treating the buffer as a circle. This prevents wasted memory if elements are frequently enqueued and dequeued.

Your task is to implement the `MyCircularQueue` class, which supports the following operations:

- `MyCircularQueue(k)`: Initializes the object with the size of the queue to be `k`. All values will be in the range `[0, 1000]`.
- `enqueue(value)`: Inserts an element into the circular queue. Returns `true` if the operation is successful, `false` otherwise (if the queue is full).
- `dequeue()`: Deletes an element from the circular queue. Returns `true` if the operation is successful, `false` otherwise (if the queue is empty).
- `Front()`: Gets the front element from the queue. Returns the element value, or `-1` if the queue is empty.
- `Rear()`: Gets the last element from the queue. Returns the element value, or `-1` if the queue is empty.
- `isEmpty()`: Checks whether the circular queue is empty. Returns `true` if empty, `false` otherwise.
- `isFull()`: Checks whether the circular queue is full. Returns `true` if full, `false` otherwise.

You should implement your circular queue using an array (or equivalent data structure) and manage the `front` and `rear` pointers using modulo arithmetic.","- `1 <= k <= 1000` (Capacity of the queue)
- `0 <= value <= 1000` (Values to enqueue)
- At most `3000` calls will be made to `enqueue`, `dequeue`, `Front`, `Rear`, `isEmpty`, and `isFull`.
- All operations run in O(1) time.","3
10
enqueue 1
enqueue 2
enqueue 3
enqueue 4
Rear
isFull
dequeue
enqueue 4
Rear
Front","true
true
true
false
3
true
true
true
4
2","Input:
2
8
enqueue 1
enqueue 2
enqueue 3
Front
Rear
dequeue
enqueue 3
Front
Output:
true
true
false
1
2
true
true
2
Input:
5
12
enqueue 10
enqueue 20
enqueue 30
enqueue 40
Front
Rear
isEmpty
isFull
dequeue
dequeue
enqueue 50
Front
Output:
true
true
true
true
10
40
false
true
true
true
true
30
Input:
1
7
enqueue 5
isFull
Front
Rear
dequeue
isEmpty
dequeue
Output:
true
true
5
5
true
true
false","#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

typedef struct {
    int* data;
    int front;
    int rear;
    int size;
    int capacity;
} MyCircularQueue;

MyCircularQueue* myCircularQueueCreate(int k) {
    MyCircularQueue* obj = (MyCircularQueue*)malloc(sizeof(MyCircularQueue));
    obj->data = (int*)malloc(sizeof(int) * k);
    obj->front = -1;
    obj->rear = -1;
    obj->size = 0;
    obj->capacity = k;
    return obj;
}

bool myCircularQueueIsEmpty(MyCircularQueue* obj) {
    return obj->size == 0;
}

bool myCircularQueueIsFull(MyCircularQueue* obj) {
    return obj->size == obj->capacity;
}

bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) {
    if (myCircularQueueIsFull(obj)) {
        return false;
    }
    obj->rear = (obj->rear + 1) % obj->capacity;
    obj->data[obj->rear] = value;
    if (obj->front == -1) { // First element being added
        obj->front = 0;
    }
    obj->size++;
    return true;
}

bool myCircularQueueDeQueue(MyCircularQueue* obj) {
    if (myCircularQueueIsEmpty(obj)) {
        return false;
    }
    obj->front = (obj->front + 1) % obj->capacity;
    obj->size--;
    if (obj->size == 0) { // Queue became empty, reset pointers
        obj->front = -1;
        obj->rear = -1;
    }
    return true;
}

int myCircularQueueFront(MyCircularQueue* obj) {
    if (myCircularQueueIsEmpty(obj)) {
        return -1;
    }
    return obj->data[obj->front];
}

int myCircularQueueRear(MyCircularQueue* obj) {
    if (myCircularQueueIsEmpty(obj)) {
        return -1;
    }
    return obj->data[obj->rear];
}

void myCircularQueueFree(MyCircularQueue* obj) {
    free(obj->data);
    free(obj);
}

int main() {
    int k, n;
    scanf(""%d"", &k);
    scanf(""%d"", &n);

    MyCircularQueue* obj = myCircularQueueCreate(k);
    char command[20];
    int value;

    for (int i = 0; i < n; i++) {
        scanf(""%s"", command);
        if (strcmp(command, ""enqueue"") == 0) {
            scanf(""%d"", &value);
            printf(""%s\n"", myCircularQueueEnQueue(obj, value) ? ""true"" : ""false"");
        } else if (strcmp(command, ""dequeue"") == 0) {
            printf(""%s\n"", myCircularQueueDeQueue(obj) ? ""true"" : ""false"");
        } else if (strcmp(command, ""Front"") == 0) {
            printf(""%d\n"", myCircularQueueFront(obj));
        } else if (strcmp(command, ""Rear"") == 0) {
            printf(""%d\n"", myCircularQueueRear(obj));
        } else if (strcmp(command, ""isEmpty"") == 0) {
            printf(""%s\n"", myCircularQueueIsEmpty(obj) ? ""true"" : ""false"");
        } else if (strcmp(command, ""isFull"") == 0) {
            printf(""%s\n"", myCircularQueueIsFull(obj) ? ""true"" : ""false"");
        }
    }

    myCircularQueueFree(obj);

    return 0;
}","class MyCircularQueue:

    def __init__(self, k: int):
        self.data = [0] * k
        self.front = -1
        self.rear = -1
        self.size = 0
        self.capacity = k

    def enQueue(self, value: int) -> bool:
        if self.isFull():
            return False
        self.rear = (self.rear + 1) % self.capacity
        self.data[self.rear] = value
        if self.front == -1: # First element being added
            self.front = 0
        self.size += 1
        return True

    def deQueue(self) -> bool:
        if self.isEmpty():
            return False
        self.front = (self.front + 1) % self.capacity
        self.size -= 1
        if self.size == 0: # Queue became empty, reset pointers
            self.front = -1
            self.rear = -1
        return True

    def Front(self) -> int:
        if self.isEmpty():
            return -1
        return self.data[self.front]

    def Rear(self) -> int:
        if self.isEmpty():
            return -1
        return self.data[self.rear]

    def isEmpty(self) -> bool:
        return self.size == 0

    def isFull(self) -> bool:
        return self.size == self.capacity

if __name__ == ""__main__"":
    k = int(input())
    n = int(input())

    obj = MyCircularQueue(k)

    for _ in range(n):
        command_line = input().split()
        command = command_line[0]
        
        if command == ""enqueue"":
            value = int(command_line[1])
            print(obj.enQueue(value))
        elif command == ""dequeue"":
            print(obj.deQueue())
        elif command == ""Front"":
            print(obj.Front())
        elif command == ""Rear"":
            print(obj.Rear())
        elif command == ""isEmpty"":
            print(obj.isEmpty())
        elif command == ""isFull"":
            print(obj.isFull())","import java.util.Scanner;

class MyCircularQueue {
    private int[] data;
    private int front;
    private int rear;
    private int size;
    private int capacity;

    public MyCircularQueue(int k) {
        capacity = k;
        data = new int[k];
        front = -1;
        rear = -1;
        size = 0;
    }

    public boolean enQueue(int value) {
        if (isFull()) {
            return false;
        }
        rear = (rear + 1) % capacity;
        data[rear] = value;
        if (front == -1) { // First element being added
            front = 0;
        }
        size++;
        return true;
    }

    public boolean deQueue() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        size--;
        if (size == 0) { // Queue became empty, reset pointers
            front = -1;
            rear = -1;
        }
        return true;
    }

    public int Front() {
        if (isEmpty()) {
            return -1;
        }
        return data[front];
    }

    public int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return data[rear];
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean isFull() {
        return size == capacity;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int k = scanner.nextInt();
        int n = scanner.nextInt();

        MyCircularQueue obj = new MyCircularQueue(k);
        
        for (int i = 0; i < n; i++) {
            String command = scanner.next();
            if (command.equals(""enqueue"")) {
                int value = scanner.nextInt();
                System.out.println(obj.enQueue(value));
            } else if (command.equals(""dequeue"")) {
                System.out.println(obj.deQueue());
            } else if (command.equals(""Front"")) {
                System.out.println(obj.Front());
            } else if (command.equals(""Rear"")) {
                System.out.println(obj.Rear());
            } else if (command.equals(""isEmpty"")) {
                System.out.println(obj.isEmpty());
            } else if (command.equals(""isFull"")) {
                System.out.println(obj.isFull());
            }
        }

        scanner.close();
    }
}","const readline = require('readline');

class MyCircularQueue {
    constructor(k) {
        this.data = new Array(k);
        this.front = -1;
        this.rear = -1;
        this.size = 0;
        this.capacity = k;
    }

    enQueue(value) {
        if (this.isFull()) {
            return false;
        }
        this.rear = (this.rear + 1) % this.capacity;
        this.data[this.rear] = value;
        if (this.front === -1) { // First element being added
            this.front = 0;
        }
        this.size++;
        return true;
    }

    deQueue() {
        if (this.isEmpty()) {
            return false;
        }
        this.front = (this.front + 1) % this.capacity;
        this.size--;
        if (this.size === 0) { // Queue became empty, reset pointers
            this.front = -1;
            this.rear = -1;
        }
        return true;
    }

    Front() {
        if (this.isEmpty()) {
            return -1;
        }
        return this.data[this.front];
    }

    Rear() {
        if (this.isEmpty()) {
            return -1;
        }
        return this.data[this.rear];
    }

    isEmpty() {
        return this.size === 0;
    }

    isFull() {
        return this.size === this.capacity;
    }
}

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let lines = [];
rl.on('line', (line) => {
    lines.push(line);
});

rl.on('close', () => {
    const k = parseInt(lines[0]);
    const n = parseInt(lines[1]);
    let lineIndex = 2;

    const obj = new MyCircularQueue(k);

    for (let i = 0; i < n; i++) {
        const commandLine = lines[lineIndex++].split(' ');
        const command = commandLine[0];
        
        if (command === ""enqueue"") {
            const value = parseInt(commandLine[1]);
            console.log(obj.enQueue(value));
        } else if (command === ""dequeue"") {
            console.log(obj.deQueue());
        } else if (command === ""Front"") {
            console.log(obj.Front());
        } else if (command === ""Rear"") {
            console.log(obj.Rear());
        } else if (command === ""isEmpty"") {
            console.log(obj.isEmpty());
        } else if (command === ""isFull"") {
            console.log(obj.isFull());
        }
    }
});","#include <iostream>
#include <vector>
#include <string>

class MyCircularQueue {
private:
    std::vector<int> data;
    int front;
    int rear;
    int size;
    int capacity;

public:
    MyCircularQueue(int k) {
        capacity = k;
        data.resize(k);
        front = -1;
        rear = -1;
        size = 0;
    }

    bool enQueue(int value) {
        if (isFull()) {
            return false;
        }
        rear = (rear + 1) % capacity;
        data[rear] = value;
        if (front == -1) { // First element being added
            front = 0;
        }
        size++;
        return true;
    }

    bool deQueue() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        size--;
        if (size == 0) { // Queue became empty, reset pointers
            front = -1;
            rear = -1;
        }
        return true;
    }

    int Front() {
        if (isEmpty()) {
            return -1;
        }
        return data[front];
    }

    int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return data[rear];
    }

    bool isEmpty() {
        return size == 0;
    }

    bool isFull() {
        return size == capacity;
    }
};

int main() {
    int k, n;
    std::cin >> k;
    std::cin >> n;

    MyCircularQueue* obj = new MyCircularQueue(k);
    std::string command;
    int value;

    for (int i = 0; i < n; ++i) {
        std::cin >> command;
        if (command == ""enqueue"") {
            std::cin >> value;
            std::cout << (obj->enQueue(value) ? ""true"" : ""false"") << std::endl;
        } else if (command == ""dequeue"") {
            std::cout << (obj->deQueue() ? ""true"" : ""false"") << std::endl;
        } else if (command == ""Front"") {
            std::cout << obj->Front() << std::endl;
        } else if (command == ""Rear"") {
            std::cout << obj->Rear() << std::endl;
        } else if (command == ""isEmpty"") {
            std::cout << (obj->isEmpty() ? ""true"" : ""false"") << std::endl;
        } else if (command == ""isFull"") {
            std::cout << (obj->isFull() ? ""true"" : ""false"") << std::endl;
        }
    }

    delete obj;
    return 0;
}","#include <iostream>
#include <vector>
#include <string>

class MyCircularQueue {
private:
    std::vector<int> data;
    int front;
    int rear;
    int size;
    int capacity;

public:
    MyCircularQueue(int k) {
        capacity = k;
        data.resize(k);
        front = -1;
        rear = -1;
        size = 0;
    }

    bool enQueue(int value) {
        if (isFull()) {
            return false;
        }
        rear = (rear + 1) % capacity;
        data[rear] = value;
        if (front == -1) { // First element being added
            front = 0;
        }
        size++;
        return true;
    }

    bool deQueue() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        size--;
        if (size == 0) { // Queue became empty, reset pointers
            front = -1;
            rear = -1;
        }
        return true;
    }

    int Front() {
        if (isEmpty()) {
            return -1;
        }
        return data[front];
    }

    int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return data[rear];
    }

    bool isEmpty() {
        return size == 0;
    }

    bool isFull() {
        return size == capacity;
    }
};

int main() {
    int k, n;
    std::cin >> k;
    std::cin >> n;

    MyCircularQueue* obj = new MyCircularQueue(k);
    std::string command;
    int value;

    for (int i = 0; i < n; ++i) {
        std::cin >> command;
        if (command == ""enqueue"") {
            std::cin >> value;
            std::cout << (obj->enQueue(value) ? ""true"" : ""false"") << std::endl;
        } else if (command == ""dequeue"") {
            std::cout << (obj->deQueue() ? ""true"" : ""false"") << std::endl;
        } else if (command == ""Front"") {
            std::cout << obj->Front() << std::endl;
        } else if (command == ""Rear"") {
            std::cout << obj->Rear() << std::endl;
        } else if (command == ""isEmpty"") {
            std::cout << (obj->isEmpty() ? ""true"" : ""false"") << std::endl;
        } else if (command == ""isFull"") {
            std::cout << (obj->isFull() ? ""true"" : ""false"") << std::endl;
        }
    }

    delete obj;
    return 0;
}"
Yellow-39,Intro to Backtracking,"*   Backtracking
*   Recursion
*   Depth-First Search (implicitly)
*   State Management",You are given an array `nums` of distinct integers. Your task is to return all possible permutations of the numbers in `nums`. A permutation is an arrangement of all elements in a specific order. You can return the answer in any order.,"* `1 <= nums.length <= 6`
* `-10 <= nums[i] <= 10`
* All the integers in `nums` are unique.","**

3
1 2 3


**","**

[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

*(The order of permutations in the output list may vary, but all must be present.)*","Input: 2
0 1
Output: [[0,1],[1,0]]
Input: 1
5
Output: [[5]]
Input: 4
1 2 3 4
Output: [[1,2,3,4],[1,2,4,3],[1,3,2,4],[1,3,4,2],[1,4,2,3],[1,4,3,2],[2,1,3,4],[2,1,4,3],[2,3,1,4],[2,3,4,1],[2,4,1,3],[2,4,3,1],[3,1,2,4],[3,1,4,2],[3,2,1,4],[3,2,4,1],[3,4,1,2],[3,4,2,1],[4,1,2,3],[4,1,3,2],[4,2,1,3],[4,2,3,1],[4,3,1,2],[4,3,2,1]]
Input: 3
-1 0 1
Output: [[-1,0,1],[-1,1,0],[0,-1,1],[0,1,-1],[1,-1,0],[1,0,-1]]","#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

// Helper function to print a single permutation in the format [x,y,z]
void printPermutation(int* arr, int size) {
    printf(""["");
    for (int i = 0; i < size; i++) {
        printf(""%d"", arr[i]);
        if (i < size - 1) {
            printf("","");
        }
    }
    printf(""]"");
}

// Recursive backtracking function
// count_ptr is used to correctly format the output with commas between permutations
void backtrack(int* nums, int numsSize, int* currentPermutation, bool* visited, int k, int* count_ptr) {
    // Base case: if k equals numsSize, a complete permutation is formed
    if (k == numsSize) {
        if (*count_ptr > 0) {
            printf("","");
        }
        printPermutation(currentPermutation, numsSize);
        (*count_ptr)++;
        return;
    }

    // Recursive step: iterate through nums
    for (int i = 0; i < numsSize; i++) {
        if (!visited[i]) {
            // Choose: add nums[i] to currentPermutation
            currentPermutation[k] = nums[i];
            visited[i] = true;

            // Explore: recursively call for next element
            backtrack(nums, numsSize, currentPermutation, visited, k + 1, count_ptr);

            // Unchoose (Backtrack): remove nums[i] from currentPermutation and mark as unvisited
            visited[i] = false;
        }
    }
}

// Main logic function to initiate finding permutations
void solvePermutations(int* nums, int numsSize) {
    if (numsSize == 0) {
        printf(""[]\n"");
        return;
    }

    int* currentPermutation = (int*)malloc(sizeof(int) * numsSize);
    bool* visited = (bool*)calloc(numsSize, sizeof(bool)); // calloc initializes to false
    int permutationCount = 0; // Counter for correct comma separation

    printf(""[""); // Start outer list
    backtrack(nums, numsSize, currentPermutation, visited, 0, &permutationCount);
    printf(""]\n""); // End outer list

    free(currentPermutation);
    free(visited);
}

int main() {
    int n;
    scanf(""%d"", &n);

    int* nums = NULL;
    if (n > 0) {
        nums = (int*)malloc(sizeof(int) * n);
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &nums[i]);
        }
    }
    
    solvePermutations(nums, n); // Call the main logic function

    if (nums != NULL) {
        free(nums);
    }

    return 0;
}","import json

class Solution:
    def _backtrack(self, nums, current_permutation, visited, results):
        # Base case: if current_permutation is complete
        if len(current_permutation) == len(nums):
            results.append(list(current_permutation)) # Add a copy
            return

        # Recursive step: iterate through nums
        for i in range(len(nums)):
            if not visited[i]:
                # Choose
                current_permutation.append(nums[i])
                visited[i] = True

                # Explore
                self._backtrack(nums, current_permutation, visited, results)

                # Unchoose (Backtrack)
                visited[i] = False
                current_permutation.pop()

    def permute(self, nums):
        results = []
        if not nums:
            return results

        current_permutation = []
        visited = [False] * len(nums) # Initialize all to False

        self._backtrack(nums, current_permutation, visited, results)
        return results

def main():
    n = int(input())
    # Read space-separated integers
    nums = list(map(int, input().split()))

    sol = Solution()
    all_permutations = sol.permute(nums)

    # Print the results in the required JSON-like format, no spaces.
    print(json.dumps(all_permutations).replace("" "", """"))

if __name__ == ""__main__"":
    main()","import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Solution {

    // Helper function for backtracking
    private void backtrack(int[] nums, List<Integer> currentPermutation, 
                           boolean[] visited, List<List<Integer>> results) {
        // Base case: if currentPermutation is complete
        if (currentPermutation.size() == nums.length) {
            results.add(new ArrayList<>(currentPermutation)); // Add a copy
            return;
        }

        // Recursive step: iterate through nums
        for (int i = 0; i < nums.length; i++) {
            if (!visited[i]) {
                // Choose
                currentPermutation.add(nums[i]);
                visited[i] = true;

                // Explore
                backtrack(nums, currentPermutation, visited, results);

                // Unchoose (Backtrack)
                visited[i] = false;
                currentPermutation.remove(currentPermutation.size() - 1);
            }
        }
    }

    // Main logic function
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> results = new ArrayList<>();
        if (nums == null || nums.length == 0) {
            return results;
        }

        List<Integer> currentPermutation = new ArrayList<>();
        boolean[] visited = new boolean[nums.length]; // All initialized to false

        backtrack(nums, currentPermutation, visited, results);
        return results;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }
        scanner.close();

        Solution sol = new Solution();
        List<List<Integer>> allPermutations = sol.permute(nums);

        // Print the results in the required format
        System.out.print(""["");
        for (int i = 0; i < allPermutations.size(); i++) {
            List<Integer> perm = allPermutations.get(i);
            System.out.print(""["");
            for (int j = 0; j < perm.size(); j++) {
                System.out.print(perm.get(j));
                if (j < perm.size() - 1) {
                    System.out.print("","");
                }
            }
            System.out.print(""]"");
            if (i < allPermutations.size() - 1) {
                System.out.print("","");
            }
        }
        System.out.println(""]"");
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

class Solution {
    _backtrack(nums, currentPermutation, visited, results) {
        // Base case: if currentPermutation is complete
        if (currentPermutation.length === nums.length) {
            results.push([...currentPermutation]); // Add a copy
            return;
        }

        // Recursive step: iterate through nums
        for (let i = 0; i < nums.length; i++) {
            if (!visited[i]) {
                // Choose
                currentPermutation.push(nums[i]);
                visited[i] = true;

                // Explore
                this._backtrack(nums, currentPermutation, visited, results);

                // Unchoose (Backtrack)
                visited[i] = false;
                currentPermutation.pop();
            }
        }
    }

    permute(nums) {
        const results = [];
        if (!nums || nums.length === 0) {
            return results;
        }

        const currentPermutation = [];
        const visited = new Array(nums.length).fill(false); // Initialize all to false

        this._backtrack(nums, currentPermutation, visited, results);
        return results;
    }
}

let inputLines = [];
rl.on('line', (line) => {
    inputLines.push(line);
}).on('close', () => {
    const n = parseInt(inputLines[0]);
    const nums = inputLines[1].split(' ').map(Number);

    const sol = new Solution();
    const allPermutations = sol.permute(nums);

    // Print the results in the required JSON-like format, no spaces.
    console.log(JSON.stringify(allPermutations).replace(/\s/g, ''));
});","#include <iostream>
#include <vector>
#include <algorithm> 

// Helper function for backtracking
void backtrack(std::vector<int>& nums, std::vector<int>& currentPermutation, 
               std::vector<bool>& visited, std::vector<std::vector<int>>& results) {
    // Base case: if currentPermutation is complete
    if (currentPermutation.size() == nums.size()) {
        results.push_back(currentPermutation); // Add a copy
        return;
    }

    // Recursive step: iterate through nums
    for (int i = 0; i < nums.size(); ++i) {
        if (!visited[i]) {
            // Choose
            currentPermutation.push_back(nums[i]);
            visited[i] = true;

            // Explore
            backtrack(nums, currentPermutation, visited, results);

            // Unchoose (Backtrack)
            visited[i] = false;
            currentPermutation.pop_back();
        }
    }
}

// Main logic function
std::vector<std::vector<int>> permute(std::vector<int>& nums) {
    std::vector<std::vector<int>> results;
    if (nums.empty()) {
        return results;
    }

    std::vector<int> currentPermutation;
    std::vector<bool> visited(nums.size(), false); // Initialize all to false

    backtrack(nums, currentPermutation, visited, results);
    return results;
}

// Helper function to print the vector of vectors in the required format
void printResults(const std::vector<std::vector<int>>& results) {
    std::cout << ""["";
    for (size_t i = 0; i < results.size(); ++i) {
        std::cout << ""["";
        for (size_t j = 0; j < results[i].size(); ++j) {
            std::cout << results[i][j];
            if (j < results[i].size() - 1) {
                std::cout << "","";
            }
        }
        std::cout << ""]"";
        if (i < results.size() - 1) {
            std::cout << "","";
        }
    }
    std::cout << ""]"" << std::endl;
}

int main() {
    int n;
    std::cin >> n;

    std::vector<int> nums(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> nums[i];
    }

    // Call the main logic function
    std::vector<std::vector<int>> allPermutations = permute(nums);

    // Print the results
    printResults(allPermutations);

    return 0;
}","#include <iostream>
#include <vector>
#include <algorithm> 

// Helper function for backtracking
void backtrack(std::vector<int>& nums, std::vector<int>& currentPermutation, 
               std::vector<bool>& visited, std::vector<std::vector<int>>& results) {
    // Base case: if currentPermutation is complete
    if (currentPermutation.size() == nums.size()) {
        results.push_back(currentPermutation); // Add a copy
        return;
    }

    // Recursive step: iterate through nums
    for (int i = 0; i < nums.size(); ++i) {
        if (!visited[i]) {
            // Choose
            currentPermutation.push_back(nums[i]);
            visited[i] = true;

            // Explore
            backtrack(nums, currentPermutation, visited, results);

            // Unchoose (Backtrack)
            visited[i] = false;
            currentPermutation.pop_back();
        }
    }
}

// Main logic function
std::vector<std::vector<int>> permute(std::vector<int>& nums) {
    std::vector<std::vector<int>> results;
    if (nums.empty()) {
        return results;
    }

    std::vector<int> currentPermutation;
    std::vector<bool> visited(nums.size(), false); // Initialize all to false

    backtrack(nums, currentPermutation, visited, results);
    return results;
}

// Helper function to print the vector of vectors in the required format
void printResults(const std::vector<std::vector<int>>& results) {
    std::cout << ""["";
    for (size_t i = 0; i < results.size(); ++i) {
        std::cout << ""["";
        for (size_t j = 0; j < results[i].size(); ++j) {
            std::cout << results[i][j];
            if (j < results[i].size() - 1) {
                std::cout << "","";
            }
        }
        std::cout << ""]"";
        if (i < results.size() - 1) {
            std::cout << "","";
        }
    }
    std::cout << ""]"" << std::endl;
}

int main() {
    int n;
    std::cin >> n;

    std::vector<int> nums(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> nums[i];
    }

    // Call the main logic function
    std::vector<std::vector<int>> allPermutations = permute(nums);

    // Print the results
    printResults(allPermutations);

    return 0;
}"
Yellow-40,LeetCode,"- **Linked Lists:** Understanding what a node is, how pointers/references connect nodes, and the concept of a `head` and `NULL`/`None` (end of list).
- **Iteration/Traversal:** Moving through a linked list, node by node, using a loop.
- **Pointer Manipulation:** The core of this problem involves carefully changing which node each `next` pointer refers to, effectively 'flipping' the direction of the links.
- **Edge Cases:** Handling special scenarios like an empty list (no nodes) or a list with only one node.","Given the `head` of a singly linked list, reverse the list, and return the reversed list.

A singly linked list is a linear data structure where each element (called a node) points to the next element in the sequence. Reversing it means that the last node becomes the first, the second-to-last becomes the second, and so on, with all the pointers flipped to point in the opposite direction.

For example, if your list is `1 -> 2 -> 3 -> NULL`, after reversing, it should become `3 -> 2 -> 1 -> NULL`.","- The number of nodes in the list is in the range `[0, 5000]`.
- `-5000 <= Node.val <= 5000`.",1 2 3 4 5,"5 4 3 2 1

(","Input: 1 2 3 4 5
Output: 5 4 3 2 1,Input:
Output:,Input: 7
Output: 7,Input: 10 20
Output: 20 10,Input: 1 2 2 1
Output: 1 2 2 1","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Definition for singly-linked list.
struct ListNode {
    int val;
    struct ListNode *next;
};

struct ListNode* reverseList(struct ListNode* head) {
    struct ListNode* prev = NULL;
    struct ListNode* curr = head;
    struct ListNode* next_node = NULL;

    while (curr != NULL) {
        next_node = curr->next; // Store next node
        curr->next = prev;      // Reverse current node's pointer
        prev = curr;            // Move prev one step forward
        curr = next_node;       // Move curr one step forward
    }
    return prev; // prev will be the new head
}

// Helper function to create a new node
struct ListNode* createNode(int val) {
    struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
    if (newNode == NULL) {
        perror(""Failed to allocate memory for ListNode"");
        exit(EXIT_FAILURE);
    }
    newNode->val = val;
    newNode->next = NULL;
    return newNode;
}

// Helper function to print the list
void printList(struct ListNode* head) {
    struct ListNode* current = head;
    if (current == NULL) {
        printf(""\n"");
        return;
    }
    while (current != NULL) {
        printf(""%d"", current->val);
        if (current->next != NULL) {
            printf("" "");
        }
        current = current->next;
    }
    printf(""\n"");
}

// Helper function to free the list memory
void freeList(struct ListNode* head) {
    struct ListNode* current = head;
    while (current != NULL) {
        struct ListNode* temp = current;
        current = current->next;
        free(temp);
    }
}

int main() {
    struct ListNode* head = NULL;
    struct ListNode* tail = NULL;
    int val;

    char line[1000];
    if (fgets(line, sizeof(line), stdin) == NULL) {
        // Error reading or EOF immediately, treat as empty list
        printList(reverseList(head));
        return 0;
    }

    // Remove trailing newline character if present
    line[strcspn(line, ""\n"")] = 0;

    // If line is empty after stripping newline, it's an empty list
    if (strlen(line) == 0) {
        printList(reverseList(head));
        return 0;
    }

    char *token = strtok(line, "" "");
    while (token != NULL) {
        val = atoi(token);
        struct ListNode* newNode = createNode(val);
        if (head == NULL) {
            head = newNode;
            tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
        token = strtok(NULL, "" "");
    }

    struct ListNode* reversedHead = reverseList(head);
    printList(reversedHead);

    freeList(reversedHead); // Free memory of the reversed list

    return 0;
}","# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        prev = None
        curr = head

        while curr:
            next_node = curr.next  # Store next node
            curr.next = prev       # Reverse current node's pointer
            prev = curr            # Move prev one step forward
            curr = next_node       # Move curr one step forward
        return prev # prev will be the new head

# Helper function to print the list
def print_list(head: ListNode):
    current = head
    values = []
    while current:
        values.append(str(current.val))
        current = current.next
    print("" "".join(values))

# Main function for I/O
if __name__ == ""__main__"":
    line = input().strip()

    head = None
    tail = None

    if line:
        values = list(map(int, line.split()))
        for val in values:
            new_node = ListNode(val)
            if head is None:
                head = new_node
                tail = new_node
            else:
                tail.next = new_node
                tail = new_node

    sol = Solution()
    reversed_head = sol.reverseList(head)
    print_list(reversed_head)","import java.util.Scanner;

// Definition for singly-linked list.
class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        ListNode nextNode = null;

        while (curr != null) {
            nextNode = curr.next; // Store next node
            curr.next = prev;     // Reverse current node's pointer
            prev = curr;          // Move prev one step forward
            curr = nextNode;      // Move curr one step forward
        }
        return prev; // prev will be the new head
    }
}

public class Main {
    // Helper function to print the list
    public static void printList(ListNode head) {
        ListNode current = head;
        if (current == null) {
            System.out.println();
            return;
        }
        while (current != null) {
            System.out.print(current.val);
            if (current.next != null) {
                System.out.print("" "");
            }
            current = current.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String line = scanner.nextLine();
        scanner.close();

        ListNode head = null;
        ListNode tail = null;

        if (!line.trim().isEmpty()) {
            String[] parts = line.trim().split("" "");
            for (String part : parts) {
                int val = Integer.parseInt(part);
                ListNode newNode = new ListNode(val);
                if (head == null) {
                    head = newNode;
                    tail = newNode;
                } else {
                    tail.next = newNode;
                    tail = newNode;
                }
            }
        }

        Solution sol = new Solution();
        ListNode reversedHead = sol.reverseList(head);
        printList(reversedHead);
    }
}","// Definition for singly-linked list.
function ListNode(val, next) {
    this.val = (val===undefined ? 0 : val)
    this.next = (next===undefined ? null : next)
}

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    let prev = null;
    let curr = head;
    let nextNode = null;

    while (curr !== null) {
        nextNode = curr.next; // Store next node
        curr.next = prev;     // Reverse current node's pointer
        prev = curr;          // Move prev one step forward
        curr = nextNode;      // Move curr one step forward
    }
    return prev; // prev will be the new head
};

// Helper function to print the list
function printList(head) {
    let current = head;
    const values = [];
    while (current !== null) {
        values.push(current.val);
        current = current.next;
    }
    console.log(values.join(' '));
}

// Main function for I/O
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.on('line', (line) => {
    let head = null;
    let tail = null;

    if (line.trim() !== '') {
        const values = line.split(' ').map(Number);
        for (const val of values) {
            const newNode = new ListNode(val);
            if (head === null) {
                head = newNode;
                tail = newNode;
            } else {
                tail.next = newNode;
                tail = newNode;
            }
        }
    }

    const reversedHead = reverseList(head);
    printList(reversedHead);
    rl.close();
});","#include <iostream>
#include <vector>
#include <string>
#include <sstream>

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* curr = head;
        ListNode* next_node = nullptr;

        while (curr != nullptr) {
            next_node = curr->next; // Store next node
            curr->next = prev;      // Reverse current node's pointer
            prev = curr;            // Move prev one step forward
            curr = next_node;       // Move curr one step forward
        }
        return prev; // prev will be the new head
    }
};

// Helper function to print the list
void printList(ListNode* head) {
    ListNode* current = head;
    if (current == nullptr) {
        std::cout << std::endl;
        return;
    }
    while (current != nullptr) {
        std::cout << current->val;
        if (current->next != nullptr) {
            std::cout << "" "";
        }
        current = current->next;
    }
    std::cout << std::endl;
}

// Helper function to free the list memory
void freeList(ListNode* head) {
    ListNode* current = head;
    while (current != nullptr) {
        ListNode* temp = current;
        current = current->next;
        delete temp;
    }
}

int main() {
    std::string line;
    std::getline(std::cin, line);

    ListNode* head = nullptr;
    ListNode* tail = nullptr;

    if (!line.empty()) {
        std::stringstream ss(line);
        int val;
        while (ss >> val) {
            ListNode* newNode = new ListNode(val);
            if (head == nullptr) {
                head = newNode;
                tail = newNode;
            } else {
                tail->next = newNode;
                tail = newNode;
            }
        }
    }

    Solution sol;
    ListNode* reversedHead = sol.reverseList(head);
    printList(reversedHead);

    freeList(reversedHead); // Free memory of the reversed list

    return 0;
}","#include <iostream>
#include <vector>
#include <string>
#include <sstream>

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* curr = head;
        ListNode* next_node = nullptr;

        while (curr != nullptr) {
            next_node = curr->next; // Store next node
            curr->next = prev;      // Reverse current node's pointer
            prev = curr;            // Move prev one step forward
            curr = next_node;       // Move curr one step forward
        }
        return prev; // prev will be the new head
    }
};

// Helper function to print the list
void printList(ListNode* head) {
    ListNode* current = head;
    if (current == nullptr) {
        std::cout << std::endl;
        return;
    }
    while (current != nullptr) {
        std::cout << current->val;
        if (current->next != nullptr) {
            std::cout << "" "";
        }
        current = current->next;
    }
    std::cout << std::endl;
}

// Helper function to free the list memory
void freeList(ListNode* head) {
    ListNode* current = head;
    while (current != nullptr) {
        ListNode* temp = current;
        current = current->next;
        delete temp;
    }
}

int main() {
    std::string line;
    std::getline(std::cin, line);

    ListNode* head = nullptr;
    ListNode* tail = nullptr;

    if (!line.empty()) {
        std::stringstream ss(line);
        int val;
        while (ss >> val) {
            ListNode* newNode = new ListNode(val);
            if (head == nullptr) {
                head = newNode;
                tail = newNode;
            } else {
                tail->next = newNode;
                tail = newNode;
            }
        }
    }

    Solution sol;
    ListNode* reversedHead = sol.reverseList(head);
    printList(reversedHead);

    freeList(reversedHead); // Free memory of the reversed list

    return 0;
}"
Yellow-41,Recursive Fibonacci,"*   **Recursion**: A function calling itself to solve smaller subproblems.
*   **Base Cases**: Conditions that stop the recursion and provide a direct result.
*   **Recursive Step**: The part of the function that breaks down the problem and calls itself with modified arguments.","Welcome, aspiring coder! In this problem, you'll explore the classic Fibonacci sequence using the power of recursion. The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. 

Your task is to write a function that calculates the `n`-th Fibonacci number. The sequence typically starts as: 0, 1, 1, 2, 3, 5, 8, 13, ...

For example:
- `fib(0)` should return 0
- `fib(1)` should return 1
- `fib(2)` should return `fib(1) + fib(0) = 1 + 0 = 1`
- `fib(3)` should return `fib(2) + fib(1) = 1 + 1 = 2`

You must implement this using a recursive approach.","*   `n` is a non-negative integer.
*   `0 <= n <= 20` (The value of `n` is kept small to allow for the direct recursive solution without performance issues for a Yellow Belt level.)","**

5


**","**

5


**","Input: 0
Output: 0
Input: 1
Output: 1
Input: 2
Output: 1
Input: 10
Output: 55
Input: 15
Output: 610","#include <stdio.h>

// Function to calculate the nth Fibonacci number recursively
int fibonacci(int n) {
    // Base cases
    if (n <= 1) {
        return n;
    }
    // Recursive step
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    int n;
    // Read input from stdin
    scanf(""%d"", &n);
    
    // Call the fibonacci function and print the result
    printf(""%d\n"", fibonacci(n));
    
    return 0;
}","def fibonacci(n: int) -> int:
    """"""
    Calculates the nth Fibonacci number recursively.
    """"""
    # Base cases
    if n <= 1:
        return n
    # Recursive step
    return fibonacci(n - 1) + fibonacci(n - 2)

if __name__ == ""__main__"":
    # Read input from stdin
    n = int(input())
    
    # Call the fibonacci function and print the result
    print(fibonacci(n))","import java.util.Scanner;

public class Main {

    // Function to calculate the nth Fibonacci number recursively
    public int fibonacci(int n) {
        // Base cases
        if (n <= 1) {
            return n;
        }
        // Recursive step
        return fibonacci(n - 1) + fibonacci(n - 2);
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // Read input from stdin
        int n = scanner.nextInt();
        
        Main sol = new Main();
        // Call the fibonacci function and print the result
        System.out.println(sol.fibonacci(n));
        
        scanner.close();
    }
}","function fibonacci(n) {
    // Base cases
    if (n <= 1) {
        return n;
    }
    // Recursive step
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// Read input from stdin using readline module
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.on('line', (line) => {
    const n = parseInt(line.trim(), 10);
    // Call the fibonacci function and print the result
    console.log(fibonacci(n));
    rl.close(); // Close the interface after processing the line
});","#include <iostream>

// Function to calculate the nth Fibonacci number recursively
int fibonacci(int n) {
    // Base cases
    if (n <= 1) {
        return n;
    }
    // Recursive step
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    int n;
    // Read input from stdin
    std::cin >> n;
    
    // Call the fibonacci function and print the result
    std::cout << fibonacci(n) << std::endl;
    
    return 0;
}","#include <iostream>

// Function to calculate the nth Fibonacci number recursively
int fibonacci(int n) {
    // Base cases
    if (n <= 1) {
        return n;
    }
    // Recursive step
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    int n;
    // Read input from stdin
    std::cin >> n;
    
    // Call the fibonacci function and print the result
    std::cout << fibonacci(n) << std::endl;
    
    return 0;
}"
Yellow-42,Frequency Count / Anagrams,"*   Frequency Counting
*   Character Arrays / Hash Maps
*   String Manipulation","You are given two strings, `s` and `t`. Your task is to determine if `t` is an anagram of `s`. An anagram is formed by rearranging the letters of another word or phrase, using all the original letters exactly once. For this problem, assume the strings contain only lowercase English letters.","*   `1 <= s.length, t.length <= 5 * 10^4`
*   `s` and `t` consist of lowercase English letters.","s = ""anagram"", t = ""nagaram""",TRUE,"Input: s = ""listen"", t = ""silent""
Output: true
Input: s = ""abc"", t = ""bca""
Output: true
Input: s = ""hello"", t = ""holle""
Output: true
Input: s = ""apple"", t = ""aple""
Output: false
Input: s = ""zzzaac"", t = ""aazzcz""
Output: true","#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_STR_LEN 50000

bool isAnagram(char *s, char *t) {
    int len_s = strlen(s);
    int len_t = strlen(t);

    if (len_s != len_t) {
        return false;
    }

    int freq[26];
    memset(freq, 0, sizeof(freq));

    for (int i = 0; i < len_s; i++) {
        freq[s[i] - 'a']++;
    }

    for (int i = 0; i < len_t; i++) {
        freq[t[i] - 'a']--;
        if (freq[t[i] - 'a'] < 0) {
            return false;
        }
    }

    return true;
}

int main() {
    char *s = (char *)malloc(sizeof(char) * (MAX_STR_LEN + 1));
    char *t = (char *)malloc(sizeof(char) * (MAX_STR_LEN + 1));

    if (s == NULL || t == NULL) {
        fprintf(stderr, ""Memory allocation failed.\n"");
        return 1;
    }

    // Read input strings, limit characters to prevent buffer overflow
    if (scanf(""%50000s"", s) != 1) {
        fprintf(stderr, ""Error reading string s.\n"");
        free(s);
        free(t);
        return 1;
    }
    if (scanf(""%50000s"", t) != 1) {
        fprintf(stderr, ""Error reading string t.\n"");
        free(s);
        free(t);
        return 1;
    }

    if (isAnagram(s, t)) {
        printf(""true\n"");
    } else {
        printf(""false\n"");
    }

    free(s);
    free(t);

    return 0;
}","import sys

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False

        freq = [0] * 26

        for char_s in s:
            freq[ord(char_s) - ord('a')] += 1

        for char_t in t:
            freq[ord(char_t) - ord('a')] -= 1
            if freq[ord(char_t) - ord('a')] < 0:
                return False
        
        return True

if __name__ == '__main__':
    input_lines = sys.stdin.readlines()
    s = input_lines[0].strip()
    t = input_lines[1].strip()

    sol = Solution()
    if sol.isAnagram(s, t):
        print(""true"")
    else:
        print(""false"")","import java.util.Scanner;

class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }

        int[] freq = new int[26];

        for (char c : s.toCharArray()) {
            freq[c - 'a']++;
        }

        for (char c : t.toCharArray()) {
            freq[c - 'a']--;
            if (freq[c - 'a'] < 0) {
                return false;
            }
        }

        return true;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.next();
        String t = scanner.next();
        scanner.close();

        Solution sol = new Solution();
        if (sol.isAnagram(s, t)) {
            System.out.println(""true"");
        } else {
            System.out.println(""false"");
        }
    }
}","/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function(s, t) {
    if (s.length !== t.length) {
        return false;
    }

    let freq = new Array(26).fill(0);

    for (let i = 0; i < s.length; i++) {
        freq[s.charCodeAt(i) - 'a'.charCodeAt(0)]++;
    }

    for (let i = 0; i < t.length; i++) {
        freq[t.charCodeAt(i) - 'a'.charCodeAt(0)]--;
        if (freq[t.charCodeAt(i) - 'a'.charCodeAt(0)] < 0) {
            return false;
        }
    }

    return true;
};

// Main function for handling input/output in a Node.js-like environment
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

let lines = [];
rl.on('line', (line) => {
  lines.push(line);
});

rl.on('close', () => {
  const s = lines[0];
  const t = lines[1];

  if (isAnagram(s, t)) {
    console.log(""true"");
  } else {
    console.log(""false"");
  }
});","#include <iostream>
#include <string>
#include <vector>
#include <numeric>

class Solution {
public:
    bool isAnagram(std::string s, std::string t) {
        if (s.length() != t.length()) {
            return false;
        }

        std::vector<int> freq(26, 0);

        for (char c : s) {
            freq[c - 'a']++;
        }

        for (char c : t) {
            freq[c - 'a']--;
            if (freq[c - 'a'] < 0) {
                return false;
            }
        }

        return true;
    }
};

int main() {
    std::string s, t;
    std::cin >> s >> t;

    Solution sol;
    if (sol.isAnagram(s, t)) {
        std::cout << ""true"" << std::endl;
    } else {
        std::cout << ""false"" << std::endl;
    }

    return 0;
}","#include <iostream>
#include <string>
#include <vector>
#include <numeric>

class Solution {
public:
    bool isAnagram(std::string s, std::string t) {
        if (s.length() != t.length()) {
            return false;
        }

        std::vector<int> freq(26, 0);

        for (char c : s) {
            freq[c - 'a']++;
        }

        for (char c : t) {
            freq[c - 'a']--;
            if (freq[c - 'a'] < 0) {
                return false;
            }
        }

        return true;
    }
};

int main() {
    std::string s, t;
    std::cin >> s >> t;

    Solution sol;
    if (sol.isAnagram(s, t)) {
        std::cout << ""true"" << std::endl;
    } else {
        std::cout << ""false"" << std::endl;
    }

    return 0;
}"
Yellow-43,Linear Search,"*   Arrays
*   Iteration (Loops)
*   Conditional Statements
*   Return Values
*   Linear Search","You are given an array of integers `arr` and a target integer `target`. Your task is to implement a linear search algorithm to find the first index of the `target` in the `arr`. If the `target` is not found in the array, you should return `-1`.","*   `1 <= arr.length <= 1000`
*   `-1000 <= arr[i] <= 1000`
*   `-1000 <= target <= 1000`","arr = [4, 2, 7, 1, 9]
target = 7",2,"Input: 5
1 2 3 4 5
3
Output: 2
Input: 1
99
99
Output: 0
Input: 7
10 20 30 40 50 60 70
70
Output: 6
Input: 5
-5 -2 0 2 5
-1
Output: -1
Input: 6
1 5 3 5 8 9
5
Output: 1","#include <stdio.h>

// Function to perform linear search
int linearSearch(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}

int main() {
    int n;
    // Read the size of the array
    scanf(""%d"", &n);

    int arr[n]; // Declare array of size n (VLA - C99 feature)
    // Read array elements
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]);
    }

    int target;
    // Read the target element
    scanf(""%d"", &target);

    // Call the linear search function
    int result = linearSearch(arr, n, target);

    // Print the result
    printf(""%d\n"", result);

    return 0;
}","def linear_search(arr, target):
    """"""
    Function to perform linear search.
    :param arr: List of integers to search within.
    :param target: The integer to search for.
    :return: The index of the first occurrence of the target, or -1 if not found.
    """"""
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # Target found, return its index
    return -1  # Target not found

if __name__ == ""__main__"":
    # Read the size of the array
    n = int(input())

    # Read array elements
    arr = list(map(int, input().split()))

    # Read the target element
    target = int(input())

    # Call the linear search function
    result = linear_search(arr, target)

    # Print the result
    print(result)","import java.util.Scanner;

public class Solution {

    // Function to perform linear search
    public static int linearSearch(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i; // Target found, return its index
            }
        }
        return -1; // Target not found
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the size of the array
        int n = scanner.nextInt();

        int[] arr = new int[n];
        // Read array elements
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        // Read the target element
        int target = scanner.nextInt();

        // Call the linear search function
        int result = linearSearch(arr, target);

        // Print the result
        System.out.println(result);

        scanner.close();
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let inputLines = [];

rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    // Function to perform linear search
    function linearSearch(arr, target) {
        for (let i = 0; i < arr.length; i++) {
            if (arr[i] === target) {
                return i; // Target found, return its index
            }
        }
        return -1; // Target not found
    }

    // Parse input
    const n = parseInt(inputLines[0]);
    const arr = inputLines[1].split(' ').map(Number);
    const target = parseInt(inputLines[2]);

    // Call the linear search function
    const result = linearSearch(arr, target);

    // Print the result
    console.log(result);
});","#include <iostream>
#include <vector>

// Function to perform linear search
int linearSearch(const std::vector<int>& arr, int target) {
    for (int i = 0; i < arr.size(); ++i) {
        if (arr[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}

int main() {
    int n;
    // Read the size of the array
    std::cin >> n;

    std::vector<int> arr(n);
    // Read array elements
    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i];
    }

    int target;
    // Read the target element
    std::cin >> target;

    // Call the linear search function
    int result = linearSearch(arr, target);

    // Print the result
    std::cout << result << std::endl;

    return 0;
}","#include <iostream>
#include <vector>

// Function to perform linear search
int linearSearch(const std::vector<int>& arr, int target) {
    for (int i = 0; i < arr.size(); ++i) {
        if (arr[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}

int main() {
    int n;
    // Read the size of the array
    std::cin >> n;

    std::vector<int> arr(n);
    // Read array elements
    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i];
    }

    int target;
    // Read the target element
    std::cin >> target;

    // Call the linear search function
    int result = linearSearch(arr, target);

    // Print the result
    std::cout << result << std::endl;

    return 0;
}"
Yellow-44,Circular Queue basics,"*   Array-based queue implementation
*   Circular array concept using the modulo operator (`%`)
*   Managing `front` and `rear` pointers (or indices)
*   Handling queue empty and full conditions
*   First-In, First-Out (FIFO) principle","A circular queue is a linear data structure that operates in a First-In, First-Out (FIFO) manner, similar to a regular queue. The key difference is that the last position is connected back to the first position, forming a circle. This allows for efficient reuse of array space once elements are dequeued from the front.

Your task is to implement a `CircularQueue` class (or equivalent structure) that supports the following operations:

*   `CircularQueue(k)`: Initializes the queue with a maximum capacity of `k` elements.
*   `enqueue(value)`: Adds an element `value` to the rear of the queue. Returns `true` if the operation was successful, `false` otherwise (if the queue is full).
*   `dequeue()`: Removes an element from the front of the queue. Returns `true` if the operation was successful, `false` otherwise (if the queue is empty).
*   `front()`: Gets the front element of the queue. Returns the element if the queue is not empty, ` -1` otherwise.
*   `rear()`: Gets the last element of the queue. Returns the element if the queue is not empty, `-1` otherwise.
*   `isEmpty()`: Checks whether the circular queue is empty. Returns `true` if empty, `false` otherwise.
*   `isFull()`: Checks whether the circular queue is full. Returns `true` if full, `false` otherwise.

All values will be integers.","*   `1 <= k <= 1000` (capacity)
*   `0 <= value <= 1000` (values to enqueue)
*   At most `1000` calls will be made to `enqueue`, `dequeue`, `front`, `rear`, `isEmpty`, and `isFull`.","**

init 3
enqueue 1
enqueue 2
enqueue 3
enqueue 4
rear
isFull
dequeue
enqueue 4
front


**","**

true
true
true
false
3
true
true
4


**","Input:
init 2
isEmpty
enqueue 10
enqueue 20
isFull
enqueue 30
front
rear
dequeue
dequeue
isEmpty
dequeue
Output:
true
true
true
false
10
20
true
true
true
false
Input:
init 1
enqueue 5
front
rear
enqueue 6
dequeue
front
isEmpty
enqueue 7
isFull
Output:
true
5
5
false
true
-1
true
true
true
Input:
init 1
enqueue 100
front
rear
dequeue
front
isEmpty
enqueue 200
rear
dequeue
isEmpty
Output:
true
100
100
true
-1
true
true
200
true
true","#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

typedef struct {
    int* queue_arr;
    int front;
    int rear; // points to the next available slot
    int count;
    int capacity;
} CircularQueue;

CircularQueue* circularQueueCreate(int k) {
    CircularQueue* obj = (CircularQueue*)malloc(sizeof(CircularQueue));
    if (obj == NULL) return NULL; // Handle allocation failure
    obj->queue_arr = (int*)malloc(sizeof(int) * k);
    if (obj->queue_arr == NULL) { // Handle allocation failure
        free(obj);
        return NULL;
    }
    obj->front = 0;
    obj->rear = 0;
    obj->count = 0;
    obj->capacity = k;
    return obj;
}

bool circularQueueIsEmpty(CircularQueue* obj) {
    return obj->count == 0;
}

bool circularQueueIsFull(CircularQueue* obj) {
    return obj->count == obj->capacity;
}

bool circularQueueEnqueue(CircularQueue* obj, int value) {
    if (circularQueueIsFull(obj)) {
        return false;
    }
    obj->queue_arr[obj->rear] = value;
    obj->rear = (obj->rear + 1) % obj->capacity;
    obj->count++;
    return true;
}

bool circularQueueDequeue(CircularQueue* obj) {
    if (circularQueueIsEmpty(obj)) {
        return false;
    }
    obj->front = (obj->front + 1) % obj->capacity;
    obj->count--;
    return true;
}

int circularQueueFront(CircularQueue* obj) {
    if (circularQueueIsEmpty(obj)) {
        return -1;
    }
    return obj->queue_arr[obj->front];
}

int circularQueueRear(CircularQueue* obj) {
    if (circularQueueIsEmpty(obj)) {
        return -1;
    }
    // The actual rear element is at (rear - 1 + capacity) % capacity
    // Adding capacity before modulo handles cases where (rear - 1) might be negative (e.g., rear=0)
    return obj->queue_arr[(obj->rear - 1 + obj->capacity) % obj->capacity];
}

void circularQueueFree(CircularQueue* obj) {
    if (obj == NULL) return;
    free(obj->queue_arr);
    free(obj);
}

int main() {
    CircularQueue* cq = NULL;
    char command[20];
    int k_val, value_val;

    while (scanf(""%s"", command) != EOF) {
        if (strcmp(command, ""init"") == 0) {
            scanf(""%d"", &k_val);
            if (cq != NULL) {
                circularQueueFree(cq); // Free previous queue if exists
            }
            cq = circularQueueCreate(k_val);
        } else if (strcmp(command, ""enqueue"") == 0) {
            scanf(""%d"", &value_val);
            printf(""%s\n"", circularQueueEnqueue(cq, value_val) ? ""true"" : ""false"");
        } else if (strcmp(command, ""dequeue"") == 0) {
            printf(""%s\n"", circularQueueDequeue(cq) ? ""true"" : ""false"");
        } else if (strcmp(command, ""front"") == 0) {
            printf(""%d\n"", circularQueueFront(cq));
        } else if (strcmp(command, ""rear"") == 0) {
            printf(""%d\n"", circularQueueRear(cq));
        } else if (strcmp(command, ""isEmpty"") == 0) {
            printf(""%s\n"", circularQueueIsEmpty(cq) ? ""true"" : ""false"");
        } else if (strcmp(command, ""isFull"") == 0) {
            printf(""%s\n"", circularQueueIsFull(cq) ? ""true"" : ""false"");
        }
    }
    circularQueueFree(cq); // Free final queue

    return 0;
}","import sys

class CircularQueue:
    def __init__(self, k: int):
        self.queue = [0] * k
        self.front = 0
        self.rear = 0 # points to the next available slot
        self.count = 0
        self.capacity = k

    def enqueue(self, value: int) -> bool:
        if self.isFull():
            return False
        self.queue[self.rear] = value
        self.rear = (self.rear + 1) % self.capacity
        self.count += 1
        return True

    def dequeue(self) -> bool:
        if self.isEmpty():
            return False
        self.front = (self.front + 1) % self.capacity
        self.count -= 1
        return True

    def front(self) -> int:
        if self.isEmpty():
            return -1
        return self.queue[self.front]

    def rear(self) -> int:
        if self.isEmpty():
            return -1
        # The actual rear element is at (rear - 1 + capacity) % capacity
        # Adding capacity before modulo handles cases where (rear - 1) might be negative (e.g., rear=0)
        return self.queue[(self.rear - 1 + self.capacity) % self.capacity]

    def isEmpty(self) -> bool:
        return self.count == 0

    def isFull(self) -> bool:
        return self.count == self.capacity

# Main function to handle I/O
def solve():
    circular_queue = None
    results = []

    for line in sys.stdin:
        parts = line.strip().split()
        command = parts[0]

        if command == ""init"":
            k = int(parts[1])
            circular_queue = CircularQueue(k)
        elif command == ""enqueue"":
            value = int(parts[1])
            results.append(str(circular_queue.enqueue(value)).lower())
        elif command == ""dequeue"":
            results.append(str(circular_queue.dequeue()).lower())
        elif command == ""front"":
            results.append(str(circular_queue.front()))
        elif command == ""rear"":
            results.append(str(circular_queue.rear()))
        elif command == ""isEmpty"":
            results.append(str(circular_queue.isEmpty()).lower())
        elif command == ""isFull"":
            results.append(str(circular_queue.isFull()).lower())
    
    for res in results:
        print(res)

solve()","import java.util.Scanner;

class CircularQueue {
    private int[] queue;
    private int front;
    private int rear; // points to the next available slot
    private int count;
    private int capacity;

    public CircularQueue(int k) {
        queue = new int[k];
        front = 0;
        rear = 0;
        count = 0;
        capacity = k;
    }

    public boolean enqueue(int value) {
        if (isFull()) {
            return false;
        }
        queue[rear] = value;
        rear = (rear + 1) % capacity;
        count++;
        return true;
    }

    public boolean dequeue() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        count--;
        return true;
    }

    public int front() {
        if (isEmpty()) {
            return -1;
        }
        return queue[front];
    }

    public int rear() {
        if (isEmpty()) {
            return -1;
        }
        // The actual rear element is at (rear - 1 + capacity) % capacity
        // Adding capacity before modulo handles cases where (rear - 1) might be negative (e.g., rear=0)
        return queue[(rear - 1 + capacity) % capacity];
    }

    public boolean isEmpty() {
        return count == 0;
    }

    public boolean isFull() {
        return count == capacity;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        CircularQueue circularQueue = null;

        while (scanner.hasNextLine()) {
            String line = scanner.nextLine();
            String[] parts = line.trim().split("" "");
            String command = parts[0];

            switch (command) {
                case ""init"":
                    int k = Integer.parseInt(parts[1]);
                    circularQueue = new CircularQueue(k);
                    break;
                case ""enqueue"":
                    int value = Integer.parseInt(parts[1]);
                    System.out.println(circularQueue.enqueue(value));
                    break;
                case ""dequeue"":
                    System.out.println(circularQueue.dequeue());
                    break;
                case ""front"":
                    System.out.println(circularQueue.front());
                    break;
                case ""rear"":
                    System.out.println(circularQueue.rear());
                    break;
                case ""isEmpty"":
                    System.out.println(circularQueue.isEmpty());
                    break;
                case ""isFull"":
                    System.out.println(circularQueue.isFull());
                    break;
            }
        }
        scanner.close();
    }
}","class CircularQueue {
    constructor(k) {
        this.queue = new Array(k);
        this.front = 0;
        this.rear = 0; // points to the next available slot
        this.count = 0;
        this.capacity = k;
    }

    enqueue(value) {
        if (this.isFull()) {
            return false;
        }
        this.queue[this.rear] = value;
        this.rear = (this.rear + 1) % this.capacity;
        this.count++;
        return true;
    }

    dequeue() {
        if (this.isEmpty()) {
            return false;
        }
        this.front = (this.front + 1) % this.capacity;
        this.count--;
        return true;
    }

    front() {
        if (this.isEmpty()) {
            return -1;
        }
        return this.queue[this.front];
    }

    rear() {
        if (this.isEmpty()) {
            return -1;
        }
        // The actual rear element is at (rear - 1 + capacity) % capacity
        // Adding capacity before modulo handles cases where (rear - 1) might be negative (e.g., rear=0)
        return this.queue[(this.rear - 1 + this.capacity) % this.capacity];
    }

    isEmpty() {
        return this.count === 0;
    }

    isFull() {
        return this.count === this.capacity;
    }
}

// Main function to handle I/O
function solve() {
    let circularQueue = null;
    const results = [];
    // Read input from stdin for Node.js environment
    // In a browser environment, this part would be different (e.g., prompt, event listeners)
    const inputLines = require('fs').readFileSync(0, 'utf-8').trim().split('\n');
    
    for (const line of inputLines) {
        const parts = line.trim().split(' ');
        const command = parts[0];

        switch (command) {
            case ""init"":
                const k = parseInt(parts[1]);
                circularQueue = new CircularQueue(k);
                break;
            case ""enqueue"":
                const value = parseInt(parts[1]);
                results.push(circularQueue.enqueue(value).toString());
                break;
            case ""dequeue"":
                results.push(circularQueue.dequeue().toString());
                break;
            case ""front"":
                results.push(circularQueue.front().toString());
                break;
            case ""rear"":
                results.push(circularQueue.rear().toString());
                break;
            case ""isEmpty"":
                results.push(circularQueue.isEmpty().toString());
                break;
            case ""isFull"":
                results.push(circularQueue.isFull().toString());
                break;
        }
    }
    
    console.log(results.join('\n'));
}

solve();","#include <iostream>
#include <vector>
#include <string>
#include <sstream>

class CircularQueue {
private:
    std::vector<int> queue;
    int front_ptr;
    int rear_ptr; // points to the next available slot
    int current_count;
    int capacity;

public:
    CircularQueue(int k) {
        queue.resize(k);
        front_ptr = 0;
        rear_ptr = 0;
        current_count = 0;
        capacity = k;
    }

    bool enqueue(int value) {
        if (isFull()) {
            return false;
        }
        queue[rear_ptr] = value;
        rear_ptr = (rear_ptr + 1) % capacity;
        current_count++;
        return true;
    }

    bool dequeue() {
        if (isEmpty()) {
            return false;
        }
        front_ptr = (front_ptr + 1) % capacity;
        current_count--;
        return true;
    }

    int front() {
        if (isEmpty()) {
            return -1;
        }
        return queue[front_ptr];
    }

    int rear() {
        if (isEmpty()) {
            return -1;
        }
        // The actual rear element is at (rear_ptr - 1 + capacity) % capacity
        // Adding capacity before modulo handles cases where (rear_ptr - 1) might be negative (e.g., rear_ptr=0)
        return queue[(rear_ptr - 1 + capacity) % capacity];
    }

    bool isEmpty() {
        return current_count == 0;
    }

    bool isFull() {
        return current_count == capacity;
    }
};

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    CircularQueue* circularQueue = nullptr;
    std::string line;

    while (std::getline(std::cin, line)) {
        std::stringstream ss(line);
        std::string command;
        ss >> command;

        if (command == ""init"") {
            int k;
            ss >> k;
            if (circularQueue != nullptr) {
                delete circularQueue; // Clean up previous queue if any
            }
            circularQueue = new CircularQueue(k);
        } else if (command == ""enqueue"") {
            int value;
            ss >> value;
            std::cout << (circularQueue->enqueue(value) ? ""true"" : ""false"") << std::endl;
        } else if (command == ""dequeue"") {
            std::cout << (circularQueue->dequeue() ? ""true"" : ""false"") << std::endl;
        } else if (command == ""front"") {
            std::cout << circularQueue->front() << std::endl;
        } else if (command == ""rear"") {
            std::cout << circularQueue->rear() << std::endl;
        } else if (command == ""isEmpty"") {
            std::cout << (circularQueue->isEmpty() ? ""true"" : ""false"") << std::endl;
        } else if (command == ""isFull"") {
            std::cout << (circularQueue->isFull() ? ""true"" : ""false"") << std::endl;
        }
    }

    if (circularQueue != nullptr) {
        delete circularQueue; // Clean up allocated memory
    }

    return 0;
}","#include <iostream>
#include <vector>
#include <string>
#include <sstream>

class CircularQueue {
private:
    std::vector<int> queue;
    int front_ptr;
    int rear_ptr; // points to the next available slot
    int current_count;
    int capacity;

public:
    CircularQueue(int k) {
        queue.resize(k);
        front_ptr = 0;
        rear_ptr = 0;
        current_count = 0;
        capacity = k;
    }

    bool enqueue(int value) {
        if (isFull()) {
            return false;
        }
        queue[rear_ptr] = value;
        rear_ptr = (rear_ptr + 1) % capacity;
        current_count++;
        return true;
    }

    bool dequeue() {
        if (isEmpty()) {
            return false;
        }
        front_ptr = (front_ptr + 1) % capacity;
        current_count--;
        return true;
    }

    int front() {
        if (isEmpty()) {
            return -1;
        }
        return queue[front_ptr];
    }

    int rear() {
        if (isEmpty()) {
            return -1;
        }
        // The actual rear element is at (rear_ptr - 1 + capacity) % capacity
        // Adding capacity before modulo handles cases where (rear_ptr - 1) might be negative (e.g., rear_ptr=0)
        return queue[(rear_ptr - 1 + capacity) % capacity];
    }

    bool isEmpty() {
        return current_count == 0;
    }

    bool isFull() {
        return current_count == capacity;
    }
};

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    CircularQueue* circularQueue = nullptr;
    std::string line;

    while (std::getline(std::cin, line)) {
        std::stringstream ss(line);
        std::string command;
        ss >> command;

        if (command == ""init"") {
            int k;
            ss >> k;
            if (circularQueue != nullptr) {
                delete circularQueue; // Clean up previous queue if any
            }
            circularQueue = new CircularQueue(k);
        } else if (command == ""enqueue"") {
            int value;
            ss >> value;
            std::cout << (circularQueue->enqueue(value) ? ""true"" : ""false"") << std::endl;
        } else if (command == ""dequeue"") {
            std::cout << (circularQueue->dequeue() ? ""true"" : ""false"") << std::endl;
        } else if (command == ""front"") {
            std::cout << circularQueue->front() << std::endl;
        } else if (command == ""rear"") {
            std::cout << circularQueue->rear() << std::endl;
        } else if (command == ""isEmpty"") {
            std::cout << (circularQueue->isEmpty() ? ""true"" : ""false"") << std::endl;
        } else if (command == ""isFull"") {
            std::cout << (circularQueue->isFull() ? ""true"" : ""false"") << std::endl;
        }
    }

    if (circularQueue != nullptr) {
        delete circularQueue; // Clean up allocated memory
    }

    return 0;
}"
Yellow-45,Prefix & Suffix Sums,"*   Prefix Sums (also known as Cumulative Sums)
*   Array Manipulation
*   Range Queries
*   Time and Space Complexity Analysis","YouYou are given an array of integers and a list of queries. Each query consists of two indices, `L` and `R`, representing a range `[L, R]` (inclusive) within the array. Your task is to find the sum of all elements in the array for each given range query.

This problem tests your ability to efficiently process multiple range sum queries on a static array. A naive approach of summing elements for each query would be too slow for large inputs.","*   `1 <= N <= 10^5` (where `N` is the number of elements in the array)
*   `-1000 <= arr[i] <= 1000` (value of each element in the array)
*   `1 <= Q <= 10^5` (where `Q` is the number of queries)
*   `0 <= L <= R < N` (indices for each query)","**

5
1 2 3 4 5
3
0 2
1 3
2 4


**","**

6
9
12


**","Input:
4
-1 2 -3 4
3
0 0
1 2
0 3
Output:
-1
-1
2
Input:
1
100
1
0 0
Output:
100
Input:
5
10 20 30 40 50
3
0 0
2 2
0 4
Output:
10
30
150
Input:
4
0 0 0 0
2
0 1
2 3
Output:
0
0","#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int left;
    int right;
} Query;

// Function to solve the range sum queries using prefix sums
// Note: For very large sums, prefixSum should be long long. Given constraints, int is acceptable.
int* solve(int* arr, int n, Query* queries, int numQueries) {
    int* prefixSum = (int*) malloc(sizeof(int) * (n + 1));
    if (prefixSum == NULL) {
        return NULL; // Handle allocation failure
    }
    prefixSum[0] = 0;
    for (int i = 0; i < n; i++) {
        prefixSum[i + 1] = prefixSum[i] + arr[i];
    }

    int* results = (int*) malloc(sizeof(int) * numQueries);
    if (results == NULL) {
        free(prefixSum);
        return NULL; // Handle allocation failure
    }

    for (int i = 0; i < numQueries; i++) {
        int L = queries[i].left;
        int R = queries[i].right;
        // Sum from index L to R (inclusive) is prefixSum[R+1] - prefixSum[L]
        results[i] = prefixSum[R + 1] - prefixSum[L];
    }

    free(prefixSum); // Free allocated prefixSum array
    return results;
}

int main() {
    int n;
    scanf(""%d"", &n);

    int* arr = (int*) malloc(sizeof(int) * n);
    if (arr == NULL) {
        return 1; // Indicate error
    }
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]);
    }

    int numQueries;
    scanf(""%d"", &numQueries);

    Query* queries = (Query*) malloc(sizeof(Query) * numQueries);
    if (queries == NULL) {
        free(arr);
        return 1; // Indicate error
    }
    for (int i = 0; i < numQueries; i++) {
        scanf(""%d %d"", &queries[i].left, &queries[i].right);
    }

    int* results = solve(arr, n, queries, numQueries);

    if (results == NULL) {
        free(arr);
        free(queries);
        return 1;
    }

    for (int i = 0; i < numQueries; i++) {
        printf(""%d\n"", results[i]);
    }

    free(arr);
    free(queries);
    free(results);
    return 0;
}","import sys

# Function to solve the range sum queries using prefix sums
def solve(arr, queries):
    n = len(arr)
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + arr[i]

    results = []
    for L, R in queries:
        # Sum from index L to R (inclusive) is prefix_sum[R+1] - prefix_sum[L]
        results.append(prefix_sum[R + 1] - prefix_sum[L])
    return results

def main():
    # Read N
    n = int(sys.stdin.readline())

    # Read array elements
    arr = list(map(int, sys.stdin.readline().split()))

    # Read number of queries
    num_queries = int(sys.stdin.readline())

    # Read queries (L, R tuples)
    queries = []
    for _ in range(num_queries):
        L, R = map(int, sys.stdin.readline().split())
        queries.append((L, R)) 

    # Solve and print results
    results = solve(arr, queries)
    for result in results:
        sys.stdout.write(str(result) + ""\n"")

if __name__ == ""__main__"":
    main()","import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

class Query {
    int left;
    int right;

    public Query(int left, int right) {
        this.left = left;
        this.right = right;
    }
}

public class Solution {

    // Function to solve the range sum queries using prefix sums
    public static List<Integer> solve(int[] arr, List<Query> queries) {
        int n = arr.length;
        // Use long for prefixSum to prevent potential overflow, especially if constraints were larger.
        // For current constraints (N=10^5, val=1000), int (max 2*10^9) would technically suffice (max sum 10^8).
        long[] prefixSum = new long[n + 1];
        prefixSum[0] = 0;
        for (int i = 0; i < n; i++) {
            prefixSum[i + 1] = prefixSum[i] + arr[i];
        }

        List<Integer> results = new ArrayList<>();
        for (Query q : queries) {
            int L = q.left;
            int R = q.right;
            // Sum from index L to R (inclusive) is prefixSum[R+1] - prefixSum[L]
            results.add((int)(prefixSum[R + 1] - prefixSum[L]));
        }
        return results;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        int numQueries = scanner.nextInt();
        List<Query> queries = new ArrayList<>();
        for (int i = 0; i < numQueries; i++) {
            int L = scanner.nextInt();
            int R = scanner.nextInt();
            queries.add(new Query(L, R));
        }

        List<Integer> results = solve(arr, queries);

        for (int result : results) {
            System.out.println(result);
        }

        scanner.close();
    }
}","// Function to solve the range sum queries using prefix sums
function solve(arr, queries) {
    const n = arr.length;
    const prefixSum = new Array(n + 1).fill(0);
    for (let i = 0; i < n; i++) {
        prefixSum[i + 1] = prefixSum[i] + arr[i];
    }

    const results = [];
    for (const query of queries) {
        const L = query[0]; // Assuming query is [L, R]
        const R = query[1];
        // Sum from index L to R (inclusive) is prefixSum[R+1] - prefixSum[L]
        results.push(prefixSum[R + 1] - prefixSum[L]);
    }
    return results;
}

function main() {
    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\n');
    let lineIndex = 0;

    const n = parseInt(input[lineIndex++]);
    const arr = input[lineIndex++].split(' ').map(Number);

    const numQueries = parseInt(input[lineIndex++]);
    const queries = [];
    for (let i = 0; i < numQueries; i++) {
        queries.push(input[lineIndex++].split(' ').map(Number));
    }

    const results = solve(arr, queries);

    for (const result of results) {
        console.log(result);
    }
}

main();","#include <iostream>
#include <vector>
#include <numeric>

struct Query {
    int left;
    int right;
};

// Function to solve the range sum queries using prefix sums
std::vector<int> solve(const std::vector<int>& arr, const std::vector<Query>& queries) {
    int n = arr.size();
    // Use long long for prefixSum to prevent potential overflow, especially if constraints were larger.
    // For current constraints (N=10^5, val=1000), int (max 2*10^9) would technically suffice (max sum 10^8).
    std::vector<long long> prefixSum(n + 1, 0);
    for (int i = 0; i < n; ++i) {
        prefixSum[i + 1] = prefixSum[i] + arr[i];
    }

    std::vector<int> results;
    results.reserve(queries.size()); // Pre-allocate memory for efficiency

    for (const auto& q : queries) {
        int L = q.left;
        int R = q.right;
        // Sum from index L to R (inclusive) is prefixSum[R+1] - prefixSum[L]
        results.push_back(static_cast<int>(prefixSum[R + 1] - prefixSum[L]));
    }
    return results;
}

int main() {
    // Optimize C++ standard streams for competitive programming
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    std::vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i];
    }

    int numQueries;
    std::cin >> numQueries;

    std::vector<Query> queries(numQueries);
    for (int i = 0; i < numQueries; ++i) {
        std::cin >> queries[i].left >> queries[i].right;
    }

    std::vector<int> results = solve(arr, queries);

    for (int result : results) {
        std::cout << result << ""\n"";
    }

    return 0;
}","#include <iostream>
#include <vector>
#include <numeric>

struct Query {
    int left;
    int right;
};

// Function to solve the range sum queries using prefix sums
std::vector<int> solve(const std::vector<int>& arr, const std::vector<Query>& queries) {
    int n = arr.size();
    // Use long long for prefixSum to prevent potential overflow, especially if constraints were larger.
    // For current constraints (N=10^5, val=1000), int (max 2*10^9) would technically suffice (max sum 10^8).
    std::vector<long long> prefixSum(n + 1, 0);
    for (int i = 0; i < n; ++i) {
        prefixSum[i + 1] = prefixSum[i] + arr[i];
    }

    std::vector<int> results;
    results.reserve(queries.size()); // Pre-allocate memory for efficiency

    for (const auto& q : queries) {
        int L = q.left;
        int R = q.right;
        // Sum from index L to R (inclusive) is prefixSum[R+1] - prefixSum[L]
        results.push_back(static_cast<int>(prefixSum[R + 1] - prefixSum[L]));
    }
    return results;
}

int main() {
    // Optimize C++ standard streams for competitive programming
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    std::vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i];
    }

    int numQueries;
    std::cin >> numQueries;

    std::vector<Query> queries(numQueries);
    for (int i = 0; i < numQueries; ++i) {
        std::cin >> queries[i].left >> queries[i].right;
    }

    std::vector<int> results = solve(arr, queries);

    for (int result : results) {
        std::cout << result << ""\n"";
    }

    return 0;
}"
Yellow-46,Intro to Backtracking,"*   Backtracking
*   Recursion
*   Decision Tree
*   Time and Space Complexity Analysis",You are given an array of unique integers `nums`. Your task is to return all possible subsets (the power set) of this array. The order of the subsets and the order of elements within each subset do not matter. Duplicate subsets should not be included.,"*   `1 <= nums.length <= 10`
*   `0 <= nums[i] <= 100`
*   All the integers in `nums` are unique.","`[1, 2, 3]`","`[[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]`","Input: 5
Output: []
[5]
Input: 10 20
Output: []
[10]
[20]
[10 20]
Input: 4 5 6 7
Output: []
[4]
[5]
[6]
[7]
[4 5]
[4 6]
[4 7]
[5 6]
[5 7]
[6 7]
[4 5 6]
[4 5 7]
[4 6 7]
[5 6 7]
[4 5 6 7]
Input: 0 1
Output: []
[0]
[1]
[0 1]
Input: 80 90 100
Output: []
[80]
[90]
[100]
[80 90]
[80 100]
[90 100]
[80 90 100]","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// A helper function to print an integer array (subset)
void printSubset(int* subset, int size) {
    printf(""["");
    for (int i = 0; i < size; i++) {
        printf(""%d"", subset[i]);
        if (i < size - 1) {
            printf("" "");
        }
    }
    printf(""]\n"");
}

// Backtracking helper function to generate subsets
// For C, we'll print subsets directly to avoid complex memory management for a list of lists,
// as is common in competitive programming when the goal is to find and print all solutions.
void backtrack(int* nums, int numsSize, int* currentSubset, int currentSubsetSize, int startIdx) {
    // Base case: currentSubset is a valid subset, print it.
    printSubset(currentSubset, currentSubsetSize);

    // Recursive step: Explore choices
    for (int i = startIdx; i < numsSize; i++) {
        // Choose: Add nums[i] to currentSubset
        currentSubset[currentSubsetSize] = nums[i];

        // Explore: Recurse with the next element
        backtrack(nums, numsSize, currentSubset, currentSubsetSize + 1, i + 1);

        // Unchoose (Backtrack): Conceptually remove the last element.
        // In C with a fixed-size `currentSubset` passed by value or managing size, 
        // simply returning from the function means `currentSubsetSize` will revert for the caller.
        // No explicit `pop_back` is needed on the array itself, as we pass `currentSubsetSize + 1` 
        // to the next call, and currentSubsetSize will implicitly be its old value for the next iteration.
    }
}

// Main function to find all subsets
void findSubsets(int* nums, int numsSize) {
    // currentSubset will hold the elements for the current subset being built.
    // Max size of currentSubset is numsSize (when all elements are included).
    int* currentSubset = (int*)malloc(numsSize * sizeof(int));
    if (currentSubset == NULL) {
        fprintf(stderr, ""Memory allocation failed\n"");
        return;
    }

    // Start the backtracking process
    backtrack(nums, numsSize, currentSubset, 0, 0);

    free(currentSubset);
}

int main() {
    int nums[10]; // Max constraint 10 elements
    int numsSize = 0;
    int num;

    // Read input from stdin: space-separated integers on a single line
    char buffer[100]; // Buffer to read the line
    if (fgets(buffer, sizeof(buffer), stdin) == NULL) {
        // Handle error or empty input
        return 1;
    }

    char* token = strtok(buffer, "" \n"");
    while (token != NULL && numsSize < 10) {
        nums[numsSize++] = atoi(token);
        token = strtok(NULL, "" \n"");
    }
    
    // As per constraints, nums.length >= 1, so no empty array input for main logic
    // If it were allowed and empty, just [] would be the output.

    findSubsets(nums, numsSize);

    return 0;
}","import sys

class Solution:
    def _backtrack(self, nums, start_idx, current_subset, result):
        # Add the current subset to the result list
        result.append(list(current_subset)) # Append a copy to prevent modification issues

        # Explore choices
        for i in range(start_idx, len(nums)):
            # Choose: Add nums[i] to current_subset
            current_subset.append(nums[i])

            # Explore: Recurse with the next element
            self._backtrack(nums, i + 1, current_subset, result)

            # Unchoose (Backtrack): Remove the last element to explore other paths
            current_subset.pop()

    def find_subsets(self, nums):
        result = []
        current_subset = []
        self._backtrack(nums, 0, current_subset, result)
        return result

def main():
    line = sys.stdin.readline().strip()

    # Constraints say nums.length >= 1, but handling empty input defensively.
    if not line:
        print(""[]"")
        return

    nums = list(map(int, line.split()))

    sol = Solution()
    result = sol.find_subsets(nums)

    # Print the results
    for subset in result:
        print(""["" + "" "".join(map(str, subset)) + ""]"")

if __name__ == ""__main__"":
    main()","import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;

public class Solution {

    // Helper function for backtracking
    private void backtrack(int[] nums,
                           int startIdx,
                           List<Integer> currentSubset,
                           List<List<Integer>> result) {

        // Add the current subset to the result list
        result.add(new ArrayList<>(currentSubset)); // Add a copy to prevent modification issues

        // Explore choices
        for (int i = startIdx; i < nums.length; i++) {
            // Choose: Add nums[i] to currentSubset
            currentSubset.add(nums[i]);

            // Explore: Recurse with the next element
            backtrack(nums, i + 1, currentSubset, result);

            // Unchoose (Backtrack): Remove the last element to explore other paths
            currentSubset.remove(currentSubset.size() - 1);
        }
    }

    // Main function to find all subsets
    public List<List<Integer>> findSubsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();
        backtrack(nums, 0, currentSubset, result);
        return result;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String line = scanner.nextLine();
        scanner.close();

        // Constraints say nums.length >= 1, but handling empty input defensively.
        if (line.trim().isEmpty()) {
            System.out.println(""[]""); 
            return;
        }

        String[] numStrings = line.trim().split(""\\s+"");
        int[] nums = new int[numStrings.length];
        for (int i = 0; i < numStrings.length; i++) {
            nums[i] = Integer.parseInt(numStrings[i]);
        }

        Solution sol = new Solution();
        List<List<Integer>> result = sol.findSubsets(nums);

        // Print the results
        for (List<Integer> subset : result) {
            System.out.print(""["");
            for (int i = 0; i < subset.size(); i++) {
                System.out.print(subset.get(i));
                if (i < subset.size() - 1) {
                    System.out.print("" "");
                }
            }
            System.out.println(""]"");
        }
    }
}","const readline = require('readline');

class Solution {
    _backtrack(nums, startIdx, currentSubset, result) {
        // Add the current subset to the result list
        result.push([...currentSubset]); // Push a shallow copy to prevent modification issues

        // Explore choices
        for (let i = startIdx; i < nums.length; i++) {
            // Choose: Add nums[i] to currentSubset
            currentSubset.push(nums[i]);

            // Explore: Recurse with the next element
            this._backtrack(nums, i + 1, currentSubset, result);

            // Unchoose (Backtrack): Remove the last element to explore other paths
            currentSubset.pop();
        }
    }

    // Main function to find all subsets
    findSubsets(nums) {
        const result = [];
        const currentSubset = [];
        this._backtrack(nums, 0, currentSubset, result);
        return result;
    }
}

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.on('line', (line) => {
    // Constraints say nums.length >= 1, but handling empty input defensively.
    if (line.trim() === '') {
        console.log(""[]"");
        rl.close();
        return;
    }

    const nums = line.split(' ').map(Number);

    const sol = new Solution();
    const result = sol.findSubsets(nums);

    // Print the results
    for (const subset of result) {
        console.log(`[${subset.join(' ')}]`);
    }

    rl.close();
});","#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <sstream>

// Helper function for backtracking
void backtrack(const std::vector<int>& nums,
               int startIdx,
               std::vector<int>& currentSubset,
               std::vector<std::vector<int>>& result) {
    
    // Add the current subset to the result list
    result.push_back(currentSubset);

    // Explore choices
    for (int i = startIdx; i < nums.size(); ++i) {
        // Choose: Add nums[i] to currentSubset
        currentSubset.push_back(nums[i]);

        // Explore: Recurse with the next element
        backtrack(nums, i + 1, currentSubset, result);

        // Unchoose (Backtrack): Remove the last element to explore other paths
        currentSubset.pop_back();
    }
}

// Main function to find all subsets
std::vector<std::vector<int>> findSubsets(const std::vector<int>& nums) {
    std::vector<std::vector<int>> result;
    std::vector<int> currentSubset;
    backtrack(nums, 0, currentSubset, result);
    return result;
}

int main() {
    std::vector<int> nums;
    int num;
    std::string line;

    // Read a line of space-separated integers from stdin
    std::getline(std::cin, line);
    std::stringstream ss(line);
    while (ss >> num) {
        nums.push_back(num);
    }

    // Constraints say nums.length >= 1, so no empty array input for main logic
    // If it were allowed and empty, just {{}} (a list containing one empty list) would be the output.

    std::vector<std::vector<int>> result = findSubsets(nums);

    // Print the results
    for (const auto& subset : result) {
        std::cout << ""["";
        for (size_t i = 0; i < subset.size(); ++i) {
            std::cout << subset[i];
            if (i < subset.size() - 1) {
                std::cout << "" "";
            }
        }
        std::cout << ""]\n"";
    }

    return 0;
}","#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <sstream>

// Helper function for backtracking
void backtrack(const std::vector<int>& nums,
               int startIdx,
               std::vector<int>& currentSubset,
               std::vector<std::vector<int>>& result) {
    
    // Add the current subset to the result list
    result.push_back(currentSubset);

    // Explore choices
    for (int i = startIdx; i < nums.size(); ++i) {
        // Choose: Add nums[i] to currentSubset
        currentSubset.push_back(nums[i]);

        // Explore: Recurse with the next element
        backtrack(nums, i + 1, currentSubset, result);

        // Unchoose (Backtrack): Remove the last element to explore other paths
        currentSubset.pop_back();
    }
}

// Main function to find all subsets
std::vector<std::vector<int>> findSubsets(const std::vector<int>& nums) {
    std::vector<std::vector<int>> result;
    std::vector<int> currentSubset;
    backtrack(nums, 0, currentSubset, result);
    return result;
}

int main() {
    std::vector<int> nums;
    int num;
    std::string line;

    // Read a line of space-separated integers from stdin
    std::getline(std::cin, line);
    std::stringstream ss(line);
    while (ss >> num) {
        nums.push_back(num);
    }

    // Constraints say nums.length >= 1, so no empty array input for main logic
    // If it were allowed and empty, just {{}} (a list containing one empty list) would be the output.

    std::vector<std::vector<int>> result = findSubsets(nums);

    // Print the results
    for (const auto& subset : result) {
        std::cout << ""["";
        for (size_t i = 0; i < subset.size(); ++i) {
            std::cout << subset[i];
            if (i < subset.size() - 1) {
                std::cout << "" "";
            }
        }
        std::cout << ""]\n"";
    }

    return 0;
}"
Yellow-47,Intro to Backtracking,"*   **Backtracking:** A general algorithmic technique for finding all (or some) solutions to a computational problem, particularly constraint satisfaction problems, by systematically trying to build a solution incrementally. If a partial solution cannot be completed to a valid solution, it ""backtracks"" to an earlier state and tries another option.
*   **Recursion:** A function calling itself to solve a smaller instance of the same problem. Backtracking problems are often naturally solved using recursion.
*   **Base Cases:** The condition under which a recursive function stops calling itself and returns a result.
*   **State Management:** Keeping track of the current state of the solution (e.g., characters chosen so far, characters remaining to be chosen) during the recursive calls.",You are given a string `s` consisting of unique lowercase English letters. Your task is to generate and print all possible permutations of this string. A permutation is an arrangement of all its characters in a different order.,"*   `1 <= s.length <= 7` (To keep the number of permutations manageable for a Yellow Belt)
*   `s` consists only of unique lowercase English letters.","**

abc


**","**

abc
acb
bac
bca
cab
cba","Input: a
Output:
a
Input: ab
Output:
ab
ba
Input: abcd
Output:
abcd
abdc
acbd
acdb
adbc
adcb
bacd
badc
bcad
bcda
bdac
bdca
cabd
cadb
cbad
cbda
cdab
cdba
dabc
dacb
dbac
dbca
dcab
dcba
Input: xyz
Output:
xyz
xzy
yxz
yzx
zxy
zyx","#include <stdio.h>
#include <string.h>
#include <stdbool.h>

// Function to print all permutations
void findPermutations(char* str_arr, int n, char* current_perm, bool* visited, int level) {
    // Base case: If the current permutation length equals string length, print it
    if (level == n) {
        current_perm[level] = '\0'; // Null-terminate the string
        printf(""%s\n"", current_perm);
        return;
    }

    // Recursive step: Try each character from the original string
    for (int i = 0; i < n; i++) {
        // If character at index i has not been visited
        if (!visited[i]) {
            // Choose: Add character to current permutation and mark as visited
            current_perm[level] = str_arr[i];
            visited[i] = true;

            // Explore: Recurse for the next level
            findPermutations(str_arr, n, current_perm, visited, level + 1);

            // Unchoose (Backtrack): Remove character from current permutation and unmark as visited
            visited[i] = false;
        }
    }
}

int main() {
    char s[10]; // Assuming max string length as per constraints + null terminator
    if (scanf(""%s"", s) != 1) {
        return 1; // Error reading input
    }

    int n = strlen(s);

    char current_perm[10]; // Buffer for current permutation
    bool visited[10];      // Visited array

    // Initialize visited array to all false
    for (int i = 0; i < n; i++) {
        visited[i] = false;
    }

    findPermutations(s, n, current_perm, visited, 0);

    return 0;
}","def find_permutations_util(s_chars, current_perm, visited, results):
    # Base case: If the current permutation length equals string length, add it to results
    if len(current_perm) == len(s_chars):
        results.append("""".join(current_perm))
        return

    # Recursive step: Try each character from the original string
    for i in range(len(s_chars)):
        # If character at index i has not been visited
        if not visited[i]:
            # Choose: Add character to current permutation and mark as visited
            current_perm.append(s_chars[i])
            visited[i] = True

            # Explore: Recurse
            find_permutations_util(s_chars, current_perm, visited, results)

            # Unchoose (Backtrack): Remove character from current permutation and unmark as visited
            visited[i] = False
            current_perm.pop()

def get_all_permutations(s):
    s_chars = list(s)
    current_perm = []
    visited = [False] * len(s_chars)
    results = []

    find_permutations_util(s_chars, current_perm, visited, results)
    return results

if __name__ == ""__main__"":
    s = input()
    permutations = get_all_permutations(s)
    for p in permutations:
        print(p)","import java.util.Scanner;

public class Permutations {

    // Function to print all permutations
    public static void findPermutations(char[] s_chars, StringBuilder currentPerm, boolean[] visited) {
        // Base case: If the current permutation length equals string length, print it
        if (currentPerm.length() == s_chars.length) {
            System.out.println(currentPerm.toString());
            return;
        }

        // Recursive step: Try each character from the original string
        for (int i = 0; i < s_chars.length; i++) {
            // If character at index i has not been visited
            if (!visited[i]) {
                // Choose: Add character to current permutation and mark as visited
                currentPerm.append(s_chars[i]);
                visited[i] = true;

                // Explore: Recurse
                findPermutations(s_chars, currentPerm, visited);

                // Unchoose (Backtrack): Remove character from current permutation and unmark as visited
                currentPerm.deleteCharAt(currentPerm.length() - 1);
                visited[i] = false;
            }
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.next();
        scanner.close();

        char[] s_chars = s.toCharArray();
        StringBuilder currentPerm = new StringBuilder();
        boolean[] visited = new boolean[s_chars.length];

        findPermutations(s_chars, currentPerm, visited);
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

// Function to print all permutations
function findPermutations(s_chars, currentPerm, visited) {
    // Base case: If the current permutation length equals string length, print it
    if (currentPerm.length === s_chars.length) {
        console.log(currentPerm.join(''));
        return;
    }

    // Recursive step: Try each character from the original string
    for (let i = 0; i < s_chars.length; i++) {
        // If character at index i has not been visited
        if (!visited[i]) {
            // Choose: Add character to current permutation and mark as visited
            currentPerm.push(s_chars[i]);
            visited[i] = true;

            // Explore: Recurse
            findPermutations(s_chars, currentPerm, visited);

            // Unchoose (Backtrack): Remove character from current permutation and unmark as visited
            visited[i] = false;
            currentPerm.pop();
        }
    }
}

rl.on('line', (s) => {
    const s_chars = s.split('');
    const currentPerm = [];
    const visited = new Array(s_chars.length).fill(false);

    findPermutations(s_chars, currentPerm, visited);
    rl.close();
});","#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

// Function to print all permutations
void findPermutations(const std::string& s, std::string& current_perm, std::vector<bool>& visited) {
    // Base case: If the current permutation length equals string length, print it
    if (current_perm.length() == s.length()) {
        std::cout << current_perm << std::endl;
        return;
    }

    // Recursive step: Try each character from the original string
    for (int i = 0; i < s.length(); ++i) {
        // If character at index i has not been visited
        if (!visited[i]) {
            // Choose: Add character to current permutation and mark as visited
            current_perm.push_back(s[i]);
            visited[i] = true;

            // Explore: Recurse
            findPermutations(s, current_perm, visited);

            // Unchoose (Backtrack): Remove character from current permutation and unmark as visited
            visited[i] = false;
            current_perm.pop_back();
        }
    }
}

int main() {
    std::string s;
    std::cin >> s;

    std::string current_perm;
    std::vector<bool> visited(s.length(), false);

    findPermutations(s, current_perm, visited);

    return 0;
}","#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

// Function to print all permutations
void findPermutations(const std::string& s, std::string& current_perm, std::vector<bool>& visited) {
    // Base case: If the current permutation length equals string length, print it
    if (current_perm.length() == s.length()) {
        std::cout << current_perm << std::endl;
        return;
    }

    // Recursive step: Try each character from the original string
    for (int i = 0; i < s.length(); ++i) {
        // If character at index i has not been visited
        if (!visited[i]) {
            // Choose: Add character to current permutation and mark as visited
            current_perm.push_back(s[i]);
            visited[i] = true;

            // Explore: Recurse
            findPermutations(s, current_perm, visited);

            // Unchoose (Backtrack): Remove character from current permutation and unmark as visited
            visited[i] = false;
            current_perm.pop_back();
        }
    }
}

int main() {
    std::string s;
    std::cin >> s;

    std::string current_perm;
    std::vector<bool> visited(s.length(), false);

    findPermutations(s, current_perm, visited);

    return 0;
}"
Yellow-48,Intro to Backtracking,"- Backtracking
- Recursion
- Decision Tree
- Subset Generation
- State Management in Recursive Calls","Given an array of unique integers `nums`, the task is to return all possible subsets (the power set). The solution set must not contain duplicate subsets.

The order of the subsets and the order of elements within each subset does not matter, but your output should be consistent.","- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`
- All the integers in `nums` are unique.","`1 2 3`

####","[]
[1]
[1 2]
[1 2 3]
[1 3]
[2]
[2 3]
[3]

(Note: The order of subsets shown here is one possible valid output. Your output might have a different order, which is acceptable as long as all subsets are present and unique.)","Input: 1 2
Output: []
[1]
[1 2]
[2]
Input: 5
Output: []
[5]
Input: 
Output: []
Input: -1 0 1
Output: []
[-1]
[-1 0]
[-1 0 1]
[-1 1]
[0]
[0 1]
[1]
Input: 10 20
Output: []
[10]
[10 20]
[20]","#include <stdio.n>
#include <stdlib.h>

// Dynamic array for a single subset
typedef struct {
    int* data;
    int size;
    int capacity;
} Subset;

// Dynamic array for all subsets
typedef struct {
    Subset* subsets;
    int size;
    int capacity;
} SubsetsList;

// Function to initialize a Subset
void initSubset(Subset* s) {
    s->data = NULL;
    s->size = 0;
    s->capacity = 0;
}

// Function to add an element to a Subset
void addToSubset(Subset* s, int val) {
    if (s->size == s->capacity) {
        s->capacity = (s->capacity == 0) ? 1 : s->capacity * 2;
        s->data = (int*)realloc(s->data, s->capacity * sizeof(int));
        if (s->data == NULL) {
            fprintf(stderr, ""Memory allocation failed for subset data.\n"");
            exit(EXIT_FAILURE);
        }
    }
    s->data[s->size++] = val;
}

// Function to remove the last element from a Subset
void removeFromSubset(Subset* s) {
    if (s->size > 0) {
        s->size--;
    }
}

// Function to initialize SubsetsList
void initSubsetsList(SubsetsList* sl) {
    sl->subsets = NULL;
    sl->size = 0;
    sl->capacity = 0;
}

// Function to add a copy of a Subset to SubsetsList
void addSubsetToList(SubsetsList* sl, const Subset* s) {
    if (sl->size == sl->capacity) {
        sl->capacity = (sl->capacity == 0) ? 1 : sl->capacity * 2;
        sl->subsets = (Subset*)realloc(sl->subsets, sl->capacity * sizeof(Subset));
        if (sl->subsets == NULL) {
            fprintf(stderr, ""Memory allocation failed for subsets list.\n"");
            exit(EXIT_FAILURE);
        }
    }
    
    Subset new_s;
    initSubset(&new_s);
    for (int i = 0; i < s->size; ++i) {
        addToSubset(&new_s, s->data[i]);
    }
    sl->subsets[sl->size++] = new_s;
}

// Function to free memory of a Subset
void freeSubset(Subset* s) {
    free(s->data);
    s->data = NULL;
    s->size = 0;
    s->capacity = 0;
}

// Function to free memory of SubsetsList
void freeSubsetsList(SubsetsList* sl) {
    for (int i = 0; i < sl->size; ++i) {
        freeSubset(&sl->subsets[i]);
    }
    free(sl->subsets);
    sl->subsets = NULL;
    sl->size = 0;
    sl->capacity = 0;
}

// Backtracking helper function
void backtrack(int index, int* nums, int nums_size, Subset* current_subset, SubsetsList* result_list) {
    addSubsetToList(result_list, current_subset);

    for (int i = index; i < nums_size; ++i) {
        addToSubset(current_subset, nums[i]);
        backtrack(i + 1, nums, nums_size, current_subset, result_list);
        removeFromSubset(current_subset); // Backtrack
    }
}

// Main logic function to find all subsets
SubsetsList generateSubsets(int* nums, int nums_size) {
    SubsetsList result_list;
    initSubsetsList(&result_list);

    Subset current_subset;
    initSubset(&current_subset);

    backtrack(0, nums, nums_size, &current_subset, &result_list);
    
    freeSubset(&current_subset); // Free the temp subset used in recursion
    
    return result_list;
}

int main() {
    int nums[10]; // Max 10 elements as per constraints
    int nums_size = 0;
    int val;

    // Read input numbers until newline or EOF
    // Using a loop with getchar() to correctly handle space-separated integers
    // and stop on newline, assuming single line input.
    char buffer[100]; // Small buffer for input line
    if (fgets(buffer, sizeof(buffer), stdin) != NULL) {
        char* ptr = buffer;
        while (sscanf(ptr, ""%d"", &val) == 1) {
            nums[nums_size++] = val;
            // Move pointer past the number and any spaces
            while (*ptr != '\0' && *ptr != ' ' && *ptr != '\n') {
                ptr++;
            }
            while (*ptr != '\0' && *ptr == ' ') {
                ptr++;
            }
            if (*ptr == '\n' || *ptr == '\0') break;
        }
    }

    SubsetsList result = generateSubsets(nums, nums_size);

    // Print the result
    for (int i = 0; i < result.size; ++i) {
        printf(""["");
        for (int j = 0; j < result.subsets[i].size; ++j) {
            printf(""%d"", result.subsets[i].data[j]);
            if (j < result.subsets[i].size - 1) {
                printf("" "");
            }
        }
        printf(""]\n"");
    }

    freeSubsetsList(&result);

    return 0;
}","import sys

class Solution:
    def subsets(self, nums: list[int]) -> list[list[int]]:
        result = []
        current_subset = []
        
        def backtrack(index):
            result.append(list(current_subset)) # Add a copy of the current subset
            
            for i in range(index, len(nums)):
                current_subset.append(nums[i]) # Include nums[i]
                backtrack(i + 1) # Recurse with the next index
                current_subset.pop() # Backtrack: remove nums[i]
        
        backtrack(0)
        return result

def main():
    line = sys.stdin.readline().strip()
    
    if line:
        nums = list(map(int, line.split()))
    else:
        nums = []

    sol = Solution()
    result = sol.subsets(nums)

    # Print the result
    for subset in result:
        sys.stdout.write(""["")
        sys.stdout.write("" "".join(map(str, subset)))
        sys.stdout.write(""]\n"")

if __name__ == ""__main__"":
    main()","import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;

public class Solution {

    public List<List<Integer>> generateSubsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();
        backtrack(0, nums, currentSubset, result);
        return result;
    }

    private void backtrack(int index, int[] nums, List<Integer> currentSubset, List<List<Integer>> result) {
        result.add(new ArrayList<>(currentSubset)); // Add a copy of the current subset

        for (int i = index; i < nums.length; i++) {
            currentSubset.add(nums[i]); // Include nums[i]
            backtrack(i + 1, nums, currentSubset, result); // Recurse with the next index
            currentSubset.remove(currentSubset.size() - 1); // Backtrack: remove nums[i]
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String line = scanner.nextLine();
        scanner.close();

        // Parse the input line into an array of integers
        String[] numStrings = line.trim().split("" "");
        
        int[] nums;
        if (line.trim().isEmpty()) { // Handle empty input case
            nums = new int[0];
        } else {
            nums = new int[numStrings.length];
            for (int i = 0; i < numStrings.length; i++) {
                nums[i] = Integer.parseInt(numStrings[i]);
            }
        }

        Solution sol = new Solution();
        List<List<Integer>> result = sol.generateSubsets(nums);

        // Print the result
        for (List<Integer> subset : result) {
            System.out.print(""["");
            for (int i = 0; i < subset.size(); i++) {
                System.out.print(subset.get(i));
                if (i < subset.size() - 1) {
                    System.out.print("" "");
                }
            }
            System.out.println(""]"");
        }
    }
}","class Solution {
    subsets(nums) {
        const result = [];
        const currentSubset = [];

        function backtrack(index) {
            result.push([...currentSubset]); // Add a copy of the current subset

            for (let i = index; i < nums.length; i++) {
                currentSubset.push(nums[i]); // Include nums[i]
                backtrack(i + 1); // Recurse with the next index
                currentSubset.pop(); // Backtrack: remove nums[i]
            }
        }

        backtrack(0);
        return result;
    }
}

// Function to handle input and output for the platform
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    rl.on('line', (line) => {
        let nums;
        if (line.trim() === """") {
            nums = [];
        } else {
            nums = line.split(' ').map(Number);
        }

        const sol = new Solution();
        const result = sol.subsets(nums);

        // Print the result
        for (const subset of result) {
            process.stdout.write(""["");
            process.stdout.write(subset.join("" ""));
            process.stdout.write(""]\n"");
        }
        rl.close(); // Close the readline interface after processing input
    });
}

// Ensure main is called if script is executed directly
if (require.main === module) {
    main();
}","#include <iostream>
#include <vector>
#include <string>
#include <sstream>

void backtrack(int index, const std::vector<int>& nums, std::vector<int>& current_subset, std::vector<std::vector<int>>& result) {
    result.push_back(current_subset); // Add the current subset to the result

    for (int i = index; i < nums.size(); ++i) {
        current_subset.push_back(nums[i]); // Include nums[i]
        backtrack(i + 1, nums, current_subset, result); // Recurse with the next index
        current_subset.pop_back(); // Backtrack: remove nums[i]
    }
}

std::vector<std::vector<int>> generateSubsets(const std::vector<int>& nums) {
    std::vector<std::vector<int>> result;
    std::vector<int> current_subset;
    backtrack(0, nums, current_subset, result);
    return result;
}

int main() {
    std::string line;
    std::getline(std::cin, line);
    std::stringstream ss(line);
    
    std::vector<int> nums;
    int num;
    while (ss >> num) {
        nums.push_back(num);
    }

    std::vector<std::vector<int>> result = generateSubsets(nums);

    // Print the result
    for (const auto& subset : result) {
        std::cout << ""["";
        for (size_t i = 0; i < subset.size(); ++i) {
            std::cout << subset[i];
            if (i < subset.size() - 1) {
                std::cout << "" "";
            }
        }
        std::cout << ""]"" << std::endl;
    }

    return 0;
}","#include <iostream>
#include <vector>
#include <string>
#include <sstream>

void backtrack(int index, const std::vector<int>& nums, std::vector<int>& current_subset, std::vector<std::vector<int>>& result) {
    result.push_back(current_subset); // Add the current subset to the result

    for (int i = index; i < nums.size(); ++i) {
        current_subset.push_back(nums[i]); // Include nums[i]
        backtrack(i + 1, nums, current_subset, result); // Recurse with the next index
        current_subset.pop_back(); // Backtrack: remove nums[i]
    }
}

std::vector<std::vector<int>> generateSubsets(const std::vector<int>& nums) {
    std::vector<std::vector<int>> result;
    std::vector<int> current_subset;
    backtrack(0, nums, current_subset, result);
    return result;
}

int main() {
    std::string line;
    std::getline(std::cin, line);
    std::stringstream ss(line);
    
    std::vector<int> nums;
    int num;
    while (ss >> num) {
        nums.push_back(num);
    }

    std::vector<std::vector<int>> result = generateSubsets(nums);

    // Print the result
    for (const auto& subset : result) {
        std::cout << ""["";
        for (size_t i = 0; i < subset.size(); ++i) {
            std::cout << subset[i];
            if (i < subset.size() - 1) {
                std::cout << "" "";
            }
        }
        std::cout << ""]"" << std::endl;
    }

    return 0;
}"
Yellow-49,Linear Search,"*   Linear Search
*   Array Traversal
*   Iteration (Loops)
*   Conditional Statements","You are given an array of integers `arr` and a target integer `target`. Your task is to implement a linear search algorithm to find the first occurrence of the `target` in the `arr`. If the `target` is found, return its 0-based index. If the `target` is not present in the array, return `-1`.","* `1 <= n <= 1000` (where `n` is the size of the array `arr`)
* `-1000 <= arr[i] <= 1000`
* `-1000 <= target <= 1000`","**

5
10 20 30 40 50
30

**","**

2

**","Input: 5
10 20 30 40 50
10
Output: 0
Input: 5
10 20 30 40 50
50
Output: 4
Input: 7
1 5 3 8 5 9 2
5
Output: 1
Input: 3
-5 -10 -15
-10
Output: 1
Input: 4
1 2 3 4
0
Output: -1","#include <stdio.h>
#include <stdlib.h> // For malloc, free

// Function to perform linear search
// Returns the 0-based index of the first occurrence of target, or -1 if not found.
int linearSearch(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found in the array
}

int main() {
    int n;
    // Read the size of the array
    if (scanf(""%d"", &n) != 1 || n < 1 || n > 1000) {
        fprintf(stderr, ""Invalid array size.\n"");
        return 1;
    }

    // Allocate memory for the array
    int* arr = (int*)malloc(n * sizeof(int));
    if (arr == NULL) {
        fprintf(stderr, ""Memory allocation failed.\n"");
        return 1;
    }

    // Read array elements
    for (int i = 0; i < n; i++) {
        if (scanf(""%d"", &arr[i]) != 1) {
            fprintf(stderr, ""Failed to read array element.\n"");
            free(arr);
            return 1;
        }
    }

    int target;
    // Read the target value
    if (scanf(""%d"", &target) != 1) {
        fprintf(stderr, ""Failed to read target value.\n"");
        free(arr);
        return 1;
    }

    // Call the linear search function
    int result = linearSearch(arr, n, target);

    // Print the result
    printf(""%d\n"", result);

    // Free the allocated memory
    free(arr);

    return 0;
}","import sys

def linear_search(arr, target):
    """"""
    Performs linear search to find the first occurrence of target in arr.
    Returns the 0-based index of the first occurrence, or -1 if not found.
    """"""
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # Target found, return its index
    return -1  # Target not found in the array

def main():
    # Read the size of the array
    n = int(input())
    if not (1 <= n <= 1000):
        print(""Invalid array size."", file=sys.stderr)
        sys.exit(1)

    # Read array elements
    arr = list(map(int, input().split()))
    if len(arr) != n:
        print(""Number of array elements does not match declared size."", file=sys.stderr)
        sys.exit(1)

    # Read the target value
    target = int(input())

    # Call the linear search function
    result = linear_search(arr, target)

    # Print the result
    print(result)

if __name__ == ""__main__"":
    main()","import java.util.Scanner;

public class Main {

    // Function to perform linear search
    // Returns the 0-based index of the first occurrence of target, or -1 if not found.
    public static int linearSearch(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i; // Target found, return its index
            }
        }
        return -1; // Target not found in the array
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the size of the array
        int n = scanner.nextInt();
        if (n < 1 || n > 1000) {
            System.err.println(""Invalid array size."");
            scanner.close();
            return;
        }

        // Read array elements
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        // Read the target value
        int target = scanner.nextInt();

        // Call the linear search function
        int result = linearSearch(arr, target);

        // Print the result
        System.out.println(result);

        scanner.close();
    }
}","// Function to perform linear search
// Returns the 0-based index of the first occurrence of target, or -1 if not found.
function linearSearch(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found in the array
}

// Main execution logic for handling input/output
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let inputLines = [];
    rl.on('line', (line) => {
        inputLines.push(line);
    });

    rl.on('close', () => {
        let lineIndex = 0;

        // Read the size of the array
        const n = parseInt(inputLines[lineIndex++]);
        if (isNaN(n) || n < 1 || n > 1000) {
            console.error(""Invalid array size."");
            process.exit(1);
        }

        // Read array elements
        const arr = inputLines[lineIndex++].split(' ').map(Number);
        if (arr.length !== n) {
            console.error(""Number of array elements does not match declared size."");
            process.exit(1);
        }

        // Read the target value
        const target = parseInt(inputLines[lineIndex++]);
        if (isNaN(target)) {
            console.error(""Invalid target value."");
            process.exit(1);
        }

        // Call the linear search function
        const result = linearSearch(arr, target);

        // Print the result
        console.log(result);
    });
}

main();","#include <iostream>
#include <vector> // For std::vector

// Function to perform linear search
// Returns the 0-based index of the first occurrence of target, or -1 if not found.
int linearSearch(const std::vector<int>& arr, int target) {
    for (int i = 0; i < arr.size(); ++i) {
        if (arr[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found in the array
}

int main() {
    std::ios_base::sync_with_stdio(false); // Optimize C++ standard streams
    std::cin.tie(NULL); // Untie cin from cout

    int n;
    // Read the size of the array
    if (!(std::cin >> n) || n < 1 || n > 1000) {
        std::cerr << ""Invalid array size."" << std::endl;
        return 1;
    }

    // Read array elements into a std::vector
    std::vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        if (!(std::cin >> arr[i])) {
            std::cerr << ""Failed to read array element."" << std::endl;
            return 1;
        }
    }

    int target;
    // Read the target value
    if (!(std::cin >> target)) {
        std::cerr << ""Failed to read target value."" << std::endl;
        return 1;
    }

    // Call the linear search function
    int result = linearSearch(arr, target);

    // Print the result
    std::cout << result << std::endl;

    return 0;
}",4.2
Yellow-50,Prefix & Suffix Sums,"- Prefix Sums
- Array Manipulation
- Time and Space Complexity Analysis","You are given an array of integers, `arr`, and a list of queries. Each query consists of two indices, `start` and `end`, representing a range within the array (inclusive). Your task is to calculate the sum of all elements within each specified range for every query.

For example, if `arr = [1, 2, 3, 4, 5]` and a query is `[0, 2]`, the sum would be `arr[0] + arr[1] + arr[2] = 1 + 2 + 3 = 6`. You need to process all queries efficiently.","- `1 <= N <= 10^5` (where `N` is the length of `arr`)
- `-1000 <= arr[i] <= 1000`
- `1 <= Q <= 10^5` (where `Q` is the number of queries)
- `0 <= start <= end < N` for each query","Array: `[1, 2, 3, 4, 5]`
Queries: `[[0, 2], [1, 3]]`","`[6, 9]`","Input: 1
10
1
0 0
Output: 10
Input: 5
5 -2 8 -1 3
2
0 4
1 2
Output: 13
6
Input: 5
1 1 1 1 1
3
0 0
0 4
2 2
Output: 1
5
1
Input: 5
-1 -2 -3 -4 -5
2
0 1
3 4
Output: -3
-9","#include <stdio.h>
#include <stdlib.h> // For malloc, free

// Function to calculate range sums using prefix sums
// arr: input array
// N: size of arr
// queries: 2D array of queries, each query is {start, end}
// Q: number of queries
// resultSize: pointer to store the size of the result array
// Returns a dynamically allocated array of long long sums
long long* calculateRangeSums(int* arr, int N, int (*queries)[2], int Q, int* resultSize) {
    if (N == 0 || Q == 0) {
        *resultSize = 0;
        return NULL;
    }

    // Allocate memory for prefix sum array
    // prefixSum[i] stores sum from arr[0] to arr[i]
    long long* prefixSum = (long long*)malloc(N * sizeof(long long));
    if (prefixSum == NULL) {
        // Handle allocation failure
        *resultSize = 0;
        return NULL;
    }

    prefixSum[0] = arr[0];
    for (int i = 1; i < N; i++) {
        prefixSum[i] = prefixSum[i - 1] + arr[i];
    }

    // Allocate memory for results
    long long* results = (long long*)malloc(Q * sizeof(long long));
    if (results == NULL) {
        // Handle allocation failure, free prefixSum array
        free(prefixSum);
        *resultSize = 0;
        return NULL;
    }

    for (int i = 0; i < Q; i++) {
        int start = queries[i][0];
        int end = queries[i][1];

        if (start == 0) {
            results[i] = prefixSum[end];
        } else {
            results[i] = prefixSum[end] - prefixSum[start - 1];
        }
    }

    free(prefixSum); // Free prefix sum array as it's no longer needed
    *resultSize = Q;
    return results;
}

int main() {
    int N;
    scanf(""%d"", &N);

    int* arr = (int*)malloc(N * sizeof(int));
    if (arr == NULL) {
        return 1; // Allocation failed
    }
    for (int i = 0; i < N; i++) {
        scanf(""%d"", &arr[i]);
    }

    int Q;
    scanf(""%d"", &Q);

    int (*queries)[2] = (int(*)[2])malloc(Q * sizeof(int[2]));
    if (queries == NULL) {
        free(arr);
        return 1; // Allocation failed
    }
    for (int i = 0; i < Q; i++) {
        scanf(""%d %d"", &queries[i][0], &queries[i][1]);
    }

    int resultSize;
    long long* results = calculateRangeSums(arr, N, queries, Q, &resultSize);

    for (int i = 0; i < resultSize; i++) {
        printf(""%lld\n"", results[i]);
    }

    free(arr);
    free(queries);
    free(results); // Free the results array returned by the function

    return 0;
}","def calculate_range_sums(arr, queries):
    if not arr or not queries:
        return []

    # Build prefix sum array
    # prefix_sum[i] stores sum from arr[0] to arr[i]
    prefix_sum = [0] * len(arr)
    prefix_sum[0] = arr[0]
    for i in range(1, len(arr)):
        prefix_sum[i] = prefix_sum[i - 1] + arr[i]

    results = []
    for start, end in queries:
        if start == 0:
            results.append(prefix_sum[end])
        else:
            results.append(prefix_sum[end] - prefix_sum[start - 1])
            
    return results

def main():
    N = int(input())
    arr = list(map(int, input().split()))

    Q = int(input())
    queries = []
    for _ in range(Q):
        start, end = map(int, input().split())
        queries.append((start, end))

    results = calculate_range_sums(arr, queries)

    for s in results:
        print(s)

if __name__ == ""__main__"":
    main()","import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {

    // Function to calculate range sums using prefix sums
    public List<Long> calculateRangeSums(int[] arr, int[][] queries) {
        if (arr == null || arr.length == 0 || queries == null || queries.length == 0) {
            return new ArrayList<>();
        }

        // Build prefix sum array
        // prefixSum[i] stores sum from arr[0] to arr[i]
        long[] prefixSum = new long[arr.length];
        prefixSum[0] = arr[0];
        for (int i = 1; i < arr.length; i++) {
            prefixSum[i] = prefixSum[i - 1] + arr[i];
        }

        List<Long> results = new ArrayList<>();
        for (int[] query : queries) {
            int start = query[0];
            int end = query[1];

            if (start == 0) {
                results.add(prefixSum[end]);
            } else {
                results.add(prefixSum[end] - prefixSum[start - 1]);
            }
        }

        return results;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Main solution = new Main(); // Create an instance to call the non-static method

        int N = scanner.nextInt();
        int[] arr = new int[N];
        for (int i = 0; i < N; i++) {
            arr[i] = scanner.nextInt();
        }

        int Q = scanner.nextInt();
        int[][] queries = new int[Q][2];
        for (int i = 0; i < Q; i++) {
            queries[i][0] = scanner.nextInt();
            queries[i][1] = scanner.nextInt();
        }

        List<Long> results = solution.calculateRangeSums(arr, queries);

        for (long sum : results) {
            System.out.println(sum);
        }

        scanner.close();
    }
}","function calculateRangeSums(arr, queries) {
    if (!arr || arr.length === 0 || !queries || queries.length === 0) {
        return [];
    }

    // Build prefix sum array
    // prefixSum[i] stores sum from arr[0] to arr[i]
    const prefixSum = new Array(arr.length);
    prefixSum[0] = arr[0];
    for (let i = 1; i < arr.length; i++) {
        prefixSum[i] = prefixSum[i - 1] + arr[i];
    }

    const results = [];
    for (const query of queries) {
        const start = query[0];
        const end = query[1];

        if (start === 0) {
            results.push(prefixSum[end]);
        } else {
            results.push(prefixSum[end] - prefixSum[start - 1]);
        }
    }

    return results;
}

function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let lines = [];
    rl.on('line', (line) => {
        lines.push(line);
    }).on('close', () => {
        let lineIndex = 0;

        const N = parseInt(lines[lineIndex++]);
        const arr = lines[lineIndex++].split(' ').map(Number);

        const Q = parseInt(lines[lineIndex++]);
        const queries = [];
        for (let i = 0; i < Q; i++) {
            queries.push(lines[lineIndex++].split(' ').map(Number));
        }

        const results = calculateRangeSums(arr, queries);

        for (const sum of results) {
            console.log(sum);
        }
    });
}

main();","#include <iostream>
#include <vector>
#include <numeric> // For std::partial_sum, though manual implementation is fine

// Function to calculate range sums using prefix sums
std::vector<long long> calculateRangeSums(const std::vector<int>& arr, const std::vector<std::pair<int, int>>& queries) {
    if (arr.empty() || queries.empty()) {
        return {};
    }

    // Build prefix sum array
    // prefixSum[i] stores sum from arr[0] to arr[i]
    std::vector<long long> prefixSum(arr.size());
    prefixSum[0] = arr[0];
    for (size_t i = 1; i < arr.size(); ++i) {
        prefixSum[i] = prefixSum[i - 1] + arr[i];
    }

    std::vector<long long> results;
    results.reserve(queries.size()); // Pre-allocate memory for results

    for (const auto& query : queries) {
        int start = query.first;
        int end = query.second;

        if (start == 0) {
            results.push_back(prefixSum[end]);
        } else {
            results.push_back(prefixSum[end] - prefixSum[start - 1]);
        }
    }

    return results;
}

int main() {
    std::ios_base::sync_with_stdio(false); // Optimize C++ standard streams for faster I/O
    std::cin.tie(NULL);

    int N;
    std::cin >> N;

    std::vector<int> arr(N);
    for (int i = 0; i < N; ++i) {
        std::cin >> arr[i];
    }

    int Q;
    std::cin >> Q;

    std::vector<std::pair<int, int>> queries(Q);
    for (int i = 0; i < Q; ++i) {
        std::cin >> queries[i].first >> queries[i].second;
    }

    std::vector<long long> results = calculateRangeSums(arr, queries);

    for (long long sum : results) {
        std::cout << sum << ""\n"";
    }

    return 0;
}",4.2
Yellow-51,Prefix & Suffix Sums,"*   Array Traversal
*   Prefix Sums (implicit calculation)
*   Summation","Given an array `arr` of `n` integers, your task is to find the *first* equilibrium point in the array. An equilibrium point is an index `i` such that the sum of elements strictly to its left (indices `0` to `i-1`) is equal to the sum of elements strictly to its right (indices `i+1` to `n-1`). If no such index exists, return -1.","*   `1 <= n <= 1000`
*   `-100 <= arr[i] <= 100`","**

7
-7 1 5 2 -4 3 0

**","**

3

**","Input: 1
0
Output: 0
Input: 5
1 2 3 4 5
Output: -1
Input: 6
1 2 3 -3 2 1
Output: 2
Input: 3
-1 0 1
Output: 1
Input: 4
2 3 5 10
Output: -1","#include <stdio.h>
#include <stdlib.h>

// Function to find the first equilibrium point
int findEquilibriumPoint(int arr[], int n) {
    if (n == 0) {
        return -1;
    }

    long long totalSum = 0;
    for (int i = 0; i < n; i++) {
        totalSum += arr[i];
    }

    long long leftSum = 0;
    for (int i = 0; i < n; i++) {
        // rightSum = totalSum - leftSum - arr[i]
        // Note: For a single element array, leftSum is 0, rightSum is 0. So index 0 is an equilibrium point.
        if (leftSum == (totalSum - leftSum - arr[i])) {
            return i;
        }
        leftSum += arr[i];
    }

    return -1;
}

int main() {
    int n;
    scanf(""%d"", &n);

    int *arr = (int *)malloc(n * sizeof(int));
    if (arr == NULL) {
        return 1; // Memory allocation failed
    }

    for (int i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]);
    }

    int result = findEquilibriumPoint(arr, n);
    printf(""%d\n"", result);

    free(arr);
    return 0;
}","import sys

def find_equilibrium_point(arr):
    n = len(arr)
    if n == 0:
        return -1

    total_sum = sum(arr)
    left_sum = 0

    for i in range(n):
        # right_sum = total_sum - left_sum - arr[i]
        # Note: For a single element array, left_sum is 0, right_sum is 0. So index 0 is an equilibrium point.
        if left_sum == (total_sum - left_sum - arr[i]):
            return i
        left_sum += arr[i]

    return -1

def main():
    n = int(sys.stdin.readline())
    arr = list(map(int, sys.stdin.readline().split()))

    result = find_equilibrium_point(arr)
    sys.stdout.write(str(result) + '\n')

if __name__ == '__main__':
    main()","import java.util.Scanner;

public class Solution {

    // Function to find the first equilibrium point
    public static int findEquilibriumPoint(int[] arr) {
        int n = arr.length;
        if (n == 0) {
            return -1;
        }

        long totalSum = 0;
        for (int x : arr) {
            totalSum += x;
        }

        long leftSum = 0;
        for (int i = 0; i < n; i++) {
            // rightSum = totalSum - leftSum - arr[i]
            // Note: For a single element array, leftSum is 0, rightSum is 0. So index 0 is an equilibrium point.
            if (leftSum == (totalSum - leftSum - arr[i])) {
                return i;
            }
            leftSum += arr[i];
        }

        return -1;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
        scanner.close();

        int result = findEquilibriumPoint(arr);
        System.out.println(result);
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

// Function to find the first equilibrium point
function findEquilibriumPoint(arr) {
    const n = arr.length;
    if (n === 0) {
        return -1;
    }

    let totalSum = 0;
    for (let i = 0; i < n; i++) {
        totalSum += arr[i];
    }

    let leftSum = 0;
    for (let i = 0; i < n; i++) {
        // rightSum = totalSum - leftSum - arr[i]
        // Note: For a single element array, leftSum is 0, rightSum is 0. So index 0 is an equilibrium point.
        if (leftSum === (totalSum - leftSum - arr[i])) {
            return i;
        }
        leftSum += arr[i];
    }

    return -1;
}

let input = [];
rl.on('line', (line) => {
    input.push(line);
}).on('close', () => {
    const n = parseInt(input[0]);
    const arr = input[1].split(' ').map(Number);

    const result = findEquilibriumPoint(arr);
    console.log(result);
});","#include <iostream>
#include <vector>
#include <numeric>

// Function to find the first equilibrium point
int findEquilibriumPoint(const std::vector<int>& arr) {
    int n = arr.size();
    if (n == 0) {
        return -1;
    }

    long long totalSum = 0;
    for (int x : arr) {
        totalSum += x;
    }

    long long leftSum = 0;
    for (int i = 0; i < n; ++i) {
        // rightSum = totalSum - leftSum - arr[i]
        // Note: For a single element array, leftSum is 0, rightSum is 0. So index 0 is an equilibrium point.
        if (leftSum == (totalSum - leftSum - arr[i])) {
            return i;
        }
        leftSum += arr[i];
    }

    return -1;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    std::vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i];
    }

    int result = findEquilibriumPoint(arr);
    std::cout << result << std::endl;

    return 0;
}",4.4
White-103,LeetCode,"- **2D Arrays (Matrices)**: Understanding how to work with grid-like data structures.
- **In-place Modification**: Modifying data directly in its original memory location without using extra space.
- **Matrix Transposition**: Swapping elements across the main diagonal (e.g., `matrix[i][j]` becomes `matrix[j][i]`).
- **Array Reversal**: Flipping the order of elements within a 1D array or a row of a 2D array.
- **Nested Loops**: Using loops within loops to iterate through all elements of a 2D array.","You are given an `n x n` 2D matrix, which represents an image. Your task is to rotate the image by 90 degrees clockwise.

You must do this **in-place**, meaning you have to modify the input 2D matrix directly. You should not allocate another 2D matrix to perform the rotation. Think of it like rotating a physical photo frame without replacing the photo inside.

For example, if you have a 3x3 matrix:

1 2 3
4 5 6
7 8 9

After rotating it 90 degrees clockwise, it should become:

7 4 1
8 5 2
9 6 3","- `n == matrix.length == matrix[i].length` (The matrix is always square)
- `1 <= n <= 20` (The size of the matrix will be between 1x1 and 20x20)
- `-1000 <= matrix[i][j] <= 1000` (The values inside the matrix are integers)","`matrix = [[1,2,3],[4,5,6],[7,8,9]]`","`[[7,4,1],[8,5,2],[9,6,3]]`","Input: 
3
1 2 3
4 5 6
7 8 9
Output: 
7 4 1
8 5 2
9 6 3,Input: 
4
5 1 9 11
2 4 8 10
13 3 6 7
15 14 12 16
Output: 
15 13 2 5
14 3 4 1
12 6 8 9
16 7 10 11,Input: 
2
1 2
3 4
Output: 
3 1
4 2,Input: 
1
7
Output: 
7","#include <stdio.h>
#include <stdlib.h>

// Function to rotate the matrix in-place
void rotate(int** matrix, int matrixSize, int* matrixColSize) {
    // 1. Transpose the matrix
    for (int i = 0; i < matrixSize; i++) {
        for (int j = i + 1; j < matrixSize; j++) {
            // Swap matrix[i][j] with matrix[j][i]
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }

    // 2. Reverse each row
    for (int i = 0; i < matrixSize; i++) {
        int left = 0;
        int right = matrixSize - 1;
        while (left < right) {
            // Swap matrix[i][left] with matrix[i][right]
            int temp = matrix[i][left];
            matrix[i][left] = matrix[i][right];
            matrix[i][right] = temp;
            left++;
            right--;
        }
    }
}

int main() {
    int n;
    scanf(""%d"", &n);

    // Dynamically allocate matrix
    int** matrix = (int**)malloc(n * sizeof(int*));
    // For LeetCode compatibility, matrixColSize array is usually passed, 
    // but for square matrices all elements are 'n'.
    int* colSizes = (int*)malloc(n * sizeof(int)); 

    for (int i = 0; i < n; i++) {
        matrix[i] = (int*)malloc(n * sizeof(int));
        colSizes[i] = n; // Each row has n columns
        for (int j = 0; j < n; j++) {
            scanf(""%d"", &matrix[i][j]);
        }
    }

    rotate(matrix, n, colSizes); // Pass n as matrixSize and colSizes (though not strictly needed for square)

    // Print the rotated matrix
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            printf(""%d%s"", matrix[i][j], (j == n - 1) ? """" : "" "");
        }
        printf(""\n"");
    }

    // Free dynamically allocated memory
    for (int i = 0; i < n; i++) {
        free(matrix[i]);
    }
    free(matrix);
    free(colSizes);

    return 0;
}","import sys

class Solution:
    def rotate(self, matrix: list[list[int]]) -> None:
        """"""
        Do not return anything, modify matrix in-place instead.
        """"""
        n = len(matrix)

        # 1. Transpose the matrix
        for i in range(n):
            for j in range(i + 1, n):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]

        # 2. Reverse each row
        for i in range(n):
            matrix[i].reverse() # Python's list.reverse() works in-place

def main():
    lines = sys.stdin.readlines()
    n = int(lines[0].strip())
    matrix = []
    for i in range(1, n + 1):
        row = list(map(int, lines[i].strip().split()))
        matrix.append(row)

    sol = Solution()
    sol.rotate(matrix)

    # Print the rotated matrix
    for row in matrix:
        print(*(row)) # Python's print(*list) prints space-separated elements

if __name__ == ""__main__"":
    main()","import java.util.Scanner;

class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;

        // 1. Transpose the matrix
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }

        // 2. Reverse each row
        for (int i = 0; i < n; i++) {
            int left = 0;
            int right = n - 1;
            while (left < right) {
                int temp = matrix[i][left];
                matrix[i][left] = matrix[i][right];
                matrix[i][right] = temp;
                left++;
                right--;
            }
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();

        int[][] matrix = new int[n][n];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = scanner.nextInt();
            }
        }

        Solution sol = new Solution();
        sol.rotate(matrix);

        // Print the rotated matrix
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(matrix[i][j] + (j == n - 1 ? """" : "" ""));
            }
            System.out.println();
        }

        scanner.close();
    }
}","// Function to rotate the matrix in-place
function rotate(matrix) {
    const n = matrix.length;

    // 1. Transpose the matrix
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]]; // ES6 destructuring for swap
        }
    }

    // 2. Reverse each row
    for (let i = 0; i < n; i++) {
        matrix[i].reverse(); // Array.prototype.reverse() works in-place
    }
}

// Handle I/O
// Node.js specific for stdin/stdout
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let n;
let matrix = [];
let lineCount = 0;

rl.on('line', (line) => {
    if (lineCount === 0) {
        n = parseInt(line);
    } else {
        matrix.push(line.split(' ').map(Number));
    }
    lineCount++;

    if (lineCount > n) { // All lines including n have been read
        rotate(matrix);

        // Print the rotated matrix
        for (let i = 0; i < n; i++) {
            console.log(matrix[i].join(' '));
        }
        rl.close();
    }
});","#include <iostream>
#include <vector>
#include <algorithm> // For std::reverse

// Function to rotate the matrix in-place
void rotate(std::vector<std::vector<int>>& matrix) {
    int n = matrix.size();

    // 1. Transpose the matrix
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            std::swap(matrix[i][j], matrix[j][i]);
        }
    }

    // 2. Reverse each row
    for (int i = 0; i < n; i++) {
        std::reverse(matrix[i].begin(), matrix[i].end());
    }
}

int main() {
    int n;
    std::cin >> n;

    std::vector<std::vector<int>> matrix(n, std::vector<int>(n));

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            std::cin >> matrix[i][j];
        }
    }

    rotate(matrix);

    // Print the rotated matrix
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            std::cout << matrix[i][j] << (j == n - 1 ? """" : "" "");
        }
        std::cout << std::endl;
    }

    return 0;
}",4.2
DELETE-103-rotate-image,Deletion,N/A,Deleted folder: 103-rotate-image,N/A,N/A,N/A,N/A,,,,,,N/A
Yellow-52,LeetCode,"*   **2D Arrays (Matrices)**: Understanding how to store and access data in a grid-like structure.
*   **In-place Operations**: Modifying the existing data structure directly without creating a new one, which is important for memory efficiency.
*   **Nested Loops**: Using loops within loops to iterate through all elements of a 2D array.
*   **Swapping Elements**: Exchanging the values of two variables, a fundamental operation in many algorithms.
*   **Algorithmic Thinking**: Breaking down a complex transformation (like rotation) into simpler, manageable steps.","You are given an `n x n` 2D `matrix` representing an image. You need to rotate the image by 90 degrees clockwise.

You must do this in-place, which means you modify the input 2D matrix directly. Do NOT allocate another 2D matrix to perform the rotation.

For example, if you have:

1 2 3
4 5 6
7 8 9

After rotating 90 degrees clockwise, it becomes:

7 4 1
8 5 2
9 6 3","*   `n == matrix.length == matrix[i].length`
*   `1 <= n <= 20`
*   `-1000 <= matrix[i][j] <= 1000`","** `matrix = [[1,2,3],[4,5,6],[7,8,9]]`
**","** `[[7,4,1],[8,5,2],[9,6,3]]`

**","Input: 3
1 2 3
4 5 6
7 8 9
Output: 7 4 1
8 5 2
9 6 3,Input: 4
5 1 9 11
2 4 8 10
13 3 6 7
15 14 12 16
Output: 15 13 2 5
14 3 4 1
12 6 8 9
16 7 10 11,Input: 1
1
Output: 1,Input: 2
1 2
3 4
Output: 3 1
4 2","#include <stdio.h>
#include <stdlib.h>

// Function to rotate the matrix
void rotate(int** matrix, int n) {
    // 1. Transpose the matrix
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }

    // 2. Reverse each row
    for (int i = 0; i < n; i++) {
        int left = 0;
        int right = n - 1;
        while (left < right) {
            int temp = matrix[i][left];
            matrix[i][left] = matrix[i][right];
            matrix[i][right] = temp;
            left++;
            right--;
        }
    }
}

int main() {
    int n;
    // Input format: first line is N, then N lines of N space-separated integers
    // Example:
    // 3
    // 1 2 3
    // 4 5 6
    // 7 8 9
    scanf(""%d"", &n);

    // Allocate memory for the matrix
    int** matrix = (int**)malloc(n * sizeof(int*));
    for (int i = 0; i < n; i++) {
        matrix[i] = (int*)malloc(n * sizeof(int));
        for (int j = 0; j < n; j++) {
            scanf(""%d"", &matrix[i][j]);
        }
    }

    // Rotate the matrix
    rotate(matrix, n);

    // Print the rotated matrix
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            printf(""%d%s"", matrix[i][j], (j == n - 1) ? """" : "" "");
        }
        printf(""\n"");
    }

    // Free allocated memory
    for (int i = 0; i < n; i++) {
        free(matrix[i]);
    }
    free(matrix);

    return 0;
}","class Solution:
    def rotate(self, matrix: list[list[int]]) -> None:
        """"""
        Do not return anything, modify matrix in-place instead.
        """"""
        n = len(matrix)

        # 1. Transpose the matrix
        for i in range(n):
            for j in range(i + 1, n):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]

        # 2. Reverse each row
        for i in range(n):
            matrix[i].reverse() # Python's list.reverse() is convenient

def main():
    # Input format: first line is N, then N lines of N space-separated integers
    # Example:
    # 3
    # 1 2 3
    # 4 5 6
    # 7 8 9
    n = int(input())
    matrix = []
    for _ in range(n):
        matrix.append(list(map(int, input().split())))

    sol = Solution()
    sol.rotate(matrix)

    # Print the rotated matrix
    for row in matrix:
        print(*(row)) # Python's print(*row) will print elements separated by space

if __name__ == ""__main__"":
    main()","import java.util.Scanner;

class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;

        // 1. Transpose the matrix
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }

        // 2. Reverse each row
        for (int i = 0; i < n; i++) {
            int left = 0;
            int right = n - 1;
            while (left < right) {
                int temp = matrix[i][left];
                matrix[i][left] = matrix[i][right];
                matrix[i][right] = temp;
                left++;
                right--;
            }
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // Input format: first line is N, then N lines of N space-separated integers
        // Example:
        // 3
        // 1 2 3
        // 4 5 6
        // 7 8 9
        int n = scanner.nextInt();

        int[][] matrix = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = scanner.nextInt();
            }
        }

        Solution sol = new Solution();
        sol.rotate(matrix);

        // Print the rotated matrix
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(matrix[i][j] + (j == n - 1 ? """" : "" ""));
            }
            System.out.println();
        }

        scanner.close();
    }
}","/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
function rotate(matrix) {
    const n = matrix.length;

    // 1. Transpose the matrix
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]]; // ES6 destructuring for swap
        }
    }

    // 2. Reverse each row
    for (let i = 0; i < n; i++) {
        matrix[i].reverse(); // Array.prototype.reverse() is convenient
    }
}

// Function to handle input and output for testing
function main() {
    // Input format: first line is N, then N lines of N space-separated integers
    // Example:
    // 3
    // 1 2 3
    // 4 5 6
    // 7 8 9
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let n = 0;
    let matrix = [];
    let lineNum = 0;

    rl.on('line', (line) => {
        if (lineNum === 0) {
            n = parseInt(line);
        } else {
            matrix.push(line.split(' ').map(Number));
        }
        lineNum++;

        if (lineNum > n) { // All lines of matrix data read
            rotate(matrix);

            // Print the rotated matrix
            for (let i = 0; i < n; i++) {
                console.log(matrix[i].join(' '));
            }
            rl.close();
        }
    });
}

if (require.main === module) {
    main();
}","#include <iostream>
#include <vector>
#include <algorithm> // For std::swap and std::reverse

// Function to rotate the matrix
void rotate(std::vector<std::vector<int>>& matrix) {
    int n = matrix.size();

    // 1. Transpose the matrix
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            std::swap(matrix[i][j], matrix[j][i]);
        }
    }

    // 2. Reverse each row
    for (int i = 0; i < n; i++) {
        std::reverse(matrix[i].begin(), matrix[i].end());
    }
}

int main() {
    int n;
    // Input format: first line is N, then N lines of N space-separated integers
    // Example:
    // 3
    // 1 2 3
    // 4 5 6
    // 7 8 9
    std::cin >> n;

    std::vector<std::vector<int>> matrix(n, std::vector<int>(n));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            std::cin >> matrix[i][j];
        }
    }

    // Rotate the matrix
    rotate(matrix);

    // Print the rotated matrix
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            std::cout << matrix[i][j] << (j == n - 1 ? """" : "" "");
        }
        std::cout << std::endl;
    }

    return 0;
}",4.2
Yellow-53,Kadane’s Algorithm,"*   Dynamic Programming
*   Array Traversal
*   Optimization",You are given an array of integers. Your task is to find the contiguous subarray (a subarray containing at least one number) which has the largest sum and return its sum.,"*   1 <= `nums.length` <= 10^5
*   -10^4 <= `nums[i]` <= 10^4","nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]",6,"Input: 5
1 2 3 4 5
Output: 15
Input: 4
-1 -2 -3 -4
Output: -1
Input: 6
-2 1 -3 5 -1 2
Output: 6
Input: 1
7
Output: 7","#include <stdio.h>
#include <stdlib.h> // For malloc, free

int max(int a, int b) {
    return (a > b) ? a : b;
}

int maxSubArray(int* nums, int numsSize) {
    if (numsSize == 0) {
        // According to constraints, numsSize will be at least 1.
        // If allowed, returning 0 or handling as error would be appropriate.
        return 0; 
    }

    int max_so_far = nums[0];
    int current_max = nums[0];

    for (int i = 1; i < numsSize; i++) {
        current_max = max(nums[i], current_max + nums[i]);
        max_so_far = max(max_so_far, current_max);
    }

    return max_so_far;
}

int main() {
    int numsSize;
    scanf(""%d"", &numsSize);

    int* nums = (int*)malloc(numsSize * sizeof(int));
    if (nums == NULL) {
        fprintf(stderr, ""Memory allocation failed\n"");
        return 1; 
    }

    for (int i = 0; i < numsSize; i++) {
        scanf(""%d"", &nums[i]);
    }

    int result = maxSubArray(nums, numsSize);
    printf(""%d\n"", result);

    free(nums);
    return 0;
}","def max_sub_array(nums):
    if not nums:
        # According to constraints, nums will have at least 1 element.
        # If allowed, returning 0 or raising a ValueError would be appropriate.
        return 0 

    max_so_far = nums[0]
    current_max = nums[0]

    for i in range(1, len(nums)):
        current_max = max(nums[i], current_max + nums[i])
        max_so_far = max(max_so_far, current_max)

    return max_so_far

if __name__ == ""__main__"":
    nums_size = int(input())
    nums = list(map(int, input().split()))

    result = max_sub_array(nums)
    print(result)","import java.util.Scanner;

public class Solution {

    public int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0) {
            // According to constraints, nums will have at least 1 element.
            // If allowed, returning 0 or throwing an IllegalArgumentException would be appropriate.
            return 0; 
        }

        int maxSoFar = nums[0];
        int currentMax = nums[0];

        for (int i = 1; i < nums.length; i++) {
            currentMax = Math.max(nums[i], currentMax + nums[i]);
            maxSoFar = Math.max(maxSoFar, currentMax);
        }

        return maxSoFar;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int numsSize = scanner.nextInt();
        int[] nums = new int[numsSize];
        for (int i = 0; i < numsSize; i++) {
            nums[i] = scanner.nextInt();
        }
        scanner.close();

        Solution sol = new Solution();
        int result = sol.maxSubArray(nums);
        System.out.println(result);
    }
}","function maxSubArray(nums) {
    if (!nums || nums.length === 0) {
        // According to constraints, nums will have at least 1 element.
        // If allowed, returning 0 or throwing an error would be appropriate.
        return 0; 
    }

    let maxSoFar = nums[0];
    let currentMax = nums[0];

    for (let i = 1; i < nums.length; i++) {
        currentMax = Math.max(nums[i], currentMax + nums[i]);
        maxSoFar = Math.max(maxSoFar, currentMax);
    }

    return maxSoFar;
}

// Handle input/output for competitive programming environment
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let inputLines = [];
    rl.on('line', (line) => {
        inputLines.push(line);
    }).on('close', () => {
        const numsSize = parseInt(inputLines[0], 10);
        const nums = inputLines[1].split(' ').map(Number);

        const result = maxSubArray(nums);
        console.log(result);
    });
}

main();","#include <iostream>
#include <vector>
#include <algorithm> // For std::max

int maxSubArray(const std::vector<int>& nums) {
    if (nums.empty()) {
        // According to constraints, nums will have at least 1 element.
        // If allowed, returning 0 or throwing an exception would be appropriate.
        return 0; 
    }

    int max_so_far = nums[0];
    int current_max = nums[0];

    for (size_t i = 1; i < nums.size(); ++i) {
        current_max = std::max(nums[i], current_max + nums[i]);
        max_so_far = std::max(max_so_far, current_max);
    }

    return max_so_far;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int numsSize;
    std::cin >> numsSize;

    std::vector<int> nums(numsSize);
    for (int i = 0; i < numsSize; ++i) {
        std::cin >> nums[i];
    }

    int result = maxSubArray(nums);
    std::cout << result << std::endl;

    return 0;
}",4.4
Yellow-54,Infix to Postfix Conversion,"*   **Stacks**: LIFO (Last-In, First-Out) data structure.
*   **Operator Precedence**: The rules that define the order in which operations are performed (e.g., multiplication before addition).
*   **Associativity**: The rule for operators with the same precedence (e.g., `a - b - c` is `(a - b) - c`).
*   **Algorithm Design**: Developing a step-by-step procedure to solve a problem.
*   **String Manipulation**: Processing and building strings.","In computer science, expressions can be written in various notations. Two common ones are **Infix** and **Postfix** (also known as Reverse Polish Notation or RPN). Infix notation is what we commonly use in mathematics, where operators are placed *between* their operands (e.g., `A + B`). Postfix notation places operators *after* their operands (e.g., `A B +`).

Converting an infix expression to its postfix equivalent is a fundamental problem that highlights the power of stacks in managing operator precedence and associativity. Your task is to implement a program that takes an infix expression as input and returns its postfix representation.","*   The input `infixExpression` will be a string consisting of single-character operands (uppercase English letters A-Z), and the operators `+`, `-`, `*`, `/`, and parentheses `(` `)`. 
*   The input expression will be valid and well-formed (no missing operands, no unmatched parentheses, etc.).
*   The length of the `infixExpression` will be between 1 and 100 characters.
*   Operators `*` and `/` have higher precedence than `+` and `-`.
*   All operators are left-associative.",A+B*C,"ABC*+


**","Input: (A+B)*C
Output: AB+C*
Input: A*(B+C)/D
Output: ABC+*D/
Input: X-Y/Z+M*N
Output: XYZ/-MN*+
Input: P+Q/(R-S)*T
Output: PQRS-/T*+","#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_STACK_SIZE 101 // Max expression length + 1

typedef struct {
    char items[MAX_STACK_SIZE];
    int top;
} Stack;

void initStack(Stack* s) {
    s->top = -1;
}

bool isEmpty(Stack* s) {
    return s->top == -1;
}

void push(Stack* s, char value) {
    if (s->top == MAX_STACK_SIZE - 1) {
        // Stack overflow, should not happen with valid constraints
        return;
    }
    s->items[++(s->top)] = value;
}

char pop(Stack* s) {
    if (s->top == -1) {
        // Stack underflow, should not happen with valid logic
        return '\0'; // Or handle error appropriately
    }
    return s->items[(s->top)--];
}

char peek(Stack* s) {
    if (s->top == -1) {
        return '\0'; // Or handle error appropriately
    }
    return s->items[s->top];
}

int getPrecedence(char op) {
    switch (op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        default:
            return 0; // For operands, parentheses
    }
}

char* infixToPostfix(const char* infixExpression) {
    Stack operatorStack;
    initStack(&operatorStack);

    int len = strlen(infixExpression);
    char* postfixResult = (char*)malloc(sizeof(char) * (len + 1));
    if (postfixResult == NULL) {
        fprintf(stderr, ""Memory allocation failed\n"");
        exit(EXIT_FAILURE);
    }
    int k = 0; // Index for postfixResult

    for (int i = 0; i < len; i++) {
        char ch = infixExpression[i];

        if ((ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9')) {
            // Operand
            postfixResult[k++] = ch;
        } else if (ch == '(') {
            push(&operatorStack, ch);
        } else if (ch == ')') {
            while (!isEmpty(&operatorStack) && peek(&operatorStack) != '(') {
                postfixResult[k++] = pop(&operatorStack);
            }
            if (!isEmpty(&operatorStack) && peek(&operatorStack) == '(') {
                pop(&operatorStack); // Pop '('
            }
        } else { // Operator
            while (!isEmpty(&operatorStack) && peek(&operatorStack) != '(' && 
                   getPrecedence(peek(&operatorStack)) >= getPrecedence(ch)) {
                postfixResult[k++] = pop(&operatorStack);
            }
            push(&operatorStack, ch);
        }
    }

    // Pop any remaining operators from the stack
    while (!isEmpty(&operatorStack)) {
        postfixResult[k++] = pop(&operatorStack);
    }

    postfixResult[k] = '\0'; // Null-terminate the string
    return postfixResult;
}

int main() {
    char infix[MAX_STACK_SIZE];
    if (scanf(""%s"", infix) != 1) {
        fprintf(stderr, ""Failed to read input\n"");
        return 1;
    }

    char* postfix = infixToPostfix(infix);
    printf(""%s\n"", postfix);

    free(postfix); // Free allocated memory

    return 0;
}","def get_precedence(op):
    if op == '+' or op == '-':
        return 1
    elif op == '*' or op == '/':
        return 2
    else:
        return 0  # For operands, parentheses

def infix_to_postfix(infix_expression):
    postfix_result = []
    operator_stack = []

    for char in infix_expression:
        if 'A' <= char <= 'Z' or 'a' <= char <= 'z' or '0' <= char <= '9':
            # Operand
            postfix_result.append(char)
        elif char == '(':{
            operator_stack.append(char)
        }elif char == ')':
            while operator_stack and operator_stack[-1] != '(':{
                postfix_result.append(operator_stack.pop())
            }if operator_stack and operator_stack[-1] == '(':
                operator_stack.pop()  # Pop '('
        else:  # Operator
            while operator_stack and operator_stack[-1] != '(' and \
                  get_precedence(operator_stack[-1]) >= get_precedence(char):
                postfix_result.append(operator_stack.pop())
            operator_stack.append(char)
    
    # Pop any remaining operators from the stack
    while operator_stack:
        postfix_result.append(operator_stack.pop())

    return """".join(postfix_result)

if __name__ == ""__main__"":
    infix = input()
    postfix = infix_to_postfix(infix)
    print(postfix)","import java.util.Scanner;
import java.util.Stack;

public class InfixToPostfix {

    // Function to get precedence of operators
    private static int getPrecedence(char op) {
        switch (op) {
            case '+':
            case '-':
                return 1;
            case '*':
            case '/':
                return 2;
            default:
                return 0; // For operands, parentheses
        }
    }

    public static String infixToPostfix(String infixExpression) {
        StringBuilder postfixResult = new StringBuilder();
        Stack<Character> operatorStack = new Stack<>();

        for (char ch : infixExpression.toCharArray()) {
            if (Character.isLetterOrDigit(ch)) {
                // Operand
                postfixResult.append(ch);
            } else if (ch == '(') {
                operatorStack.push(ch);
            } else if (ch == ')') {
                while (!operatorStack.isEmpty() && operatorStack.peek() != '(') {
                    postfixResult.append(operatorStack.pop());
                }
                if (!operatorStack.isEmpty() && operatorStack.peek() == '(') {
                    operatorStack.pop(); // Pop '('
                }
            } else { // Operator
                while (!operatorStack.isEmpty() && operatorStack.peek() != '(' && 
                       getPrecedence(operatorStack.peek()) >= getPrecedence(ch)) {
                    postfixResult.append(operatorStack.pop());
                }
                operatorStack.push(ch);
            }
        }

        // Pop any remaining operators from the stack
        while (!operatorStack.isEmpty()) {
            postfixResult.append(operatorStack.pop());
        }

        return postfixResult.toString();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String infix = scanner.nextLine();
        String postfix = infixToPostfix(infix);
        System.out.println(postfix);
        scanner.close();
    }
}","const readline = require('readline');

// Function to get precedence of operators
function getPrecedence(op) {
    switch (op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        default:
            return 0; // For operands, parentheses
    }
}

function infixToPostfix(infixExpression) {
    let postfixResult = [];
    let operatorStack = [];

    for (let i = 0; i < infixExpression.length; i++) {
        let ch = infixExpression[i];

        if (/[a-zA-Z0-9]/.test(ch)) {
            // Operand (letter or digit)
            postfixResult.push(ch);
        } else if (ch === '(') {
            operatorStack.push(ch);
        } else if (ch === ')') {
            while (operatorStack.length > 0 && operatorStack[operatorStack.length - 1] !== '(') {
                postfixResult.push(operatorStack.pop());
            }
            if (operatorStack.length > 0 && operatorStack[operatorStack.length - 1] === '(') {
                operatorStack.pop(); // Pop '('
            }
        } else { // Operator
            while (operatorStack.length > 0 && operatorStack[operatorStack.length - 1] !== '(' && 
                   getPrecedence(operatorStack[operatorStack.length - 1]) >= getPrecedence(ch)) {
                postfixResult.push(operatorStack.pop());
            }
            operatorStack.push(ch);
        }
    }

    // Pop any remaining operators from the stack
    while (operatorStack.length > 0) {
        postfixResult.push(operatorStack.pop());
    }

    return postfixResult.join('');
}

// Main function to handle input/output
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.on('line', (line) => {
    const infix = line.trim();
    const postfix = infixToPostfix(infix);
    console.log(postfix);
    rl.close();
});","#include <iostream>
#include <string>
#include <stack>
#include <map>

// Function to get precedence of operators
int getPrecedence(char op) {
    if (op == '+' || op == '-') {
        return 1;
    } else if (op == '*' || op == '/') {
        return 2;
    } else {
        return 0; // For operands, parentheses
    }
}

std::string infixToPostfix(const std::string& infixExpression) {
    std::string postfixResult = """";
    std::stack<char> operatorStack;

    for (char& ch : infixExpression) {
        if (isalnum(ch)) {
            // Operand (letter or digit)
            postfixResult += ch;
        } else if (ch == '(') {
            operatorStack.push(ch);
        } else if (ch == ')') {
            while (!operatorStack.empty() && operatorStack.top() != '(') {
                postfixResult += operatorStack.top();
                operatorStack.pop();
            }
            if (!operatorStack.empty() && operatorStack.top() == '(') {
                operatorStack.pop(); // Pop '('
            }
        } else { // Operator
            while (!operatorStack.empty() && operatorStack.top() != '(' && 
                   getPrecedence(operatorStack.top()) >= getPrecedence(ch)) {
                postfixResult += operatorStack.top();
                operatorStack.pop();
            }
            operatorStack.push(ch);
        }
    }

    // Pop any remaining operators from the stack
    while (!operatorStack.empty()) {
        postfixResult += operatorStack.top();
        operatorStack.pop();
    }

    return postfixResult;
}

int main() {
    std::string infix;
    std::cin >> infix;

    std::string postfix = infixToPostfix(infix);
    std::cout << postfix << std::endl;

    return 0;
}",4.2
Yellow-55,Prefix & Suffix Sums,"*   Prefix Sums
*   Array Traversal
*   Time Complexity Optimization for repeated queries","Given an array of integers `nums`, your task is to design a system that can efficiently calculate the sum of elements between specified indices `i` and `j` (inclusive), where `i <= j`. You will receive multiple such queries for the same array. This means you should pre-process the array to make each sum query as fast as possible.","*   `1 <= nums.length <= 10^4`
*   `-1000 <= nums[k] <= 1000`
*   `0 <= i <= j < nums.length`
*   `1 <= num_queries <= 10^4`
*   The sum of elements will fit within a 64-bit signed integer (long in Java/C++, long long in C).","6
-2 0 3 -5 2 -1
3
0 2
2 5
0 5

Explanation:
*   The array `nums` is `[-2, 0, 3, -5, 2, -1]`. Its length is 6.
*   There are 3 queries.
*   Query 1: `(0, 2)` -> Sum of `nums[0]` through `nums[2]` is `(-2 + 0 + 3) = 1`
*   Query 2: `(2, 5)` -> Sum of `nums[2]` through `nums[5]` is `(3 + -5 + 2 + -1) = -1`
*   Query 3: `(0, 5)` -> Sum of `nums[0]` through `nums[5]` is `(-2 + 0 + 3 + -5 + 2 + -1) = -3`

####","1
-1
-3","Input: 5
1 2 3 4 5
3
0 0
0 4
2 3
Output: 1
15
7
Input: 1
10
1
0 0
Output: 10
Input: 5
-1 -2 -3 -4 -5
2
0 1
2 4
Output: -3
-12
Input: 6
7 1 5 3 6 4
2
0 5
1 3
Output: 26
9","#include <stdio.h>
#include <stdlib.h>

// Function to precompute prefix sums
void computePrefixSums(int* nums, int numsSize, long long* prefixSums) {
    prefixSums[0] = 0;
    for (int i = 0; i < numsSize; i++) {
        prefixSums[i + 1] = prefixSums[i] + nums[i];
    }
}

// Function to calculate sum of a range
long long sumRange(long long* prefixSums, int i, int j) {
    return prefixSums[j + 1] - prefixSums[i];
}

int main() {
    int numsSize;
    scanf(""%d"", &numsSize);

    int* nums = (int*)malloc(numsSize * sizeof(int));
    if (nums == NULL) {
        return 1; // Error allocating memory
    }

    for (int i = 0; i < numsSize; i++) {
        scanf(""%d"", &nums[i]);
    }

    // Allocate memory for prefix sums array (size numsSize + 1)
    long long* prefixSums = (long long*)malloc((numsSize + 1) * sizeof(long long));
    if (prefixSums == NULL) {
        free(nums);
        return 1; // Error allocating memory
    }

    computePrefixSums(nums, numsSize, prefixSums);

    int numQueries;
    scanf(""%d"", &numQueries);

    for (int q = 0; q < numQueries; q++) {
        int i, j;
        scanf(""%d %d"", &i, &j);
        printf(""%lld\n"", sumRange(prefixSums, i, j));
    }

    free(nums);
    free(prefixSums);

    return 0;
}","class NumArray:
    def __init__(self, nums: list[int]):
        self.prefix_sums = [0] * (len(nums) + 1)
        for i in range(len(nums)):
            self.prefix_sums[i + 1] = self.prefix_sums[i] + nums[i]

    def sumRange(self, i: int, j: int) -> int:
        return self.prefix_sums[j + 1] - self.prefix_sums[i]

def main():
    nums_size = int(input())
    nums = list(map(int, input().split()))

    obj = NumArray(nums)

    num_queries = int(input())
    results = []
    for _ in range(num_queries):
        i, j = map(int, input().split())
        results.append(str(obj.sumRange(i, j)))
    
    print(""\n"".join(results))

if __name__ == ""__main__"":
    main()","import java.util.Scanner;

class NumArray {
    private long[] prefixSums;

    // Constructor to precompute prefix sums
    public NumArray(int[] nums) {
        prefixSums = new long[nums.length + 1];
        prefixSums[0] = 0;
        for (int i = 0; i < nums.length; i++) {
            prefixSums[i + 1] = prefixSums[i] + nums[i];
        }
    }

    // Function to calculate sum of a range
    public long sumRange(int i, int j) {
        return prefixSums[j + 1] - prefixSums[i];
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int numsSize = scanner.nextInt();
        int[] nums = new int[numsSize];
        for (int i = 0; i < numsSize; i++) {
            nums[i] = scanner.nextInt();
        }

        NumArray obj = new NumArray(nums); // Create object, precomputes prefix sums

        int numQueries = scanner.nextInt();
        for (int q = 0; q < numQueries; q++) {
            int i = scanner.nextInt();
            int j = scanner.nextInt();
            System.out.println(obj.sumRange(i, j));
        }

        scanner.close();
    }
}","class NumArray {
    /**
     * @param {number[]} nums
     */
    constructor(nums) {
        this.prefixSums = new Array(nums.length + 1).fill(0);
        for (let i = 0; i < nums.length; i++) {
            this.prefixSums[i + 1] = this.prefixSums[i] + nums[i];
        }
    }

    /**
     * @param {number} i
     * @param {number} j
     * @return {number}
     */
    sumRange(i, j) {
        return this.prefixSums[j + 1] - this.prefixSums[i];
    }
}

function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let lines = [];
    rl.on('line', (line) => {
        lines.push(line);
    }).on('close', () => {
        let lineIdx = 0;

        const numsSize = parseInt(lines[lineIdx++]);
        const nums = lines[lineIdx++].split(' ').map(Number);

        const obj = new NumArray(nums);

        const numQueries = parseInt(lines[lineIdx++]);
        let results = [];
        for (let q = 0; q < numQueries; q++) {
            const [i, j] = lines[lineIdx++].split(' ').map(Number);
            results.push(obj.sumRange(i, j));
        }
        console.log(results.join('\n'));
    });
}

main();","#include <iostream>
#include <vector>

// Class to encapsulate the logic
class NumArray {
private:
    std::vector<long long> prefixSums;

public:
    // Constructor to precompute prefix sums
    NumArray(const std::vector<int>& nums) {
        prefixSums.resize(nums.size() + 1, 0);
        for (int i = 0; i < nums.size(); ++i) {
            prefixSums[i + 1] = prefixSums[i] + nums[i];
        }
    }

    // Function to calculate sum of a range
    long long sumRange(int i, int j) {
        return prefixSums[j + 1] - prefixSums[i];
    }
};

int main() {
    std::ios_base::sync_with_stdio(false); // Optimize C++ standard streams
    std::cin.tie(NULL);

    int numsSize;
    std::cin >> numsSize;

    std::vector<int> nums(numsSize);
    for (int i = 0; i < numsSize; ++i) {
        std::cin >> nums[i];
    }

    NumArray obj(nums); // Create object, precomputes prefix sums

    int numQueries;
    std::cin >> numQueries;

    for (int q = 0; q < numQueries; ++q) {
        int i, j;
        std::cin >> i >> j;
        std::cout << obj.sumRange(i, j) << ""\n"";
    }

    return 0;
}",4.4
Yellow-56,Frequency Count / Anagrams,"*   String Manipulation
*   Frequency Counting
*   Arrays","An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. For example, ""listen"" is an anagram of ""silent"".

Your task is to write a function that determines if two given strings, `s1` and `s2`, are anagrams of each other.","*   `s1` and `s2` consist of lowercase English letters.
*   `1 <= s1.length, s2.length <= 1000`","s1 = ""listen""
s2 = ""silent""","true

**Example 2:**","Input: apple aple
Output: false
Input: aabbcc abcabc
Output: true
Input: anagram nagaram
Output: true
Input: rat car
Output: false
Input: topcoder coderpot
Output: true","#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>

// Function to check if two strings are anagrams
bool areAnagrams(const char* s1, const char* s2) {
    int len1 = strlen(s1);
    int len2 = strlen(s2);

    if (len1 != len2) {
        return false;
    }

    int freq[26] = {0}; // Frequency array for lowercase English letters

    // Increment counts for characters in s1
    for (int i = 0; i < len1; i++) {
        freq[s1[i] - 'a']++;
    }

    // Decrement counts for characters in s2
    for (int i = 0; i < len2; i++) {
        freq[s2[i] - 'a']--;
    }

    // Check if all counts in the frequency array are zero
    for (int i = 0; i < 26; i++) {
        if (freq[i] != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    char s1_buffer[1001]; // Max length 1000 + null terminator
    char s2_buffer[1001];

    // Read input strings
    if (scanf(""%s %s"", s1_buffer, s2_buffer) != 2) {
        fprintf(stderr, ""Error reading input.\n"");
        return 1;
    }

    // Call the core logic function
    if (areAnagrams(s1_buffer, s2_buffer)) {
        printf(""true\n"");
    } else {
        printf(""false\n"");
    }

    return 0;
}","import sys

def are_anagrams(s1: str, s2: str) -> bool:
    if len(s1) != len(s2):
        return False

    freq = [0] * 26  # Frequency list for lowercase English letters

    # Increment counts for characters in s1
    for char_code in map(ord, s1):
        freq[char_code - ord('a')] += 1

    # Decrement counts for characters in s2
    for char_code in map(ord, s2):
        freq[char_code - ord('a')] -= 1

    # Check if all counts in the frequency list are zero
    for count in freq:
        if count != 0:
            return False

    return True

if __name__ == ""__main__"":
    # Read input strings from stdin
    # Assuming input will be two space-separated strings on one line
    try:
        s1, s2 = sys.stdin.readline().strip().split()
    except ValueError:
        print(""Error: Please provide two space-separated strings."", file=sys.stderr)
        sys.exit(1)

    # Call the core logic function
    result = are_anagrams(s1, s2)
    print(str(result).lower()) # Print ""true"" or ""false"" in lowercase","import java.util.Scanner;

public class AnagramChecker {

    // Function to check if two strings are anagrams
    public static boolean areAnagrams(String s1, String s2) {
        if (s1.length() != s2.length()) {
            return false;
        }

        int[] freq = new int[26]; // Frequency array for lowercase English letters

        // Increment counts for characters in s1
        for (char c : s1.toCharArray()) {
            freq[c - 'a']++;
        }

        // Decrement counts for characters in s2
        for (char c : s2.toCharArray()) {
            freq[c - 'a']--;
        }

        // Check if all counts in the frequency array are zero
        for (int count : freq) {
            if (count != 0) {
                return false;
            }
        }

        return true;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read input strings
        String s1 = scanner.next();
        String s2 = scanner.next();

        // Call the core logic function
        if (areAnagrams(s1, s2)) {
            System.out.println(""true"");
        } else {
            System.out.println(""false"");
        }

        scanner.close();
    }
}","function areAnagrams(s1, s2) {
    if (s1.length !== s2.length) {
        return false;
    }

    const freq = new Array(26).fill(0); // Frequency array for lowercase English letters

    // Increment counts for characters in s1
    for (let i = 0; i < s1.length; i++) {
        freq[s1.charCodeAt(i) - 'a'.charCodeAt(0)]++;
    }

    // Decrement counts for characters in s2
    for (let i = 0; i < s2.length; i++) {
        freq[s2.charCodeAt(i) - 'a'.charCodeAt(0)]--;
    }

    // Check if all counts in the frequency array are zero
    for (let i = 0; i < freq.length; i++) {
        if (freq[i] !== 0) {
            return false;
        }
    }

    return true;
}

// Function to handle input and output for the problem
function main() {
    // Read input from stdin
    // Assuming input is two space-separated strings on a single line
    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim();
    const [s1, s2] = input.split(' ');

    // Call the core logic function
    const result = areAnagrams(s1, s2);
    console.log(result.toString()); // Output ""true"" or ""false""
}

// Ensure main is called when the script runs
main();","#include <iostream>
#include <string>
#include <vector>

// Function to check if two strings are anagrams
bool areAnagrams(const std::string& s1, const std::string& s2) {
    if (s1.length() != s2.length()) {
        return false;
    }

    std::vector<int> freq(26, 0); // Frequency vector for lowercase English letters

    // Increment counts for characters in s1
    for (char c : s1) {
        freq[c - 'a']++;
    }

    // Decrement counts for characters in s2
    for (char c : s2) {
        freq[c - 'a']--;
    }

    // Check if all counts in the frequency vector are zero
    for (int count : freq) {
        if (count != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    std::string s1, s2;

    // Read input strings
    std::cin >> s1 >> s2;

    // Call the core logic function
    if (areAnagrams(s1, s2)) {
        std::cout << ""true"" << std::endl;
    } else {
        std::cout << ""false"" << std::endl;
    }

    return 0;
}",3.8
Yellow-57,Frequency Count / Anagrams,"*   Frequency Counting
*   Arrays (as frequency counters)
*   String Manipulation
*   Basic Conditional Logic","An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. For example, ""listen"" is an anagram of ""silent"".

Your task is to implement a function that determines whether two given strings are anagrams of each other. For this problem, we will assume the input strings contain only lowercase English letters and the comparison should be case-sensitive.","*   The input strings `s1` and `s2` will consist only of lowercase English letters ('a'-'z').
*   The length of each string will be between 0 and 1000 characters, inclusive.","**
s1 = ""listen""
s2 = ""silent""

**","**
true

**","Input: race
Output: true
Input: topcoder
Output: false
Input: apple
Output: false
Input: mom
Output: true
Input: 
Output: true","#include <stdio.h>
#include <string.h>
#include <stdbool.h>

// Function to check if two strings are anagrams
bool areAnagrams(const char* s1, const char* s2) {
    int len1 = strlen(s1);
    int len2 = strlen(s2);

    // If lengths are different, they cannot be anagrams
    if (len1 != len2) {
        return false;
    }

    // Frequency array for lowercase English letters
    // 'a' through 'z' (26 characters)
    int freq[26] = {0};

    // Populate frequencies for s1
    for (int i = 0; i < len1; i++) {
        freq[s1[i] - 'a']++;
    }

    // Decrement frequencies for s2
    for (int i = 0; i < len2; i++) {
        freq[s2[i] - 'a']--;
    }

    // Check if all frequencies are zero
    for (int i = 0; i < 26; i++) {
        if (freq[i] != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    char s1[1001]; // Max length 1000 + null terminator
    char s2[1001];

    // Read the first string
    // fgets reads the newline character if present, need to remove it
    if (fgets(s1, sizeof(s1), stdin) != NULL) {
        s1[strcspn(s1, ""\n"")] = 0; // Remove newline
    } else {
        return 1; // Error reading input
    }

    // Read the second string
    if (fgets(s2, sizeof(s2), stdin) != NULL) {
        s2[strcspn(s2, ""\n"")] = 0; // Remove newline
    } else {
        return 1; // Error reading input
    }

    if (areAnagrams(s1, s2)) {
        printf(""true\n"");
    } else {
        printf(""false\n"");
    }

    return 0;
}","def are_anagrams(s1: str, s2: str) -> bool:
    """"""
    Checks if two strings are anagrams of each other.
    Assumes strings contain only lowercase English letters.
    """"""
    # If lengths are different, they cannot be anagrams
    if len(s1) != len(s2):
        return False

    # Frequency array (list) for lowercase English letters
    # 'a' through 'z' (26 characters)
    freq = [0] * 26

    # Populate frequencies for s1
    for char_code in map(ord, s1):
        freq[char_code - ord('a')] += 1

    # Decrement frequencies for s2
    for char_code in map(ord, s2):
        freq[char_code - ord('a')] -= 1

    # Check if all frequencies are zero
    for count in freq:
        if count != 0:
            return False

    return True

if __name__ == ""__main__"":
    # Read the first string
    s1 = input()

    # Read the second string
    s2 = input()

    if are_anagrams(s1, s2):
        print(""true"")
    else:
        print(""false"")","import java.util.Scanner;

public class AnagramChecker {

    // Function to check if two strings are anagrams
    public static boolean areAnagrams(String s1, String s2) {
        // If lengths are different, they cannot be anagrams
        if (s1.length() != s2.length()) {
            return false;
        }

        // Frequency array for lowercase English letters
        // 'a' through 'z' (26 characters)
        int[] freq = new int[26];
        // Java initializes int arrays to 0 by default, so no explicit fill needed

        // Populate frequencies for s1
        for (char c : s1.toCharArray()) {
            freq[c - 'a']++;
        }

        // Decrement frequencies for s2
        for (char c : s2.toCharArray()) {
            freq[c - 'a']--;
        }

        // Check if all frequencies are zero
        for (int count : freq) {
            if (count != 0) {
                return false;
            }
        }

        return true;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the first string
        String s1 = scanner.nextLine();

        // Read the second string
        String s2 = scanner.nextLine();

        if (areAnagrams(s1, s2)) {
            System.out.println(""true"");
        } else {
            System.out.println(""false"");
        }

        scanner.close();
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let lines = [];
rl.on('line', (line) => {
    lines.push(line);
}).on('close', () => {
    const s1 = lines[0];
    const s2 = lines[1];

    if (areAnagrams(s1, s2)) {
        console.log(""true"");
    } else {
        console.log(""false"");
    }
});

// Function to check if two strings are anagrams
function areAnagrams(s1, s2) {
    // If lengths are different, they cannot be anagrams
    if (s1.length !== s2.length) {
        return false;
    }

    // Frequency array for lowercase English letters
    // 'a' through 'z' (26 characters)
    const freq = new Array(26).fill(0);

    // Populate frequencies for s1
    for (let i = 0; i < s1.length; i++) {
        freq[s1.charCodeAt(i) - 'a'.charCodeAt(0)]++;
    }

    // Decrement frequencies for s2
    for (let i = 0; i < s2.length; i++) {
        freq[s2.charCodeAt(i) - 'a'.charCodeAt(0)]--;
    }

    // Check if all frequencies are zero
    for (let i = 0; i < 26; i++) {
        if (freq[i] !== 0) {
            return false;
        }
    }

    return true;
}","#include <iostream>
#include <string>
#include <vector>

// Function to check if two strings are anagrams
bool areAnagrams(const std::string& s1, const std::string& s2) {
    // If lengths are different, they cannot be anagrams
    if (s1.length() != s2.length()) {
        return false;
    }

    // Frequency array for lowercase English letters
    // 'a' through 'z' (26 characters)
    std::vector<int> freq(26, 0);

    // Populate frequencies for s1
    for (char c : s1) {
        freq[c - 'a']++;
    }

    // Decrement frequencies for s2
    for (char c : s2) {
        freq[c - 'a']--;
    }

    // Check if all frequencies are zero
    for (int count : freq) {
        if (count != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    std::string s1, s2;

    // Read the first string
    std::getline(std::cin, s1);

    // Read the second string
    std::getline(std::cin, s2);

    if (areAnagrams(s1, s2)) {
        std::cout << ""true"" << std::endl;
    } else {
        std::cout << ""false"" << std::endl;
    }

    return 0;
}",4.2
White-103,Basic String Manipulation,"- Basic string input/output
- String iteration
- Character access in strings
- Building a new string","Write a program that takes a single word or sentence as input and prints its characters in reverse order. For example, if the input is ""hello"", the output should be ""olleh"".","- The input string will consist of printable ASCII characters.
- The length of the string will be between 1 and 1000 characters.",`world`,`dlrow`,"Input: programming
Output: gnimmargorp
Input: a
Output: a
Input: level
Output: level
Input: 12345
Output: 54321
Input: hello world
Output: dlrow olleh","#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// Function to reverse a string
char* reverseString(const char* s) {
    int length = strlen(s);
    char* reversed_s = (char*)malloc(sizeof(char) * (length + 1)); // +1 for null terminator
    if (reversed_s == NULL) {
        // Handle allocation error
        return NULL;
    }

    for (int i = 0; i < length; i++) {
        reversed_s[i] = s[length - 1 - i];
    }
    reversed_s[length] = '\0'; // Null-terminate the new string

    return reversed_s;
}

int main() {
    char input_buffer[1002]; // Max 1000 chars + newline + null terminator
    
    // Read input string, including spaces
    if (fgets(input_buffer, sizeof(input_buffer), stdin) != NULL) {
        // Remove trailing newline character, if present
        input_buffer[strcspn(input_buffer, ""\n"")] = 0;

        char* reversed = reverseString(input_buffer);
        if (reversed != NULL) {
            printf(""%s\n"", reversed);
            free(reversed); // Free the dynamically allocated memory
        }
    }

    return 0;
}","def reverse_string(s: str) -> str:
    reversed_chars = []
    for i in range(len(s) - 1, -1, -1):
        reversed_chars.append(s[i])
    return """".join(reversed_chars)

if __name__ == ""__main__"":
    input_s = input() # Read a line from stdin
    result = reverse_string(input_s)
    print(result)","import java.util.Scanner;

public class Main {

    // Function to reverse a string
    public static String reverseString(String s) {
        StringBuilder sb = new StringBuilder();
        for (int i = s.length() - 1; i >= 0; i--) {
            sb.append(s.charAt(i));
        }
        return sb.toString();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String inputString = scanner.nextLine(); // Read entire line
        
        String reversed = reverseString(inputString);
        System.out.println(reversed);
        
        scanner.close();
    }
}","function reverseString(s) {
    let reversed_s = """";
    for (let i = s.length - 1; i >= 0; i--) {
        reversed_s += s[i];
    }
    return reversed_s;
}

// Node.js specific for reading input
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.on('line', (input) => {
    const result = reverseString(input);
    console.log(result);
    rl.close();
});","#include <iostream>
#include <string>

// Function to reverse a string
std::string reverseString(const std::string& s) {
    std::string reversed_s = """";
    for (int i = s.length() - 1; i >= 0; --i) {
        reversed_s += s[i];
    }
    return reversed_s;
}

int main() {
    std::string input_s;
    std::getline(std::cin, input_s); // Read entire line

    std::string reversed = reverseString(input_s);
    std::cout << reversed << std::endl;

    return 0;
}",4.4
Yellow-58,Intro to Backtracking,"*   **Backtracking**: A general algorithm for finding all (or some) solutions to computational problems, that incrementally builds candidates to the solutions, and abandons a candidate (""backtracks"") as soon as it determines that the candidate cannot possibly be completed to a valid solution.
*   **Recursion**: A method where the solution to a problem depends on solutions to smaller instances of the same problem.
*   **Decision Tree**: Visualizing the choices made at each step of the algorithm as a tree structure, where each node represents a decision point (e.g., include or exclude an element).
*   **Time and Space Complexity Analysis**: Understanding how the resources consumed by an algorithm scale with input size.","Given an array of distinct integers `nums`, return all possible subsets (the power set). The solution set must not contain duplicate subsets. The order of the subsets or the elements within a subset does not matter.","*   `1 <= nums.length <= 10`
*   `-10 <= nums[i] <= 10`
*   All the integers in `nums` are unique.","`nums = [1, 2, 3]`","1
2
1 2
3
1 3
2 3
1 2 3

(Note: The empty line represents the empty set. The order of subsets in the output may vary.)","Input: 1
5
Output:

5
Input: 2
0 1
Output:

0
1
0 1
Input: 4
7 8 9 10
Output:

7
8
7 8
9
7 9
8 9
7 8 9
10
7 10
8 10
7 8 10
9 10
7 9 10
8 9 10
7 8 9 10
Input: 3
-1 0 1
Output:

-1
0
-1 0
1
-1 1
0 1
-1 0 1","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Structure to hold a single subset
typedef struct {
    int* elements;
    int size;
} Subset;

// Global list of all subsets found
Subset* allSubsets = NULL;
int allSubsetsCount = 0;
int allSubsetsCapacity = 0;

// Helper function to add a subset to the global list
void addSubset(int* current_subset, int current_size) {
    if (allSubsetsCount >= allSubsetsCapacity) {
        allSubsetsCapacity = allSubsetsCapacity == 0 ? 1 : allSubsetsCapacity * 2;
        allSubsets = (Subset*)realloc(allSubsets, allSubsetsCapacity * sizeof(Subset));
        if (allSubsets == NULL) {
            perror(""realloc failed"");
            exit(EXIT_FAILURE);
        }
    }
    Subset newSubset;
    newSubset.elements = (int*)malloc(current_size * sizeof(int));
    if (newSubset.elements == NULL) {
        perror(""malloc failed"");
        exit(EXIT_FAILURE);
    }
    memcpy(newSubset.elements, current_subset, current_size * sizeof(int));
    newSubset.size = current_size;
    allSubsets[allSubsetsCount++] = newSubset;
}

// The backtracking logic
void backtrack(int* nums, int numsSize, int index, int* current_subset, int current_size) {
    // Add the current_subset to the result list (base case for each path)
    addSubset(current_subset, current_size);

    for (int i = index; i < numsSize; i++) {
        // Include nums[i]
        current_subset[current_size] = nums[i];
        current_size++;

        // Recurse with the next index
        backtrack(nums, numsSize, i + 1, current_subset, current_size);

        // Exclude nums[i] (backtrack)
        current_size--; // Effectively remove the last element
    }
}

// Main function to find all subsets
Subset* findSubsets(int* nums, int numsSize, int* returnSize) {
    int* current_subset = (int*)malloc(numsSize * sizeof(int)); // Max possible subset size is numsSize
    if (current_subset == NULL) {
        perror(""malloc failed"");
        exit(EXIT_FAILURE);
    }

    // Reset global variables for findSubsets to be callable multiple times (if needed)
    if (allSubsets != NULL) {
        for (int i = 0; i < allSubsetsCount; i++) {
            free(allSubsets[i].elements);
        }
        free(allSubsets);
    }
    allSubsets = NULL;
    allSubsetsCount = 0;
    allSubsetsCapacity = 0;

    backtrack(nums, numsSize, 0, current_subset, 0);

    free(current_subset);

    *returnSize = allSubsetsCount;
    return allSubsets;
}


// --- Main function for I/O ---
int main() {
    int n;
    scanf(""%d"", &n);

    int* nums = (int*)malloc(n * sizeof(int));
    if (nums == NULL) {
        perror(""malloc failed"");
        return EXIT_FAILURE;
    }

    for (int i = 0; i < n; i++) {
        scanf(""%d"", &nums[i]);
    }

    int resultSize;
    Subset* resultSubsets = findSubsets(nums, n, &resultSize);

    // Print the subsets
    for (int i = 0; i < resultSize; i++) {
        for (int j = 0; j < resultSubsets[i].size; j++) {
            printf(""%d%s"", resultSubsets[i].elements[j], (j == resultSubsets[i].size - 1) ? """" : "" "");
        }
        printf(""\n"");
        free(resultSubsets[i].elements); // Free individual subset elements
    }
    free(resultSubsets); // Free the array of Subsets
    free(nums);

    return 0;
}","class Solution:
    def findSubsets(self, nums: list[int]) -> list[list[int]]:
        result = []
        current_subset = []

        # Optional: Sort nums to ensure consistent output order, though not strictly required.
        # nums.sort()

        def backtrack(index):
            # Add a copy of the current_subset to the result list (base case for each path)
            result.append(list(current_subset))

            for i in range(index, len(nums)):
                # Include nums[i]
                current_subset.append(nums[i])

                # Recurse with the next index
                backtrack(i + 1)

                # Exclude nums[i] (backtrack)
                current_subset.pop()

        backtrack(0)
        return result

# --- Main function for I/O ---
if __name__ == ""__main__"":
    n = int(input())
    nums = list(map(int, input().split()))

    sol = Solution()
    result = sol.findSubsets(nums)

    # Print the subsets
    for subset in result:
        print(*subset) # Uses * to unpack the list and print elements space-separated, prints empty line for empty list","import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;

class Solution {

    // The backtracking logic
    private void backtrack(int[] nums, int index, List<Integer> currentSubset, List<List<Integer>> result) {
        // Add a copy of the currentSubset to the result list (base case for each path)
        result.add(new ArrayList<>(currentSubset));

        for (int i = index; i < nums.length; i++) {
            // Include nums[i]
            currentSubset.add(nums[i]);

            // Recurse with the next index
            backtrack(nums, i + 1, currentSubset, result);

            // Exclude nums[i] (backtrack)
            currentSubset.remove(currentSubset.size() - 1);
        }
    }

    // Main function to find all subsets
    public List<List<Integer>> findSubsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();

        // Optional: Sort nums to ensure consistent output order, though not strictly required.
        // Arrays.sort(nums);

        backtrack(nums, 0, currentSubset, result);
        return result;
    }
}

// --- Main class for I/O ---
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }

        Solution sol = new Solution();
        List<List<Integer>> result = sol.findSubsets(nums);

        // Print the subsets
        for (List<Integer> subset : result) {
            for (int i = 0; i < subset.size(); i++) {
                System.out.print(subset.get(i) + (i == subset.size() - 1 ? """" : "" ""));
            }
            System.out.println();
        }

        scanner.close();
    }
}","class Solution {
    findSubsets(nums) {
        const result = [];
        const currentSubset = [];

        // Optional: Sort nums to ensure consistent output order, though not strictly required.
        // nums.sort((a, b) => a - b);

        const backtrack = (index) => {
            // Add a copy of the currentSubset to the result list
            result.push([...currentSubset]);

            for (let i = index; i < nums.length; i++) {
                // Include nums[i]
                currentSubset.push(nums[i]);

                // Recurse with the next index
                backtrack(i + 1);

                // Exclude nums[i] (backtrack)
                currentSubset.pop();
            }
        };

        backtrack(0);
        return result;
    }
}

// --- Main function for I/O ---
const main = () => {
    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\n');
    let lineIndex = 0;

    const n = parseInt(input[lineIndex++], 10);
    const nums = input[lineIndex++].split(' ').map(Number);

    const sol = new Solution();
    const result = sol.findSubsets(nums);

    // Print the subsets
    for (const subset of result) {
        console.log(subset.join(' ')); // Prints empty string for empty array, resulting in an empty line
    }
};

main();","#include <iostream>
#include <vector>
#include <algorithm> // For std::sort (optional)

// The backtracking logic
void backtrack(const std::vector<int>& nums, int index, std::vector<int>& current_subset, std::vector<std::vector<int>>& result) {
    // Add the current_subset to the result list (base case for each path)
    result.push_back(current_subset);

    for (int i = index; i < nums.size(); ++i) {
        // Include nums[i]
        current_subset.push_back(nums[i]);

        // Recurse with the next index
        backtrack(nums, i + 1, current_subset, result);

        // Exclude nums[i] (backtrack)
        current_subset.pop_back();
    }
}

// Main function to find all subsets
std::vector<std::vector<int>> findSubsets(std::vector<int>& nums) {
    std::vector<std::vector<int>> result;
    std::vector<int> current_subset;

    // Optional: Sort nums to ensure consistent output order, though not strictly required.
    // std::sort(nums.begin(), nums.end());

    backtrack(nums, 0, current_subset, result);
    return result;
}

// --- Main function for I/O ---
int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    std::vector<int> nums(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> nums[i];
    }

    std::vector<std::vector<int>> result = findSubsets(nums);

    // Print the subsets
    for (const auto& subset : result) {
        for (size_t i = 0; i < subset.size(); ++i) {
            std::cout << subset[i] << (i == subset.size() - 1 ? """" : "" "");
        }
        std::cout << std::endl;
    }

    return 0;
}",4
Yellow-59,Prefix & Suffix Sums,"*   Prefix Sums
*   Array Manipulation
*   Time Complexity Optimization
*   Basic I/O Operations","Given an array of integers `nums` and a list of `queries`, your task is to efficiently calculate the sum of elements within specified ranges for each query. Each query consists of two indices, `L` and `R`, representing a 0-indexed range `[L, R]` (inclusive). For each query, you must return the sum of `nums[L]` through `nums[R]` inclusive.","*   `1 <= N <= 10^5` (where `N` is the length of `nums`)
*   `-1000 <= nums[i] <= 1000`
*   `1 <= Q <= 10^5` (where `Q` is the number of queries)
*   `0 <= L <= R < N` for all queries
*   The sum of any range will fit within a standard 32-bit signed integer.","**

5
1 2 3 4 5
2
0 2
2 4


**Explanation:**

`nums = [1, 2, 3, 4, 5]`
`queries = [[0, 2], [2, 4]]`

*   For query `[0, 2]`: `nums[0] + nums[1] + nums[2] = 1 + 2 + 3 = 6`
*   For query `[2, 4]`: `nums[2] + nums[3] + nums[4] = 3 + 4 + 5 = 12`

**","**

6
12","Input: 1
10
1
0 0
Output: 10
Input: 4
0 0 0 0
3
0 0
1 2
0 3
Output: 0
0
0
Input: 5
-1 2 -3 4 -5
3
0 1
1 3
0 4
Output: 1
3
-3
Input: 5
7 1 8 2 9
1
0 4
Output: 27
Input: 6
1 2 3 4 5 6
4
0 2
1 3
2 4
3 5
Output: 6
9
12
15","#include <stdio.h>
#include <stdlib.h>

// Function to calculate range sums using prefix sums
// nums: pointer to the input array
// numsSize: size of the input array
// queries: 2D array of queries, where each query is {L, R}
// queriesSize: number of queries
// returnSize: pointer to an int to store the size of the returned array
// Returns a dynamically allocated array of integers containing the sum for each query
int* solve(int* nums, int numsSize, int** queries, int queriesSize, int* returnSize) {
    if (numsSize == 0) {
        *returnSize = 0;
        return NULL;
    }

    // Allocate memory for prefix sum array (size numsSize + 1)
    int* prefixSums = (int*)calloc(numsSize + 1, sizeof(int));
    if (prefixSums == NULL) {
        // Handle allocation failure
        *returnSize = 0;
        return NULL;
    }

    // Build prefix sum array
    // prefixSums[i] stores the sum of nums[0...i-1]
    for (int i = 0; i < numsSize; i++) {
        prefixSums[i+1] = prefixSums[i] + nums[i];
    }

    // Allocate memory for results array
    int* results = (int*)malloc(queriesSize * sizeof(int));
    if (results == NULL) {
        // Handle allocation failure
        free(prefixSums);
        *returnSize = 0;
        return NULL;
    }

    // Process each query
    for (int i = 0; i < queriesSize; i++) {
        int L = queries[i][0];
        int R = queries[i][1];
        // Sum of nums[L...R] is prefixSums[R+1] - prefixSums[L]
        results[i] = prefixSums[R+1] - prefixSums[L];
    }

    // Clean up allocated memory for prefixSums
    free(prefixSums);
    *returnSize = queriesSize;
    return results;
}

int main() {
    int N;
    scanf(""%d"", &N);

    int* nums = (int*)malloc(N * sizeof(int));
    if (nums == NULL) return 1; // Allocation failed
    for (int i = 0; i < N; i++) {
        scanf(""%d"", &nums[i]);
    }

    int Q;
    scanf(""%d"", &Q);

    int** queries = (int**)malloc(Q * sizeof(int*));
    if (queries == NULL) {
        free(nums);
        return 1; // Allocation failed
    }
    for (int i = 0; i < Q; i++) {
        queries[i] = (int*)malloc(2 * sizeof(int)); // Each query has L and R
        if (queries[i] == NULL) {
            // Free previously allocated queries and nums
            for (int j = 0; j < i; j++) {
                free(queries[j]);
            }
            free(queries);
            free(nums);
            return 1; // Allocation failed
        }
        scanf(""%d %d"", &queries[i][0], &queries[i][1]);
    }

    int returnSize;
    int* results = solve(nums, N, queries, Q, &returnSize);

    for (int i = 0; i < returnSize; i++) {
        printf(""%d\n"", results[i]);
    }

    // Free all dynamically allocated memory
    free(nums);
    for (int i = 0; i < Q; i++) {
        free(queries[i]);
    }
    free(queries);
    free(results);

    return 0;
}","import sys

def solve(nums, queries):
    if not nums:
        return []

    # Build prefix sum array
    # prefix_sums[i] stores the sum of nums[0...i-1]
    prefix_sums = [0] * (len(nums) + 1)
    for i in range(len(nums)):
        prefix_sums[i+1] = prefix_sums[i] + nums[i]

    results = []
    # Process each query
    for L, R in queries:
        # Sum of nums[L...R] is prefix_sums[R+1] - prefix_sums[L]
        results.append(prefix_sums[R+1] - prefix_sums[L])

    return results

if __name__ == '__main__':
    N = int(sys.stdin.readline())
    nums = list(map(int, sys.stdin.readline().split()))

    Q = int(sys.stdin.readline())
    queries = []
    for _ in range(Q):
        L, R = map(int, sys.stdin.readline().split())
        queries.append([L, R])

    results = solve(nums, queries)

    for result in results:
        sys.stdout.write(str(result) + ""\n"")","import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

class Solution {
    public List<Integer> solve(int[] nums, int[][] queries) {
        List<Integer> results = new ArrayList<>();
        if (nums == null || nums.length == 0) {
            return results;
        }

        // Build prefix sum array
        // prefixSums[i] stores the sum of nums[0...i-1]
        int[] prefixSums = new int[nums.length + 1];
        prefixSums[0] = 0;
        for (int i = 0; i < nums.length; i++) {
            prefixSums[i+1] = prefixSums[i] + nums[i];
        }

        // Process each query
        for (int[] query : queries) {
            int L = query[0];
            int R = query[1];
            // Sum of nums[L...R] is prefixSums[R+1] - prefixSums[L]
            results.add(prefixSums[R+1] - prefixSums[L]);
        }

        return results;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int N = scanner.nextInt();
        int[] nums = new int[N];
        for (int i = 0; i < N; i++) {
            nums[i] = scanner.nextInt();
        }

        int Q = scanner.nextInt();
        int[][] queries = new int[Q][2];
        for (int i = 0; i < Q; i++) {
            queries[i][0] = scanner.nextInt();
            queries[i][1] = scanner.nextInt();
        }

        Solution sol = new Solution();
        List<Integer> results = sol.solve(nums, queries);

        for (int result : results) {
            System.out.println(result);
        }

        scanner.close();
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let inputLines = [];
rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    let lineIdx = 0;

    const N = parseInt(inputLines[lineIdx++]);
    const nums = inputLines[lineIdx++].split(' ').map(Number);

    const Q = parseInt(inputLines[lineIdx++]);
    const queries = [];
    for (let i = 0; i < Q; i++) {
        queries.push(inputLines[lineIdx++].split(' ').map(Number));
    }

    const results = solve(nums, queries);

    results.forEach(result => {
        console.log(result);
    });
});


function solve(nums, queries) {
    if (nums.length === 0) {
        return [];
    }

    // Build prefix sum array
    // prefixSums[i] stores the sum of nums[0...i-1]
    const prefixSums = new Array(nums.length + 1).fill(0);
    for (let i = 0; i < nums.length; i++) {
        prefixSums[i+1] = prefixSums[i] + nums[i];
    }

    const results = [];
    // Process each query
    for (const query of queries) {
        const L = query[0];
        const R = query[1];
        // Sum of nums[L...R] is prefixSums[R+1] - prefixSums[L]
        results.push(prefixSums[R+1] - prefixSums[L]);
    }

    return results;
}","#include <iostream>
#include <vector>
#include <numeric> // Optional, but good to know

std::vector<int> solve(const std::vector<int>& nums, const std::vector<std::vector<int>>& queries) {
    if (nums.empty()) {
        return {};
    }

    // Build prefix sum array
    // prefixSums[i] stores the sum of nums[0...i-1]
    std::vector<int> prefixSums(nums.size() + 1, 0);
    for (int i = 0; i < nums.size(); ++i) {
        prefixSums[i+1] = prefixSums[i] + nums[i];
    }

    std::vector<int> results;
    results.reserve(queries.size()); // Pre-allocate memory for efficiency

    // Process each query
    for (const auto& query : queries) {
        int L = query[0];
        int R = query[1];
        // Sum of nums[L...R] is prefixSums[R+1] - prefixSums[L]
        results.push_back(prefixSums[R+1] - prefixSums[L]);
    }

    return results;
}

int main() {
    std::ios_base::sync_with_stdio(false); // Optimize C++ standard streams
    std::cin.tie(NULL);                   // Untie cin from cout

    int N;
    std::cin >> N;

    std::vector<int> nums(N);
    for (int i = 0; i < N; ++i) {
        std::cin >> nums[i];
    }

    int Q;
    std::cin >> Q;

    std::vector<std::vector<int>> queries(Q, std::vector<int>(2));
    for (int i = 0; i < Q; ++i) {
        std::cin >> queries[i][0] >> queries[i][1];
    }

    std::vector<int> results = solve(nums, queries);

    for (int result : results) {
        std::cout << result << ""\n"";
    }

    return 0;
}",4.4
Yellow-60,Intro to Backtracking,"- **Backtracking**: A general algorithm for finding all (or some) solutions to computational problems that incrementally builds candidates to the solutions, and abandons a candidate (""backtracks"") as soon as it determines that the candidate cannot possibly be completed to a valid solution.
- **Recursion**: A method where the solution to a problem depends on solutions to smaller instances of the same problem.
- **Decision Trees**: Visualizing the choices made at each step of the backtracking process helps in understanding how all possibilities are explored.","Given an array `nums` of distinct integers, return all possible subsets (the power set). The solution set must not contain duplicate subsets. The order of subsets or the order of elements within a subset does not matter.","- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`
- All the integers in `nums` are unique.","`nums = [1, 2, 3]`","`[[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]`
(The order of subsets and elements within subsets shown here is just one possible valid output order.)","Input: 0
Output: [[]]
Input: 1
0
Output: [[], [0]]
Input: 2
1 2
Output: [[], [1], [2], [1, 2]]
Input: 3
-1 0 1
Output: [[], [-1], [0], [1], [-1, 0], [-1, 1], [0, 1], [-1, 0, 1]]
Input: 4
4 5 6 7
Output: [[], [4], [5], [6], [7], [4, 5], [4, 6], [4, 7], [5, 6], [5, 7], [6, 7], [4, 5, 6], [4, 5, 7], [4, 6, 7], [5, 6, 7], [4, 5, 6, 7]]","#include <stdio.h>
#include <stdlib.h>

// Helper function to print a single subset
void printSubset(int* subset, int subsetSize) {
    printf(""["");
    for (int i = 0; i < subsetSize; i++) {
        printf(""%d"", subset[i]);
        if (i < subsetSize - 1) {
            printf("", "");
        }
    }
    printf(""]"");
}

// Backtracking function
// current_subset: buffer to hold the current subset elements
// subset_size: current number of elements in current_subset
// nums: input array
// nums_size: size of input array
// index: current index in nums to consider
void backtrack(int* current_subset, int subset_size, int* nums, int nums_size, int index) {
    // Base case: All elements considered
    if (index == nums_size) {
        printSubset(current_subset, subset_size);
        printf(""\n"");
        return;
    }

    // Decision 1: Exclude nums[index]
    // Simply move to the next element without adding current one
    backtrack(current_subset, subset_size, nums, nums_size, index + 1);

    // Decision 2: Include nums[index]
    // Add current element to subset buffer
    current_subset[subset_size] = nums[index];
    // Recurse with the new element included and an increased subset_size
    backtrack(current_subset, subset_size + 1, nums, nums_size, index + 1);
    // No explicit ""remove"" (pop) needed for current_subset[subset_size] because
    // when the function returns, the 'subset_size' in the calling context
    // will naturally revert to its previous value, effectively pruning the element.
}

// Main logic function to initiate the subset generation
void generateSubsets(int* nums, int nums_size) {
    // A temporary buffer to hold the current subset. Max size is nums_size.
    int* current_subset = (int*)malloc(sizeof(int) * nums_size);
    if (current_subset == NULL) {
        fprintf(stderr, ""Memory allocation failed\n"");
        return;
    }

    backtrack(current_subset, 0, nums, nums_size, 0);

    free(current_subset);
}

int main() {
    int nums_size;
    // Read the number of elements
    scanf(""%d"", &nums_size);

    int* nums = (int*)malloc(sizeof(int) * nums_size);
    if (nums == NULL) {
        fprintf(stderr, ""Memory allocation failed\n"");
        return 1;
    }

    // Read the elements into the array
    for (int i = 0; i < nums_size; i++) {
        scanf(""%d"", &nums[i]);
    }

    // Call the logic function
    generateSubsets(nums, nums_size);

    // Free dynamically allocated memory
    free(nums);
    return 0;
}","import sys

class Solution:
    def _backtrack(self, index, current_subset, nums, result):
        # Base case: All elements considered
        if index == len(nums):
            result.append(list(current_subset)) # Add a copy of the current_subset
            return

        # Decision 1: Exclude nums[index]
        self._backtrack(index + 1, current_subset, nums, result)

        # Decision 2: Include nums[index]
        current_subset.append(nums[index]) # Add the current element
        self._backtrack(index + 1, current_subset, nums, result)
        # Backtrack: Remove the last added element to explore other paths
        current_subset.pop()

    def generateSubsets(self, nums):
        result = []
        current_subset = []
        self._backtrack(0, current_subset, nums, result)
        return result

def main():
    # Read the number of elements
    n = int(sys.stdin.readline())
    # Read the elements into the list
    nums = list(map(int, sys.stdin.readline().split()))

    sol = Solution()
    all_subsets = sol.generateSubsets(nums)

    # Sort the subsets for consistent output, first by size, then lexicographically
    all_subsets.sort(key=lambda x: (len(x), x))

    # Print the result in the desired format
    sys.stdout.write(""["")
    for i, subset in enumerate(all_subsets):
        sys.stdout.write(""["")
        sys.stdout.write("", "".join(map(str, subset)))
        sys.stdout.write(""]"")
        if i < len(all_subsets) - 1:
            sys.stdout.write("", "")
    sys.stdout.write(""]\n"")

if __name__ == ""__main__"":
    main()","import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class Solution {

    // Backtracking function to generate subsets
    private void backtrack(int index, List<Integer> currentSubset, int[] nums, List<List<Integer>> result) {
        // Base case: All elements considered
        if (index == nums.length) {
            result.add(new ArrayList<>(currentSubset)); // Add a copy of the currentSubset
            return;
        }

        // Decision 1: Exclude nums[index]
        backtrack(index + 1, currentSubset, nums, result);

        // Decision 2: Include nums[index]
        currentSubset.add(nums[index]); // Add the current element
        backtrack(index + 1, currentSubset, nums, result);
        // Backtrack: Remove the last added element to explore other paths
        currentSubset.remove(currentSubset.size() - 1);
    }

    // Main logic function for generating subsets
    public List<List<Integer>> generateSubsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();
        backtrack(0, currentSubset, nums, result);
        return result;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // Read the number of elements
        int n = scanner.nextInt();
        int[] nums = new int[n];
        // Read the elements into the array
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }
        scanner.close();

        Solution sol = new Solution();
        List<List<Integer>> allSubsets = sol.generateSubsets(nums);

        // Sort the subsets for consistent output, first by size, then lexicographically
        Collections.sort(allSubsets, (a, b) -> {
            if (a.size() != b.size()) {
                return a.size() - b.size();
            }
            for (int i = 0; i < a.size(); i++) {
                int cmp = Integer.compare(a.get(i), b.get(i));
                if (cmp != 0) {
                    return cmp;
                }
            }
            return 0; // Equal
        });

        // Print the result in the desired format
        System.out.print(""["");
        for (int i = 0; i < allSubsets.size(); i++) {
            List<Integer> subset = allSubsets.get(i);
            System.out.print(""["");
            for (int j = 0; j < subset.size(); j++) {
                System.out.print(subset.get(j));
                if (j < subset.size() - 1) {
                    System.out.print("", "");
                }
            }
            System.out.print(""]"");
            if (i < allSubsets.size() - 1) {
                System.out.print("", "");
            }
        }
        System.out.println(""]"");
    }
}","// Backtracking function to generate subsets
function backtrack(index, currentSubset, nums, result) {
    // Base case: All elements considered
    if (index === nums.length) {
        result.push([...currentSubset]); // Add a copy of the currentSubset
        return;
    }

    // Decision 1: Exclude nums[index]
    backtrack(index + 1, currentSubset, nums, result);

    // Decision 2: Include nums[index]
    currentSubset.push(nums[index]); // Add the current element
    backtrack(index + 1, currentSubset, nums, result);
    // Backtrack: Remove the last added element to explore other paths
    currentSubset.pop();
}

// Main logic function for generating subsets
function generateSubsets(nums) {
    const result = [];
    const currentSubset = [];
    backtrack(0, currentSubset, nums, result);
    return result;
}

// Main execution function to handle I/O
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let inputLines = [];
    rl.on('line', (line) => {
        inputLines.push(line);
    });

    rl.on('close', () => {
        // Read the number of elements
        const n = parseInt(inputLines[0]);
        // Read the elements into the array
        const nums = inputLines[1].split(' ').map(Number);

        // Call the logic function
        const allSubsets = generateSubsets(nums);

        // Sort the subsets for consistent output, first by size, then lexicographically
        allSubsets.sort((a, b) => {
            if (a.length !== b.length) {
                return a.length - b.length;
            }
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) {
                    return a[i] - b[i];
                }
            }
            return 0; // Equal
        });

        // Print the result in the desired format
        process.stdout.write(""["");
        for (let i = 0; i < allSubsets.length; i++) {
            const subset = allSubsets[i];
            process.stdout.write(""["");
            process.stdout.write(subset.join("", ""));
            process.stdout.write(""]"");
            if (i < allSubsets.length - 1) {
                process.stdout.write("", "");
            }
        }
        process.stdout.write(""]\n"");
    });
}

main();","#include <iostream>
#include <vector>
#include <algorithm> // For std::sort
#include <string>

// Function to print a vector of integers in the desired format
void printVector(const std::vector<int>& vec) {
    std::cout << ""["";
    for (size_t i = 0; i < vec.size(); ++i) {
        std::cout << vec[i];
        if (i < vec.size() - 1) {
            std::cout << "", "";
        }
    }
    std::cout << ""]"";
}

// Backtracking function to generate subsets
void backtrack(int index, std::vector<int>& current_subset, const std::vector<int>& nums, std::vector<std::vector<int>>& result) {
    // Base case: All elements considered
    if (index == nums.size()) {
        result.push_back(current_subset); // Add a copy of the current_subset
        return;
    }

    // Decision 1: Exclude nums[index]
    backtrack(index + 1, current_subset, nums, result);

    // Decision 2: Include nums[index]
    current_subset.push_back(nums[index]); // Add the current element
    backtrack(index + 1, current_subset, nums, result);
    // Backtrack: Remove the last added element to explore other paths
    current_subset.pop_back();
}

// Main logic function for generating subsets
std::vector<std::vector<int>> generateSubsets(const std::vector<int>& nums) {
    std::vector<std::vector<int>> result;
    std::vector<int> current_subset;
    backtrack(0, current_subset, nums, result);
    return result;
}

int main() {
    int n;
    // Read the number of elements
    std::cin >> n;

    std::vector<int> nums(n);
    // Read the elements into the vector
    for (int i = 0; i < n; ++i) {
        std::cin >> nums[i];
    }

    // Call the logic function
    std::vector<std::vector<int>> allSubsets = generateSubsets(nums);

    // Sort the subsets for consistent output, first by size, then lexicographically
    std::sort(allSubsets.begin(), allSubsets.end(), [](const std::vector<int>& a, const std::vector<int>& b) {
        if (a.size() != b.size()) {
            return a.size() < b.size();
        }
        for (size_t i = 0; i < a.size(); ++i) {
            if (a[i] != b[i]) {
                return a[i] < b[i];
            }
        }
        return false; // Equal
    });

    // Print the result in the desired format
    std::cout << ""["";
    for (size_t i = 0; i < allSubsets.size(); ++i) {
        printVector(allSubsets[i]);
        if (i < allSubsets.size() - 1) {
            std::cout << "", "";
        }
    }
    std::cout << ""]"" << std::endl;

    return 0;
}",4.4
Yellow-61,LeetCode,"*   **Recursion/Backtracking**: This problem is a classic example of using recursion to explore all possible paths to a solution. We make a choice, explore the consequences, and then ""backtrack"" to try another choice.
*   **Decision Tree**: Imagine a tree where at each step, you decide whether to add an opening parenthesis or a closing parenthesis. The goal is to find all paths from the root to a leaf that form a valid parentheses string.
*   **State Management**: During recursion, we keep track of how many opening parentheses we've used, how many closing parentheses we've used, and the current string we're building.
*   **Base Case**: The condition under which the recursion stops and a valid solution is found (e.g., when we've used all `n` opening and `n` closing parentheses).
*   **Pruning (Optimization)**: We can avoid exploring paths that will never lead to a valid solution. For instance, we should never add a closing parenthesis if we haven't added an opening one first, or if we've already used all `n` opening parentheses.","You are given a number `n`, which represents the number of pairs of parentheses you need to generate. Your task is to write a function that generates all possible combinations of well-formed parentheses.

A ""well-formed"" parentheses string means that:
1. Every opening parenthesis '(' has a corresponding closing parenthesis ')'.
2. Every closing parenthesis ')' has a corresponding opening parenthesis '('.
3. Parentheses are correctly nested (e.g., `()` is well-formed, `)(` is not).

For example, if `n = 3`, you need to generate all combinations of 3 pairs of parentheses that are well-formed.",*   `1 <= n <= 8`,"** `n = 3`

**","**

((()))
(()())
(())()
()(())
()()()

(The order of the strings in the output does not matter.)","Input: 1
Output:
(),Input: 2
Output:
(())
()(),Input: 3
Output:
((()))
(()())
(())()
()(())
()()(),Input: 4
Output:
(((())))
((()()))
((())())
((()))()
(()(()))
(()()())
(()())()
(())()()
()((()))
()(()())
()(())()
()()(())
()()()()","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Helper function for backtracking
void backtrack(char** result, int* resultSize, char* current_path, int path_idx, int open_count, int close_count, int n) {
    if (path_idx == 2 * n) {
        // Base case: current_path is complete
        current_path[path_idx] = '\0'; // Null-terminate the string
        // Dynamically reallocate result array if needed (simplified for common LeetCode size constraints here)
        // For n=8, Catalan(8) is 1430, so initial allocation of 2000 is safe.
        result[*resultSize] = strdup(current_path); // Duplicate and store the string
        (*resultSize)++;
        return;
    }

    // Try adding an open parenthesis
    if (open_count < n) {
        current_path[path_idx] = '(';
        backtrack(result, resultSize, current_path, path_idx + 1, open_count + 1, close_count, n);
    }

    // Try adding a close parenthesis
    if (close_count < open_count) {
        current_path[path_idx] = ')';
        backtrack(result, resultSize, current_path, path_idx + 1, open_count, close_count + 1, n);
    }
}

// Main function signature as typically expected by LeetCode C for string arrays
char** generateParenthesis(int n, int* returnSize) {
    // Max number of solutions is Catalan(n), which is large but bounded for n=8.
    // C(8) = 1430. Max length of string is 2*8 + 1 = 17.
    // Let's pre-allocate a reasonable upper bound for results. 2000 pointers should be fine.
    char** result = (char**)malloc(sizeof(char*) * 2000); 
    *returnSize = 0;

    // A buffer to build the current parenthesis string
    char* current_path = (char*)malloc(sizeof(char) * (2 * n + 1));

    backtrack(result, returnSize, current_path, 0, 0, 0, n);

    free(current_path); // Free the temporary buffer
    return result;
}

// Main function to handle I/O for testing
int main() {
    int n;
    // Read n from stdin
    if (scanf(""%d"", &n) != 1) {
        fprintf(stderr, ""Error reading input.\n"");
        return 1;
    }

    int returnSize;
    char** result = generateParenthesis(n, &returnSize);

    // Print results, one per line
    for (int i = 0; i < returnSize; i++) {
        printf(""%s\n"", result[i]);
        free(result[i]); // Free each string
    }
    free(result); // Free the array of pointers

    return 0;
}","import sys

class Solution:
    def generateParenthesis(self, n: int) -> list[str]:
        result = []
        # current_path is a list of characters for efficient appending/popping
        current_path = []

        def backtrack(open_count, close_count):
            # Base case: current_path is complete
            if open_count == n and close_count == n:
                result.append("""".join(current_path))
                return

            # Try adding an open parenthesis
            if open_count < n:
                current_path.append('(') # Add
                backtrack(open_count + 1, close_count)
                current_path.pop() # Backtrack

            # Try adding a close parenthesis
            if close_count < open_count:
                current_path.append(')') # Add
                backtrack(open_count, close_count + 1)
                current_path.pop() # Backtrack

        backtrack(0, 0)
        return result

def main():
    n = int(sys.stdin.readline()) # Read n from stdin

    sol = Solution()
    result = sol.generateParenthesis(n)

    # Print results, one per line
    for s in result:
        sys.stdout.write(s + '\n')

if __name__ == '__main__':
    main()","import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> result = new ArrayList<>();
        // Using a StringBuilder for efficient string manipulation during backtracking
        backtrack(result, new StringBuilder(), 0, 0, n);
        return result;
    }

    private void backtrack(List<String> result, StringBuilder currentPath, int openCount, int closeCount, int n) {
        // Base case: currentPath is complete
        if (currentPath.length() == 2 * n) {
            result.add(currentPath.toString());
            return;
        }

        // Try adding an open parenthesis
        if (openCount < n) {
            currentPath.append('('); // Add
            backtrack(result, currentPath, openCount + 1, closeCount, n);
            currentPath.deleteCharAt(currentPath.length() - 1); // Backtrack
        }

        // Try adding a close parenthesis
        if (closeCount < openCount) {
            currentPath.append(')'); // Add
            backtrack(result, currentPath, openCount, closeCount + 1, n);
            currentPath.deleteCharAt(currentPath.length() - 1); // Backtrack
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        scanner.close();

        Solution sol = new Solution();
        List<String> result = sol.generateParenthesis(n);

        // Print results, one per line
        for (String s : result) {
            System.out.println(s);
        }
    }
}","// Function as typically expected in LeetCode environment
function generateParenthesis(n) {
    const result = [];
    // currentPath is an array of characters for efficient appending/popping
    const currentPath = [];

    function backtrack(openCount, closeCount) {
        // Base case: currentPath is complete
        if (currentPath.length === 2 * n) {
            result.push(currentPath.join(''));
            return;
        }

        // Try adding an open parenthesis
        if (openCount < n) {
            currentPath.push('('); // Add
            backtrack(openCount + 1, closeCount);
            currentPath.pop(); // Backtrack
        }

        // Try adding a close parenthesis
        if (closeCount < openCount) {
            currentPath.push(')'); // Add
            backtrack(openCount, closeCount + 1);
            currentPath.pop(); // Backtrack
        }
    }

    backtrack(0, 0);
    return result;
}

// Main function to handle I/O for testing
// In a typical LeetCode environment, only the generateParenthesis function is expected.
// For raw runnable code, we need to simulate input/output.
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.question('', (input) => {
    const n = parseInt(input.trim(), 10);

    const result = generateParenthesis(n);

    // Print results, one per line
    for (const s of result) {
        console.log(s);
    }

    rl.close();
});","#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

class Solution {
public:
    void backtrack(std::vector<std::string>& result, std::string& current_path, int open_count, int close_count, int n) {
        // Base case: current_path is complete
        if (current_path.length() == 2 * n) {
            result.push_back(current_path);
            return;
        }

        // Try adding an open parenthesis
        if (open_count < n) {
            current_path.push_back('('); // Add
            backtrack(result, current_path, open_count + 1, close_count, n);
            current_path.pop_back(); // Backtrack
        }

        // Try adding a close parenthesis
        if (close_count < open_count) {
            current_path.push_back(')'); // Add
            backtrack(result, current_path, open_count, close_count + 1, n);
            current_path.pop_back(); // Backtrack
        }
    }

    std::vector<std::string> generateParenthesis(int n) {
        std::vector<std::string> result;
        std::string current_path; // Use a single string for building
        current_path.reserve(2 * n); // Pre-allocate memory for efficiency
        backtrack(result, current_path, 0, 0, n);
        return result;
    }
};

int main() {
    int n;
    // Read n from stdin
    std::cin >> n;

    Solution sol;
    std::vector<std::string> result = sol.generateParenthesis(n);

    // Print results, one per line
    for (const std::string& s : result) {
        std::cout << s << std::endl;
    }

    return 0;
}",4.2
Yellow-62,Sliding Window (Introductory problems),"*   Sliding Window Technique
*   Queue (or Deque) for efficient tracking of elements
*   Array traversal","You are given an array of `N` integers and an integer `K`. Your task is to find the first negative integer for each and every contiguous subarray (window) of size `K`. If a window does not contain any negative integers, you should report `0` for that window.","*   `1 <= N <= 10^5`
*   `1 <= K <= N`
*   `-10^9 <= A[i] <= 10^9`","**
N = 8, K = 3
A = [12, -1, -7, 8, -15, 30, 16, 28]

**","**
-1 -1 -7 -15 -15 0

**","Input: 5 2
1 2 3 4 5
Output: 0 0 0 0
Input: 4 2
-1 -2 -3 -4
Output: -1 -2 -3
Input: 5 5
10 -20 30 -40 50
Output: -20
Input: 6 1
-5 0 10 -15 20 -25
Output: -5 0 0 -15 0 -25
Input: 6 3
-1 -2 3 -4 5 -6
Output: -1 -2 -4 -4","#include <stdio.h>
#include <stdlib.h> // For malloc, free
#include <stdbool.h> // For bool

// A simple queue implementation using an array for indices
typedef struct {
    int* data;
    int front;
    int rear;
    int capacity;
    int size;
} Queue;

Queue* createQueue(int capacity) {
    Queue* q = (Queue*)malloc(sizeof(Queue));
    q->capacity = capacity;
    q->front = 0;
    q->rear = -1;
    q->size = 0;
    q->data = (int*)malloc(sizeof(int) * capacity);
    return q;
}

void enqueue(Queue* q, int item) {
    if (q->size == q->capacity) {
        // In this problem, max capacity is N, so it's fine.
        // A real-world queue might need dynamic resizing or error handling.
        return;
    }
    q->rear = (q->rear + 1) % q->capacity;
    q->data[q->rear] = item;
    q->size++;
}

int dequeue(Queue* q) {
    if (q->size == 0) {
        return -1; // Or some error indicator
    }
    int item = q->data[q->front];
    q->front = (q->front + 1) % q->capacity;
    q->size--;
    return item;
}

int getFront(Queue* q) {
    if (q->size == 0) {
        return -1; // Or some error indicator
    }
    return q->data[q->front];
}

bool isEmpty(Queue* q) {
    return q->size == 0;
}

void freeQueue(Queue* q) {
    free(q->data);
    free(q);
}

void findFirstNegativeInWindows(int arr[], int n, int k) {
    Queue* q = createQueue(n); // Queue stores indices of negative numbers

    for (int i = 0; i < n; i++) {
        // Remove elements from the front of the queue that are out of the current window
        if (!isEmpty(q) && getFront(q) <= i - k) {
            dequeue(q);
        }

        // Add the current element's index if it's negative
        if (arr[i] < 0) {
            enqueue(q, i);
        }

        // If the window has reached size K, print the first negative
        if (i >= k - 1) {
            if (!isEmpty(q)) {
                printf(""%d "", arr[getFront(q)]);
            } else {
                printf(""0 "");
            }
        }
    }
    printf(""\n"");

    freeQueue(q);
}

int main() {
    int n, k;
    scanf(""%d %d"", &n, &k);

    int* arr = (int*)malloc(sizeof(int) * n);
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]);
    }

    findFirstNegativeInWindows(arr, n, k);

    free(arr);

    return 0;
}","import collections

def find_first_negative_in_windows(arr, n, k):
    dq = collections.deque() # Stores indices of negative numbers
    result = []

    for i in range(n):
        # Remove elements from the front of the deque that are out of the current window
        # An index 'idx' is out of the window [i-k+1, i] if idx <= i-k
        if dq and dq[0] <= i - k:
            dq.popleft()

        # Add the current element's index if it's negative
        if arr[i] < 0:
            dq.append(i)

        # If the window has reached size K, append the first negative
        # The window is [i-k+1 ... i]
        if i >= k - 1:
            if dq:
                result.append(str(arr[dq[0]]))
            else:
                result.append(""0"")

    print("" "".join(result))

if __name__ == ""__main__"":
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))

    find_first_negative_in_windows(arr, n, k)","import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class FirstNegativeInWindow {

    public static void findFirstNegativeInWindows(int[] arr, int n, int k) {
        // Use a LinkedList as a Queue to store indices of negative numbers
        Queue<Integer> dq = new LinkedList<>();

        StringBuilder result = new StringBuilder();

        for (int i = 0; i < n; i++) {
            // Remove elements from the front of the queue that are out of the current window
            // An index 'idx' is out of the window [i-k+1, i] if idx <= i-k
            if (!dq.isEmpty() && dq.peek() <= i - k) {
                dq.poll();
            }

            // Add the current element's index if it's negative
            if (arr[i] < 0) {
                // For a Queue, add() (or offer()) adds to the tail.
                dq.add(i);
            }

            // If the window has reached size K, append the first negative
            // The window is [i-k+1 ... i]
            if (i >= k - 1) {
                if (!dq.isEmpty()) {
                    result.append(arr[dq.peek()]).append("" "");
                } else {
                    result.append(""0 "");
                }
            }
        }
        System.out.println(result.toString().trim());
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        int k = scanner.nextInt();

        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        findFirstNegativeInWindows(arr, n, k);

        scanner.close();
    }
}","function findFirstNegativeInWindows(arr, n, k) {
    const dq = []; // Stores indices of negative numbers (simulated deque using array methods)
    const result = [];

    for (let i = 0; i < n; i++) {
        // Remove elements from the front of the deque that are out of the current window
        // An index 'idx' is out of the window [i-k+1, i] if idx <= i-k
        while (dq.length > 0 && dq[0] <= i - k) {
            dq.shift(); // Remove from front
        }

        // Add the current element's index if it's negative
        if (arr[i] < 0) {
            dq.push(i); // Add to back
        }

        // If the window has reached size K, append the first negative
        // The window is [i-k+1 ... i]
        if (i >= k - 1) {
            if (dq.length > 0) {
                result.push(arr[dq[0]]); // Peek at front
            } else {
                result.push(0);
            }
        }
    }
    console.log(result.join("" ""));
}

// Handle input/output for competitive programming environment
// Reads N and K from the first line
// Reads array elements from the second line
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let inputLines = [];
rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    const nk = inputLines[0].split(' ').map(Number);
    const n = nk[0];
    const k = nk[1];
    const arr = inputLines[1].split(' ').map(Number);

    findFirstNegativeInWindows(arr, n, k);
});","#include <iostream>
#include <vector>
#include <deque>

void findFirstNegativeInWindows(const std::vector<int>& arr, int n, int k) {
    std::deque<int> dq; // Stores indices of negative numbers

    for (int i = 0; i < n; ++i) {
        // Remove elements from the front of the deque that are out of the current window
        // An index 'idx' is out of the window [i-k+1, i] if idx <= i-k
        if (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }

        // Add the current element's index if it's negative
        if (arr[i] < 0) {
            dq.push_back(i);
        }

        // If the window has reached size K, print the first negative
        // The window is [i-k+1 ... i]
        if (i >= k - 1) {
            if (!dq.empty()) {
                std::cout << arr[dq.front()] << "" "";
            } else {
                std::cout << ""0 "";
            }
        }
    }
    std::cout << std::endl;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n, k;
    std::cin >> n >> k;

    std::vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i];
    }

    findFirstNegativeInWindows(arr, n, k);

    return 0;
}",4.4
Yellow-63,Queue Implementation (Array/LL),"- Queue Data Structure (FIFO - First-In, First-Out)
- Singly Linked Lists
- Node management (pointers/references)
- Basic Data Structure Operations (add, remove, peek, check emptiness, size)
- Edge case handling (e.g., empty queue operations)","Implement a Queue data structure using a singly linked list. Your queue should support the following operations:

- `enqueue(value)`: Add an element to the rear of the queue.
- `dequeue()`: Remove and return the element from the front of the queue. If the queue is empty, indicate this.
- `peek()`: Return the element at the front of the queue without removing it. If the queue is empty, indicate this.
- `isEmpty()`: Return `true` if the queue is empty, `false` otherwise.
- `size()`: Return the current number of elements in the queue.

Your implementation should correctly handle all edge cases, such as performing operations on an empty queue.","- The queue will store integers.
- Maximum number of operations: 1000.
- Values of elements for `enqueue` will be between -10^9 and 10^9.
- For `dequeue` and `peek` on an empty queue, print ""Queue is empty"".","7
enqueue 10
enqueue 20
dequeue
peek
size
isEmpty
dequeue


####","10
20
1
false
20","Input: 5
enqueue 1
enqueue 2
dequeue
dequeue
isEmpty
Output: 1
2
true
Input: 8
enqueue 100
peek
enqueue 200
dequeue
size
enqueue 300
dequeue
peek
Output: 100
100
1
300
Input: 6
isEmpty
dequeue
peek
enqueue 50
size
isEmpty
Output: true
Queue is empty
Queue is empty
1
false
Input: 9
enqueue 1
enqueue 2
dequeue
enqueue 3
enqueue 4
dequeue
dequeue
dequeue
isEmpty
Output: 1
2
3
4
true","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define a Node structure
typedef struct Node {
    int data;
    struct Node* next;
} Node;

// Define a Queue structure
typedef struct Queue {
    Node* front;
    Node* rear;
    int currentSize;
} Queue;

// Function to initialize a new Queue
Queue* createQueue() {
    Queue* q = (Queue*)malloc(sizeof(Queue));
    if (q == NULL) {
        perror(""Failed to allocate memory for queue"");
        exit(EXIT_FAILURE);
    }
    q->front = NULL;
    q->rear = NULL;
    q->currentSize = 0;
    return q;
}

// Function to check if the queue is empty
int isEmpty(Queue* q) {
    return q->front == NULL;
}

// Function to get the current size of the queue
int size(Queue* q) {
    return q->currentSize;
}

// Function to add an element to the rear of the queue
void enqueue(Queue* q, int value) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    if (newNode == NULL) {
        perror(""Failed to allocate memory for node"");
        exit(EXIT_FAILURE);
    }
    newNode->data = value;
    newNode->next = NULL;

    if (isEmpty(q)) {
        q->front = newNode;
        q->rear = newNode;
    } else {
        q->rear->next = newNode;
        q->rear = newNode;
    }
    q->currentSize++;
}

// Function to remove and return the element from the front of the queue
// Returns an indicator (e.g., -1 for error) or uses an output parameter
// For simplicity, we'll print and return 0 if empty, otherwise the value
int dequeue(Queue* q) {
    if (isEmpty(q)) {
        printf(""Queue is empty\n"");
        return -1; // Indicate error or special value
    }
    Node* temp = q->front;
    int dequeuedValue = temp->data;
    q->front = q->front->next;

    if (q->front == NULL) { // If queue becomes empty after dequeue
        q->rear = NULL;
    }
    free(temp);
    q->currentSize--;
    return dequeuedValue;
}

// Function to peek at the front element without removing it
int peek(Queue* q) {
    if (isEmpty(q)) {
        printf(""Queue is empty\n"");
        return -1; // Indicate error or special value
    }
    return q->front->data;
}

// Function to free all memory associated with the queue
void freeQueue(Queue* q) {
    Node* current = q->front;
    Node* next;
    while (current != NULL) {
        next = current->next;
        free(current);
        current = next;
    }
    free(q);
}

int main() {
    Queue* myQueue = createQueue();
    int N;
    scanf(""%d"", &N);

    char command[20];
    int value;
    int result;

    for (int i = 0; i < N; i++) {
        scanf(""%s"", command);
        if (strcmp(command, ""enqueue"") == 0) {
            scanf(""%d"", &value);
            enqueue(myQueue, value);
        } else if (strcmp(command, ""dequeue"") == 0) {
            result = dequeue(myQueue);
            if (result != -1) {
                printf(""%d\n"", result);
            }
        } else if (strcmp(command, ""peek"") == 0) {
            result = peek(myQueue);
            if (result != -1) {
                printf(""%d\n"", result);
            }
        } else if (strcmp(command, ""isEmpty"") == 0) {
            if (isEmpty(myQueue)) {
                printf(""true\n"");
            } else {
                printf(""false\n"");
            }
        } else if (strcmp(command, ""size"") == 0) {
            printf(""%d\n"", size(myQueue));
        }
    }

    freeQueue(myQueue);

    return 0;
}","class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class Queue:
    def __init__(self):
        self.front = None
        self.rear = None
        self.current_size = 0

    def is_empty(self):
        return self.front is None

    def size(self):
        return self.current_size

    def enqueue(self, value):
        new_node = Node(value)
        if self.is_empty():
            self.front = new_node
            self.rear = new_node
        else:
            self.rear.next = new_node
            self.rear = new_node
        self.current_size += 1

    def dequeue(self):
        if self.is_empty():
            print(""Queue is empty"")
            return -1  # Indicate error or special value
        dequeued_value = self.front.data
        self.front = self.front.next

        if self.front is None:  # If queue becomes empty after dequeue
            self.rear = None
        self.current_size -= 1
        return dequeued_value

    def peek(self):
        if self.is_empty():
            print(""Queue is empty"")
            return -1  # Indicate error or special value
        return self.front.data

def solve():
    my_queue = Queue()
    N = int(input())

    for _ in range(N):
        command_parts = input().split()
        command = command_parts[0]

        if command == ""enqueue"":
            value = int(command_parts[1])
            my_queue.enqueue(value)
        elif command == ""dequeue"":
            result = my_queue.dequeue()
            if result != -1:
                print(result)
        elif command == ""peek"":
            result = my_queue.peek()
            if result != -1:
                print(result)
        elif command == ""isEmpty"":
            print(str(my_queue.is_empty()).lower())
        elif command == ""size"":
            print(my_queue.size())

if __name__ == '__main__':
    solve()","import java.util.Scanner;

class Node {
    int data;
    Node next;

    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}

class Queue {
    private Node front;
    private Node rear;
    private int currentSize;

    public Queue() {
        this.front = null;
        this.rear = null;
        this.currentSize = 0;
    }

    public boolean isEmpty() {
        return front == null;
    }

    public int size() {
        return currentSize;
    }

    public void enqueue(int value) {
        Node newNode = new Node(value);
        if (isEmpty()) {
            front = newNode;
            rear = newNode;
        } else {
            rear.next = newNode;
            rear = newNode;
        }
        currentSize++;
    }

    public int dequeue() {
        if (isEmpty()) {
            System.out.println(""Queue is empty"");
            return -1; // Indicate error or special value
        }
        int dequeuedValue = front.data;
        front = front.next;

        if (front == null) { // If queue becomes empty after dequeue
            rear = null;
        }
        currentSize--;
        return dequeuedValue;
    }

    public int peek() {
        if (isEmpty()) {
            System.out.println(""Queue is empty"");
            return -1; // Indicate error or special value
        }
        return front.data;
    }
}

public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Queue myQueue = new Queue();

        int N = scanner.nextInt();
        scanner.nextLine(); // Consume newline

        for (int i = 0; i < N; i++) {
            String line = scanner.nextLine();
            String[] parts = line.split("" "");
            String command = parts[0];

            if (command.equals(""enqueue"")) {
                int value = Integer.parseInt(parts[1]);
                myQueue.enqueue(value);
            } else if (command.equals(""dequeue"")) {
                int result = myQueue.dequeue();
                if (result != -1) {
                    System.out.println(result);
                }
            } else if (command.equals(""peek"")) {
                int result = myQueue.peek();
                if (result != -1) {
                    System.out.println(result);
                }
            } else if (command.equals(""isEmpty"")) {
                System.out.println(myQueue.isEmpty());
            } else if (command.equals(""size"")) {
                System.out.println(myQueue.size());
            }
        }

        scanner.close();
    }
}","class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

class Queue {
    constructor() {
        this.front = null;
        this.rear = null;
        this.currentSize = 0;
    }

    isEmpty() {
        return this.front === null;
    }

    size() {
        return this.currentSize;
    }

    enqueue(value) {
        const newNode = new Node(value);
        if (this.isEmpty()) {
            this.front = newNode;
            this.rear = newNode;
        } else {
            this.rear.next = newNode;
            this.rear = newNode;
        }
        this.currentSize++;
    }

    dequeue() {
        if (this.isEmpty()) {
            console.log(""Queue is empty"");
            return -1; // Indicate error or special value
        }
        const dequeuedValue = this.front.data;
        this.front = this.front.next;

        if (this.front === null) { // If queue becomes empty after dequeue
            this.rear = null;
        }
        this.currentSize--;
        return dequeuedValue;
    }

    peek() {
        if (this.isEmpty()) {
            console.log(""Queue is empty"");
            return -1; // Indicate error or special value
        }
        return this.front.data;
    }
}

function solve() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    const myQueue = new Queue();
    let N;
    let lineNumber = 0;
    let commands = [];

    rl.on('line', (line) => {
        if (lineNumber === 0) {
            N = parseInt(line);
        } else {
            commands.push(line);
        }
        lineNumber++;

        if (lineNumber > N) {
            rl.close();
        }
    });

    rl.on('close', () => {
        for (const commandLine of commands) {
            const parts = commandLine.split(' ');
            const command = parts[0];

            if (command === ""enqueue"") {
                const value = parseInt(parts[1]);
                myQueue.enqueue(value);
            } else if (command === ""dequeue"") {
                const result = myQueue.dequeue();
                if (result !== -1) {
                    console.log(result);
                }
            } else if (command === ""peek"") {
                const result = myQueue.peek();
                if (result !== -1) {
                    console.log(result);
                }
            } else if (command === ""isEmpty"") {
                console.log(myQueue.isEmpty());
            } else if (command === ""size"") {
                console.log(myQueue.size());
            }
        }
    });
}

solve();","#include <iostream>
#include <string>

// Define a Node structure
struct Node {
    int data;
    Node* next;

    Node(int val) : data(val), next(nullptr) {}
};

// Define a Queue class
class Queue {
private:
    Node* frontPtr;
    Node* rearPtr;
    int currentSize;

public:
    // Constructor
    Queue() : frontPtr(nullptr), rearPtr(nullptr), currentSize(0) {}

    // Destructor to free memory
    ~Queue() {
        while (frontPtr != nullptr) {
            Node* temp = frontPtr;
            frontPtr = frontPtr->next;
            delete temp;
        }
    }

    // Function to check if the queue is empty
    bool isEmpty() {
        return frontPtr == nullptr;
    }

    // Function to get the current size of the queue
    int size() {
        return currentSize;
    }

    // Function to add an element to the rear of the queue
    void enqueue(int value) {
        Node* newNode = new Node(value);
        if (isEmpty()) {
            frontPtr = newNode;
            rearPtr = newNode;
        } else {
            rearPtr->next = newNode;
            rearPtr = newNode;
        }
        currentSize++;
    }

    // Function to remove and return the element from the front of the queue
    int dequeue() {
        if (isEmpty()) {
            std::cout << ""Queue is empty"" << std::endl;
            return -1; // Indicate error or special value
        }
        Node* temp = frontPtr;
        int dequeuedValue = temp->data;
        frontPtr = frontPtr->next;

        if (frontPtr == nullptr) { // If queue becomes empty after dequeue
            rearPtr = nullptr;
        }
        delete temp;
        currentSize--;
        return dequeuedValue;
    }

    // Function to peek at the front element without removing it
    int peek() {
        if (isEmpty()) {
            std::cout << ""Queue is empty"" << std::endl;
            return -1; // Indicate error or special value
        }
        return frontPtr->data;
    }
};

int main() {
    Queue myQueue;
    int N;
    std::cin >> N;

    std::string command;
    int value;
    int result;

    for (int i = 0; i < N; i++) {
        std::cin >> command;
        if (command == ""enqueue"") {
            std::cin >> value;
            myQueue.enqueue(value);
        } else if (command == ""dequeue"") {
            result = myQueue.dequeue();
            if (result != -1) {
                std::cout << result << std::endl;
            }
        } else if (command == ""peek"") {
            result = myQueue.peek();
            if (result != -1) {
                std::cout << result << std::endl;
            }
        } else if (command == ""isEmpty"") {
            if (myQueue.isEmpty()) {
                std::cout << ""true"" << std::endl;
            } else {
                std::cout << ""false"" << std::endl;
            }
        } else if (command == ""size"") {
            std::cout << myQueue.size() << std::endl;
        }
    }

    return 0;
}",4.4
Yellow-64,Frequency Count / Anagrams,"*   Frequency Arrays / Hash Maps
*   String Manipulation
*   Character Counting
*   Conditional Logic","Given two strings, `s` and `t`, determine if `t` is an anagram of `s`. An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once.","*   `1 <= s.length, t.length <= 1000`
*   `s` and `t` consist only of lowercase English letters.","**

anagram
nagaram

**","**

true","Input: s = ""listen""
t = ""silent""
Output: true
Input: s = ""hello""
t = ""world""
Output: false
Input: s = ""aabb""
t = ""baba""
Output: true
Input: s = ""rat""
t = ""car""
Output: false
Input: s = ""program""
t = ""grapram""
Output: false","#include <stdio.h>
#include <string.h>
#include <stdbool.h>

bool isAnagram(const char* s, const char* t) {
    int len_s = strlen(s);
    int len_t = strlen(t);

    if (len_s != len_t) {
        return false;
    }

    int counts[26] = {0}; // For lowercase English letters 'a' through 'z'

    for (int i = 0; i < len_s; i++) {
        counts[s[i] - 'a']++;
    }

    for (int i = 0; i < len_t; i++) {
        counts[t[i] - 'a']--;
    }

    for (int i = 0; i < 26; i++) {
        if (counts[i] != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    char s[1001]; // Max length 1000 + null terminator
    char t[1001];

    if (scanf(""%1000s"", s) != 1) return 1; // Read string s
    if (scanf(""%1000s"", t) != 1) return 1; // Read string t

    if (isAnagram(s, t)) {
        printf(""true\n"");
    } else {
        printf(""false\n"");
    }

    return 0;
}","import sys

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False

        counts = [0] * 26 # For lowercase English letters 'a' through 'z'

        for char_s in s:
            counts[ord(char_s) - ord('a')] += 1

        for char_t in t:
            counts[ord(char_t) - ord('a')] -= 1

        for count in counts:
            if count != 0:
                return False
        
        return True

if __name__ == ""__main__"":
    s = sys.stdin.readline().strip() # Read string s
    t = sys.stdin.readline().strip() # Read string t

    sol = Solution()
    if sol.isAnagram(s, t):
        sys.stdout.write(""true\n"")
    else:
        sys.stdout.write(""false\n"")","import java.util.Scanner;

public class Solution {

    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }

        int[] counts = new int[26]; // For lowercase English letters 'a' through 'z'

        for (char c : s.toCharArray()) {
            counts[c - 'a']++;
        }

        for (char c : t.toCharArray()) {
            counts[c - 'a']--;
        }

        for (int count : counts) {
            if (count != 0) {
                return false;
            }
        }

        return true;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.next(); // Read string s
        String t = scanner.next(); // Read string t
        scanner.close();

        Solution sol = new Solution();
        if (sol.isAnagram(s, t)) {
            System.out.println(""true"");
        } else {
            System.out.println(""false"");
        }
    }
}","// Function to check if two strings are anagrams
function isAnagram(s, t) {
    if (s.length !== t.length) {
        return false;
    }

    const counts = new Array(26).fill(0); // For lowercase English letters 'a' through 'z'

    for (let i = 0; i < s.length; i++) {
        counts[s.charCodeAt(i) - 'a'.charCodeAt(0)]++;
    }

    for (let i = 0; i < t.length; i++) {
        counts[t.charCodeAt(i) - 'a'.charCodeAt(0)]--;
    }

    for (let i = 0; i < 26; i++) {
        if (counts[i] !== 0) {
            return false;
        }
    }

    return true;
}

// Main part for handling input/output in a Node.js-like environment
let input = """";
process.stdin.on('data', data => {
    input += data.toString();
});

process.stdin.on('end', () => {
    const lines = input.trim().split('\n');
    const s = lines[0];
    const t = lines[1];

    if (isAnagram(s, t)) {
        process.stdout.write(""true\n"");
    } else {
        process.stdout.write(""false\n"");
    }
});","#include <iostream>
#include <string>
#include <vector>

bool isAnagram(std::string s, std::string t) {
    if (s.length() != t.length()) {
        return false;
    }

    std::vector<int> counts(26, 0); // For lowercase English letters 'a' through 'z'

    for (char c : s) {
        counts[c - 'a']++;
    }

    for (char c : t) {
        counts[c - 'a']--;
    }

    for (int count : counts) {
        if (count != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    std::string s, t;
    std::cin >> s >> t; // Read strings s and t

    if (isAnagram(s, t)) {
        std::cout << ""true"" << std::endl;
    } else {
        std::cout << ""false"" << std::endl;
    }

    return 0;
}",4.2
Yellow-65,Prefix & Suffix Sums,"- Arrays
- Prefix Sums
- Iteration
- Edge Cases (empty sums)","Given an array of integers, your task is to find the lowest index `i` where the sum of elements to the left of `i` is equal to the sum of elements to the right of `i`.

If there are no elements to the left of `i` (i.e., `i = 0`), the left sum is considered 0. Similarly, if there are no elements to the right of `i` (i.e., `i = n-1`), the right sum is considered 0.

If multiple such indices exist, return the smallest one. If no such index exists, return -1.","- `0 <= arr.length <= 10^5`
- `-1000 <= arr[i] <= 1000`","7
-7 1 5 2 -4 3 0","3

**","Input: 7
1 2 3 4 3 2 1
Output: 3
Input: 3
1 -1 4
Output: 2
Input: 3
2 3 5
Output: -1
Input: 1
0
Output: 0
Input: 1
10
Output: 0","#include <stdio.h>
#include <stdlib.h>

// Function to find the sum symmetry index
int findSumSymmetryIndex(int* arr, int n) {
    if (n == 0) {
        return -1; // No elements, no symmetry index
    }

    long long totalSum = 0; // Use long long to prevent potential overflow
    for (int i = 0; i < n; i++) {
        totalSum += arr[i];
    }

    long long leftSum = 0; // Sum of elements to the left of the current index
    for (int i = 0; i < n; i++) {
        // Calculate rightSum: totalSum - leftSum - current_element
        // If leftSum == rightSum, we found the index
        if (leftSum == (totalSum - leftSum - arr[i])) {
            return i; // Return the first (lowest) such index found
        }
        // Add current element to leftSum for the next iteration
        leftSum += arr[i];
    }

    return -1; // No sum symmetry index found
}

int main() {
    int n;
    scanf(""%d"", &n);

    int* arr = NULL;
    if (n > 0) {
        arr = (int*)malloc(n * sizeof(int));
        if (arr == NULL) {
            fprintf(stderr, ""Memory allocation failed\n"");
            return 1; // Indicate an error
        }
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &arr[i]);
        }
    }

    int result = findSumSymmetryIndex(arr, n);
    printf(""%d\n"", result);

    if (n > 0) {
        free(arr);
    }

    return 0;
}","def find_sum_symmetry_index(arr):
    n = len(arr)
    if n == 0:
        return -1  # No elements, no symmetry index

    total_sum = sum(arr)  # Python handles large integers automatically

    left_sum = 0  # Sum of elements to the left of the current index
    for i in range(n):
        # Calculate right_sum: total_sum - left_sum - current_element
        # If left_sum == right_sum, we found the index
        if left_sum == (total_sum - left_sum - arr[i]):
            return i  # Return the first (lowest) such index found
        # Add current element to left_sum for the next iteration
        left_sum += arr[i]

    return -1  # No sum symmetry index found

if __name__ == ""__main__"":
    n = int(input())
    arr = list(map(int, input().split()))

    result = find_sum_symmetry_index(arr)
    print(result)","import java.util.Scanner;

public class Solution {

    // Function to find the sum symmetry index
    public static int findSumSymmetryIndex(int[] arr) {
        int n = arr.length;
        if (n == 0) {
            return -1; // No elements, no symmetry index
        }

        long totalSum = 0; // Use long to prevent potential overflow
        for (int x : arr) {
            totalSum += x;
        }

        long leftSum = 0; // Sum of elements to the left of the current index
        for (int i = 0; i < n; i++) {
            // Calculate rightSum: totalSum - leftSum - current_element
            // If leftSum == rightSum, we found the index
            if (leftSum == (totalSum - leftSum - arr[i])) {
                return i; // Return the first (lowest) such index found
            }
            // Add current element to leftSum for the next iteration
            leftSum += arr[i];
        }

        return -1; // No sum symmetry index found
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        int result = findSumSymmetryIndex(arr);
        System.out.println(result);

        scanner.close();
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let inputLines = [];
rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    const n = parseInt(inputLines[0]);
    const arr = inputLines[1].split(' ').map(Number);

    const result = findSumSymmetryIndex(arr);
    console.log(result);
});

// Function to find the sum symmetry index
function findSumSymmetryIndex(arr) {
    const n = arr.length;
    if (n === 0) {
        return -1; // No elements, no symmetry index
    }

    let totalSum = 0;
    for (const x of arr) {
        totalSum += x;
    }
    // JavaScript numbers are double-precision floats, but handle integers up to 2^53 safely.
    // Given constraints (10^5 elements, values up to 1000), totalSum will not exceed 10^8,
    // which is well within the safe integer limit.

    let leftSum = 0; // Sum of elements to the left of the current index
    for (let i = 0; i < n; i++) {
        // Calculate rightSum: totalSum - leftSum - current_element
        // If leftSum == rightSum, we found the index
        if (leftSum === (totalSum - leftSum - arr[i])) {
            return i; // Return the first (lowest) such index found
        }
        // Add current element to leftSum for the next iteration
        leftSum += arr[i];
    }

    return -1; // No sum symmetry index found
}","#include <iostream>
#include <vector>
#include <numeric> // Required for std::accumulate if used

// Function to find the sum symmetry index
int findSumSymmetryIndex(const std::vector<int>& arr) {
    int n = arr.size();
    if (n == 0) {
        return -1; // No elements, no symmetry index
    }

    long long totalSum = 0; // Use long long to prevent potential overflow
    for (int x : arr) {
        totalSum += x;
    }
    // Alternative using std::accumulate:
    // long long totalSum = std::accumulate(arr.begin(), arr.end(), 0LL);

    long long leftSum = 0; // Sum of elements to the left of the current index
    for (int i = 0; i < n; ++i) {
        // Calculate rightSum: totalSum - leftSum - current_element
        // If leftSum == rightSum, we found the index
        if (leftSum == (totalSum - leftSum - arr[i])) {
            return i; // Return the first (lowest) such index found
        }
        // Add current element to leftSum for the next iteration
        leftSum += arr[i];
    }

    return -1; // No sum symmetry index found
}

int main() {
    // Optimize C++ standard streams for faster I/O
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    std::vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i];
    }

    int result = findSumSymmetryIndex(arr);
    std::cout << result << std::endl;

    return 0;
}",4.4
Yellow-66,Linear Search,"*   Linear Search
*   Arrays
*   Iteration (Loops)
*   Conditional Statements
*   Counters","You are given an array of integers and a target integer. You are also given an integer `k`. Your task is to implement a function that finds the 0-based index of the *k*-th occurrence of the `target` integer in the array. If the target appears fewer than `k` times, or if the target is not present at all, return -1.","* `1 <= n <= 1000` (where `n` is the number of elements in the array)
* `1 <= k <= n`
* `-10^9 <= arr[i] <= 10^9`
* `-10^9 <= target <= 10^9`","5
10 20 30 20 50
20
2

####","3

####","Input: 7
1 5 8 12 13 15 18
13
1
Output: 4
Input: 8
10 20 30 20 40 20 50 20
20
3
Output: 5
Input: 5
1 2 3 2 1
1
3
Output: -1
Input: 4
1 2 3 4
99
1
Output: -1
Input: 1
42
42
1
Output: 0
Input: 6
5 5 5 5 5 5
5
6
Output: 5
Input: 5
10 20 10 30 10
10
4
Output: -1","#include <stdio.h>

// Function to find the k-th occurrence of a target using linear search
int findKthOccurrence(int arr[], int n, int target, int k) {
    int count = 0; // Initialize counter for occurrences
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            count++; // Increment count on target match
            if (count == k) {
                return i; // k-th occurrence found, return its index
            }
        }
    }
    return -1; // Target not found k times
}

int main() {
    int n;
    scanf(""%d"", &n);

    int arr[n]; // VLA for simplicity, though dynamic allocation or fixed size is safer for larger N
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]);
    }

    int target;
    scanf(""%d"", &target);
    
    int k;
    scanf(""%d"", &k);

    int result = findKthOccurrence(arr, n, target, k);
    printf(""%d\n"", result);

    return 0;
}","def find_kth_occurrence(arr, target, k):
    count = 0  # Initialize counter for occurrences
    for i in range(len(arr)):
        if arr[i] == target:
            count += 1  # Increment count on target match
            if count == k:
                return i  # k-th occurrence found, return its index
    return -1  # Target not found k times

if __name__ == '__main__':
    n = int(input())
    arr = list(map(int, input().split()))
    target = int(input())
    k = int(input())

    result = find_kth_occurrence(arr, target, k)
    print(result)","import java.util.Scanner;

public class Solution {

    // Function to find the k-th occurrence of a target using linear search
    public int findKthOccurrence(int[] arr, int target, int k) {
        int count = 0; // Initialize counter for occurrences
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                count++; // Increment count on target match
                if (count == k) {
                    return i; // k-th occurrence found, return its index
                }
            }
        }
        return -1; // Target not found k times
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        int target = scanner.nextInt();
        int k = scanner.nextInt();

        Solution sol = new Solution();
        int result = sol.findKthOccurrence(arr, target, k);
        System.out.println(result);

        scanner.close();
    }
}","function findKthOccurrence(arr, target, k) {
    let count = 0; // Initialize counter for occurrences
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            count++; // Increment count on target match
            if (count === k) {
                return i; // k-th occurrence found, return its index
            }
        }
    }
    return -1; // Target not found k times
}

// To handle input/output in a typical competitive programming environment
// This part is for local testing or specific online judges. For browser env, you'd call findKthOccurrence directly.
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let inputLines = [];
rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    const n = parseInt(inputLines[0]);
    const arr = inputLines[1].split(' ').map(Number);
    const target = parseInt(inputLines[2]);
    const k = parseInt(inputLines[3]); // Read k as well

    const result = findKthOccurrence(arr, target, k);
    console.log(result);
});","#include <iostream>
#include <vector>

// Function to find the k-th occurrence of a target using linear search
int findKthOccurrence(const std::vector<int>& arr, int target, int k) {
    int count = 0; // Initialize counter for occurrences
    for (int i = 0; i < arr.size(); ++i) {
        if (arr[i] == target) {
            count++; // Increment count on target match
            if (count == k) {
                return i; // k-th occurrence found, return its index
            }
        }
    }
    return -1; // Target not found k times
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    std::vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i];
    }

    int target;
    std::cin >> target;

    int k;
    std::cin >> k;

    int result = findKthOccurrence(arr, target, k);
    std::cout << result << std::endl;

    return 0;
}",4.4
Yellow-67,Recursive Sequences (Tribonacci),"*   Recursion
*   Base Cases
*   Recursive Step
*   Call Stack","The Tribonacci sequence is a fascinating extension of the classic Fibonacci sequence. Instead of each number being the sum of the two preceding ones, in the Tribonacci sequence, each number is the sum of the **three** preceding numbers.

A common definition of the sequence starts with:
*   T(0) = 0
*   T(1) = 1
*   T(2) = 1

For any `n > 2`, the `n`-th Tribonacci number, T(n), is defined as:
`T(n) = T(n-1) + T(n-2) + T(n-3)`

Your task is to implement a recursive function that calculates the `n`-th Tribonacci number. Given a non-negative integer `n`, return the `n`-th Tribonacci number based on the definition above.",*   `0 <= n <= 15`,5,7,"Input: 0
Output: 0
Input: 1
Output: 1
Input: 2
Output: 1
Input: 3
Output: 2
Input: 5
Output: 7
Input: 10
Output: 149
Input: 15
Output: 3136","#include <stdio.h>

// Function to calculate the n-th Tribonacci number recursively
int tribonacci(int n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 1;
    }
    // For n > 2
    return tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);
}

int main() {
    int n;

    // Read input from stdin
    if (scanf(""%d"", &n) != 1) {
        return 1; // Error reading input
    }

    // Calculate and print the result to stdout
    printf(""%d\n"", tribonacci(n));

    return 0;
}","import sys

def tribonacci(n):
    """"""
    Calculates the n-th Tribonacci number recursively.
    """"""
    if n == 0:
        return 0
    elif n == 1:
        return 1
    elif n == 2:
        return 1
    else:
        return tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3)

def main():
    # Read input from stdin
    n = int(sys.stdin.readline().strip())

    # Calculate and print the result to stdout
    sys.stdout.write(str(tribonacci(n)) + ""\n"")

if __name__ == ""__main__"":
    main()","import java.util.Scanner;

public class Solution {

    // Function to calculate the n-th Tribonacci number recursively
    public int tribonacci(int n) {
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        if (n == 2) {
            return 1;
        }
        // For n > 2
        return tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read input from stdin
        int n = scanner.nextInt();
        scanner.close();

        Solution sol = new Solution();
        // Calculate and print the result to stdout
        System.out.println(sol.tribonacci(n));
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

// Function to calculate the n-th Tribonacci number recursively
function tribonacci(n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 1;
    }
    // For n > 2
    return tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);
}

rl.on('line', (line) => {
    const n = parseInt(line.trim(), 10);
    // Calculate and print the result to stdout
    console.log(tribonacci(n));
    rl.close();
});","#include <iostream>

// Function to calculate the n-th Tribonacci number recursively
int tribonacci(int n) {
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 1;
    }
    // For n > 2
    return tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);
}

int main() {
    int n;

    // Read input from stdin
    std::cin >> n;

    // Calculate and print the result to stdout
    std::cout << tribonacci(n) << std::endl;

    return 0;
}",4.4
Yellow-68,Prefix & Suffix Sums,"- Prefix Sums
- Array manipulation
- Efficient range querying","You are given an array of integers, `nums`, and a list of queries. Each query consists of two indices, `L` and `R`, representing a range within the `nums` array. Your task is to calculate the sum of all elements in the `nums` array from index `L` to `R` (inclusive) for each query.","- `1 <= N <= 10^5` (where N is the length of `nums`)
- `-10^9 <= nums[i] <= 10^9`
- `1 <= Q <= 10^5` (where Q is the number of queries)
- `0 <= L <= R < N` for each query","N = 5
nums = [1, 2, 3, 4, 5]
Q = 3
queries = [[0, 2], [1, 3], [2, 4]]","6
9
12","Input: 1
100
1
0 0
Output: 100
Input: 7
-5 10 -3 8 -1 20 0
4
0 6
1 3
4 4
0 0
Output: 29
15
-1
-5
Input: 10
1 2 3 4 5 6 7 8 9 10
3
0 9
0 0
9 9
Output: 55
1
10
Input: 6
0 0 10 20 0 0
5
0 0
1 5
2 3
0 5
4 4
Output: 0
30
30
30
0","#include <stdio.h>
#include <stdlib.h>

// Function to calculate range sums using prefix sums
// n: size of the nums array
// nums: the input array
// q_count: number of queries
// queries: 2D array of queries, each query is {L, R}
// Returns an array of sums for each query.
long long* calculateRangeSums(int n, int* nums, int q_count, int queries[][2]) {
    // Allocate memory for prefix sum array
    // prefixSum[i] stores sum of nums[0]...nums[i-1]
    // prefixSum[0] = 0
    long long* prefixSum = (long long*)malloc((n + 1) * sizeof(long long));
    if (prefixSum == NULL) {
        // Handle memory allocation failure
        return NULL;
    }
    prefixSum[0] = 0;

    // Build prefix sum array
    for (int i = 0; i < n; i++) {
        prefixSum[i + 1] = prefixSum[i] + nums[i];
    }

    // Allocate memory for results
    long long* results = (long long*)malloc(q_count * sizeof(long long));
    if (results == NULL) {
        free(prefixSum); // Clean up
        return NULL;
    }

    // Process queries
    for (int i = 0; i < q_count; i++) {
        int L = queries[i][0];
        int R = queries[i][1];
        results[i] = prefixSum[R + 1] - prefixSum[L];
    }

    free(prefixSum); // Free prefix sum array as it's no longer needed
    return results;
}

int main() {
    int N;
    scanf(""%d"", &N);

    int* nums = (int*)malloc(N * sizeof(int));
    if (nums == NULL) {
        return 1; // Memory allocation failed
    }
    for (int i = 0; i < N; i++) {
        scanf(""%d"", &nums[i]);
    }

    int Q;
    scanf(""%d"", &Q);

    // Queries are 2D array, Q rows, 2 columns {L, R}
    int (*queries)[2] = malloc(Q * sizeof(int[2]));
    if (queries == NULL) {
        free(nums);
        return 1; // Memory allocation failed
    }

    for (int i = 0; i < Q; i++) {
        scanf(""%d %d"", &queries[i][0], &queries[i][1]);
    }

    long long* sums = calculateRangeSums(N, nums, Q, queries);

    if (sums != NULL) {
        for (int i = 0; i < Q; i++) {
            printf(""%lld\n"", sums[i]);
        }
        free(sums); // Free results array
    } else {
        // Handle error if calculateRangeSums returned NULL
        printf(""Error: Could not calculate sums.\n"");
    }

    free(nums);
    free(queries);

    return 0;
}","import sys

# Function to calculate range sums using prefix sums
# nums: the input list
# queries: list of lists/tuples, each query is [L, R]
# Returns a list of sums for each query.
def calculate_range_sums(nums, queries):
    n = len(nums)
    # prefix_sum[i] stores sum of nums[0]...nums[i-1]
    # prefix_sum[0] = 0
    prefix_sum = [0] * (n + 1)

    # Build prefix sum array
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]

    results = []
    # Process queries
    for L, R in queries:
        results.append(prefix_sum[R + 1] - prefix_sum[L])
    
    return results

def main():
    input = sys.stdin.readline
    
    N = int(input())
    nums = list(map(int, input().split()))

    Q = int(input())
    queries = []
    for _ in range(Q):
        L, R = map(int, input().split())
        queries.append([L, R])

    sums = calculate_range_sums(nums, queries)

    for s in sums:
        sys.stdout.write(str(s) + ""\n"")

if __name__ == ""__main__"":
    main()","import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.PrintWriter;
import java.util.ArrayList;
import java.util.List;

public class Solution {

    // Function to calculate range sums using prefix sums
    // nums: the input array
    // queries: 2D array of queries, each query is {L, R}
    // Returns a list of sums for each query.
    public List<Long> calculateRangeSums(int[] nums, int[][] queries) {
        int n = nums.length;
        // prefixSum[i] stores sum of nums[0]...nums[i-1]
        // prefixSum[0] = 0
        long[] prefixSum = new long[n + 1];
        prefixSum[0] = 0;

        // Build prefix sum array
        for (int i = 0; i < n; i++) {
            prefixSum[i + 1] = prefixSum[i] + nums[i];
        }

        List<Long> results = new ArrayList<>();

        // Process queries
        for (int[] query : queries) {
            int L = query[0];
            int R = query[1];
            results.add(prefixSum[R + 1] - prefixSum[L]);
        }

        return results;
    }

    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        PrintWriter pw = new PrintWriter(System.out);
        Solution sol = new Solution();

        int N = Integer.parseInt(br.readLine());
        int[] nums = new int[N];
        String[] numStr = br.readLine().split("" "");
        for (int i = 0; i < N; i++) {
            nums[i] = Integer.parseInt(numStr[i]);
        }

        int Q = Integer.parseInt(br.readLine());
        int[][] queries = new int[Q][2];
        for (int i = 0; i < Q; i++) {
            String[] queryStr = br.readLine().split("" "");
            queries[i][0] = Integer.parseInt(queryStr[0]);
            queries[i][1] = Integer.parseInt(queryStr[1]);
        }

        List<Long> sums = sol.calculateRangeSums(nums, queries);

        for (long sum : sums) {
            pw.println(sum);
        }

        pw.flush();
        pw.close();
        br.close();
    }
}","// Function to calculate range sums using prefix sums
// nums: the input array
// queries: array of arrays, each query is [L, R]
// Returns an array of sums for each query.
function calculateRangeSums(nums, queries) {
    const n = nums.length;
    // prefixSum[i] stores sum of nums[0]...nums[i-1]
    // prefixSum[0] = 0
    const prefixSum = new Array(n + 1).fill(0);

    // Build prefix sum array
    for (let i = 0; i < n; i++) {
        prefixSum[i + 1] = prefixSum[i] + nums[i];
    }

    const results = [];
    // Process queries
    for (const query of queries) {
        const L = query[0];
        const R = query[1];
        results.push(prefixSum[R + 1] - prefixSum[L]);
    }

    return results;
}

function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let lines = [];
    rl.on('line', (line) => {
        lines.push(line);
    }).on('close', () => {
        let lineIdx = 0;

        const N = parseInt(lines[lineIdx++]);
        const nums = lines[lineIdx++].split(' ').map(Number);

        const Q = parseInt(lines[lineIdx++]);
        const queries = [];
        for (let i = 0; i < Q; i++) {
            queries.push(lines[lineIdx++].split(' ').map(Number));
        }

        const sums = calculateRangeSums(nums, queries);

        sums.forEach(sum => console.log(sum));
    });
}

// Call main function to start program execution
main();","#include <iostream>
#include <vector>
#include <numeric> // For std::partial_sum, though we'll implement manually for prefix sum

// Function to calculate range sums using prefix sums
// nums: the input vector
// queries: vector of pairs, each pair is {L, R}
// Returns a vector of sums for each query.
std::vector<long long> calculateRangeSums(const std::vector<int>& nums, const std::vector<std::pair<int, int>>& queries) {
    int n = nums.size();
    // prefixSum[i] stores sum of nums[0]...nums[i-1]
    // prefixSum[0] = 0
    std::vector<long long> prefixSum(n + 1, 0);

    // Build prefix sum array
    for (int i = 0; i < n; i++) {
        prefixSum[i + 1] = prefixSum[i] + nums[i];
    }

    std::vector<long long> results;
    results.reserve(queries.size()); // Pre-allocate memory

    // Process queries
    for (const auto& query : queries) {
        int L = query.first;
        int R = query.second;
        results.push_back(prefixSum[R + 1] - prefixSum[L]);
    }

    return results;
}

int main() {
    std::ios_base::sync_with_stdio(false); // Optimize C++ standard streams for faster I/O
    std::cin.tie(NULL);

    int N;
    std::cin >> N;

    std::vector<int> nums(N);
    for (int i = 0; i < N; i++) {
        std::cin >> nums[i];
    }

    int Q;
    std::cin >> Q;

    std::vector<std::pair<int, int>> queries(Q);
    for (int i = 0; i < Q; i++) {
        std::cin >> queries[i].first >> queries[i].second;
    }

    std::vector<long long> sums = calculateRangeSums(nums, queries);

    for (long long sum : sums) {
        std::cout << sum << ""\n"";
    }

    return 0;
}",4.4
Yellow-69,Infix to Postfix Conversion,"*   Stack data structure
*   Operator precedence rules
*   Associativity of operators
*   Parsing expressions","Imagine you're developing the core logic for a specialized processor or an efficient calculator that only understands mathematical operations in a specific way: Postfix Notation (also known as Reverse Polish Notation, or RPN). In this format, operators are placed *after* their operands (e.g., `A B +` instead of `A + B`). This ""machine-friendly"" format simplifies evaluation because it eliminates the need for parentheses to define the order of operations and can be processed directly using a stack.

Your mission is to act as a ""language translator"" for this processor. You need to write a program that takes a standard mathematical expression (Infix notation), which is how humans usually write it, and converts it into its equivalent Postfix expression. This translation requires carefully handling operator precedence (like multiplication before addition) and parentheses.","*   The input `infix_expression` will be a string containing uppercase English letters (A-Z) as operands (representing variables or simple values), and the operators `+`, `-`, `*`, `/`, `^` (for exponentiation), `(`, and `)`.
*   All operands are single characters.
*   The input expression will be valid (balanced parentheses, valid operator/operand placement) – you don't need to validate it.
*   Operator precedence (from highest to lowest): `^` > `*`, `/` > `+`, `-`.
*   Associativity: `^` is right-associative, `*`, `/`, `+`, `-` are left-associative.
*   The length of the `infix_expression` will be between 1 and 100 characters.
*   No spaces in the input string.",`A+B*C`,`ABC*+`,"Input: (A+B)*C-D
Output: AB+C*D-
Input: A/B-C*D+E
Output: AB/CD*-E+
Input: A*(B+C/(D-E))
Output: ABCDE-/+*
Input: A^B+C*D
Output: AB^CD*+
Input: ((A+B)*C)^D
Output: AB+C*D^","#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

#define MAX_STACK_SIZE 101 // Max expression length is 100 + 1 for null terminator

// Stack implementation (global for simplicity in C, can be passed as context)
char stack[MAX_STACK_SIZE];
int top_idx = -1; // Renamed 'top' to 'top_idx' to avoid conflicts with peek/pop logic

void push(char c) {
    if (top_idx >= MAX_STACK_SIZE - 1) {
        // Stack overflow, not expected with given constraints and valid input
        fprintf(stderr, ""Stack overflow\n"");
        exit(EXIT_FAILURE);
    }
    stack[++top_idx] = c;
}

char pop() {
    if (top_idx == -1) {
        // Stack underflow, should not happen with valid input
        fprintf(stderr, ""Stack underflow\n"");
        return '\0';
    }
    return stack[top_idx--];
}

char peek() {
    if (top_idx == -1) {
        return '\0'; // Indicate empty stack
    }
    return stack[top_idx];
}

int isEmpty() {
    return top_idx == -1;
}

// Helper functions
int getPrecedence(char op) {
    if (op == '+' || op == '-') return 1;
    if (op == '*' || op == '/') return 2;
    if (op == '^') return 3;
    return 0; // Not an operator or parenthesis
}

int isRightAssociative(char op) {
    return op == '^';
}

int isOperator(char c) {
    return c == '+' || c == '-' || c == '*' || c == '/' || c == '^';
}

int isOperand(char c) {
    return isupper(c); // Operands are A-Z
}

char* infixToPostfix(const char* infix) {
    int len = strlen(infix);
    char* postfix = (char*)malloc(sizeof(char) * (len + 1));
    if (postfix == NULL) {
        fprintf(stderr, ""Memory allocation failed\n"");
        exit(EXIT_FAILURE);
    }
    int k = 0; // Index for postfix expression
    top_idx = -1; // Reset stack for each call

    for (int i = 0; i < len; i++) {
        char c = infix[i];

        if (isOperand(c)) {
            postfix[k++] = c;
        } else if (c == '(') {
            push(c);
        } else if (c == ')') {
            while (!isEmpty() && peek() != '(') {
                postfix[k++] = pop();
            }
            if (!isEmpty() && peek() == '(') {
                pop(); // Pop '('
            }
            // else: Unbalanced parentheses, but constraints guarantee balanced
        } else if (isOperator(c)) {
            while (!isEmpty() && peek() != '(' &&
                   (getPrecedence(peek()) > getPrecedence(c) ||
                    (getPrecedence(peek()) == getPrecedence(c) && !isRightAssociative(c)))) {
                postfix[k++] = pop();
            }
            push(c);
        }
    }

    while (!isEmpty()) {
        postfix[k++] = pop();
    }
    postfix[k] = '\0'; // Null-terminate the postfix string

    return postfix;
}

int main() {
    char infix_expression[MAX_STACK_SIZE];
    if (scanf(""%s"", infix_expression) != 1) {
        fprintf(stderr, ""Failed to read input.\n"");
        return 1;
    }

    char* postfix_expression = infixToPostfix(infix_expression);
    printf(""%s\n"", postfix_expression);

    free(postfix_expression); // Free dynamically allocated memory
    return 0;
}","def get_precedence(op):
    if op in ('+', '-'):
        return 1
    if op in ('*', '/'):
        return 2
    if op == '^':
        return 3
    return 0

def is_right_associative(op):
    return op == '^'

def is_operator(char):
    return char in ('+', '-', '*', '/', '^')

def is_operand(char):
    return 'A' <= char <= 'Z'

def infix_to_postfix(infix_expression):
    postfix = []
    stack = []

    for char in infix_expression:
        if is_operand(char):
            postfix.append(char)
        elif char == '(':{
            stack.append(char)
        elif char == ')':
            while stack and stack[-1] != '(':{
                postfix.append(stack.pop())
            if stack: # Pop '('
                stack.pop()
            # else: Unbalanced parentheses, but constraints guarantee balanced
        elif is_operator(char):
            while stack and stack[-1] != '(' and \
                  (get_precedence(stack[-1]) > get_precedence(char) or \
                   (get_precedence(stack[-1]) == get_precedence(char) and not is_right_associative(char))):
                postfix.append(stack.pop())
            stack.append(char)
    
    while stack:
        postfix.append(stack.pop())

    return """".join(postfix)

if __name__ == ""__main__"":
    infix_input = input()
    postfix_output = infix_to_postfix(infix_input)
    print(postfix_output)","import java.util.Stack;
import java.util.Scanner;

public class InfixToPostfixConverter {

    // Helper functions
    private static int getPrecedence(char op) {
        if (op == '+' || op == '-') return 1;
        if (op == '*' || op == '/') return 2;
        if (op == '^') return 3;
        return 0; // Not an operator or parenthesis
    }

    private static boolean isRightAssociative(char op) {
        return op == '^';
    }

    private static boolean isOperator(char c) {
        return c == '+' || c == '-' || c == '*' || c == '/' || c == '^';
    }

    private static boolean isOperand(char c) {
        return Character.isUpperCase(c); // Operands are A-Z
    }

    public static String infixToPostfix(String infix) {
        StringBuilder postfix = new StringBuilder();
        Stack<Character> stack = new Stack<>();

        for (char c : infix.toCharArray()) {
            if (isOperand(c)) {
                postfix.append(c);
            } else if (c == '(') {
                stack.push(c);
            } else if (c == ')') {
                while (!stack.isEmpty() && stack.peek() != '(') {
                    postfix.append(stack.pop());
                }
                if (!stack.isEmpty()) { // Pop '('
                    stack.pop();
                }
                // else: Unbalanced parentheses, but constraints guarantee balanced
            } else if (isOperator(c)) {
                while (!stack.isEmpty() && stack.peek() != '(' &&
                       (getPrecedence(stack.peek()) > getPrecedence(c) ||
                        (getPrecedence(stack.peek()) == getPrecedence(c) && !isRightAssociative(c)))) {
                    postfix.append(stack.pop());
                }
                stack.push(c);
            }
        }

        while (!stack.isEmpty()) {
            postfix.append(stack.pop());
        }

        return postfix.toString();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String infixExpression = scanner.nextLine();
        scanner.close();

        String postfixExpression = infixToPostfix(infixExpression);
        System.out.println(postfixExpression);
    }
}","function getPrecedence(op) {
    if (op === '+' || op === '-') return 1;
    if (op === '*' || op === '/') return 2;
    if (op === '^') return 3;
    return 0; // Not an operator or parenthesis
}

function isRightAssociative(op) {
    return op === '^';
}

function isOperator(char) {
    return ['+', '-', '*', '/', '^'].includes(char);
}

function isOperand(char) {
    return char >= 'A' && char <= 'Z';
}

function infixToPostfix(infixExpression) {
    let postfix = [];
    let stack = [];

    for (let i = 0; i < infixExpression.length; i++) {
        let char = infixExpression[i];

        if (isOperand(char)) {
            postfix.push(char);
        } else if (char === '(') {
            stack.push(char);
        } else if (char === ')') {
            while (stack.length > 0 && stack[stack.length - 1] !== '(') {
                postfix.push(stack.pop());
            }
            if (stack.length > 0) { // Pop '('
                stack.pop();
            }
            // else: Unbalanced parentheses, but constraints guarantee balanced
        } else if (isOperator(char)) {
            while (stack.length > 0 && stack[stack.length - 1] !== '(' &&
                   (getPrecedence(stack[stack.length - 1]) > getPrecedence(char) ||
                    (getPrecedence(stack[stack.length - 1]) === getPrecedence(char) && !isRightAssociative(char)))) {
                postfix.push(stack.pop());
            }
            stack.push(char);
        }
    }

    while (stack.length > 0) {
        postfix.push(stack.pop());
    }

    return postfix.join('');
}

// For competitive programming environments, input/output typically uses process.stdin/stdout
// Example for Node.js environment:
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.on('line', (line) => {
    const infixInput = line.trim();
    const postfixOutput = infixToPostfix(infixInput);
    console.log(postfixOutput);
    rl.close();
});","#include <iostream>
#include <string>
#include <stack>
#include <cctype> // For isupper

// Helper functions
int getPrecedence(char op) {
    if (op == '+' || op == '-') return 1;
    if (op == '*' || op == '/') return 2;
    if (op == '^') return 3;
    return 0; // Not an operator or parenthesis
}

bool isRightAssociative(char op) {
    return op == '^';
}

bool isOperator(char c) {
    return c == '+' || c == '-' || c == '*' || c == '/' || c == '^';
}

bool isOperand(char c) {
    return std::isupper(c); // Operands are A-Z
}

std::string infixToPostfix(const std::string& infix) {
    std::string postfix = """";
    std::stack<char> s;

    for (char c : infix) {
        if (isOperand(c)) {
            postfix += c;
        } else if (c == '(') {
            s.push(c);
        } else if (c == ')') {
            while (!s.empty() && s.top() != '(') {
                postfix += s.top();
                s.pop();
            }
            if (!s.empty()) { // Pop '('
                s.pop();
            }
            // else: Unbalanced parentheses, but constraints guarantee balanced
        } else if (isOperator(c)) {
            while (!s.empty() && s.top() != '(' &&
                   (getPrecedence(s.top()) > getPrecedence(c) ||
                    (getPrecedence(s.top()) == getPrecedence(c) && !isRightAssociative(c)))) {
                postfix += s.top();
                s.pop();
            }
            s.push(c);
        }
    }

    while (!s.empty()) {
        postfix += s.top();
        s.pop();
    }

    return postfix;
}

int main() {
    std::string infix_expression;
    std::cin >> infix_expression;

    std::string postfix_expression = infixToPostfix(infix_expression);
    std::cout << postfix_expression << std::endl;

    return 0;
}",4.2
Yellow-70,Character Hashing,"*   String Iteration
*   Character Manipulation (case conversion, checking if character is alphabetic)
*   Hash Maps (or frequency arrays as a basic form of hashing)
*   Basic I/O operations","You are given a string `s`. Your task is to count the frequency of each alphabetical character (a-z, case-insensitive) present in the string. The result should be a collection of character-count pairs, where each character is represented in lowercase. Characters that are not alphabetical should be ignored.","*   The length of the string `s` will be between 0 and 1000 characters.
*   The string `s` can contain uppercase letters, lowercase letters, numbers, spaces, and special characters.
*   Only English alphabetical characters (A-Z, a-z) should be counted.
*   The output should represent counts for lowercase characters. If 'A' and 'a' both appear, their counts should be combined under 'a'.
*   If a character does not appear, it should not be included in the output.","""Hello World!""","{'h': 1, 'e': 1, 'l': 3, 'o': 2, 'w': 1, 'r': 1, 'd': 1}","Input: Programming is fun!
Output: {'a': 1, 'f': 1, 'g': 2, 'i': 2, 'm': 2, 'n': 1, 'o': 1, 'p': 1, 'r': 2, 's': 1, 'u': 1}
Input: AaBbCc123!@#
Output: {'a': 2, 'b': 2, 'c': 2}
Input: zzzyyyxxx
Output: {'x': 3, 'y': 3, 'z': 3}
Input: 12345
Output: {}
Input: ","#include <stdio.h>
#include <string.h>
#include <ctype.h>  // For tolower, isalpha

// Function to count character frequencies
void char_frequency_counter(const char *s, int *counts) {
    // Initialize counts to zero
    for (int i = 0; i < 26; i++) {
        counts[i] = 0;
    }

    // Iterate through the string
    int i = 0;
    while (s[i] != '\0') {
        char c = s[i];
        if (isalpha(c)) { // Check if it's an alphabet character
            char lower_c = tolower(c); // Convert to lowercase
            counts[lower_c - 'a']++; // Increment count for the corresponding index
        }
        i++;
    }
}

int main() {
    char input_buffer[1001]; // Max 1000 chars + null terminator
    
    if (fgets(input_buffer, sizeof(input_buffer), stdin) == NULL) {
        return 1; // Error reading input
    }

    // Remove newline character if present
    input_buffer[strcspn(input_buffer, ""\n"")] = 0;

    int counts[26]; // Array to store counts for 'a' through 'z'

    char_frequency_counter(input_buffer, counts);

    // Print the results in a JSON-like format: {'char': count, ...}
    int first_pair = 1;
    printf(""{"");
    for (int i = 0; i < 26; i++) {
        if (counts[i] > 0) {
            if (!first_pair) {
                printf("", "");
            }
            printf(""'%c': %d"", (char)('a' + i), counts[i]);
            first_pair = 0;
        }
    }
    printf(""}\n"");

    return 0;
}","import sys

def char_frequency_counter(s: str) -> dict:
    counts = {}
    for char in s:
        if char.isalpha(): # Check if it's an alphabet character
            lower_char = char.lower() # Convert to lowercase
            counts[lower_char] = counts.get(lower_char, 0) + 1 # Increment count
    return counts

def main():
    s = sys.stdin.readline().strip() # Read entire line from stdin and strip newline

    frequencies = char_frequency_counter(s)

    # Print the results in a JSON-like format: {'char': count, ...}
    output_parts = []
    for char in sorted(frequencies.keys()): # Sort keys for consistent output
        output_parts.append(f""'{char}': {frequencies[char]}"")
    
    print(""{"" + "", "".join(output_parts) + ""}"")

if __name__ == ""__main__"":
    main()","import java.util.HashMap;
import java.util.Map;
import java.util.Scanner;
import java.util.TreeMap; // For sorted output, though HashMap is also fine

public class Solution {

    public static Map<Character, Integer> charFrequencyCounter(String s) {
        // Using TreeMap to ensure keys are sorted for consistent output, 
        // though HashMap is also functionally correct per problem. 
        Map<Character, Integer> counts = new TreeMap<>();

        for (char c : s.toCharArray()) {
            if (Character.isLetter(c)) { // Check if it's an alphabet character
                char lowerC = Character.toLowerCase(c); // Convert to lowercase
                counts.put(lowerC, counts.getOrDefault(lowerC, 0) + 1); // Increment count
            }
        }
        return counts;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine(); // Read entire line from stdin
        scanner.close();

        Map<Character, Integer> frequencies = charFrequencyCounter(s);

        // Print the results in a JSON-like format: {'char': count, ...}
        StringBuilder sb = new StringBuilder(""{"");
        boolean firstPair = true;
        for (Map.Entry<Character, Integer> entry : frequencies.entrySet()) {
            if (!firstPair) {
                sb.append("", "");
            }
            sb.append(""'"").append(entry.getKey()).append(""': "").append(entry.getValue());
            firstPair = false;
        }
        sb.append(""}"");
        System.out.println(sb.toString());
    }
}","function charFrequencyCounter(s) {
    const counts = {}; // Use a plain object as a hash map

    for (let i = 0; i < s.length; i++) {
        const char = s[i];
        // Check if it's an alphabet character (case-insensitive)
        if (char.match(/^[a-zA-Z]$/)) { 
            const lowerChar = char.toLowerCase(); // Convert to lowercase
            counts[lowerChar] = (counts[lowerChar] || 0) + 1; // Increment count
        }
    }
    return counts;
}

function main() {
    // Read input from stdin
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    rl.on('line', (line) => {
        const frequencies = charFrequencyCounter(line);
        
        // Print the results in a JSON-like format: {'char': count, ...}
        // Sort keys for consistent output, as object key iteration order is not guaranteed to be lexical.
        const sortedKeys = Object.keys(frequencies).sort();
        const outputParts = sortedKeys.map(key => `'${key}': ${frequencies[key]}`);
        console.log(`{${outputParts.join(', ')}}`);
        
        rl.close();
    });
}

// Call main function to start program
main();","#include <iostream>
#include <string>
#include <vector>
#include <cctype> // For std::tolower, std::isalpha
#include <map>    // To store and print results easily

// Function to count character frequencies
std::map<char, int> charFrequencyCounter(const std::string& s) {
    std::map<char, int> counts; // Using a map to store frequencies

    for (char c : s) {
        if (std::isalpha(c)) { // Check if it's an alphabet character
            char lower_c = std::tolower(c); // Convert to lowercase
            counts[lower_c]++; // Increment count
        }
    }
    return counts;
}

int main() {
    std::string s;
    std::getline(std::cin, s); // Read entire line from stdin

    std::map<char, int> frequencies = charFrequencyCounter(s);

    // Print the results in a JSON-like format: {'char': count, ...}
    std::cout << ""{"";
    bool first_pair = true;
    for (const auto& pair : frequencies) {
        if (!first_pair) {
            std::cout << "", "";
        }
        std::cout << ""'"" << pair.first << ""': "" << pair.second;
        first_pair = false;
    }
    std::cout << ""}\n"";

    return 0;
}",4.2
Yellow-71,Prefix & Suffix Sums,"*   Prefix Sums
*   Array Manipulation
*   Efficient Range Query Processing","Given an array of integers and several queries, for each query, you need to find the sum of elements within a specified range `[L, R]` (inclusive).","*   `1 <= N <= 1000` (Array size)
*   `1 <= Q <= 500` (Number of queries)
*   `-1000 <= arr[i] <= 1000` (Element values)
*   `0 <= L <= R < N` (Query range indices)","5
1 2 3 4 5
3
0 2
1 3
2 4


####","6
9
12


####","Input: 6
10 20 5 15 30 25
4
0 0
0 5
2 2
1 4
Output: 10
105
5
70
Input: 4
-5 0 10 -3
2
0 3
1 2
Output: 2
10
Input: 1
100
1
0 0
Output: 100
Input: 7
1 2 3 4 5 6 7
5
0 6
3 5
1 1
0 3
4 6
Output: 28
15
2
10
18","#include <stdio.h>
#include <stdlib.h> // For malloc and free

// Function to calculate prefix sums and then answer queries
void calculateRangeSums(int* arr, int n, int* queries_L, int* queries_R, int q) {
    long long* prefixSums = (long long*) malloc((n + 1) * sizeof(long long));
    if (prefixSums == NULL) {
        // Handle allocation error if needed
        return;
    }
    prefixSums[0] = 0;
    for (int i = 0; i < n; i++) {
        prefixSums[i + 1] = prefixSums[i] + arr[i];
    }

    for (int i = 0; i < q; i++) {
        int L = queries_L[i];
        int R = queries_R[i];
        long long rangeSum = prefixSums[R + 1] - prefixSums[L];
        printf(""%lld\n"", rangeSum);
    }

    free(prefixSums);
}

int main() {
    int n;
    scanf(""%d"", &n);

    int* arr = (int*) malloc(n * sizeof(int));
    if (arr == NULL) {
        return 1; // Error allocating memory
    }
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]);
    }

    int q;
    scanf(""%d"", &q);

    int* queries_L = (int*) malloc(q * sizeof(int));
    int* queries_R = (int*) malloc(q * sizeof(int));
    if (queries_L == NULL || queries_R == NULL) {
        free(arr);
        free(queries_L);
        free(queries_R);
        return 1; // Error allocating memory
    }

    for (int i = 0; i < q; i++) {
        scanf(""%d %d"", &queries_L[i], &queries_R[i]);
    }

    calculateRangeSums(arr, n, queries_L, queries_R, q);

    free(arr);
    free(queries_L);
    free(queries_R);

    return 0;
}","def calculate_range_sums(arr, queries):
    n = len(arr)
    # prefix_sums[i] stores the sum of elements from arr[0] to arr[i-1]
    # So, prefix_sums has size n+1, with prefix_sums[0] = 0
    prefix_sums = [0] * (n + 1)
    for i in range(n):
        prefix_sums[i + 1] = prefix_sums[i] + arr[i]

    for L, R in queries:
        # Sum of arr[L...R] = (sum of arr[0...R]) - (sum of arr[0...L-1])
        # Which is prefix_sums[R+1] - prefix_sums[L]
        range_sum = prefix_sums[R + 1] - prefix_sums[L]
        print(range_sum)

if __name__ == ""__main__"":
    n = int(input())
    arr = list(map(int, input().split()))

    q = int(input())
    queries = []
    for _ in range(q):
        L, R = map(int, input().split())
        queries.append((L, R))

    calculate_range_sums(arr, queries)","import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

public class Solution {

    public static void calculateRangeSums(int[] arr, int[] queryL, int[] queryR) {
        int n = arr.length;
        long[] prefixSums = new long[n + 1];
        prefixSums[0] = 0;
        for (int i = 0; i < n; i++) {
            prefixSums[i + 1] = prefixSums[i] + arr[i];
        }

        for (int i = 0; i < queryL.length; i++) {
            int L = queryL[i];
            int R = queryR[i];
            long rangeSum = prefixSums[R + 1] - prefixSums[L];
            System.out.println(rangeSum);
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        int q = scanner.nextInt();
        int[] queryL = new int[q];
        int[] queryR = new int[q];
        for (int i = 0; i < q; i++) {
            queryL[i] = scanner.nextInt();
            queryR[i] = scanner.nextInt();
        }

        calculateRangeSums(arr, queryL, queryR);

        scanner.close();
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let inputLines = [];
rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    main();
});

function calculateRangeSums(arr, queries) {
    const n = arr.length;
    const prefixSums = new Array(n + 1).fill(0);
    for (let i = 0; i < n; i++) {
        prefixSums[i + 1] = prefixSums[i] + arr[i];
    }

    for (const query of queries) {
        const L = query[0];
        const R = query[1];
        const rangeSum = prefixSums[R + 1] - prefixSums[L];
        console.log(rangeSum);
    }
}

function main() {
    let lineIndex = 0;

    const n = parseInt(inputLines[lineIndex++]);
    const arr = inputLines[lineIndex++].split(' ').map(Number);

    const q = parseInt(inputLines[lineIndex++]);
    const queries = [];
    for (let i = 0; i < q; i++) {
        queries.push(inputLines[lineIndex++].split(' ').map(Number));
    }

    calculateRangeSums(arr, queries);
}","#include <iostream>
#include <vector>
#include <numeric> // Not strictly needed for this approach, but useful for sums

// Function to calculate prefix sums and then answer queries
void calculateRangeSums(const std::vector<int>& arr, const std::vector<std::pair<int, int>>& queries) {
    int n = arr.size();
    std::vector<long long> prefixSums(n + 1, 0);
    for (int i = 0; i < n; ++i) {
        prefixSums[i + 1] = prefixSums[i] + arr[i];
    }

    for (const auto& query : queries) {
        int L = query.first;
        int R = query.second;
        long long rangeSum = prefixSums[R + 1] - prefixSums[L];
        std::cout << rangeSum << std::endl;
    }
}

int main() {
    std::ios_base::sync_with_stdio(false); // Optimize C++ I/O
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    std::vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i];
    }

    int q;
    std::cin >> q;

    std::vector<std::pair<int, int>> queries(q);
    for (int i = 0; i < q; ++i) {
        std::cin >> queries[i].first >> queries[i].second;
    }

    calculateRangeSums(arr, queries);

    return 0;
}",4.4
Yellow-72,Frequency Count / Anagrams,"*   String Manipulation
*   Character Frequency Counting
*   Arrays (as frequency maps)
*   Conditional Logic
*   String Normalization/Filtering (Case-insensitivity, ignoring non-alphabetic characters)","An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. For example, ""listen"" is an anagram of ""silent"".

For this problem, we're expanding the definition to *phrases*! Your task is to implement a function that determines whether two given strings (which can be phrases with spaces, punctuation, numbers, and mixed casing) are anagrams of each other. The comparison should be **case-insensitive**, and **only alphabetic characters** should be considered for the anagram check. All non-alphabetic characters (spaces, punctuation, numbers, etc.) should be ignored.

The function should return `true` if they are anagrams and `false` otherwise.","*   The input strings `s1` and `s2` can contain lowercase English letters, uppercase English letters, spaces, numbers, and punctuation.
*   The length of both strings `s1` and `s2` will be between 1 and 200, inclusive (`1 <= len(s1), len(s2) <= 200`).","s1 = ""Listen!""
s2 = ""Silent""",TRUE,"Input: Listen!
Input: Silent
Output: true
Input: A gentleman
Input: Elegant man
Output: true
Input: Debit Card
Input: Bad Credit
Output: true
Input: The Eyes
Input: They See
Output: true
Input: Hello World
Input: World Hello
Output: true
Input: Eleven plus two
Input: Twelve plus one
Output: true
Input: Topcoder
Input: Codetorp
Output: true
Input: Anagram
Input: Nagaram
Output: true
Input: Rat
Input: Car
Output: false
Input: This is not
Input: An anagram
Output: false
Input: 1a!b@c#
Input: Cb a
Output: true","#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h> // For tolower and isalpha

bool areAnagrams(const char* s1, const char* s2) {
    int counts[26] = {0};
    int len1_alphabetic = 0;
    int len2_alphabetic = 0;

    // Process s1: count alphabetic characters and their frequencies
    for (int i = 0; s1[i] != '\0'; i++) {
        if (isalpha(s1[i])) {
            counts[tolower(s1[i]) - 'a']++;
            len1_alphabetic++;
        }
    }

    // Process s2: decrement frequencies and count alphabetic characters
    for (int i = 0; s2[i] != '\0'; i++) {
        if (isalpha(s2[i])) {
            counts[tolower(s2[i]) - 'a']--;
            len2_alphabetic++;
        }
    }

    // If the total count of alphabetic characters differs, they can't be anagrams
    if (len1_alphabetic != len2_alphabetic) {
        return false;
    }

    // Check if all frequency counts are zero
    for (int i = 0; i < 26; i++) {
        if (counts[i] != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    char s1[201]; // Max length 200 + null terminator
    char s2[201];

    // Read lines including spaces
    if (fgets(s1, sizeof(s1), stdin) == NULL) return 1;
    if (fgets(s2, sizeof(s2), stdin) == NULL) return 1;

    // Remove trailing newline characters if present (fgets includes them)
    s1[strcspn(s1, ""\n"")] = 0;
    s2[strcspn(s2, ""\n"")] = 0;

    if (areAnagrams(s1, s2)) {
        printf(""true\n"");
    } else {
        printf(""false\n"");
    }

    return 0;
}","def are_anagrams(s1: str, s2: str) -> bool:
    counts = [0] * 26
    len1_alphabetic = 0
    len2_alphabetic = 0

    # Process s1: count alphabetic characters and their frequencies
    for char_code in map(ord, s1):
        if 'a' <= chr(char_code).lower() <= 'z': # Check if it's a letter after converting to lower
            counts[char_code - ord('a') if 'a' <= chr(char_code) <= 'z' else ord(chr(char_code).lower()) - ord('a')] += 1
            len1_alphabetic += 1
    
    # A more Pythonic way for character filtering and counting:
    # For s1:
    # cleaned_s1 = [char for char in s1.lower() if 'a' <= char <= 'z']
    # for char_code in map(ord, cleaned_s1):
    #     counts[char_code - ord('a')] += 1
    # len1_alphabetic = len(cleaned_s1)

    # Process s2: decrement frequencies and count alphabetic characters
    for char_code in map(ord, s2):
        if 'a' <= chr(char_code).lower() <= 'z':
            counts[char_code - ord('a') if 'a' <= chr(char_code) <= 'z' else ord(chr(char_code).lower()) - ord('a')] -= 1
            len2_alphabetic += 1
            
    # For s2:
    # cleaned_s2 = [char for char in s2.lower() if 'a' <= char <= 'z']
    # for char_code in map(ord, cleaned_s2):
    #     counts[char_code - ord('a')] -= 1
    # len2_alphabetic = len(cleaned_s2)


    # If the total count of alphabetic characters differs, they can't be anagrams
    if len1_alphabetic != len2_alphabetic:
        return False

    # Check if all frequency counts are zero
    for count in counts:
        if count != 0:
            return False

    return True

if __name__ == '__main__':
    s1 = input() # Reads full line
    s2 = input() # Reads full line

    if are_anagrams(s1, s2):
        print(""true"")
    else:
        print(""false"")","import java.util.Scanner;
import java.util.Arrays;

public class TextTwister {

    public boolean areAnagrams(String s1, String s2) {
        int[] counts = new int[26]; // For 'a' through 'z'
        int len1Alphabetic = 0;
        int len2Alphabetic = 0;

        // Process s1: count alphabetic characters and their frequencies
        for (char c : s1.toCharArray()) {
            if (Character.isLetter(c)) {
                counts[Character.toLowerCase(c) - 'a']++;
                len1Alphabetic++;
            }
        }

        // Process s2: decrement frequencies and count alphabetic characters
        for (char c : s2.toCharArray()) {
            if (Character.isLetter(c)) {
                counts[Character.toLowerCase(c) - 'a']--;
                len2Alphabetic++;
            }
        }

        // If the total count of alphabetic characters differs, they can't be anagrams
        if (len1Alphabetic != len2Alphabetic) {
            return false;
        }

        // Check if all frequency counts are zero
        for (int count : counts) {
            if (count != 0) {
                return false;
            }
        }

        return true;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read lines including spaces
        String s1 = scanner.nextLine();
        String s2 = scanner.nextLine();

        TextTwister solution = new TextTwister();
        if (solution.areAnagrams(s1, s2)) {
            System.out.println(""true"");
        } else {
            System.out.println(""false"");
        }

        scanner.close();
    }
}","function areAnagrams(s1, s2) {
    const counts = new Array(26).fill(0);
    let len1Alphabetic = 0;
    let len2Alphabetic = 0;

    // Helper to check if a character is an English letter
    function isAlpha(char) {
        const code = char.charCodeAt(0);
        return (code >= 'a'.charCodeAt(0) && code <= 'z'.charCodeAt(0)) ||
               (code >= 'A'.charCodeAt(0) && code <= 'Z'.charCodeAt(0));
    }

    // Process s1: count alphabetic characters and their frequencies
    for (let i = 0; i < s1.length; i++) {
        const char = s1[i];
        if (isAlpha(char)) {
            counts[char.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0)]++;
            len1Alphabetic++;
        }
    }

    // Process s2: decrement frequencies and count alphabetic characters
    for (let i = 0; i < s2.length; i++) {
        const char = s2[i];
        if (isAlpha(char)) {
            counts[char.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0)]--;
            len2Alphabetic++;
        }
    }

    // If the total count of alphabetic characters differs, they can't be anagrams
    if (len1Alphabetic !== len2Alphabetic) {
        return false;
    }

    // Check if all frequency counts are zero
    for (let i = 0; i < 26; i++) {
        if (counts[i] !== 0) {
            return false;
        }
    }

    return true;
}

// Node.js example for reading two lines:
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

let lines = [];
rl.on('line', (line) => {
  lines.push(line);
  if (lines.length === 2) {
    const s1 = lines[0];
    const s2 = lines[1];
    if (areAnagrams(s1, s2)) {
        console.log(""true"");
    } else {
        console.log(""false"");
    }
    rl.close();
  }
});","#include <iostream>
#include <string>
#include <vector>
#include <numeric>
#include <cctype> // For tolower and isalpha

bool areAnagrams(const std::string& s1, const std::string& s2) {
    std::vector<int> counts(26, 0);
    int len1_alphabetic = 0;
    int len2_alphabetic = 0;

    // Process s1: count alphabetic characters and their frequencies
    for (char c : s1) {
        if (std::isalpha(c)) {
            counts[std::tolower(c) - 'a']++;
            len1_alphabetic++;
        }
    }

    // Process s2: decrement frequencies and count alphabetic characters
    for (char c : s2) {
        if (std::isalpha(c)) {
            counts[std::tolower(c) - 'a']--;
            len2_alphabetic++;
        }
    }

    // If the total count of alphabetic characters differs, they can't be anagrams
    if (len1_alphabetic != len2_alphabetic) {
        return false;
    }

    // Check if all frequency counts are zero
    for (int count : counts) {
        if (count != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    std::string s1;
    std::string s2;

    // Read lines including spaces
    std::getline(std::cin, s1);
    std::getline(std::cin, s2);

    if (areAnagrams(s1, s2)) {
        std::cout << ""true"" << std::endl;
    } else {
        std::cout << ""false"" << std::endl;
    }

    return 0;
}",3.8
Yellow-73,Character Hashing,"*   **Character Hashing**: Using character values (e.g., ASCII values) to map them to array indices.
*   **Arrays as Frequency Maps**: Utilizing an array to store counts for a fixed, small set of items (like the alphabet).
*   **String Traversal**: Iterating through each character of a string.
*   **Basic I/O**: Reading input and printing formatted output.","Given a string containing only lowercase English letters, determine the frequency of each character. Your task is to count how many times each character ('a' through 'z') appears in the string. The output should list each character that appears at least once, along with its count, in alphabetical order.","*   The input string `S` will have a length between 1 and 1000 characters, inclusive.
*   `S` will only contain lowercase English letters ('a' through 'z').","**
`banana`

**","**
`a:3`
`b:1`
`n:2`","Input: hello
Output: e:1
h:1
l:2
o:1
Input: abracadabra
Output: a:5
b:2
c:1
d:1
r:2
Input: z
Output: z:1
Input: aaaaa
Output: a:5
Input: abcdefghijklmnopqrstuvwxyz
Output: a:1
b:1
c:1
d:1
e:1
f:1
g:1
h:1
i:1
j:1
k:1
l:1
m:1
n:1
o:1
p:1
q:1
r:1
s:1
t:1
u:1
v:1
w:1
x:1
y:1
z:1","#include <stdio.h>
#include <string.h>

#define MAX_LEN 1001 // Max 1000 chars + null terminator

// Function to count character frequencies
void countFrequencies(const char* s) {
    int frequencies[26] = {0}; // Initialize all to 0
    int i;

    // Iterate through the string and count frequencies
    for (i = 0; s[i] != '\0'; i++) {
        if (s[i] >= 'a' && s[i] <= 'z') {
            frequencies[s[i] - 'a']++;
        }
    }

    // Print characters with non-zero frequencies in alphabetical order
    for (i = 0; i < 26; i++) {
        if (frequencies[i] > 0) {
            printf(""%c:%d\n"", 'a' + i, frequencies[i]);
        }
    }
}

int main() {
    char s[MAX_LEN];

    // Read input string
    if (fgets(s, MAX_LEN, stdin) != NULL) {
        // Remove trailing newline character if present
        s[strcspn(s, ""\n"")] = 0;
        countFrequencies(s);
    }
    
    return 0;
}","# Function to count character frequencies
def count_frequencies(s):
    # Using a list (array) for frequencies, 0-25 for 'a'-'z'
    frequencies = [0] * 26

    # Iterate through the string and count frequencies
    for char_val in s:
        # Check if character is a lowercase English letter
        if 'a' <= char_val <= 'z':
            frequencies[ord(char_val) - ord('a')] += 1

    # Print characters with non-zero frequencies in alphabetical order
    for i in range(26):
        if frequencies[i] > 0:
            ch = chr(ord('a') + i)
            print(f""{ch}:{frequencies[i]}"")

# Main function for I/O
if __name__ == ""__main__"":
    # Read input string from stdin, stripping newline
    s = input().strip() 
    count_frequencies(s)","import java.util.Scanner;

public class Main {

    // Function to count character frequencies
    public static void countFrequencies(String s) {
        // Using an array for frequencies as it's efficient for a fixed alphabet size
        int[] frequencies = new int[26]; // 0-25 for 'a'-'z'

        // Iterate through the string and count frequencies
        for (char c : s.toCharArray()) {
            if (c >= 'a' && c <= 'z') {
                frequencies[c - 'a']++;
            }
        }

        // Print characters with non-zero frequencies in alphabetical order
        for (int i = 0; i < 26; i++) {
            if (frequencies[i] > 0) {
                char ch = (char) ('a' + i);
                System.out.println(ch + "":"" + frequencies[i]);
            }
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine(); // Read entire line
        scanner.close();

        countFrequencies(s);
    }
}","// Function to count character frequencies
function countFrequencies(s) {
    // Using an array for frequencies, 0-25 for 'a'-'z'
    const frequencies = new Array(26).fill(0);

    // Iterate through the string and count frequencies
    for (let i = 0; i < s.length; i++) {
        const charCode = s.charCodeAt(i);
        // Check if character is a lowercase English letter
        if (charCode >= 'a'.charCodeAt(0) && charCode <= 'z'.charCodeAt(0)) {
            frequencies[charCode - 'a'.charCodeAt(0)]++;
        }
    }

    // Print characters with non-zero frequencies in alphabetical order
    for (let i = 0; i < 26; i++) {
        if (frequencies[i] > 0) {
            const ch = String.fromCharCode('a'.charCodeAt(0) + i);
            console.log(`${ch}:${frequencies[i]}`);
        }
    }
}

// Main function for I/O
// Node.js specific input handling
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.on('line', (line) => {
    countFrequencies(line);
    rl.close(); // Close the interface after processing one line
});","#include <iostream>
#include <string>
#include <vector>

// Function to count character frequencies
void countFrequencies(const std::string& s) {
    std::vector<int> frequencies(26, 0); // Initialize vector of size 26 with zeros

    // Iterate through the string and count frequencies
    for (char c : s) {
        // Only count lowercase English letters as per problem description
        if (c >= 'a' && c <= 'z') {
            frequencies[c - 'a']++;
        }
    }

    // Print characters with non-zero frequencies in alphabetical order
    for (int i = 0; i < 26; ++i) {
        if (frequencies[i] > 0) {
            char ch = 'a' + i;
            std::cout << ch << "":"" << frequencies[i] << std::endl;
        }
    }
}

int main() {
    std::ios_base::sync_with_stdio(false); // Optimize C++ streams
    std::cin.tie(NULL);                   // Untie cin from cout

    std::string s;
    std::getline(std::cin, s); // Read entire line

    countFrequencies(s);
    
    return 0;
}",4
Yellow-74,Kadane’s Algorithm (Max Subarray Sum),"-   Kadane's Algorithm
-   Dynamic Programming
-   Array Traversal
-   Prefix/Suffix Sums (implicit)","You are given an integer array `nums`. Your task is to find the maximum sum of a contiguous subarray, with the option to **delete at most one element** from the chosen subarray to maximize its sum. This means you can either:
1.  Choose a contiguous subarray and not delete any element from it (this is the standard maximum subarray sum problem).
2.  Choose a contiguous subarray and delete exactly one element from it, then calculate the sum of the remaining elements. The remaining elements, though originally from a contiguous block, might now form two separate contiguous blocks if the deleted element was in the middle.

The goal is to return the single largest possible sum achievable under these rules.","- `1 <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`","5
1 -2 0 3 -4",4,"Input: 1
-5
Output: -5
Input: 5
1 2 3 4 5
Output: 15
Input: 3
-10 -2 -5
Output: -2
Input: 8
-2 -3 4 -1 -2 1 5 -3
Output: 7
Input: 9
-2 1 -3 4 -1 2 1 -5 4
Output: 6
Input: 5
1 -2 0 3 -4
Output: 4
Input: 6
5 -1 4 -5 6 -2
Output: 14
Input: 2
-1 -2
Output: -1
Input: 7
-1 2 3 -2 5 -1 0
Output: 8","#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

// Function to find the maximum of two integers
int max(int a, int b) {
    return (a > b) ? a : b;
}

// Function to find the maximum subarray sum with at most one deletion
int maxSubarraySumWithOneDeletion(int* nums, int numsSize) {
    if (numsSize == 0) {
        return 0; // Should not be reached based on constraints (nums.length >= 1)
    }
    if (numsSize == 1) {
        return nums[0];
    }

    int* dp_forward = (int*)malloc(numsSize * sizeof(int));
    int* dp_backward = (int*)malloc(numsSize * sizeof(int));

    if (dp_forward == NULL || dp_backward == NULL) {
        fprintf(stderr, ""Memory allocation failed\n"");
        if (dp_forward) free(dp_forward);
        if (dp_backward) free(dp_backward);
        return 0; // Indicate error or handle as appropriate
    }

    // Kadane's Forward Pass
    dp_forward[0] = nums[0];
    int max_overall_sum = nums[0];
    for (int i = 1; i < numsSize; i++) {
        dp_forward[i] = max(nums[i], nums[i] + dp_forward[i-1]);
        max_overall_sum = max(max_overall_sum, dp_forward[i]);
    }

    // Kadane's Backward Pass
    dp_backward[numsSize-1] = nums[numsSize-1];
    for (int i = numsSize - 2; i >= 0; i--) {
        dp_backward[i] = max(nums[i], nums[i] + dp_backward[i+1]);
    }

    // Combine for deletion option
    // Iterate from i=1 to n-2 to ensure i-1 and i+1 are valid indices
    for (int i = 1; i < numsSize - 1; i++) {
        int sum_with_deletion = dp_forward[i-1] + dp_backward[i+1];
        max_overall_sum = max(max_overall_sum, sum_with_deletion);
    }

    free(dp_forward);
    free(dp_backward);

    return max_overall_sum;
}

int main() {
    int n;
    scanf(""%d"", &n);

    int* nums = (int*)malloc(n * sizeof(int));
    if (nums == NULL) {
        fprintf(stderr, ""Memory allocation failed\n"");
        return 1;
    }

    for (int i = 0; i < n; i++) {
        scanf(""%d"", &nums[i]);
    }

    int result = maxSubarraySumWithOneDeletion(nums, n);
    printf(""%d\n"", result);

    free(nums);

    return 0;
}","import sys

def max_subarray_sum_with_one_deletion(nums):
    if not nums:
        return 0 # Should not be reached based on constraints (nums.length >= 1)
    if len(nums) == 1:
        return nums[0]

    n = len(nums)
    dp_forward = [0] * n
    dp_backward = [0] * n

    # Kadane's Forward Pass
    dp_forward[0] = nums[0]
    max_overall_sum = nums[0]
    for i in range(1, n):
        dp_forward[i] = max(nums[i], nums[i] + dp_forward[i-1])
        max_overall_sum = max(max_overall_sum, dp_forward[i])

    # Kadane's Backward Pass
    dp_backward[n-1] = nums[n-1]
    for i in range(n - 2, -1, -1):
        dp_backward[i] = max(nums[i], nums[i] + dp_backward[i+1])

    # Combine for deletion option
    # Iterate from i=1 to n-2 to ensure i-1 and i+1 are valid indices
    for i in range(1, n - 1):
        sum_with_deletion = dp_forward[i-1] + dp_backward[i+1]
        max_overall_sum = max(max_overall_sum, sum_with_deletion)

    return max_overall_sum

if __name__ == '__main__':
    n = int(sys.stdin.readline())
    nums = list(map(int, sys.stdin.readline().split()))

    result = max_subarray_sum_with_one_deletion(nums)
    sys.stdout.write(f""{result}\n"")","import java.util.Scanner;

public class Solution {

    // Function to find the maximum subarray sum with at most one deletion
    public static int maxSubarraySumWithOneDeletion(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0; // Should not be reached based on constraints (nums.length >= 1)
        }
        if (nums.length == 1) {
            return nums[0];
        }

        int n = nums.length;
        int[] dpForward = new int[n];
        int[] dpBackward = new int[n];

        // Kadane's Forward Pass
        dpForward[0] = nums[0];
        int maxOverallSum = nums[0];
        for (int i = 1; i < n; i++) {
            dpForward[i] = Math.max(nums[i], nums[i] + dpForward[i-1]);
            maxOverallSum = Math.max(maxOverallSum, dpForward[i]);
        }

        // Kadane's Backward Pass
        dpBackward[n-1] = nums[n-1];
        for (int i = n - 2; i >= 0; i--) {
            dpBackward[i] = Math.max(nums[i], nums[i] + dpBackward[i+1]);
        }

        // Combine for deletion option
        // Iterate from i=1 to n-2 to ensure i-1 and i+1 are valid indices
        for (int i = 1; i < n - 1; i++) {
            int sumWithDeletion = dpForward[i-1] + dpBackward[i+1];
            maxOverallSum = Math.max(maxOverallSum, sumWithDeletion);
        }

        return maxOverallSum;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }
        scanner.close();

        int result = maxSubarraySumWithOneDeletion(nums);
        System.out.println(result);
    }
}","function maxSubarraySumWithOneDeletion(nums) {
    if (!nums || nums.length === 0) {
        return 0; // Should not be reached based on constraints (nums.length >= 1)
    }
    if (nums.length === 1) {
        return nums[0];
    }

    const n = nums.length;
    const dpForward = new Array(n).fill(0);
    const dpBackward = new Array(n).fill(0);

    // Kadane's Forward Pass
    dpForward[0] = nums[0];
    let maxOverallSum = nums[0];
    for (let i = 1; i < n; i++) {
        dpForward[i] = Math.max(nums[i], nums[i] + dpForward[i-1]);
        maxOverallSum = Math.max(maxOverallSum, dpForward[i]);
    }

    // Kadane's Backward Pass
    dpBackward[n-1] = nums[n-1];
    for (let i = n - 2; i >= 0; i--) {
        dpBackward[i] = Math.max(nums[i], nums[i] + dpBackward[i+1]);
    }

    // Combine for deletion option
    // Iterate from i=1 to n-2 to ensure i-1 and i+1 are valid indices
    for (let i = 1; i < n - 1; i++) {
        const sumWithDeletion = dpForward[i-1] + dpBackward[i+1];
        maxOverallSum = Math.max(maxOverallSum, sumWithDeletion);
    }

    return maxOverallSum;
}

// Read input from stdin for Node.js environment
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let inputLines = [];
rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    const n = parseInt(inputLines[0], 10);
    const nums = inputLines[1].split(' ').map(Number);
    
    const result = maxSubarraySumWithOneDeletion(nums);
    console.log(`${result}`);
});","#include <iostream>
#include <vector>
#include <algorithm>
#include <limits> // For numeric_limits

// Function to find the maximum subarray sum with at most one deletion
int maxSubarraySumWithOneDeletion(const std::vector<int>& nums) {
    if (nums.empty()) {
        return 0; // Should not be reached based on constraints (nums.length >= 1)
    }
    if (nums.size() == 1) {
        return nums[0];
    }

    int n = nums.size();
    std::vector<int> dp_forward(n);
    std::vector<int> dp_backward(n);

    // Kadane's Forward Pass
    dp_forward[0] = nums[0];
    int max_overall_sum = nums[0];
    for (int i = 1; i < n; ++i) {
        dp_forward[i] = std::max(nums[i], nums[i] + dp_forward[i-1]);
        max_overall_sum = std::max(max_overall_sum, dp_forward[i]);
    }

    // Kadane's Backward Pass
    dp_backward[n-1] = nums[n-1];
    for (int i = n - 2; i >= 0; --i) {
        dp_backward[i] = std::max(nums[i], nums[i] + dp_backward[i+1]);
    }

    // Combine for deletion option
    // Iterate from i=1 to n-2 to ensure i-1 and i+1 are valid indices
    for (int i = 1; i < n - 1; ++i) {
        int sum_with_deletion = dp_forward[i-1] + dp_backward[i+1];
        max_overall_sum = std::max(max_overall_sum, sum_with_deletion);
    }

    return max_overall_sum;
}

int main() {
    // Optimize C++ standard streams for faster input/output
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    std::vector<int> nums(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> nums[i];
    }

    int result = maxSubarraySumWithOneDeletion(nums);
    std::cout << result << std::endl;

    return 0;
}",4.6
White-104,Parameters & Arguments (pass by value/reference),"*   **Parameters and Arguments**: How values are passed to functions.
*   **Pass by Value**: Understanding that for primitive data types (like integers), a *copy* of the argument's value is made and passed to the function.
*   **Function Scope**: How variables declared within a function (including parameters) are local to that function.
*   **Local Variables**: Variables defined within a function that exist only while the function is executing.","Imagine you have a magic number. You send this number to a special 'enhancement chamber' (a function) where it's supposed to be increased by one. After it comes out of the chamber, you check your original magic number to see if it actually changed. Will it be different, or will it remain exactly as it was before entering the chamber?

Your task is to write a program that demonstrates this concept. You will read an integer from the user. Then, you will pass this integer to a function. Inside the function, the parameter (which is a copy of your original number) should be incremented. Finally, back in your main program, you will print the original integer again to observe whether its value was affected by the function call.",*   The input integer will be between `1` and `1000` (inclusive).,"5


#### Expected","Before function call (in main): 5
Inside function: Parameter value before change: 5
Inside function: Parameter value after change: 6
After function call (in main): 5","Input: 10
Output:
Before function call (in main): 10
Inside function: Parameter value before change: 10
Inside function: Parameter value after change: 11
After function call (in main): 10
Input: 1
Output:
Before function call (in main): 1
Inside function: Parameter value before change: 1
Inside function: Parameter value after change: 2
After function call (in main): 1
Input: 1000
Output:
Before function call (in main): 1000
Inside function: Parameter value before change: 1000
Inside function: Parameter value after change: 1001
After function call (in main): 1000","#include <stdio.h>

// Core logic function to demonstrate pass by value
void demonstratePassByValue(int val) {
    printf(""Inside function: Parameter value before change: %d\n"", val);
    val = val + 1; // This modifies the LOCAL copy of val, not the original in main
    printf(""Inside function: Parameter value after change: %d\n"", val);
}

int main() {
    int original_value;

    // Read input from stdin
    if (scanf(""%d"", &original_value) != 1) {
        // Handle potential input error
        fprintf(stderr, ""Error reading integer input.\n"");
        return 1;
    }

    // Print original value before the function call
    printf(""Before function call (in main): %d\n"", original_value);

    // Call the function, passing original_value by value
    demonstratePassByValue(original_value);

    // Print original value after the function call to observe no change
    printf(""After function call (in main): %d\n"", original_value);

    return 0;
}","# Core logic function to demonstrate pass by value
def demonstrate_pass_by_value(val):
    print(f""Inside function: Parameter value before change: {val}"")
    val = val + 1  # This modifies the LOCAL copy of val, not the original in the calling scope
    print(f""Inside function: Parameter value after change: {val}"")

if __name__ == ""__main__"":
    # Read input from stdin
    original_value = int(input())

    # Print original value before the function call
    print(f""Before function call (in main): {original_value}"")

    # Call the function, passing original_value by value (for immutable types like int)
    demonstrate_pass_by_value(original_value);

    # Print original value after the function call to observe no change
    print(f""After function call (in main): {original_value}"")","import java.util.Scanner;

public class Solution {

    // Core logic function to demonstrate pass by value
    public static void demonstratePassByValue(int val) {
        System.out.println(""Inside function: Parameter value before change: "" + val);
        val = val + 1; // This modifies the LOCAL copy of val, not the original in main
        System.out.println(""Inside function: Parameter value after change: "" + val);
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read input from stdin
        int originalValue = scanner.nextInt();

        // Print original value before the function call
        System.out.println(""Before function call (in main): "" + originalValue);

        // Call the function, passing originalValue by value
        demonstratePassByValue(originalValue);

        // Print original value after the function call to observe no change
        System.out.println(""After function call (in main): "" + originalValue);

        scanner.close();
    }
}","// Core logic function to demonstrate pass by value
function demonstratePassByValue(val) {
    console.log(`Inside function: Parameter value before change: ${val}`);
    val = val + 1; // This modifies the LOCAL copy of val, not the original in the calling scope
    console.log(`Inside function: Parameter value after change: ${val}`);
}

// Main execution block (handles I/O)
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    rl.on('line', (line) => {
        let originalValue = parseInt(line);

        // Print original value before the function call
        console.log(`Before function call (in main): ${originalValue}`);

        // Call the function, passing originalValue by value
        demonstratePassByValue(originalValue);

        // Print original value after the function call to observe no change
        console.log(`After function call (in main): ${originalValue}`);

        rl.close();
    });
}

// Call the main function to start execution
main();","#include <iostream>

// Core logic function to demonstrate pass by value
void demonstratePassByValue(int val) {
    std::cout << ""Inside function: Parameter value before change: "" << val << std::endl;
    val = val + 1; // This modifies the LOCAL copy of val, not the original in main
    std::cout << ""Inside function: Parameter value after change: "" << val << std::endl;
}

int main() {
    int original_value;

    // Read input from stdin
    std::cin >> original_value;

    // Print original value before the function call
    std::cout << ""Before function call (in main): "" << original_value << std::endl;

    // Call the function, passing original_value by value
    demonstratePassByValue(original_value);

    // Print original value after the function call to observe no change
    std::cout << ""After function call (in main): "" << original_value << std::endl;

    return 0;
}",4.6
Yellow-75,Prefix & Suffix Sums,"*   Prefix Sums
*   Array Manipulation
*   Range Queries
*   Time-Space Complexity Analysis
*   Conditional Summation","You are given an array of `N` integers and `Q` queries. Each query consists of three values: `start`, `end` (inclusive indices), and a `parity_type` (0 for even indices, 1 for odd indices). Your task is to find the sum of all elements in the array within the range `[start, end]` whose *indices* match the specified `parity_type` for each query.","*   `1 <= N <= 10^5`
*   `-1000 <= arr[i] <= 1000`
*   `1 <= Q <= 10^5`
*   `0 <= start <= end < N`
*   `0 <= parity_type <= 1`","5
1 2 3 4 5
3
0 2 0
1 3 1
0 4 0


####","4
6
9


####","Input:
5
-1 0 1 2 -3
3
0 4 0
1 3 1
2 2 0
Output:
-3
2
1
Input:
1
100
1
0 0 0
Output:
100
Input:
7
5 -2 3 10 -8 4 1
4
0 6 0
1 3 1
4 5 0
0 0 0
Output:
1
8
-8
5
Input:
3
0 0 0
2
0 2 0
1 1 1
Output:
0
0
Input:
6
10 20 30 40 50 60
2
0 5 0
3 3 1
Output:
90
40","#include <stdio.h>
#include <stdlib.h> // For malloc

// Core logic function to process queries using prefix sums
// arr: input array
// n: size of arr
// queries_data: 2D array of queries, each row is [start, end, parity_type]
// q: number of queries
void processQueries(int* arr, int n, int** queries_data, int q) {
    // Use long long for prefix sums to prevent potential overflow,
    // as sum can reach 10^5 * 1000 = 10^8, which fits in int, but long long is safer.
    long long* prefix_sums_even = (long long*) malloc(sizeof(long long) * (n + 1));
    long long* prefix_sums_odd = (long long*) malloc(sizeof(long long) * (n + 1));

    if (prefix_sums_even == NULL || prefix_sums_odd == NULL) {
        // Handle allocation error
        fprintf(stderr, ""Memory allocation failed for prefix_sums\n"");
        if (prefix_sums_even != NULL) free(prefix_sums_even);
        if (prefix_sums_odd != NULL) free(prefix_sums_odd);
        return;
    }

    prefix_sums_even[0] = 0;
    prefix_sums_odd[0] = 0;

    for (int i = 0; i < n; i++) {
        prefix_sums_even[i+1] = prefix_sums_even[i];
        prefix_sums_odd[i+1] = prefix_sums_odd[i];
        if (i % 2 == 0) { // Current index i is even
            prefix_sums_even[i+1] += arr[i];
        } else { // Current index i is odd
            prefix_sums_odd[i+1] += arr[i];
        }
    }

    for (int i = 0; i < q; i++) {
        int start = queries_data[i][0];
        int end = queries_data[i][1];
        int parity_type = queries_data[i][2]; // New input for parity_type
        long long sum;
        if (parity_type == 0) { // Even indices
            sum = prefix_sums_even[end + 1] - prefix_sums_even[start];
        } else { // Odd indices
            sum = prefix_sums_odd[end + 1] - prefix_sums_odd[start];
        }
        printf(""%lld\n"", sum);
    }

    free(prefix_sums_even);
    free(prefix_sums_odd);
}

int main() {
    int n;
    scanf(""%d"", &n);

    int* arr = (int*) malloc(sizeof(int) * n);
    if (arr == NULL) {
        fprintf(stderr, ""Memory allocation failed for arr\n"");
        return 1; // Error
    }
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]);
    }

    int q;
    scanf(""%d"", &q);

    int** queries_data = (int**) malloc(sizeof(int*) * q);
    if (queries_data == NULL) {
        fprintf(stderr, ""Memory allocation failed for queries_data\n"");
        free(arr);
        return 1; // Error
    }
    for (int i = 0; i < q; i++) {
        queries_data[i] = (int*) malloc(sizeof(int) * 3); // Changed size to 3 for start, end, parity_type
        if (queries_data[i] == NULL) {
            fprintf(stderr, ""Memory allocation failed for queries_data[%d]\n"", i);
            // Free previously allocated memory before exiting
            for (int j = 0; j < i; j++) free(queries_data[j]);
            free(queries_data);
            free(arr);
            return 1; // Error
        }
        scanf(""%d %d %d"", &queries_data[i][0], &queries_data[i][1], &queries_data[i][2]);
    }

    // Call the core logic function
    processQueries(arr, n, queries_data, q);

    // Free all dynamically allocated memory
    free(arr);
    for (int i = 0; i < q; i++) {
        free(queries_data[i]);
    }
    free(queries_data);

    return 0;
}","# Core logic function to process queries using prefix sums
def process_queries():
    n = int(input())
    arr = list(map(int, input().split()))

    prefix_sums_even = [0] * (n + 1)
    prefix_sums_odd = [0] * (n + 1)

    for i in range(n):
        prefix_sums_even[i+1] = prefix_sums_even[i]
        prefix_sums_odd[i+1] = prefix_sums_odd[i]
        if i % 2 == 0: # Current index i is even
            prefix_sums_even[i+1] += arr[i]
        else: # Current index i is odd
            prefix_sums_odd[i+1] += arr[i]

    q = int(input())
    for _ in range(q):
        start, end, parity_type = map(int, input().split()) # New input for parity_type
        query_sum = 0
        if parity_type == 0: # Even indices
            query_sum = prefix_sums_even[end + 1] - prefix_sums_even[start]
        else: # Odd indices
            query_sum = prefix_sums_odd[end + 1] - prefix_sums_odd[start]
        print(query_sum)

# The main execution block
if __name__ == ""__main__"":
    # Call the core logic function
    process_queries()","import java.util.Scanner;

class Solution {

    // Core logic method to process queries using prefix sums
    public void processQueries() {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        // Use long[] for prefix sums to prevent potential overflow
        long[] prefixSumsEven = new long[n + 1];
        long[] prefixSumsOdd = new long[n + 1];
        // prefixSumsEven[0] and prefixSumsOdd[0] are 0 by default for long arrays

        for (int i = 0; i < n; i++) {
            prefixSumsEven[i+1] = prefixSumsEven[i];
            prefixSumsOdd[i+1] = prefixSumsOdd[i];
            if (i % 2 == 0) { // Current index i is even
                prefixSumsEven[i+1] += arr[i];
            } else { // Current index i is odd
                prefixSumsOdd[i+1] += arr[i];
            }
        }

        int q = scanner.nextInt();
        for (int i = 0; i < q; i++) {
            int start = scanner.nextInt();
            int end = scanner.nextInt();
            int parityType = scanner.nextInt(); // New input for parityType
            long sum;
            if (parityType == 0) { // Even indices
                sum = prefixSumsEven[end + 1] - prefixSumsEven[start];
            } else { // Odd indices
                sum = prefixSumsOdd[end + 1] - prefixSumsOdd[start];
            }
            System.out.println(sum);
        }

        scanner.close();
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        // Call the core logic method
        sol.processQueries();
    }
}","// A common way to handle input in competitive programming environments for Node.js
// This setup assumes input comes line by line, similar to how Scanner works in Java
// or input() in Python for reading multiple lines.
let input = '';
process.stdin.on('data', chunk => {
    input += chunk;
});

process.stdin.on('end', () => {
    const lines = input.trim().split('\n');
    let lineIndex = 0;

    const readLine = () => lines[lineIndex++];
    const readInt = () => parseInt(readLine(), 10);
    const readArray = () => readLine().split(' ').map(Number);

    // Core logic function to process queries using prefix sums
    function processQueries() {
        const n = readInt();
        const arr = readArray();

        // JavaScript numbers can accurately represent integers up to 2^53 - 1,
        // which is sufficient for sums up to 10^8.
        const prefixSumsEven = new Array(n + 1).fill(0);
        const prefixSumsOdd = new Array(n + 1).fill(0);

        for (let i = 0; i < n; i++) {
            prefixSumsEven[i+1] = prefixSumsEven[i];
            prefixSumsOdd[i+1] = prefixSumsOdd[i];
            if (i % 2 === 0) { // Current index i is even
                prefixSumsEven[i+1] += arr[i];
            } else { // Current index i is odd
                prefixSumsOdd[i+1] += arr[i];
            }
        }

        const q = readInt();
        for (let i = 0; i < q; i++) {
            const [start, end, parityType] = readArray(); // New input format: ""start end parity_type""
            let sum;
            if (parityType === 0) { // Even indices
                sum = prefixSumsEven[end + 1] - prefixSumsEven[start];
            } else { // Odd indices
                sum = prefixSumsOdd[end + 1] - prefixSumsOdd[start];
            }
            console.log(sum);
        }
    }

    // Call the core logic function
    processQueries();
});","#include <iostream>
#include <vector>

// Core logic function to process queries using prefix sums
void processQueries() {
    int n;
    std::cin >> n;

    std::vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i];
    }

    // Use long long for prefix sums to prevent potential overflow
    std::vector<long long> prefix_sums_even(n + 1, 0);
    std::vector<long long> prefix_sums_odd(n + 1, 0);

    for (int i = 0; i < n; ++i) {
        prefix_sums_even[i+1] = prefix_sums_even[i];
        prefix_sums_odd[i+1] = prefix_sums_odd[i];
        if (i % 2 == 0) { // Current index i is even
            prefix_sums_even[i+1] += arr[i];
        } else { // Current index i is odd
            prefix_sums_odd[i+1] += arr[i];
        }
    }

    int q;
    std::cin >> q;

    for (int i = 0; i < q; ++i) {
        int start, end, parity_type;
        std::cin >> start >> end >> parity_type; // New input for parity_type
        long long sum;
        if (parity_type == 0) { // Even indices
            sum = prefix_sums_even[end + 1] - prefix_sums_even[start];
        } else { // Odd indices
            sum = prefix_sums_odd[end + 1] - prefix_sums_odd[start];
        }
        std::cout << sum << std::endl;
    }
}

int main() {
    // Optimize C++ standard streams for faster input/output.
    // This is common in competitive programming.
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    // Call the core logic function
    processQueries();

    return 0;
}",4.4
Yellow-76,"Singly Linked List (creation, traversal, insertion, deletion)","*   Singly Linked List Structure
*   Linked List Traversal
*   Node Deletion (updating pointers)
*   Handling Edge Cases (empty list, removing head node, target not found)
*   Memory Management (in C/C++)","You are given the head of a singly linked list and an integer `targetValue`. Your task is to remove the *first* occurrence of a node whose value is equal to `targetValue` from the linked list. If the `targetValue` is not found, the list should remain unchanged. Your function should return the head of the modified linked list.

This problem requires you to understand how to traverse a linked list, handle edge cases like an empty list or removing the head node, and correctly update pointers for deletion.","*   The number of nodes in the list is between 0 and 100.
*   Node values are integers between -1000 and 1000.
*   `targetValue` is an integer between -1000 and 1000.
*   The input list will be terminated by -1 (which is not part of the list data).","**

1 2 3 4 5 -1
3

**","**

1 2 4 5


**","Input:
10 20 30 -1
10
Output:
20 30

Input:
1 2 3 -1
3
Output:
1 2

Input:
5 6 7 -1
8
Output:
5 6 7

Input:
-1
1
Output:
Empty List

Input:
1 2 2 3 -1
2
Output:
1 2 3","#include <stdio.h>
#include <stdlib.h>

// Definition for singly-linked list.
struct ListNode {
    int val;
    struct ListNode *next;
};

// Function to create a new node
struct ListNode* createNode(int val) {
    struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
    if (newNode == NULL) {
        perror(""Failed to allocate memory for ListNode"");
        exit(EXIT_FAILURE);
    }
    newNode->val = val;
    newNode->next = NULL;
    return newNode;
}

// Function to remove the first occurrence of targetValue
struct ListNode* removeSpecificNode(struct ListNode* head, int targetValue) {
    if (head == NULL) {
        return NULL;
    }

    // Case 1: Target is the head node
    if (head->val == targetValue) {
        struct ListNode* temp = head;
        head = head->next;
        free(temp);
        return head;
    }

    // Case 2: Target is in the middle or end of the list
    struct ListNode* current = head;
    struct ListNode* previous = NULL;

    while (current != NULL && current->val != targetValue) {
        previous = current;
        current = current->next;
    }

    // If targetValue was found
    if (current != NULL) {
        previous->next = current->next;
        free(current);
    }

    return head;
}

// Function to print the linked list
void printList(struct ListNode* head) {
    if (head == NULL) {
        printf(""Empty List\n"");
        return;
    }
    struct ListNode* current = head;
    while (current != NULL) {
        printf(""%d"", current->val);
        if (current->next != NULL) {
            printf("" "");
        }
        current = current->next;
    }
    printf(""\n"");
}

// Function to free the linked list memory
void freeList(struct ListNode* head) {
    struct ListNode* current = head;
    while (current != NULL) {
        struct ListNode* next = current->next;
        free(current);
        current = next;
    }
}

int main() {
    struct ListNode* head = NULL;
    struct ListNode* tail = NULL;
    int val;

    // Read list elements
    while (scanf(""%d"", &val) == 1 && val != -1) {
        struct ListNode* newNode = createNode(val);
        if (head == NULL) {
            head = newNode;
            tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
    }

    int targetValue;
    // Read target value to remove
    scanf(""%d"", &targetValue);

    // Remove the specific node
    head = removeSpecificNode(head, targetValue);

    // Print the modified list
    printList(head);

    // Free memory
    freeList(head);

    return 0;
}","class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def remove_specific_node(head: ListNode, target_value: int) -> ListNode:
    if not head:
        return None

    # Case 1: Target is the head node
    if head.val == target_value:
        return head.next

    # Case 2: Target is in the middle or end of the list
    current = head
    previous = None

    while current and current.val != target_value:
        previous = current
        current = current.next

    # If target_value was found
    if current:
        previous.next = current.next # Bypass the current node
    
    return head

def print_list(head: ListNode):
    if not head:
        print(""Empty List"")
        return
    
    current = head
    elements = []
    while current:
        elements.append(str(current.val))
        current = current.next
    print("" "".join(elements))

if __name__ == '__main__':
    # Read list elements
    list_input = list(map(int, input().split()))
    
    head = None
    tail = None
    for val in list_input:
        if val == -1:
            break
        new_node = ListNode(val)
        if head is None:
            head = new_node
            tail = new_node
        else:
            tail.next = new_node
            tail = new_node
    
    # Read target value to remove
    target_value = int(input())

    # Remove the specific node
    head = remove_specific_node(head, target_value)

    # Print the modified list
    print_list(head)","import java.util.Scanner;

// Definition for singly-linked list.
class ListNode {
    int val;
    ListNode next;
    ListNode(int x) { val = x; }
}

public class Solution {

    // Function to remove the first occurrence of targetValue
    public ListNode removeSpecificNode(ListNode head, int targetValue) {
        if (head == null) {
            return null;
        }

        // Case 1: Target is the head node
        if (head.val == targetValue) {
            return head.next;
        }

        // Case 2: Target is in the middle or end of the list
        ListNode current = head;
        ListNode previous = null;

        while (current != null && current.val != targetValue) {
            previous = current;
            current = current.next;
        }

        // If targetValue was found
        if (current != null) {
            previous.next = current.next; // Bypass the current node
        }

        return head;
    }

    // Function to print the linked list
    public void printList(ListNode head) {
        if (head == null) {
            System.out.println(""Empty List"");
            return;
        }
        ListNode current = head;
        while (current != null) {
            System.out.print(current.val);
            if (current.next != null) {
                System.out.print("" "");
            }
            current = current.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        ListNode head = null;
        ListNode tail = null;

        // Read list elements
        while (scanner.hasNextInt()) {
            int val = scanner.nextInt();
            if (val == -1) {
                break;
            }
            ListNode newNode = new ListNode(val);
            if (head == null) {
                head = newNode;
                tail = newNode;
            } else {
                tail.next = newNode;
                tail = newNode;
            }
        }

        int targetValue = scanner.nextInt(); // Read target value to remove

        Solution sol = new Solution();
        // Remove the specific node
        head = sol.removeSpecificNode(head, targetValue);

        // Print the modified list
        sol.printList(head);

        scanner.close();
    }
}","// Definition for singly-linked list.
function ListNode(val, next) {
    this.val = (val === undefined ? 0 : val);
    this.next = (next === undefined ? null : next);
}

/**
 * @param {ListNode} head
 * @param {number} targetValue
 * @return {ListNode}
 */
function removeSpecificNode(head, targetValue) {
    if (!head) {
        return null;
    }

    // Case 1: Target is the head node
    if (head.val === targetValue) {
        return head.next;
    }

    // Case 2: Target is in the middle or end of the list
    let current = head;
    let previous = null;

    while (current !== null && current.val !== targetValue) {
        previous = current;
        current = current.next;
    }

    // If targetValue was found
    if (current !== null) {
        previous.next = current.next; // Bypass the current node
    }

    return head;
}

// Function to print the linked list
function printList(head) {
    if (!head) {
        console.log(""Empty List"");
        return;
    }
    let current = head;
    let elements = [];
    while (current !== null) {
        elements.push(current.val);
        current = current.next;
    }
    console.log(elements.join("" ""));
}

// Main function to handle input/output
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let lines = [];
    rl.on('line', (line) => {
        lines.push(line);
    }).on('close', () => {
        const listInput = lines[0].split(' ').map(Number);
        const targetValue = parseInt(lines[1]);

        let head = null;
        let tail = null;

        for (let val of listInput) {
            if (val === -1) {
                break;
            }
            const newNode = new ListNode(val);
            if (head === null) {
                head = newNode;
                tail = newNode;
            } else {
                tail.next = newNode;
                tail = newNode;
            }
        }

        // Remove the specific node
        head = removeSpecificNode(head, targetValue);

        // Print the modified list
        printList(head);
    });
}

main();","#include <iostream>

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// Function to remove the first occurrence of targetValue
ListNode* removeSpecificNode(ListNode* head, int targetValue) {
    if (head == nullptr) {
        return nullptr;
    }

    // Case 1: Target is the head node
    if (head->val == targetValue) {
        ListNode* temp = head;
        head = head->next;
        delete temp; // Free memory
        return head;
    }

    // Case 2: Target is in the middle or end of the list
    ListNode* current = head;
    ListNode* previous = nullptr;

    while (current != nullptr && current->val != targetValue) {
        previous = current;
        current = current->next;
    }

    // If targetValue was found
    if (current != nullptr) {
        previous->next = current->next;
        delete current; // Free memory
    }

    return head;
}

// Function to print the linked list
void printList(ListNode* head) {
    if (head == nullptr) {
        std::cout << ""Empty List"" << std::endl;
        return;
    }
    ListNode* current = head;
    while (current != nullptr) {
        std::cout << current->val;
        if (current->next != nullptr) {
            std::cout << "" "";
        }
        current = current->next;
    }
    std::cout << std::endl;
}

// Function to free the linked list memory
void freeList(ListNode* head) {
    ListNode* current = head;
    while (current != nullptr) {
        ListNode* next = current->next;
        delete current;
        current = next;
    }
}

int main() {
    ListNode* head = nullptr;
    ListNode* tail = nullptr;
    int val;

    // Read list elements
    while (std::cin >> val && val != -1) {
        ListNode* newNode = new ListNode(val);
        if (head == nullptr) {
            head = newNode;
            tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
    }

    int targetValue;
    // Read target value to remove
    std::cin >> targetValue;

    // Remove the specific node
    head = removeSpecificNode(head, targetValue);

    // Print the modified list
    printList(head);

    // Free memory
    freeList(head);

    return 0;
}",4.1
Yellow-78,Sliding Window (Introductory problems),"*   Arrays
*   Sliding Window Technique
*   Basic Arithmetic Operations","You are given an integer array `nums` and an integer `k`. Your task is to find a contiguous subarray whose length is equal to `k` that has the maximum average value. Return this maximum average.

Any answer with a calculation error less than `10^-5` will be accepted.","*   `1 <= k <= nums.length <= 10^5`
*   `-10^4 <= nums[i] <= 10^4`","6
1 12 -5 -6 50 3
4",12.75,"Input: 5
0 1 1 3 3
4
Output: 2.00000
Input: 1
5
1
Output: 5.00000
Input: 5
4 0 4 3 3
5
Output: 2.80000
Input: 5
-1 -2 -3 -4 -5
2
Output: -1.50000
Input: 5
1 2 3 4 5
2
Output: 4.50000","#include <stdio.h>
#include <stdlib.h> // For malloc, free
#include <float.h>  // For DBL_MIN

double findMaxAverage(int* nums, int numsSize, int k) {
    long long current_sum = 0;

    // Calculate the sum of the first window
    for (int i = 0; i < k; i++) {
        current_sum += nums[i];
    }

    long long max_sum = current_sum;

    // Slide the window through the rest of the array
    for (int i = k; i < numsSize; i++) {
        current_sum = current_sum - nums[i - k] + nums[i];
        if (current_sum > max_sum) {
            max_sum = current_sum;
        }
    }

    return (double)max_sum / k;
}

int main() {
    int numsSize;
    scanf(""%d"", &numsSize);

    int* nums = (int*)malloc(numsSize * sizeof(int));
    if (nums == NULL) {
        return 1; // Error handling for malloc
    }

    for (int i = 0; i < numsSize; i++) {
        scanf(""%d"", &nums[i]);
    }

    int k;
    scanf(""%d"", &k);

    double result = findMaxAverage(nums, numsSize, k);
    printf(""%.5f\n"", result);

    free(nums);
    return 0;
}","import sys
from typing import List

class Solution:
    def findMaxAverage(self, nums: List[int], k: int) -> float:
        current_sum = sum(nums[:k])
        max_sum = current_sum

        for i in range(k, len(nums)):
            current_sum = current_sum - nums[i - k] + nums[i]
            if current_sum > max_sum:
                max_sum = current_sum
        
        return float(max_sum) / k

def main():
    nums_size = int(sys.stdin.readline())

    # Read nums array (space-separated integers)
    nums = list(map(int, sys.stdin.readline().split()))

    k = int(sys.stdin.readline())

    solver = Solution()
    result = solver.findMaxAverage(nums, k)
    print(f""{result:.5f}"")

if __name__ == ""__main__"":
    main()","import java.util.Scanner;

class Solution {
    public double findMaxAverage(int[] nums, int k) {
        long currentSum = 0;

        // Calculate the sum of the first window
        for (int i = 0; i < k; i++) {
            currentSum += nums[i];
        }

        long maxSum = currentSum;

        // Slide the window through the rest of the array
        for (int i = k; i < nums.length; i++) {
            currentSum = currentSum - nums[i - k] + nums[i];
            if (currentSum > maxSum) {
                maxSum = currentSum;
            }
        }

        return (double) maxSum / k;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int numsSize = scanner.nextInt();
        int[] nums = new int[numsSize];
        for (int i = 0; i < numsSize; i++) {
            nums[i] = scanner.nextInt();
        }

        int k = scanner.nextInt();

        Solution sol = new Solution();
        double result = sol.findMaxAverage(nums, k);
        System.out.printf(""%.5f%n"", result);

        scanner.close();
    }
}","// Function signature
var findMaxAverage = function(nums, k) {
    let currentSum = 0;

    // Calculate the sum of the first window
    for (let i = 0; i < k; i++) {
        currentSum += nums[i];
    }

    let maxSum = currentSum;

    // Slide the window through the rest of the array
    for (let i = k; i < nums.length; i++) {
        currentSum = currentSum - nums[i - k] + nums[i];
        if (currentSum > maxSum) {
            maxSum = currentSum;
        }
    }

    return maxSum / k;
};

// Node.js standard input handling
let input = '';
process.stdin.on('data', chunk => {
    input += chunk;
});

process.stdin.on('end', () => {
    const lines = input.trim().split('\n');
    let lineIndex = 0;

    const numsSize = parseInt(lines[lineIndex++], 10);
    const nums = lines[lineIndex++].split(' ').map(Number); // Assuming space-separated integers

    const k = parseInt(lines[lineIndex++], 10);

    const result = findMaxAverage(nums, k);
    console.log(result.toFixed(5));
});","#include <iostream>
#include <vector>
#include <numeric> // Required for std::accumulate in some contexts, but not strictly for this sliding window implementation
#include <iomanip> // For std::fixed, std::setprecision
#include <limits>  // For std::numeric_limits

double findMaxAverage(std::vector<int>& nums, int k) {
    long long current_sum = 0;

    // Calculate the sum of the first window
    for (int i = 0; i < k; ++i) {
        current_sum += nums[i];
    }

    long long max_sum = current_sum;

    // Slide the window through the rest of the array
    for (int i = k; i < nums.size(); ++i) {
        current_sum = current_sum - nums[i - k] + nums[i];
        if (current_sum > max_sum) {
            max_sum = current_sum;
        }
    }

    return static_cast<double>(max_sum) / k;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int numsSize;
    std::cin >> numsSize;

    std::vector<int> nums(numsSize);
    for (int i = 0; i < numsSize; ++i) {
        std::cin >> nums[i];
    }

    int k;
    std::cin >> k;

    double result = findMaxAverage(nums, k);
    std::cout << std::fixed << std::setprecision(5) << result << std::endl;

    return 0;
}",4.4
Yellow-79,Fibonacci (Recursive with Memoization),"*   Recursion
*   Base Cases
*   Memoization (Top-Down Dynamic Programming)
*   Time Complexity Optimization
*   Mathematical Sequences","The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. The sequence begins: 0, 1, 1, 2, 3, 5, 8, 13, 21, and so on.

You've likely encountered simple recursive solutions for Fibonacci. However, a straightforward recursive approach, like `fib(n) = fib(n-1) + fib(n-2)`, is highly inefficient for larger `N` because it re-calculates the same Fibonacci numbers many times. This leads to exponential time complexity.

Your task is to write a function that calculates the Nth number in the Fibonacci sequence using a recursive approach, but **optimized with memoization (dynamic programming)**. This means you should store the results of previously computed Fibonacci numbers to avoid redundant calculations. The goal is to still leverage recursion but make it performant by ensuring each Fibonacci number is computed only once.

The sequence is 0-indexed, meaning `fib(0) = 0`, `fib(1) = 1`, `fib(2) = 1`, and so on.",*   `0 <= N <= 40`,"**

10


**","**

55


**","Input: 0
Output: 0
Input: 1
Output: 1
Input: 2
Output: 1
Input: 10
Output: 55
Input: 20
Output: 6765
Input: 30
Output: 832040
Input: 40
Output: 102334155","#include <stdio.h>
#include <stdlib.h> // For malloc, free
#include <string.h> // For memset

// Function to calculate the Nth Fibonacci number recursively with memoization
int fibonacci_memo(int n, int *memo) {
    // Base cases
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }

    // Check if the value is already computed
    if (memo[n] != -1) {
        return memo[n];
    }

    // Recursive step: compute and store
    memo[n] = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo);
    return memo[n];
}

int main() {
    int n;
    // Read input from stdin
    if (scanf(""%d"", &n) != 1) {
        return 1; // Error reading input
    }
    
    // Create and initialize memoization table
    // Using -1 as a sentinel value to indicate not computed
    int *memo = (int *)malloc((n + 1) * sizeof(int));
    if (memo == NULL) {
        return 1; // Memory allocation failed
    }
    for (int i = 0; i <= n; i++) {
        memo[i] = -1;
    }
    // For larger arrays, memset could be used: memset(memo, -1, (n + 1) * sizeof(int));

    // Calculate and print the Nth Fibonacci number
    printf(""%d\n"", fibonacci_memo(n, memo));
    
    // Free allocated memory
    free(memo);
    
    return 0;
}","import sys

# Function to calculate the Nth Fibonacci number recursively with memoization
def fibonacci_memo(n, memo):
    # Base cases
    if n == 0:
        return 0
    if n == 1:
        return 1

    # Check if the value is already computed
    if memo[n] != -1: # Using -1 as sentinel
        return memo[n]

    # Recursive step: compute and store
    memo[n] = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo)
    return memo[n]

if __name__ == '__main__':
    # Read input from stdin
    n = int(sys.stdin.readline().strip())
    
    # Create and initialize memoization table
    # Using -1 as a sentinel value to indicate not computed
    memo = [-1] * (n + 1)

    # Calculate and print the Nth Fibonacci number
    result = fibonacci_memo(n, memo)
    sys.stdout.write(str(result) + '\n')","import java.util.Scanner;
import java.util.Arrays; // For Arrays.fill

public class Solution {

    // Function to calculate the Nth Fibonacci number recursively with memoization
    public static int fibonacci_memo(int n, int[] memo) {
        // Base cases
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }

        // Check if the value is already computed
        if (memo[n] != -1) {
            return memo[n];
        }

        // Recursive step: compute and store
        memo[n] = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo);
        return memo[n];
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // Read input from stdin
        int n = scanner.nextInt();
        scanner.close();
        
        // Create and initialize memoization table
        // Using -1 as a sentinel value to indicate not computed
        int[] memo = new int[n + 1];
        Arrays.fill(memo, -1);

        // Calculate and print the Nth Fibonacci number
        System.out.println(fibonacci_memo(n, memo));
    }
}","const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

// Function to calculate the Nth Fibonacci number recursively with memoization
function fibonacci_memo(n, memo) {
  // Base cases
  if (n === 0) {
    return 0;
  }
  if (n === 1) {
    return 1;
  }

  // Check if the value is already computed
  if (memo[n] !== -1) { // Using -1 as sentinel
    return memo[n];
  }

  // Recursive step: compute and store
  memo[n] = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo);
  return memo[n];
}

rl.on('line', (line) => {
  const n = parseInt(line.trim(), 10);
  
  // Create and initialize memoization table
  // Using -1 as a sentinel value to indicate not computed
  const memo = new Array(n + 1).fill(-1);

  // Calculate and print the Nth Fibonacci number
  console.log(fibonacci_memo(n, memo));
  rl.close();
});","#include <iostream>
#include <vector>

// Function to calculate the Nth Fibonacci number recursively with memoization
int fibonacci_memo(int n, std::vector<int>& memo) {
    // Base cases
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }

    // Check if the value is already computed
    if (memo[n] != -1) {
        return memo[n];
    }

    // Recursive step: compute and store
    memo[n] = fibonacci_memo(n - 1, memo) + fibonacci_memo(n - 2, memo);
    return memo[n];
}

int main() {
    int n;
    // Read input from stdin
    std::cin >> n;
    
    // Create and initialize memoization table using a vector
    // Using -1 as a sentinel value to indicate not computed
    std::vector<int> memo(n + 1, -1);

    // Calculate and print the Nth Fibonacci number
    std::cout << fibonacci_memo(n, memo) << std::endl;
    
    return 0;
}",4.4
Yellow-80,Frequency Count / Anagrams,"*   Frequency Arrays
*   String Manipulation
*   Character Properties (e.g., `isalnum`, `tolower` in C/C++; `Character.isLetterOrDigit`, `Character.toLowerCase` in Java; `str.isalnum`, `str.lower` in Python; `char >= 'a' && char <= 'z'` or `char >= '0' && char <= '9'` with `char.toLowerCase()` in JS)
*   Basic Algorithm Design","In inventory and database management systems, item identifiers, product codes, or record IDs often consist of a mix of letters and numbers. Due to different input methods, region-specific formatting, or system migrations, two identifiers that refer to the *same* underlying item might appear different. For example, ""ITEM-ABC-123"" and ""123ABCITEM"" could represent the same product.

Your task is to write a function that determines if two given alphanumeric strings, `id1` and `id2`, represent the *same core set of alphanumeric characters*. This means they should be considered equivalent if they contain the same frequency of **alphabetic characters (case-insensitive)** and **digits (0-9)**, ignoring all other characters (like spaces, hyphens, slashes, punctuation, etc.). This helps in de-duplicating records and ensuring data consistency.","*   `0 <= len(id1), len(id2) <= 1000`
*   Both strings consist of English letters (uppercase and lowercase), digits, spaces, and other symbols.
*   The comparison should be case-insensitive for alphabetic characters.
*   Only alphabetic characters and digits (0-9) should be considered for the anagram check. All other characters are ignored.","id1 = ""ITEM-ABC-123""
id2 = ""123ABCITEM""",TRUE,"Input: id1 = ""Race"", id2 = ""Care""
Output: true
Input: id1 = ""Eleven plus two"", id2 = ""Twelve plus one""
Output: true
Input: id1 = ""apple"", id2 = ""aple""
Output: false
Input: id1 = ""a1b2c"", id2 = ""cba""
Output: false
Input: id1 = ""ITEM-ABC-123"", id2 = ""123ABCITEM""
Output: true
Input: id1 = ""Product-X9001"", id2 = ""9001-Pro-X""
Output: true
Input: id1 = ""ABC-123"", id2 = ""XYZ-123""
Output: false
Input: id1 = ""SKU-456"", id2 = ""SKU-45""
Output: false
Input: id1 = ""Only-123-Digits"", id2 = ""Digits-321-Only""
Output: true
Input: id1 = ""NoAlphanumeric!@#"", id2 = ""Symbols$%^""
Output: true
Input: id1 = """", id2 = """"
Output: true","#include <stdio.h>
#include <string.h>
#include <ctype.h> // For isalpha, isdigit, tolower
#include <stdbool.h>

// Function to check if two strings are alphanumeric anagrams
bool isAlphanumericAnagram(const char* id1, const char* id2) {
    int counts[36] = {0}; // Frequency array for 'a'-'z' (0-25) and '0'-'9' (26-35)

    // Process id1
    for (int i = 0; id1[i] != '\0'; i++) {
        char c = id1[i];
        if (isalpha(c)) {
            counts[tolower(c) - 'a']++;
        } else if (isdigit(c)) {
            counts[c - '0' + 26]++; // Map digits to indices 26-35
        }
    }

    // Process id2
    for (int i = 0; id2[i] != '\0'; i++) {
        char c = id2[i];
        if (isalpha(c)) {
            counts[tolower(c) - 'a']--;
        } else if (isdigit(c)) {
            counts[c - '0' + 26]--; // Map digits to indices 26-35
        }
    }

    // Check if all counts are zero
    for (int i = 0; i < 36; i++) {
        if (counts[i] != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    char id1[1001]; // Max length 1000 + null terminator
    char id2[1001];

    // Read input strings
    if (fgets(id1, sizeof(id1), stdin) == NULL) {
        return 1; // Error reading input
    }
    // Remove trailing newline character if present
    id1[strcspn(id1, ""\n"")] = '\0';

    if (fgets(id2, sizeof(id2), stdin) == NULL) {
        return 1; // Error reading input
    }
    // Remove trailing newline character if present
    id2[strcspn(id2, ""\n"")] = '\0';

    // Call the core logic function
    if (isAlphanumericAnagram(id1, id2)) {
        printf(""true\n"");
    } else {
        printf(""false\n"");
    }

    return 0;
}","import sys

def is_alphanumeric_anagram(id1: str, id2: str) -> bool:
    counts = [0] * 36  # Frequency array for 'a'-'z' (0-25) and '0'-'9' (26-35)

    # Process id1
    for char in id1:
        if char.isalpha():
            counts[ord(char.lower()) - ord('a')] += 1
        elif char.isdigit():
            counts[ord(char) - ord('0') + 26] += 1 # Map digits to indices 26-35

    # Process id2
    for char in id2:
        if char.isalpha():
            counts[ord(char.lower()) - ord('a')] -= 1
        elif char.isdigit():
            counts[ord(char) - ord('0') + 26] -= 1 # Map digits to indices 26-35

    # Check if all counts are zero
    for count in counts:
        if count != 0:
            return False

    return True

def main():
    id1 = sys.stdin.readline().strip()
    id2 = sys.stdin.readline().strip()

    if is_alphanumeric_anagram(id1, id2):
        print(""true"")
    else:
        print(""false"")

if __name__ == ""__main__"":
    main()","import java.util.Scanner;

public class AlphanumericAnagramChecker {

    // Function to check if two strings are alphanumeric anagrams
    public static boolean isAlphanumericAnagram(String id1, String id2) {
        int[] counts = new int[36]; // Frequency array for 'a'-'z' (0-25) and '0'-'9' (26-35)

        // Process id1
        for (char c : id1.toCharArray()) {
            if (Character.isLetter(c)) {
                counts[Character.toLowerCase(c) - 'a']++;
            } else if (Character.isDigit(c)) {
                counts[c - '0' + 26]++; // Map digits to indices 26-35
            }
        }

        // Process id2
        for (char c : id2.toCharArray()) {
            if (Character.isLetter(c)) {
                counts[Character.toLowerCase(c) - 'a']--;
            } else if (Character.isDigit(c)) {
                counts[c - '0' + 26]--; // Map digits to indices 26-35
            }
        }

        // Check if all counts are zero
        for (int count : counts) {
            if (count != 0) {
                return false;
            }
        }

        return true;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read input strings
        String id1 = scanner.nextLine();
        String id2 = scanner.nextLine();

        // Call the core logic function
        if (isAlphanumericAnagram(id1, id2)) {
            System.out.println(""true"");
        } else {
            System.out.println(""false"");
        }

        scanner.close();
    }
}","// Function to check if two strings are alphanumeric anagrams
function isAlphanumericAnagram(id1, id2) {
    const counts = new Array(36).fill(0); // Frequency array for 'a'-'z' (0-25) and '0'-'9' (26-35)
    
    // Helper to process a string
    const processString = (str, increment) => {
        for (let i = 0; i < str.length; i++) {
            const char = str[i];
            let index = -1; // Default to -1, means ignore

            // Check if alphabetic
            if (char >= 'a' && char <= 'z') {
                index = char.charCodeAt(0) - 'a'.charCodeAt(0);
            } else if (char >= 'A' && char <= 'Z') {
                index = char.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0);
            } 
            // Check if digit
            else if (char >= '0' && char <= '9') {
                index = char.charCodeAt(0) - '0'.charCodeAt(0) + 26; // Map digits to indices 26-35
            }

            if (index !== -1) {
                counts[index] += increment;
            }
        }
    };

    // Process id1
    processString(id1, 1);

    // Process id2
    processString(id2, -1);

    // Check if all counts are zero
    for (let i = 0; i < 36; i++) {
        if (counts[i] !== 0) {
            return false;
        }
    }

    return true;
}

// Main function to handle input/output
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let lines = [];
    rl.on('line', (line) => {
        lines.push(line);
    }).on('close', () => {
        const id1 = lines[0];
        const id2 = lines[1];

        if (isAlphanumericAnagram(id1, id2)) {
            console.log(""true"");
        } else {
            console.log(""false"");
        }
    });
}

// Call the main function
main();","#include <iostream>
#include <string>
#include <vector>
#include <cctype> // For tolower, isalpha, isdigit

// Function to check if two strings are alphanumeric anagrams
bool isAlphanumericAnagram(const std::string& id1, const std::string& id2) {
    std::vector<int> counts(36, 0); // Frequency array for 'a'-'z' (0-25) and '0'-'9' (26-35)

    // Process id1
    for (char c : id1) {
        if (std::isalpha(c)) {
            counts[std::tolower(c) - 'a']++;
        } else if (std::isdigit(c)) {
            counts[c - '0' + 26]++; // Map digits to indices 26-35
        }
    }

    // Process id2
    for (char c : id2) {
        if (std::isalpha(c)) {
            counts[std::tolower(c) - 'a']--;
        } else if (std::isdigit(c)) {
            counts[c - '0' + 26]--; // Map digits to indices 26-35
        }
    }

    // Check if all counts are zero
    for (int count : counts) {
        if (count != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    std::string id1;
    std::string id2;

    // Read input strings
    std::getline(std::cin, id1);
    std::getline(std::cin, id2);

    // Call the core logic function
    if (isAlphanumericAnagram(id1, id2)) {
        std::cout << ""true"" << std::endl;
    } else {
        std::cout << ""false"" << std::endl;
    }

    return 0;
}",4.6
Yellow-81,Kadane’s Algorithm (Max Subarray Sum with Indices),"*   Kadane's Algorithm
*   Dynamic Programming (implicit)
*   Array Traversal
*   Greedy Approach
*   Array Index Tracking","Given an integer array `nums`, find the contiguous subarray (containing at least one number) which has the largest sum. Your task is to return a list/array containing three integers: the largest sum, the starting index (0-indexed) of that subarray, and the ending index (0-indexed) of that subarray.

A contiguous subarray is a portion of an array that consists of consecutive elements.
If there are multiple subarrays with the same maximum sum, return the one that appears first (i.e., has the smallest starting index).","* `1 <= nums.length <= 10^5`
* `-10^4 <= nums[i] <= 10^4`","** `nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]`
**","** `6 3 6`
**","Input: 1
1
Output: 1 0 0
Input: 1
-1
Output: -1 0 0
Input: 3
1 2 3
Output: 6 0 2
Input: 6
-10 5 -2 8 -3 15
Output: 23 1 5
Input: 9
-2 1 -3 4 -1 2 1 -5 4
Output: 6 3 6
Input: 5
5 4 -1 7 8
Output: 23 0 4
Input: 4
-5 -2 -1 -10
Output: -1 2 2
Input: 6
-2 1 -3 4 -1 2
Output: 5 3 5
Input: 7
1 -1 1 -1 1 -1 1
Output: 1 0 0","#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

// Structure to hold the result: sum, start index, end index
typedef struct {
    int sum;
    int start;
    int end;
} Result;

// Function to find the maximum sum of a contiguous subarray along with its indices
Result maxSubArraySumWithIndices(int* nums, int numsSize) {
    Result result;
    if (numsSize == 0) {
        result.sum = 0;
        result.start = -1;
        result.end = -1;
        return result;
    }

    int max_so_far = nums[0];
    int current_max = nums[0];
    int max_start = 0;
    int max_end = 0;
    int current_start = 0;

    for (int i = 1; i < numsSize; i++) {
        if (nums[i] > current_max + nums[i]) {
            current_max = nums[i];
            current_start = i;
        } else {
            current_max = current_max + nums[i];
        }

        if (current_max > max_so_far) {
            max_so_far = current_max;
            max_start = current_start;
            max_end = i;
        }
    }

    result.sum = max_so_far;
    result.start = max_start;
    result.end = max_end;
    return result;
}

int main() {
    int numsSize;
    // Read the size of the array
    scanf(""%d"", &numsSize);

    // Allocate memory for the array
    int* nums = (int*)malloc(numsSize * sizeof(int));
    if (nums == NULL) {
        return 1; // Error allocating memory
    }

    // Read the array elements
    for (int i = 0; i < numsSize; i++) {
        scanf(""%d"", &nums[i]);
    }

    // Calculate and print the maximum subarray sum and its indices
    Result result = maxSubArraySumWithIndices(nums, numsSize);
    printf(""%d %d %d\n"", result.sum, result.start, result.end);

    // Free the allocated memory
    free(nums);

    return 0;
}","from typing import List

class Solution:
    def maxSubArraySumWithIndices(self, nums: List[int]) -> List[int]:
        if not nums:
            return [0, -1, -1]
        
        max_so_far = nums[0]
        current_max = nums[0]
        max_start = 0
        max_end = 0
        current_start = 0
        
        for i in range(1, len(nums)):
            if nums[i] > current_max + nums[i]:
                current_max = nums[i]
                current_start = i
            else:
                current_max = current_max + nums[i]
            
            if current_max > max_so_far:
                max_so_far = current_max
                max_start = current_start
                max_end = i
            
        return [max_so_far, max_start, max_end]

if __name__ == '__main__':
    # Read the size of the array
    nums_size = int(input())
    
    # Read the array elements
    # Assuming input is space-separated integers on a single line
    nums = list(map(int, input().split()))
    
    solution = Solution()
    # Calculate and print the maximum subarray sum and its indices
    result = solution.maxSubArraySumWithIndices(nums)
    print(f""{result[0]} {result[1]} {result[2]}"")","import java.util.Scanner;

public class Main {

    // Function to find the maximum sum of a contiguous subarray along with its indices
    // Returns an array: {max_sum, start_index, end_index}
    public int[] maxSubArraySumWithIndices(int[] nums) {
        if (nums == null || nums.length == 0) {
            return new int[]{0, -1, -1};
        }

        int maxSoFar = nums[0];
        int currentMax = nums[0];
        int maxStart = 0;
        int maxEnd = 0;
        int currentStart = 0;

        for (int i = 1; i < nums.length; i++) {
            if (nums[i] > currentMax + nums[i]) {
                currentMax = nums[i];
                currentStart = i;
            } else {
                currentMax = currentMax + nums[i];
            }

            if (currentMax > maxSoFar) {
                maxSoFar = currentMax;
                maxStart = currentStart;
                maxEnd = i;
            }
        }

        return new int[]{maxSoFar, maxStart, maxEnd};
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Read the size of the array
        int numsSize = scanner.nextInt();
        
        int[] nums = new int[numsSize];
        // Read the array elements
        for (int i = 0; i < numsSize; i++) {
            nums[i] = scanner.nextInt();
        }
        
        Main solution = new Main();
        // Calculate and print the maximum subarray sum and its indices
        int[] result = solution.maxSubArraySumWithIndices(nums);
        System.out.println(result[0] + "" "" + result[1] + "" "" + result[2]);
        
        scanner.close();
    }
}","/**
 * @param {number[]} nums
 * @return {number[]}
 * Returns an array: [max_sum, start_index, end_index]
 */
function maxSubArraySumWithIndices(nums) {
    if (!nums || nums.length === 0) {
        return [0, -1, -1];
    }

    let maxSoFar = nums[0];
    let currentMax = nums[0];
    let maxStart = 0;
    let maxEnd = 0;
    let currentStart = 0;

    for (let i = 1; i < nums.length; i++) {
        if (nums[i] > currentMax + nums[i]) {
            currentMax = nums[i];
            currentStart = i;
        } else {
            currentMax = currentMax + nums[i];
        }

        if (currentMax > maxSoFar) {
            maxSoFar = currentMax;
            maxStart = currentStart;
            maxEnd = i;
        }
    }

    return [maxSoFar, maxStart, maxEnd];
}

// --- Main function for handling input/output in a typical competitive programming environment ---
// This setup assumes Node.js environment where readline can be used.
// For browser-based environments or direct function calls, this part might vary.

const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let inputLines = [];
rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    const numsSize = parseInt(inputLines[0], 10);
    const nums = inputLines[1].split(' ').map(Number);

    const result = maxSubArraySumWithIndices(nums);
    console.log(`${result[0]} ${result[1]} ${result[2]}`);
});","#include <iostream>
#include <vector>
#include <algorithm> // For std::max
#include <tuple>     // For std::tuple

// Function to find the maximum sum of a contiguous subarray along with its indices
// Returns a tuple: {max_sum, start_index, end_index}
std::tuple<int, int, int> maxSubArraySumWithIndices(const std::vector<int>& nums) {
    if (nums.empty()) {
        return {0, -1, -1}; // Or throw an exception, depending on requirements
    }

    int max_so_far = nums[0];
    int current_max = nums[0];
    int max_start = 0;
    int max_end = 0;
    int current_start = 0;

    for (size_t i = 1; i < nums.size(); ++i) {
        if (nums[i] > current_max + nums[i]) {
            current_max = nums[i];
            current_start = i;
        } else {
            current_max = current_max + nums[i];
        }

        if (current_max > max_so_far) {
            max_so_far = current_max;
            max_start = current_start;
            max_end = i;
        }
    }

    return {max_so_far, max_start, max_end};
}

int main() {
    int numsSize;
    // Read the size of the array
    std::cin >> numsSize;

    std::vector<int> nums(numsSize);
    // Read the array elements
    for (int i = 0; i < numsSize; ++i) {
        std::cin >> nums[i];
    }

    // Calculate and print the maximum subarray sum and its indices
    auto result = maxSubArraySumWithIndices(nums);
    std::cout << std::get<0>(result) << "" "" << std::get<1>(result) << "" "" << std::get<2>(result) << std::endl;

    return 0;
}",4.6
Yellow-82,Linear Search,"- Linear Search / Array Traversal
- Conditional Logic (Complex/Nested)
- Edge Case Handling (Array Boundaries)
- Time and Space Complexity Analysis","You are given an array of integers `arr` and a target integer `target`. Your task is to find the **first** index (0-based) where the `target` appears in the `arr` **AND** satisfies the condition of being a 'peak' element. A peak element is one that is strictly greater than its immediate neighbors.

Here's how to determine if an element `arr[i]` is a peak:
*   **If the array has only one element (`N = 1`)**: That single element `arr[0]` is considered a peak if it matches the `target`.
*   **If `arr[i]` is the first element (`i == 0`) and `N > 1`**: It is a peak if `arr[i] > arr[i+1]`.
*   **If `arr[i]` is the last element (`i == N-1`) and `N > 1`**: It is a peak if `arr[i] > arr[i-1]`.
*   **If `arr[i]` is a middle element (`0 < i < N-1`)**: It is a peak if `arr[i] > arr[i-1]` AND `arr[i] > arr[i+1]`.

If no such targeted peak is found in the array, you should return `-1`.","- `1 <= N <= 100` (where `N` is the number of elements in `arr`)
- `-1000 <= arr[i] <= 1000`
- `-1000 <= target <= 1000`","5
1 5 3 8 2
5",1,"Input: 5
1 5 3 8 2
5
Output: 1
Input: 5
1 2 5 3 8
5
Output: -1
Input: 4
10 5 15 3
10
Output: 0
Input: 4
1 5 3 8
8
Output: 3
Input: 1
7
7
Output: 0
Input: 1
7
8
Output: -1
Input: 5
1 2 3 4 5
10
Output: -1
Input: 7
1 8 5 8 3 8 2
8
Output: 1
Input: 5
1 2 3 2 1
2
Output: -1
Input: 5
-10 -5 -15 -2 -20
-5
Output: 1","#include <stdio.h>

int findTargetedPeak(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            int isPeak = 0; // Flag to track if the current element is a peak

            if (n == 1) {
                // If N=1, the single element is always a peak
                isPeak = 1;
            } else if (i == 0) {
                // First element (N > 1): must be greater than its right neighbor
                if (arr[i] > arr[i+1]) {
                    isPeak = 1;
                }
            } else if (i == n - 1) {
                // Last element (N > 1): must be greater than its left neighbor
                if (arr[i] > arr[i-1]) {
                    isPeak = 1;
                }
            } else {
                // Middle element: must be greater than both neighbors
                if (arr[i] > arr[i-1] && arr[i] > arr[i+1]) {
                    isPeak = 1;
                }
            }

            if (isPeak) {
                return i; // Return the first index where target is found AND is a peak
            }
        }
    }
    return -1; // Targeted peak not found
}

int main() {
    int n;
    // Read the number of elements
    scanf(""%d"", &n);

    int arr[n]; // Declare array of size n
    // Read array elements
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]);
    }

    int target;
    // Read the target value
    scanf(""%d"", &target);

    // Call the function to find the targeted peak
    int result = findTargetedPeak(arr, n, target);

    // Print the result
    printf(""%d\n"", result);

    return 0;
}","def find_targeted_peak(arr, target):
    n = len(arr)
    for i in range(n):
        if arr[i] == target:
            is_peak = False # Flag to track if the current element is a peak

            if n == 1:
                # If N=1, the single element is always a peak
                is_peak = True
            elif i == 0: # First element (N > 1): must be greater than its right neighbor
                if arr[i] > arr[i+1]:
                    is_peak = True
            elif i == n - 1: # Last element (N > 1): must be greater than its left neighbor
                if arr[i] > arr[i-1]:
                    is_peak = True
            else: # Middle element: must be greater than both neighbors
                if arr[i] > arr[i-1] and arr[i] > arr[i+1]:
                    is_peak = True
            
            if is_peak:
                return i # Return the first index where target is found AND is a peak
    return -1 # Targeted peak not found

if __name__ == '__main__':
    # Read the number of elements
    n = int(input())

    # Read array elements
    arr = list(map(int, input().split()))

    # Read the target value
    target = int(input())

    # Call the function to find the targeted peak
    result = find_targeted_peak(arr, target)

    # Print the result
    print(result)","import java.util.Scanner;

public class Solution {

    public static int findTargetedPeak(int[] arr, int target) {
        int n = arr.length;
        for (int i = 0; i < n; i++) {
            if (arr[i] == target) {
                boolean isPeak = false; // Flag to track if the current element is a peak

                if (n == 1) {
                    // If N=1, the single element is always a peak
                    isPeak = true;
                } else if (i == 0) {
                    // First element (N > 1): must be greater than its right neighbor
                    if (arr[i] > arr[i+1]) {
                        isPeak = true;
                    }
                } else if (i == n - 1) {
                    // Last element (N > 1): must be greater than its left neighbor
                    if (arr[i] > arr[i-1]) {
                        isPeak = true;
                    }
                } else {
                    // Middle element: must be greater than both neighbors
                    if (arr[i] > arr[i-1] && arr[i] > arr[i+1]) {
                        isPeak = true;
                    }
                }

                if (isPeak) {
                    return i; // Return the first index where target is found AND is a peak
                }
            }
        }
        return -1; // Targeted peak not found
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the number of elements
        int n = scanner.nextInt();

        int[] arr = new int[n];
        // Read array elements
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        // Read the target value
        int target = scanner.nextInt();

        // Call the function to find the targeted peak
        int result = findTargetedPeak(arr, target);

        // Print the result
        System.out.println(result);

        scanner.close();
    }
}","function findTargetedPeak(arr, target) {
    const n = arr.length;
    for (let i = 0; i < n; i++) {
        if (arr[i] === target) {
            let isPeak = false; // Flag to track if the current element is a peak

            if (n === 1) {
                // If N=1, the single element is always a peak
                isPeak = true;
            } else if (i === 0) {
                // First element (N > 1): must be greater than its right neighbor
                if (arr[i] > arr[i+1]) {
                    isPeak = true;
                }
            } else if (i === n - 1) {
                // Last element (N > 1): must be greater than its left neighbor
                if (arr[i] > arr[i-1]) {
                    isPeak = true;
                }
            } else {
                // Middle element: must be greater than both neighbors
                if (arr[i] > arr[i-1] && arr[i] > arr[i+1]) {
                    isPeak = true;
                }
            }

            if (isPeak) {
                return i; // Return the first index where target is found AND is a peak
            }
        }
    }
    return -1; // Targeted peak not found
}

// Main function to handle input/output
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let inputLines = [];
    rl.on('line', (line) => {
        inputLines.push(line);
    });

    rl.on('close', () => {
        // The first line is N (number of elements)
        // const n = parseInt(inputLines[0]); // Not strictly needed as arr.length gives N
        
        // The second line contains the array elements
        const arr = inputLines[1].split(' ').map(Number);
        
        // The third line is the target value
        const target = parseInt(inputLines[2]);

        const result = findTargetedPeak(arr, target);
        console.log(result);
    });
}
main(); // Call main function to start execution","#include <iostream>
#include <vector>

int findTargetedPeak(const std::vector<int>& arr, int target) {
    int n = arr.size();
    for (int i = 0; i < n; ++i) {
        if (arr[i] == target) {
            bool isPeak = false; // Flag to track if the current element is a peak

            if (n == 1) {
                // If N=1, the single element is always a peak
                isPeak = true;
            } else if (i == 0) {
                // First element (N > 1): must be greater than its right neighbor
                if (arr[i] > arr[i+1]) {
                    isPeak = true;
                }
            } else if (i == n - 1) {
                // Last element (N > 1): must be greater than its left neighbor
                if (arr[i] > arr[i-1]) {
                    isPeak = true;
                }
            } else {
                // Middle element: must be greater than both neighbors
                if (arr[i] > arr[i-1] && arr[i] > arr[i+1]) {
                    isPeak = true;
                }
            }

            if (isPeak) {
                return i; // Return the first index where target is found AND is a peak
            }
        }
    }
    return -1; // Targeted peak not found
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    // Read the number of elements
    std::cin >> n;

    std::vector<int> arr(n);
    // Read array elements
    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i];
    }

    int target;
    // Read the target value
    std::cin >> target;

    // Call the function to find the targeted peak
    int result = findTargetedPeak(arr, target);

    // Print the result
    std::cout << result << std::endl;

    return 0;
}",4.2
Yellow-83,Character Hashing,"*   Character Hashing (using a frequency array)
*   Strings
*   Arrays
*   Basic Looping","Write a program that takes a string consisting of lowercase English letters and counts the frequency of each character. The program should then print each character and its count, sorted alphabetically by character, only including characters that appear at least once.","*   The input string `S` will contain only lowercase English letters (`a`-`z`).
*   `1 <= len(S) <= 1000`",`banana`,"`a: 3`
`b: 1`
`n: 2`","Input: hello
Output:
e: 1
h: 1
l: 2
o: 1
Input: aaaaabbbccc
Output:
a: 5
b: 3
c: 3
Input: abracadabra
Output:
a: 5
b: 2
c: 1
d: 1
r: 2
Input: programming
Output:
a: 1
g: 2
i: 1
m: 2
n: 1
o: 1
p: 1
r: 2
Input: z
Output:
z: 1","#include <stdio.h>
#include <string.h>
#include <stdlib.h> 

#define ALPHABET_SIZE 26

// Function to count character frequencies
void countCharacterFrequencies(const char* s) {
    int frequencies[ALPHABET_SIZE] = {0}; // Initialize all counts to 0
    int i;

    // Iterate through the string and count frequencies
    for (i = 0; s[i] != '\0'; i++) {
        if (s[i] >= 'a' && s[i] <= 'z') {
            frequencies[s[i] - 'a']++;
        }
    }

    // Print frequencies for characters that appeared
    for (i = 0; i < ALPHABET_SIZE; i++) {
        if (frequencies[i] > 0) {
            printf(""%c: %d\n"", (char)('a' + i), frequencies[i]);
        }
    }
}

int main() {
    char inputString[1001]; // Max length 1000 + null terminator

    // Read input string
    if (fgets(inputString, sizeof(inputString), stdin) != NULL) {
        // Remove trailing newline character if present
        inputString[strcspn(inputString, ""\n"")] = '\0';
        countCharacterFrequencies(inputString);
    }

    return 0;
}","import sys

def count_character_frequencies(s: str):
    """"""
    Counts the frequency of each lowercase English letter in a string.
    Prints the characters and their counts, sorted alphabetically.
    """"""
    frequencies = [0] * 26  # Initialize an array of 26 zeros for a-z

    for char_code in map(ord, s):
        if ord('a') <= char_code <= ord('z'):
            frequencies[char_code - ord('a')] += 1

    for i in range(26):
        if frequencies[i] > 0:
            char = chr(ord('a') + i)
            sys.stdout.write(f""{char}: {frequencies[i]}\n"")

if __name__ == '__main__':
    input_string = sys.stdin.readline().strip()
    count_character_frequencies(input_string)","import java.util.Scanner;

public class Solution {

    // Function to count character frequencies
    public void countCharacterFrequencies(String s) {
        // Using an array for frequency count for fixed alphabet (a-z)
        int[] frequencies = new int[26]; // All initialized to 0

        for (char c : s.toCharArray()) {
            if (c >= 'a' && c <= 'z') {
                frequencies[c - 'a']++;
            }
        }

        // Print frequencies for characters that appeared, in alphabetical order
        for (int i = 0; i < 26; i++) {
            if (frequencies[i] > 0) {
                System.out.println((char)('a' + i) + "": "" + frequencies[i]);
            }
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String inputString = scanner.nextLine();
        scanner.close();

        Solution sol = new Solution();
        sol.countCharacterFrequencies(inputString);
    }
}","function countCharacterFrequencies(s) {
    const frequencies = new Array(26).fill(0); // Initialize array for a-z

    for (let i = 0; i < s.length; i++) {
        const charCode = s.charCodeAt(i);
        if (charCode >= 'a'.charCodeAt(0) && charCode <= 'z'.charCodeAt(0)) {
            frequencies[charCode - 'a'.charCodeAt(0)]++;
        }
    }

    for (let i = 0; i < 26; i++) {
        if (frequencies[i] > 0) {
            const char = String.fromCharCode('a'.charCodeAt(0) + i);
            console.log(`${char}: ${frequencies[i]}`);
        }
    }
}

// Read input from stdin
let inputString = '';
process.stdin.on('data', data => {
    inputString += data;
});

process.stdin.on('end', () => {
    inputString = inputString.trim(); // Remove trailing newline
    countCharacterFrequencies(inputString);
});","#include <iostream>
#include <string>
#include <vector>

// Function to count character frequencies
void countCharacterFrequencies(const std::string& s) {
    std::vector<int> frequencies(26, 0); // Initialize all counts to 0

    // Iterate through the string and count frequencies
    for (char c : s) {
        if (c >= 'a' && c <= 'z') {
            frequencies[c - 'a']++;
        }
    }

    // Print frequencies for characters that appeared
    for (int i = 0; i < 26; ++i) {
        if (frequencies[i] > 0) {
            std::cout << (char)('a' + i) << "": "" << frequencies[i] << std::endl;
        }
    }
}

int main() {
    std::string inputString;

    // Read input string
    std::getline(std::cin, inputString);

    countCharacterFrequencies(inputString);

    return 0;
}",4
Yellow-84,Prefix & Suffix Sums,"*   Array Traversal
*   Summation
*   Prefix/Suffix Sums (implicit)
*   Edge Case Handling (empty left/right sums)","You are given an array of integers `nums`. Your task is to find a ""pivot index"" in this array. A pivot index is the index where the sum of all the numbers strictly to the left of the index is equal to the sum of all the numbers strictly to the right of the index.

If the index is `0`, the left sum is considered to be `0`. Similarly, if the index is the last element of the array, the right sum is considered to be `0`.

If there are multiple such pivot indexes, you should return the leftmost pivot index. If no such index exists, return `-1`.","*   `1 <= nums.length <= 1000`
*   `-1000 <= nums[i] <= 1000`","6
1 7 3 6 5 6",3,"Input: 3
1 2 3
Output: -1
Input: 3
2 1 -1
Output: 0
Input: 6
-1 -1 0 1 1 0
Output: 5
Input: 1
0
Output: 0
Input: 3
0 0 0
Output: 0","#include <stdio.h>
#include <stdlib.h>

// Core logic function to find the pivot index
int findPivotIndex(int* nums, int numsSize) {
    if (nums == NULL || numsSize == 0) {
        return -1;
    }

    long long totalSum = 0;
    for (int i = 0; i < numsSize; i++) {
        totalSum += nums[i];
    }

    long long leftSum = 0;
    for (int i = 0; i < numsSize; i++) {
        // Calculate right sum dynamically
        long long rightSum = totalSum - leftSum - nums[i];

        if (leftSum == rightSum) {
            return i;
        }

        // Update left sum for the next iteration
        leftSum += nums[i];
    }

    return -1;
}

int main() {
    // Read input array size
    int n;
    if (scanf(""%d"", &n) != 1) {
        return 1; // Error reading size
    }

    // Allocate memory for the array
    int* nums = (int*)malloc(n * sizeof(int));
    if (nums == NULL) {
        return 1; // Memory allocation failed
    }

    // Read array elements
    for (int i = 0; i < n; i++) {
        if (scanf(""%d"", &nums[i]) != 1) {
            free(nums); // Free allocated memory before exiting
            return 1; // Error reading element
        }
    }

    // Call the core logic function
    int result = findPivotIndex(nums, n);

    // Print the result
    printf(""%d\n"", result);

    // Free allocated memory
    free(nums);

    return 0;
}","def find_pivot_index(nums):
    if not nums:
        return -1

    total_sum = sum(nums)
    left_sum = 0

    for i, num in enumerate(nums):
        # Calculate right sum dynamically
        right_sum = total_sum - left_sum - num

        if left_sum == right_sum:
            return i

        # Update left sum for the next iteration
        left_sum += num

    return -1

if __name__ == ""__main__"":
    # Read input array size
    n = int(input())

    # Read array elements
    # Assuming elements are space-separated on a single line
    nums = list(map(int, input().split()))

    # Call the core logic function
    result = find_pivot_index(nums)

    # Print the result
    print(result)","import java.util.Scanner;

public class Solution {

    // Core logic function to find the pivot index
    public int findPivotIndex(int[] nums) {
        if (nums == null || nums.length == 0) {
            return -1;
        }

        long totalSum = 0; // Use long to prevent potential overflow for sum
        for (int num : nums) {
            totalSum += num;
        }

        long leftSum = 0;
        for (int i = 0; i < nums.length; i++) {
            // Calculate right sum dynamically
            long rightSum = totalSum - leftSum - nums[i];

            if (leftSum == rightSum) {
                return i;
            }

            // Update left sum for the next iteration
            leftSum += nums[i];
        }

        return -1;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read input array size
        int n = scanner.nextInt();

        // Read array elements
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }

        // Create an instance of Solution and call the core logic function
        Solution sol = new Solution();
        int result = sol.findPivotIndex(nums);

        // Print the result
        System.out.println(result);

        scanner.close();
    }
}","function findPivotIndex(nums) {
    if (!nums || nums.length === 0) {
        return -1;
    }

    let totalSum = 0;
    for (let i = 0; i < nums.length; i++) {
        totalSum += nums[i];
    }

    let leftSum = 0;
    for (let i = 0; i < nums.length; i++) {
        // Calculate right sum dynamically
        let rightSum = totalSum - leftSum - nums[i];

        if (leftSum === rightSum) {
            return i;
        }

        // Update left sum for the next iteration
        leftSum += nums[i];
    }

    return -1;
}

// Main part for handling input/output
// This setup is common for competitive programming platforms in Node.js
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let inputLines = [];
rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    // The first line contains the count (n)
    // The second line contains the array elements, space-separated
    // const n = parseInt(inputLines[0]); // n is not strictly needed if we derive it from the array length
    const nums = inputLines[1].split(' ').map(Number);

    const result = findPivotIndex(nums);
    console.log(result);
});","#include <iostream>
#include <vector>
#include <numeric> // Required for std::accumulate, though a loop is used here

// Core logic function to find the pivot index
int findPivotIndex(std::vector<int>& nums) {
    if (nums.empty()) {
        return -1;
    }

    long long totalSum = 0; // Use long long to prevent potential overflow for sum
    for (int num : nums) {
        totalSum += num;
    }

    long long leftSum = 0;
    for (int i = 0; i < nums.size(); ++i) {
        // Calculate right sum dynamically
        long long rightSum = totalSum - leftSum - nums[i];

        if (leftSum == rightSum) {
            return i;
        }

        // Update left sum for the next iteration
        leftSum += nums[i];
    }

    return -1;
}

int main() {
    // Optimize C++ standard streams for faster input/output.
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    // Read input array size
    int n;
    std::cin >> n;

    // Read array elements
    std::vector<int> nums(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> nums[i];
    }

    // Call the core logic function
    int result = findPivotIndex(nums);

    // Print the result
    std::cout << result << std::endl;

    return 0;
}",4.2
Yellow-85,Fibonacci (Recursive),"*   Recursion
*   Base Cases
*   Recursive Step
*   Function Call Stack","The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. The sequence begins: 0, 1, 1, 2, 3, 5, 8, 13, ...

Your task is to implement a recursive function that calculates the Nth number in the Fibonacci sequence. The sequence starts with F(0) = 0 and F(1) = 1.",*   0 <= N <= 30,5,5,"Input: 0
Output: 0
Input: 1
Output: 1
Input: 2
Output: 1
Input: 3
Output: 2
Input: 8
Output: 21
","#include <stdio.h>

// Function to calculate the Nth Fibonacci number recursively
int fibonacci(int n) {
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

int main() {
    int n;
    // Read input from stdin
    if (scanf(""%d"", &n) != 1) {
        // Handle error if input is not an integer
        return 1;
    }

    // Calculate Fibonacci number
    int result = fibonacci(n);

    // Print output to stdout
    printf(""%d\n"", result);

    return 0;
}","import sys

# Function to calculate the Nth Fibonacci number recursively
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)

if __name__ == ""__main__"":
    # Read input from stdin
    n = int(sys.stdin.readline())

    # Calculate Fibonacci number
    result = fibonacci(n)

    # Print output to stdout
    sys.stdout.write(str(result) + ""\n"")","import java.util.Scanner;

public class Solution {

    // Function to calculate the Nth Fibonacci number recursively
    public static int fibonacci(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        } else {
            return fibonacci(n - 1) + fibonacci(n - 2);
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // Read input from stdin
        int n = scanner.nextInt();
        scanner.close();

        // Calculate Fibonacci number
        int result = fibonacci(n);

        // Print output to stdout
        System.out.println(result);
    }
}","'use strict';

process.stdin.resume();
process.stdin.setEncoding('utf-8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', function(inputStdin) {
    inputString += inputStdin;
});

process.stdin.on('end', function() {
    inputString = inputString.split('\n');
    main();
});

function readLine() {
    return inputString[currentLine++];
}

// Function to calculate the Nth Fibonacci number recursively
function fibonacci(n) {
    if (n === 0) {
        return 0;
    } else if (n === 1) {
        return 1;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

function main() {
    const n = parseInt(readLine().trim(), 10);

    const result = fibonacci(n);

    console.log(result);
}","#include <iostream>

// Function to calculate the Nth Fibonacci number recursively
int fibonacci(int n) {
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

int main() {
    int n;
    // Read input from stdin
    std::cin >> n;

    // Calculate Fibonacci number
    int result = fibonacci(n);

    // Print output to stdout
    std::cout << result << std::endl;

    return 0;
}",4.1
Yellow-86,"Singly Linked List (creation, traversal, insertion, deletion)","- Singly Linked List structure and basic operations.
- Node creation and management.
- Traversal of a linked list.
- Insertion of a node at the end.
- Deletion of a specific node by value.
- Pointer/reference manipulation.","You are tasked with implementing a fundamental Singly Linked List and supporting three core operations: `INSERT`, `DELETE`, and `TRAVERSE`.

Your program will receive a sequence of commands, one per line:
- `INSERT <value>`: Adds a new node with the given `<value>` at the end of the linked list.
- `DELETE <value>`: Removes the first occurrence of a node with the given `<value>` from the linked list. If the value is not found, the list remains unchanged.
- `TRAVERSE`: Prints all elements of the linked list from head to tail, separated by spaces. If the list is empty, print nothing (just a newline).

After processing all commands, the program should terminate.","- The number of operations will be between 1 and 100.
- Values for `INSERT` and `DELETE` will be integers between 0 and 1000.
- The linked list will not exceed 1000 nodes at any point.
- `TRAVERSE` operations should print their output on a new line.","**
INSERT 10
INSERT 20
TRAVERSE
DELETE 10
TRAVERSE
INSERT 30
TRAVERSE

**","**
10 20
20
20 30","Input: INSERT 5
TRAVERSE
DELETE 5
TRAVERSE
INSERT 1
INSERT 2
DELETE 3
TRAVERSE
Output: 5

1 2
Input: INSERT 100
INSERT 200
INSERT 300
DELETE 100
DELETE 300
TRAVERSE
INSERT 50
TRAVERSE
DELETE 200
TRAVERSE
Output: 200
200 50

Input: INSERT 1
INSERT 2
INSERT 3
DELETE 2
TRAVERSE
DELETE 1
TRAVERSE
DELETE 3
TRAVERSE
Output: 1 3
3

Input: INSERT 7
INSERT 8
INSERT 9
TRAVERSE
DELETE 7
DELETE 8
DELETE 9
TRAVERSE
Output: 7 8 9
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define Node structure
struct Node {
    int data;
    struct Node* next;
};

// Function to insert a new node at the end of the list
struct Node* insertAtEnd(struct Node* head, int value) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (newNode == NULL) {
        // Handle malloc failure
        return head;
    }
    newNode->data = value;
    newNode->next = NULL;

    if (head == NULL) {
        return newNode;
    }

    struct Node* current = head;
    while (current->next != NULL) {
        current = current->next;
    }
    current->next = newNode;
    return head;
}

// Function to delete the first occurrence of a node with a given value
struct Node* deleteNode(struct Node* head, int value) {
    if (head == NULL) {
        return NULL;
    }

    // If head node itself holds the value to be deleted
    if (head->data == value) {
        struct Node* temp = head;
        head = head->next;
        free(temp); // Free memory
        return head;
    }

    struct Node* current = head;
    struct Node* prev = NULL;

    while (current != NULL && current->data != value) {
        prev = current;
        current = current->next;
    }

    // If value was not present in list
    if (current == NULL) {
        return head;
    }

    // Unlink the node from linked list
    prev->next = current->next;
    free(current); // Free memory
    return head;
}

// Function to print the linked list
void printList(struct Node* head) {
    struct Node* current = head;
    if (current == NULL) {
        printf(""\n"");
        return;
    }
    while (current != NULL) {
        printf(""%d"", current->data);
        current = current->next;
        if (current != NULL) {
            printf("" "");
        }
    }
    printf(""\n"");
}

// Function to free all nodes in the list
void freeList(struct Node* head) {
    struct Node* current = head;
    struct Node* nextNode;
    while (current != NULL) {
        nextNode = current->next;
        free(current);
        current = nextNode;
    }
}

// Main function to handle input and call list operations
int main() {
    struct Node* head = NULL;
    char command[10];
    int value;

    while (scanf(""%s"", command) != EOF) {
        if (strcmp(command, ""INSERT"") == 0) {
            scanf(""%d"", &value);
            head = insertAtEnd(head, value);
        } else if (strcmp(command, ""DELETE"") == 0) {
            scanf(""%d"", &value);
            head = deleteNode(head, value);
        } else if (strcmp(command, ""TRAVERSE"") == 0) {
            printList(head);
        }
    }

    // Free all allocated memory before exiting
    freeList(head);

    return 0;
}","class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def insert_at_end(self, value):
        new_node = Node(value)
        if self.head is None:
            self.head = new_node
            return

        current = self.head
        while current.next is not None:
            current = current.next
        current.next = new_node

    def delete_node(self, value):
        if self.head is None:
            return

        # If head node itself holds the value to be deleted
        if self.head.data == value:
            self.head = self.head.next
            return

        current = self.head
        prev = None

        while current is not None and current.data != value:
            prev = current
            current = current.next

        # If value was not present in list
        if current is None:
            return

        # Unlink the node from linked list
        prev.next = current.next

    def print_list(self):
        current = self.head
        if current is None:
            print() # Print empty line
            return

        elements = []
        while current is not None:
            elements.append(str(current.data))
            current = current.next
        print("" "".join(elements))

def main():
    my_list = LinkedList()
    
    while True:
        try:
            line = input().strip()
            if not line: # Handle empty line input if it can occur
                continue
            parts = line.split()
            command = parts[0]

            if command == ""INSERT"":
                value = int(parts[1])
                my_list.insert_at_end(value)
            elif command == ""DELETE"":
                value = int(parts[1])
                my_list.delete_node(value)
            elif command == ""TRAVERSE"":
                my_list.print_list()
        except EOFError:
            break
        except IndexError: # For commands like TRAVERSE which don't have a value
            if command == ""TRAVERSE"":
                my_list.print_list()
            else:
                pass # Or raise an error for malformed input
        except ValueError: # For cases where int conversion fails
            pass # Or raise an error for malformed input

if __name__ == ""__main__"":
    main()","import java.util.Scanner;

// Define Node class
class Node {
    int data;
    Node next;

    Node(int data) {
        this.data = data;
        this.next = null;
    }
}

// Define LinkedList class to encapsulate operations
class LinkedList {
    Node head;

    public LinkedList() {
        this.head = null;
    }

    // Function to insert a new node at the end of the list
    public void insertAtEnd(int value) {
        Node newNode = new Node(value);
        if (head == null) {
            head = newNode;
            return;
        }

        Node current = head;
        while (current.next != null) {
            current = current.next;
        }
        current.next = newNode;
    }

    // Function to delete the first occurrence of a node with a given value
    public void deleteNode(int value) {
        if (head == null) {
            return;
        }

        // If head node itself holds the value to be deleted
        if (head.data == value) {
            head = head.next;
            return;
        }

        Node current = head;
        Node prev = null;

        while (current != null && current.data != value) {
            prev = current;
            current = current.next;
        }

        // If value was not present in list
        if (current == null) {
            return;
        }

        // Unlink the node from linked list
        prev.next = current.next;
    }

    // Function to print the linked list
    public void printList() {
        Node current = head;
        if (current == null) {
            System.out.println();
            return;
        }
        StringBuilder sb = new StringBuilder();
        while (current != null) {
            sb.append(current.data);
            current = current.next;
            if (current != null) {
                sb.append("" "");
            }
        }
        System.out.println(sb.toString());
    }
}

// Main class to handle input and call list operations
public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        LinkedList myList = new LinkedList();

        while (scanner.hasNext()) {
            String command = scanner.next();
            if (command.equals(""INSERT"")) {
                int value = scanner.nextInt();
                myList.insertAtEnd(value);
            } else if (command.equals(""DELETE"")) {
                int value = scanner.nextInt();
                myList.deleteNode(value);
            } else if (command.equals(""TRAVERSE"")) {
                myList.printList();
            }
        }
        scanner.close();
    }
}","// Define Node class
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

// Define LinkedList class to encapsulate operations
class LinkedList {
    constructor() {
        this.head = null;
    }

    // Function to insert a new node at the end of the list
    insertAtEnd(value) {
        const newNode = new Node(value);
        if (this.head === null) {
            this.head = newNode;
            return;
        }

        let current = this.head;
        while (current.next !== null) {
            current = current.next;
        }
        current.next = newNode;
    }

    // Function to delete the first occurrence of a node with a given value
    deleteNode(value) {
        if (this.head === null) {
            return;
        }

        // If head node itself holds the value to be deleted
        if (this.head.data === value) {
            this.head = this.head.next;
            return;
        }

        let current = this.head;
        let prev = null;

        while (current !== null && current.data !== value) {
            prev = current;
            current = current.next;
        }

        // If value was not present in list
        if (current === null) {
            return;
        }

        // Unlink the node from linked list
        prev.next = current.next;
    }

    // Function to print the linked list
    printList() {
        let current = this.head;
        if (current === null) {
            console.log(); // Print empty line
            return;
        }
        let elements = [];
        while (current !== null) {
            elements.push(current.data);
            current = current.next;
        }
        console.log(elements.join("" ""));
    }
}

// Main function to handle input and call list operations
function main() {
    const myList = new LinkedList();
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
        terminal: false
    });

    rl.on('line', (line) => {
        const parts = line.split(' ');
        const command = parts[0];

        if (command === ""INSERT"") {
            const value = parseInt(parts[1]);
            myList.insertAtEnd(value);
        } else if (command === ""DELETE"") {
            const value = parseInt(parts[1]);
            myList.deleteNode(value);
        } else if (command === ""TRAVERSE"") {
            myList.printList();
        }
    });

    // Handle end of input for some systems if needed, though 'line' event handles it implicitly
    // rl.on('close', () => {
    //     // All input processed
    // });
}

main();","#include <iostream>
#include <string>
#include <sstream>

// Define Node class
class Node {
public:
    int data;
    Node* next;

    Node(int val) : data(val), next(nullptr) {}
};

// Define LinkedList class to encapsulate operations
class LinkedList {
private:
    Node* head;

public:
    LinkedList() : head(nullptr) {}

    // Destructor to free memory
    ~LinkedList() {
        Node* current = head;
        while (current != nullptr) {
            Node* nextNode = current->next;
            delete current;
            current = nextNode;
        }
    }

    // Function to insert a new node at the end of the list
    void insertAtEnd(int value) {
        Node* newNode = new Node(value);
        if (head == nullptr) {
            head = newNode;
            return;
        }

        Node* current = head;
        while (current->next != nullptr) {
            current = current->next;
        }
        current->next = newNode;
    }

    // Function to delete the first occurrence of a node with a given value
    void deleteNode(int value) {
        if (head == nullptr) {
            return;
        }

        // If head node itself holds the value to be deleted
        if (head->data == value) {
            Node* temp = head;
            head = head->next;
            delete temp;
            return;
        }

        Node* current = head;
        Node* prev = nullptr;

        while (current != nullptr && current->data != value) {
            prev = current;
            current = current->next;
        }

        // If value was not present in list
        if (current == nullptr) {
            return;
        }

        // Unlink the node from linked list
        prev->next = current->next;
        delete current;
    }

    // Function to print the linked list
    void printList() const {
        Node* current = head;
        if (current == nullptr) {
            std::cout << std::endl;
            return;
        }
        while (current != nullptr) {
            std::cout << current->data;
            current = current->next;
            if (current != nullptr) {
                std::cout << "" "";
            }
        }
        std::cout << std::endl;
    }
};

// Main function to handle input and call list operations
int main() {
    LinkedList myList;
    std::string line;
    std::string command;
    int value;

    while (std::cin >> command) {
        if (command == ""INSERT"") {
            std::cin >> value;
            myList.insertAtEnd(value);
        } else if (command == ""DELETE"") {
            std::cin >> value;
            myList.deleteNode(value);
        } else if (command == ""TRAVERSE"") {
            myList.printList();
        }
    }

    return 0;
}",3.8
Yellow-87,Character Hashing,"*   Character Hashing (using frequency arrays or maps)
*   String Manipulation (case conversion, character filtering)
*   Conditional Logic","Given a string, determine if it is a permutation of a palindrome. A palindrome is a word or phrase that reads the same forwards and backwards. A permutation is a rearrangement of letters. The palindrome does not need to be limited to just dictionary words. You should ignore casing and non-alphabetic characters (like spaces and punctuation).","*   The input string will have a length between 0 and 1000 characters.
*   The string will consist of ASCII characters, including letters, spaces, and punctuation.","""Tact Coa""",TRUE,"Input: ""aabbc""
Output: true
Input: ""Never odd or even""
Output: true
Input: ""hello world""
Output: false
Input: """"
Output: true
Input: ""A man, a plan, a canal: Panama""
Output: true","#include <stdio.h>
#include <string.h>
#include <ctype.h>
#include <stdbool.h>

bool canPermutePalindrome(const char *s) {
    int counts[26] = {0}; // Frequency array for 'a' through 'z'
    int len = strlen(s);

    for (int i = 0; i < len; i++) {
        char c = tolower(s[i]);
        if (c >= 'a' && c <= 'z') {
            counts[c - 'a']++;
        }
    }

    int odd_counts = 0;
    for (int i = 0; i < 26; i++) {
        if (counts[i] % 2 != 0) {
            odd_counts++;
        }
    }

    return odd_counts <= 1;
}

int main() {
    char input[1001]; // Max length 1000 + null terminator
    if (fgets(input, sizeof(input), stdin) != NULL) {
        // Remove trailing newline character if present
        input[strcspn(input, ""\n"")] = 0;
        
        if (canPermutePalindrome(input)) {
            printf(""true\n"");
        } else {
            printf(""false\n"");
        }
    }
    return 0;
}","def canPermutePalindrome(s: str) -> bool:
    counts = [0] * 26  # Frequency array for 'a' through 'z'

    for char_code in s.lower():
        if 'a' <= char_code <= 'z':
            counts[ord(char_code) - ord('a')] += 1
    
    odd_counts = 0
    for count in counts:
        if count % 2 != 0:
            odd_counts += 1
    
    return odd_counts <= 1

if __name__ == ""__main__"":
    input_string = input()
    if canPermutePalindrome(input_string):
        print(""true"")
    else:
        print(""false"")","import java.util.Scanner;

public class Solution {

    public boolean canPermutePalindrome(String s) {
        int[] counts = new int[26]; // Frequency array for 'a' through 'z'

        for (char ch : s.toCharArray()) {
            char lowerCh = Character.toLowerCase(ch);
            if (lowerCh >= 'a' && lowerCh <= 'z') {
                counts[lowerCh - 'a']++;
            }
        }

        int oddCounts = 0;
        for (int count : counts) {
            if (count % 2 != 0) {
                oddCounts++;
            }
        }

        return oddCounts <= 1;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String input = scanner.nextLine();
        scanner.close();

        Solution sol = new Solution();
        if (sol.canPermutePalindrome(input)) {
            System.out.println(""true"");
        } else {
            System.out.println(""false"");
        }
    }
}","function canPermutePalindrome(s) {
    const counts = new Array(26).fill(0); // Frequency array for 'a' through 'z'

    for (let i = 0; i < s.length; i++) {
        const char = s[i].toLowerCase();
        if (char >= 'a' && char <= 'z') {
            counts[char.charCodeAt(0) - 'a'.charCodeAt(0)]++;
        }
    }

    let oddCounts = 0;
    for (const count of counts) {
        if (count % 2 !== 0) {
            oddCounts++;
        }
    }

    return oddCounts <= 1;
}

// Node.js specific input/output handling
// For browser environment, this part would be different.
// Assuming a Node.js-like execution environment where stdin/stdout are available.
process.stdin.resume();
process.stdin.setEncoding('utf8');

let inputString = '';
process.stdin.on('data', function(chunk) {
    inputString += chunk;
});

process.stdin.on('end', function() {
    // Remove trailing newline character
    inputString = inputString.trim(); 
    if (canPermutePalindrome(inputString)) {
        process.stdout.write(""true\n"");
    } else {
        process.stdout.write(""false\n"");
    }
});","#include <iostream>
#include <string>
#include <vector>
#include <cctype> // For tolower

bool canPermutePalindrome(const std::string& s) {
    std::vector<int> counts(26, 0); // Frequency array for 'a' through 'z'

    for (char ch : s) {
        char lower_ch = std::tolower(ch);
        if (lower_ch >= 'a' && lower_ch <= 'z') {
            counts[lower_ch - 'a']++;
        }
    }

    int odd_counts = 0;
    for (int count : counts) {
        if (count % 2 != 0) {
            odd_counts++;
        }
    }

    return odd_counts <= 1;
}

int main() {
    std::string s;
    std::getline(std::cin, s); // Read entire line from stdin

    if (canPermutePalindrome(s)) {
        std::cout << ""true"" << std::endl;
    } else {
        std::cout << ""false"" << std::endl;
    }

    return 0;
}",4
Yellow-88,Prefix & Suffix Sums,"*   Prefix Sums
*   Array Manipulation
*   Range Queries
*   Time and Space Complexity Analysis","You are a young sorcerer tasked with calculating the magical energy within specific segments of an ancient array. Given an array of integers and a series of queries, your goal is to efficiently find the sum of elements within a specified range (inclusive) for each query.

For instance, if the array is `[1, 2, 3, 4, 5]` and a query asks for the sum between index 0 and 2, you should return `1 + 2 + 3 = 6`. If another query asks for the sum between index 1 and 3, you should return `2 + 3 + 4 = 9`.","*   `1 <= N <= 10^5` (where N is the number of elements in the array)
*   `-1000 <= arr[i] <= 1000` (value of each element in the array)
*   `1 <= Q <= 10^5` (where Q is the number of queries)
*   `0 <= start <= end < N` (query indices are 0-based and valid)","5
10 20 30 40 50
3
0 2
1 3
4 4


####","60
90
50","Input:
5
-10 -20 -30 -40 -50
2
0 1
3 4
Output:
-30
-90
Input:
7
1 2 3 -5 0 10 -2
3
0 6
3 3
4 4
Output:
9
-5
0
Input:
5
0 0 0 0 0
3
0 4
2 2
0 0
Output:
0
0
0","#include <stdio.h>
#include <stdlib.h>

// Function to build the prefix sum array
// prefix_sum[i] stores sum of arr[0]...arr[i-1]
void buildPrefixSum(const int *arr, int N, long long *prefix_sum) {
    prefix_sum[0] = 0;
    for (int i = 0; i < N; i++) {
        prefix_sum[i + 1] = prefix_sum[i] + arr[i];
    }
}

// Function to get the sum of a range using the prefix sum array
long long getRangeSum(const long long *prefix_sum, int start_idx, int end_idx) {
    // Sum from arr[start_idx] to arr[end_idx] is prefix_sum[end_idx+1] - prefix_sum[start_idx]
    return prefix_sum[end_idx + 1] - prefix_sum[start_idx];
}

int main() {
    int N;
    scanf(""%d"", &N);

    int *arr = (int *)malloc(N * sizeof(int));
    if (arr == NULL) {
        return 1; // Error
    }
    for (int i = 0; i < N; i++) {
        scanf(""%d"", &arr[i]);
    }

    long long *prefix_sum = (long long *)malloc((N + 1) * sizeof(long long));
    if (prefix_sum == NULL) {
        free(arr);
        return 1; // Error
    }

    buildPrefixSum(arr, N, prefix_sum);

    int Q;
    scanf(""%d"", &Q);

    for (int q = 0; q < Q; q++) {
        int start, end;
        scanf(""%d %d"", &start, &end);
        long long result = getRangeSum(prefix_sum, start, end);
        printf(""%lld\n"", result);
    }

    free(arr);
    free(prefix_sum);

    return 0;
}","# Function to build the prefix sum array
# prefix_sum[i] stores sum of arr[0]...arr[i-1]
def build_prefix_sum(arr):
    N = len(arr)
    prefix_sum = [0] * (N + 1)
    for i in range(N):
        prefix_sum[i + 1] = prefix_sum[i] + arr[i]
    return prefix_sum

# Function to get the sum of a range using the prefix sum array
def get_range_sum(prefix_sum, start_idx, end_idx):
    # Sum from arr[start_idx] to arr[end_idx] is prefix_sum[end_idx+1] - prefix_sum[start_idx]
    return prefix_sum[end_idx + 1] - prefix_sum[start_idx]

def solve():
    N = int(input())
    arr = list(map(int, input().split()))

    prefix_sum_array = build_prefix_sum(arr)

    Q = int(input())

    for _ in range(Q):
        start, end = map(int, input().split())
        result = get_range_sum(prefix_sum_array, start, end)
        print(result)

if __name__ == '__main__':
    solve()","import java.util.Scanner;

public class Main {

    // Function to build the prefix sum array
    // prefixSum[i] stores sum of arr[0]...arr[i-1]
    public static void buildPrefixSum(int[] arr, long[] prefixSum) {
        prefixSum[0] = 0;
        for (int i = 0; i < arr.length; i++) {
            prefixSum[i + 1] = prefixSum[i] + arr[i];
        }
    }

    // Function to get the sum of a range using the prefix sum array
    public static long getRangeSum(long[] prefixSum, int startIdx, int endIdx) {
        // Sum from arr[startIdx] to arr[endIdx] is prefixSum[endIdx+1] - prefixSum[startIdx]
        return prefixSum[endIdx + 1] - prefixSum[startIdx];
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int N = scanner.nextInt();

        int[] arr = new int[N];
        for (int i = 0; i < N; i++) {
            arr[i] = scanner.nextInt();
        }

        long[] prefixSum = new long[N + 1];
        buildPrefixSum(arr, prefixSum);

        int Q = scanner.nextInt();

        for (int q = 0; q < Q; q++) {
            int start = scanner.nextInt();
            int end = scanner.nextInt();
            long result = getRangeSum(prefixSum, start, end);
            System.out.println(result);
        }

        scanner.close();
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let inputLines = [];
let currentLine = 0;

rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    solve();
});

// Function to build the prefix sum array
// prefixSum[i] stores sum of arr[0]...arr[i-1]
function buildPrefixSum(arr) {
    const N = arr.length;
    const prefixSum = new Array(N + 1).fill(0);
    for (let i = 0; i < N; i++) {
        prefixSum[i + 1] = prefixSum[i] + arr[i];
    }
    return prefixSum;
}

// Function to get the sum of a range using the prefix sum array
function getRangeSum(prefixSum, startIdx, endIdx) {
    // Sum from arr[startIdx] to arr[endIdx] is prefixSum[endIdx+1] - prefixSum[startIdx]
    return prefixSum[endIdx + 1] - prefixSum[startIdx];
}

// Main logic function to read input, process, and print output
function solve() {
    const N = parseInt(inputLines[currentLine++]);
    const arr = inputLines[currentLine++].split(' ').map(Number);

    const prefixSumArray = buildPrefixSum(arr);

    const Q = parseInt(inputLines[currentLine++]);

    for (let q = 0; q < Q; q++) {
        const [start, end] = inputLines[currentLine++].split(' ').map(Number);
        const result = getRangeSum(prefixSumArray, start, end);
        console.log(result);
    }
}","#include <iostream>
#include <vector>
#include <numeric> 

// Function to build the prefix sum array
// prefix_sum[i] stores sum of arr[0]...arr[i-1]
void buildPrefixSum(const std::vector<int>& arr, std::vector<long long>& prefix_sum) {
    prefix_sum.resize(arr.size() + 1, 0); // Initialize with 0s
    for (size_t i = 0; i < arr.size(); ++i) {
        prefix_sum[i + 1] = prefix_sum[i] + arr[i];
    }
}

// Function to get the sum of a range using the prefix sum array
long long getRangeSum(const std::vector<long long>& prefix_sum, int start_idx, int end_idx) {
    // Sum from arr[start_idx] to arr[end_idx] is prefix_sum[end_idx+1] - prefix_sum[start_idx]
    return prefix_sum[end_idx + 1] - prefix_sum[start_idx];
}

int main() {
    std::ios_base::sync_with_stdio(false); // Optimize C++ standard streams
    std::cin.tie(NULL);

    int N;
    std::cin >> N;

    std::vector<int> arr(N);
    for (int i = 0; i < N; ++i) {
        std::cin >> arr[i];
    }

    std::vector<long long> prefix_sum;
    buildPrefixSum(arr, prefix_sum);

    int Q;
    std::cin >> Q;

    for (int q = 0; q < Q; ++q) {
        int start, end;
        std::cin >> start >> end;
        long long result = getRangeSum(prefix_sum, start, end);
        std::cout << result << ""\n"";
    }

    return 0;
}",4.4
Yellow-89,Linear Search,"- Array Traversal
- Conditional Statements
- Basic Iteration (Loops)
- Linear Search Algorithm
- Dynamic Arrays / Lists
- List Manipulation / Appending Elements","You are given an array of integers `nums` and a target integer `target`. Your task is to find *all* occurrences of the `target` in the `nums` array. If the `target` is found, return a list (or array) of its 0-based indices in ascending order. If the `target` is not present in the array, return an empty list.

This problem expands on basic search by requiring you to collect all relevant results, introducing the concept of dynamic data structures to store an unknown number of outcomes.","- `1 <= nums.length <= 1000`
- `-1000 <= nums[i] <= 1000`
- `-1000 <= target <= 1000`","nums = [4, 2, 7, 1, 9, 7]
target = 7",2 5,"Input: 6
1
2
3
2
4
2
2
Output: 1 3 5
Input: 5
10
20
30
40
50
30
Output: 2
Input: 4
1
2
3
4
5
Output: 
Input: 5
7
7
1
7
2
7
Output: 0 1 3
Input: 5
1
7
2
7
7
7
Output: 1 3 4
Input: 3
5
5
5
5
Output: 0 1 2","#include <stdio.h>
#include <stdlib.h>

/**
 * Finds all occurrences of a target value in an array and returns their indices.
 * The caller is responsible for freeing the returned dynamically allocated array.
 *
 * @param nums The input array of integers.
 * @param n The size of the input array.
 * @param target The value to search for.
 * @param returnSize A pointer to an integer that will store the number of indices found.
 * @return A dynamically allocated array of integers containing the 0-based indices
 *         where the target was found, or NULL if no occurrences or memory allocation fails.
 */
int* findAllOccurrences(int nums[], int n, int target, int* returnSize) {
    // Allocate space for potential maximum number of occurrences
    // We'll reallocate to the exact size later if needed.
    int* temp_indices = (int*)malloc(n * sizeof(int));
    if (temp_indices == NULL) {
        *returnSize = 0;
        return NULL; // Memory allocation failed
    }

    int count = 0;
    for (int i = 0; i < n; i++) {
        if (nums[i] == target) {
            temp_indices[count++] = i;
        }
    }

    *returnSize = count;

    if (count == 0) {
        free(temp_indices); // No elements found, free the temporary buffer
        return NULL;        // Return NULL to indicate no occurrences
    } else {
        // Reallocate to the exact size needed
        int* result_indices = (int*)realloc(temp_indices, count * sizeof(int));
        if (result_indices == NULL) {
            // If realloc fails, temp_indices is still valid and we return it.
            // This case is rare for shrinking, but good practice to handle.
            return temp_indices;
        }
        return result_indices;
    }
}

int main() {
    int n;
    // Read the size of the array
    scanf(""%d"", &n);

    // Dynamically allocate memory for the input array
    int *nums = (int *)malloc(n * sizeof(int));
    if (nums == NULL) {
        fprintf(stderr, ""Memory allocation failed for nums\n"");
        return 1;
    }

    // Read array elements
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &nums[i]);
    }

    int target;
    // Read the target value
    scanf(""%d"", &target);

    int returnSize = 0;
    int* result_indices = findAllOccurrences(nums, n, target, &returnSize);

    if (result_indices != NULL && returnSize > 0) {
        for (int i = 0; i < returnSize; i++) {
            printf(""%d%s"", result_indices[i], (i == returnSize - 1) ? """" : "" "");
        }
        printf(""\n""); // Newline after all indices
        free(result_indices); // Free the dynamically allocated result array
    } else {
        printf(""\n""); // Print an empty line if no target found or list is empty
    }

    // Free the input array
    free(nums);

    return 0;
}","def find_all_occurrences(nums, target):
    """"""
    Finds all occurrences of a target value in a list and returns their indices.

    Args:
        nums (list): The input list of integers.
        target (int): The value to search for.

    Returns:
        list: A list of integers containing the 0-based indices where the target was found.
              Returns an empty list if no occurrences are found.
    """"""
    indices = []
    for i in range(len(nums)):
        if nums[i] == target:
            indices.append(i)
    return indices

def main():
    # Read the size of the array
    n = int(input())

    nums = []
    # Read array elements line by line
    for _ in range(n):
        nums.append(int(input()))

    # Read the target value
    target = int(input())

    # Call the function to find all occurrences
    result_indices = find_all_occurrences(nums, target)

    # Print the results
    if result_indices:
        # Use '*' to unpack the list elements and 'sep' to join them with a space
        print(*(result_indices))
    else:
        print("""") # Print an empty line if no target found

if __name__ == '__main__':
    main()","import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {

    /**
     * Finds all occurrences of a target value in an array and returns their indices.
     *
     * @param nums The input array of integers.
     * @param target The value to search for.
     * @return A List of Integers containing the 0-based indices where the target was found.
     *         Returns an empty List if no occurrences are found.
     */
    public static List<Integer> findAllOccurrences(int[] nums, int target) {
        List<Integer> indices = new ArrayList<>();
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == target) {
                indices.add(i);
            }
        }
        return indices;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the size of the array
        int n = scanner.nextInt();
        int[] nums = new int[n];

        // Read array elements
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }

        // Read the target value
        int target = scanner.nextInt();

        // Call the function to find all occurrences
        List<Integer> result_indices = findAllOccurrences(nums, target);

        // Print the results
        if (!result_indices.isEmpty()) {
            for (int i = 0; i < result_indices.size(); i++) {
                System.out.print(result_indices.get(i) + (i == result_indices.size() - 1 ? """" : "" ""));
            }
            System.out.println(); // Newline after all indices
        } else {
            System.out.println(); // Print an empty line if no target found
        }

        scanner.close();
    }
}","/**
 * Finds all occurrences of a target value in an array and returns their indices.
 *
 * @param {number[]} nums The input array of integers.
 * @param {number} target The value to search for.
 * @returns {number[]} An array of integers containing the 0-based indices where the target was found.
 *                     Returns an empty array if no occurrences are found.
 */
function findAllOccurrences(nums, target) {
    const indices = [];
    for (let i = 0; i < nums.length; i++) {
        if (nums[i] === target) {
            indices.push(i);
        }
    }
    return indices;
}

function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let input = [];
    rl.on('line', (line) => {
        input.push(line);
    }).on('close', () => {
        // The first line is the size of the array (n)
        const n = parseInt(input[0]);

        // The next 'n' lines are the array elements
        const nums = [];
        for (let i = 1; i <= n; i++) {
            nums.push(parseInt(input[i]));
        }

        // The line after the array elements is the target
        const target = parseInt(input[n + 1]);

        // Call the function to find all occurrences
        const result_indices = findAllOccurrences(nums, target);

        // Print the results
        if (result_indices.length > 0) {
            console.log(result_indices.join(' '));
        } else {
            console.log(''); // Print an empty line if no target found
        }
    });
}

main();","#include <iostream>
#include <vector>
#include <algorithm> // For std::sort, though not strictly needed as linear search finds in order

/**
 * Finds all occurrences of a target value in a vector and returns their indices.
 *
 * @param nums The input vector of integers.
 * @param target The value to search for.
 * @return A vector of integers containing the 0-based indices where the target was found.
 *         Returns an empty vector if no occurrences are found.
 */
std::vector<int> findAllOccurrences(const std::vector<int>& nums, int target) {
    std::vector<int> indices;
    for (int i = 0; i < nums.size(); ++i) {
        if (nums[i] == target) {
            indices.push_back(i);
        }
    }
    return indices;
}

int main() {
    // Optimize C++ standard streams for faster input/output.
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    // Read the size of the vector
    std::cin >> n;

    std::vector<int> nums(n);
    // Read vector elements
    for (int i = 0; i < n; ++i) {
        std::cin >> nums[i];
    }

    int target;
    // Read the target value
    std::cin >> target;

    // Call the function to find all occurrences
    std::vector<int> result_indices = findAllOccurrences(nums, target);

    // Print the results
    if (!result_indices.empty()) {
        for (size_t i = 0; i < result_indices.size(); ++i) {
            std::cout << result_indices[i] << (i == result_indices.size() - 1 ? """" : "" "");
        }
        std::cout << std::endl;
    } else {
        std::cout << std::endl; // Print an empty line if no target found
    }

    return 0;
}",4.4
Yellow-90,Frequency Count / Anagrams,"- Frequency Counting
- Arrays for Character Frequencies
- String Manipulation","You've stumbled upon an ancient, dusty spellbook, but alas, some pages are smudged! You find two spell recipes, each written as an 'incantation' (a string of letters). You're not sure if they produce the *exact same magical effect*. According to the old wizard's lore, two spells produce the same effect if they use the *exact same magical ingredients* in the same quantities, even if those ingredients are arranged in a different order in the incantation.

Your task is to implement a function that takes two string incantations and determines if they are 'ingredient-equivalent' (i.e., anagrams of each other). The function should return `true` if they use the same ingredients with the same frequencies, and `false` otherwise.","- The input incantations `s1` and `s2` will consist only of lowercase English letters (`'a'` through `'z'`), representing different magical ingredients.
- The length of both `s1` and `s2` will be between 1 and 1000 characters, inclusive.","**
s1 = ""listen"" (an incantation for a 'fireball' spell)
s2 = ""silent"" (an incantation for an 'ablaze' spell)

**","**
true

**","Input: hello
world
Output: false
Input: rail
liar
Output: true
Input: aab
baa
Output: true
Input: abc
ab
Output: false
Input: zzzaa
aazzz
Output: true","#include <stdio.h>
#include <stdbool.h>
#include <string.h>
#include <stdlib.h> // For malloc, free

// Function to check if two strings are anagrams (ingredient-equivalent spells)
bool areAnagrams(const char* s1, const char* s2) {
    int len1 = strlen(s1);
    int len2 = strlen(s2);

    // If lengths are different, they can't be ingredient-equivalent
    if (len1 != len2) {
        return false;
    }

    int counts[26] = {0}; // Initialize all ingredient counts to 0

    // Increment counts for ingredients in the first incantation (s1)
    for (int i = 0; i < len1; i++) {
        counts[s1[i] - 'a']++;
    }

    // Decrement counts for ingredients in the second incantation (s2)
    for (int i = 0; i < len2; i++) {
        counts[s2[i] - 'a']--;
    }

    // Check if all ingredient counts are zero (meaning they matched perfectly)
    for (int i = 0; i < 26; i++) {
        if (counts[i] != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    char s1[1001]; // Max length 1000 + null terminator
    char s2[1001];

    // Read the first incantation
    if (scanf(""%s"", s1) != 1) {
        return 1; // Error reading input
    }
    // Read the second incantation
    if (scanf(""%s"", s2) != 1) {
        return 1; // Error reading input
    }

    if (areAnagrams(s1, s2)) {
        printf(""true\n"");
    } else {
        printf(""false\n"");
    }

    return 0;
}","import sys

def areAnagrams(s1: str, s2: str) -> bool:
    # If lengths are different, they can't be ingredient-equivalent
    if len(s1) != len(s2):
        return False

    counts = [0] * 26  # Initialize all ingredient counts to 0

    # Increment counts for ingredients in the first incantation (s1)
    for char_code in map(ord, s1):
        counts[char_code - ord('a')] += 1

    # Decrement counts for ingredients in the second incantation (s2)
    for char_code in map(ord, s2):
        counts[char_code - ord('a')] -= 1

    # Check if all ingredient counts are zero (meaning they matched perfectly)
    for count in counts:
        if count != 0:
            return False

    return True

if __name__ == ""__main__"":
    lines = sys.stdin.readlines()
    s1 = lines[0].strip()
    s2 = lines[1].strip()

    if areAnagrams(s1, s2):
        print(""true"")
    else:
        print(""false"")","import java.util.Scanner;
import java.util.Arrays;

public class Main {

    // Function to check if two strings are anagrams (ingredient-equivalent spells)
    public static boolean areAnagrams(String s1, String s2) {
        // If lengths are different, they can't be ingredient-equivalent
        if (s1.length() != s2.length()) {
            return false;
        }

        int[] counts = new int[26]; // All elements initialized to 0 by default for ingredient counts

        // Increment counts for ingredients in the first incantation (s1)
        for (char c : s1.toCharArray()) {
            counts[c - 'a']++;
        }

        // Decrement counts for ingredients in the second incantation (s2)
        for (char c : s2.toCharArray()) {
            counts[c - 'a']--;
        }

        // Check if all ingredient counts are zero (meaning they matched perfectly)
        for (int count : counts) {
            if (count != 0) {
                return false;
            }
        }

        return true;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        String s1 = scanner.next();
        String s2 = scanner.next();

        if (areAnagrams(s1, s2)) {
            System.out.println(""true"");
        } else {
            System.out.println(""false"");
        }

        scanner.close();
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

// Function to check if two strings are anagrams (ingredient-equivalent spells)
function areAnagrams(s1, s2) {
    // If lengths are different, they can't be ingredient-equivalent
    if (s1.length !== s2.length) {
        return false;
    }

    const counts = new Array(26).fill(0); // Initialize all ingredient counts to 0

    // Increment counts for ingredients in the first incantation (s1)
    for (let i = 0; i < s1.length; i++) {
        counts[s1.charCodeAt(i) - 'a'.charCodeAt(0)]++;
    }

    // Decrement counts for ingredients in the second incantation (s2)
    for (let i = 0; i < s2.length; i++) {
        counts[s2.charCodeAt(i) - 'a'.charCodeAt(0)]--;
    }

    // Check if all ingredient counts are zero (meaning they matched perfectly)
    for (let i = 0; i < 26; i++) {
        if (counts[i] !== 0) {
            return false;
        }
    }

    return true;
}

let inputLines = [];
rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    const s1 = inputLines[0];
    const s2 = inputLines[1];

    if (areAnagrams(s1, s2)) {
        console.log(""true"");
    } else {
        console.log(""false"");
    }
});","#include <iostream>
#include <string>
#include <vector>
#include <numeric> 

// Function to check if two strings are anagrams (ingredient-equivalent spells)
bool areAnagrams(const std::string& s1, const std::string& s2) {
    // If lengths are different, they can't be ingredient-equivalent
    if (s1.length() != s2.length()) {
        return false;
    }

    std::vector<int> counts(26, 0); // Initialize all ingredient counts to 0

    // Increment counts for ingredients in the first incantation (s1)
    for (char c : s1) {
        counts[c - 'a']++;
    }

    // Decrement counts for ingredients in the second incantation (s2)
    for (char c : s2) {
        counts[c - 'a']--;
    }

    // Check if all ingredient counts are zero (meaning they matched perfectly)
    for (int count : counts) {
        if (count != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    std::ios_base::sync_with_stdio(false); // Optimize C++ standard streams for faster I/O
    std::cin.tie(NULL);                   // Untie cin from cout

    std::string s1, s2;
    std::cin >> s1 >> s2;

    if (areAnagrams(s1, s2)) {
        std::cout << ""true\n"";
    } else {
        std::cout << ""false\n"";
    }

    return 0;
}",4.4
Yellow-91,Fibonacci (Recursive),"-   Recursion
-   Base Cases
-   Recursive Step","Hello, future problem solver! Ever noticed spirals in a sunflower or the branching patterns of a tree? Often, these natural wonders follow a special pattern called the Fibonacci sequence. It's a fundamental concept in computer science and mathematics, and it's a perfect playground for understanding **recursion**.

The Fibonacci sequence starts with 0 and 1, and each subsequent number is the sum of the two preceding ones. Think of it like a ladder where each new rung's height is determined by the two rungs below it! The sequence looks like: 0, 1, 1, 2, 3, 5, 8, 13, 21, and so on.

Your mission, should you choose to accept it, is to write a function that calculates the Nth Fibonacci number using a **recursive approach**. This means your function will call itself! Remember, we define the 0th Fibonacci number as 0, and the 1st Fibonacci number as 1.","- `0 <= N <= 20` (We've kept N small here, not because Fibonacci numbers are tiny, but because we want to focus on understanding how recursion works without running into performance issues or crashing your program from too many calls! For larger N, there are more efficient ways, but for now, let's master recursion.)","**
N = 5

**","**
5

**","Input: 0
Output: 0
Input: 1
Output: 1
Input: 2
Output: 1
Input: 7
Output: 13
Input: 10
Output: 55","#include <stdio.h>

// Function to calculate the Nth Fibonacci number recursively
int fibonacci(int n) {
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

int main() {
    int n;
    // Read input
    scanf(""%d"", &n);

    // Calculate and print the result
    printf(""%d\n"", fibonacci(n));

    return 0;
}","import sys

# Function to calculate the Nth Fibonacci number recursively
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)

if __name__ == ""__main__"":
    # Read input
    n = int(sys.stdin.readline().strip())

    # Calculate and print the result
    print(fibonacci(n))","import java.util.Scanner;

public class Solution {

    // Function to calculate the Nth Fibonacci number recursively
    public static int fibonacci(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        } else {
            return fibonacci(n - 1) + fibonacci(n - 2);
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // Read input
        int n = scanner.nextInt();
        scanner.close();

        // Calculate and print the result
        System.out.println(fibonacci(n));
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

// Function to calculate the Nth Fibonacci number recursively
function fibonacci(n) {
    if (n === 0) {
        return 0;
    } else if (n === 1) {
        return 1;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

rl.on('line', (line) => {
    const n = parseInt(line.trim(), 10);
    // Calculate and print the result
    console.log(fibonacci(n));
    rl.close();
});","#include <iostream>

// Function to calculate the Nth Fibonacci number recursively
int fibonacci(int n) {
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

int main() {
    int n;
    // Read input
    std::cin >> n;

    // Calculate and print the result
    std::cout << fibonacci(n) << std::endl;

    return 0;
}",4.4
Yellow-92,Character Hashing,"* Character Hashing
* Frequency Arrays
* String Iteration
* Basic Array Manipulation
* Finding Maximum Value in an Array","You are given a string consisting of lowercase English letters. Your task is to count the frequency of each character in the string. Additionally, you need to identify and display the character(s) that appear with the highest frequency.

The output should first list each character that appears at least once along with its count, sorted alphabetically. After this, it should clearly state which character(s) are the most frequent, along with their shared maximum count.","* The input string will contain only lowercase English letters (`a`-`z`).
* The length of the string will be between 0 and 1000 characters, inclusive.","** `hello`
**","**
`e: 1`
`h: 1`
`l: 2`
`o: 1`
`Most frequent character: l (Count: 2)`

**","Input: apple
Output: a: 1
e: 1
l: 1
p: 2
Most frequent character: p (Count: 2)
Input: zzzaac
Output: a: 2
c: 1
z: 3
Most frequent character: z (Count: 3)
Input: banana
Output: a: 3
b: 1
n: 2
Most frequent character: a (Count: 3)
Input: codingisfun
Output: c: 1
d: 1
f: 1
g: 1
i: 2
n: 2
o: 1
s: 1
u: 1
Most frequent characters: i, n (Count: 2)
Input: alligators
Output: a: 1
g: 1
i: 1
l: 2
o: 1
r: 1
s: 2
t: 1
Most frequent characters: l, s (Count: 2)
Input: 
Output: ","#include <stdio.h>
#include <string.h>
#include <limits.h> // For INT_MIN

// Function to count character frequencies
void countCharacterFrequencies(const char* s, int* frequencies) {
    // Initialize frequencies array to all zeros
    for (int i = 0; i < 26; i++) {
        frequencies[i] = 0;
    }

    int len = strlen(s);
    for (int i = 0; i < len; i++) {
        if (s[i] >= 'a' && s[i] <= 'z') {
            frequencies[s[i] - 'a']++;
        }
    }
}

int main() {
    char inputString[1001]; // Max length 1000 + null terminator
    
    // Read input string
    if (fgets(inputString, sizeof(inputString), stdin) != NULL) {
        // Remove trailing newline character if present
        inputString[strcspn(inputString, ""\n"")] = 0;
        
        int frequencies[26];
        countCharacterFrequencies(inputString, frequencies);
        
        int maxFrequency = 0;
        // Find max frequency
        for (int i = 0; i < 26; i++) {
            if (frequencies[i] > maxFrequency) {
                maxFrequency = frequencies[i];
            }
        }

        // Print all frequencies
        for (int i = 0; i < 26; i++) {
            if (frequencies[i] > 0) {
                printf(""%c: %d\n"", 'a' + i, frequencies[i]);
            }
        }

        // Print most frequent characters if any character appeared
        if (maxFrequency > 0) {
            printf(""\n""); // Newline before most frequent section
            char mostFrequentChars[27]; // Max 26 chars + null terminator
            int charCount = 0;
            for (int i = 0; i < 26; i++) {
                if (frequencies[i] == maxFrequency) {
                    mostFrequentChars[charCount++] = 'a' + i;
                }
            }
            mostFrequentChars[charCount] = '\0'; // Null terminate the string

            if (charCount == 1) {
                printf(""Most frequent character: %c (Count: %d)\n"", mostFrequentChars[0], maxFrequency);
            } else {
                printf(""Most frequent characters: "");
                for (int i = 0; i < charCount; i++) {
                    printf(""%c"", mostFrequentChars[i]);
                    if (i < charCount - 1) {
                        printf("", "");
                    }
                }
                printf("" (Count: %d)\n"", maxFrequency);
            }
        }
    }
    
    return 0;
}","import sys

def count_character_frequencies(s):
    frequencies = [0] * 26 # Initialize a list of 26 zeros

    for char_code in map(ord, s): # Iterate over ASCII values
        if ord('a') <= char_code <= ord('z'):
            frequencies[char_code - ord('a')] += 1
    
    return frequencies

def main():
    input_string = sys.stdin.readline().strip() # Read line and remove trailing newline

    frequencies = count_character_frequencies(input_string)

    max_frequency = 0
    # Find max frequency
    if frequencies: # Check if frequencies list is not empty (though it's fixed size 26 here)
        max_frequency = max(frequencies)

    # Print all frequencies
    for i in range(26):
        if frequencies[i] > 0:
            char_val = chr(ord('a') + i)
            sys.stdout.write(f""{char_val}: {frequencies[i]}\n"")

    # Print most frequent characters if any character appeared
    if max_frequency > 0: # Only print if there's at least one character counted
        most_frequent_chars = []
        for i in range(26):
            if frequencies[i] == max_frequency:
                most_frequent_chars.append(chr(ord('a') + i))
        
        sys.stdout.write(""\n"") # Newline before most frequent section
        if len(most_frequent_chars) == 1:
            sys.stdout.write(f""Most frequent character: {most_frequent_chars[0]} (Count: {max_frequency})\n"")
        else:
            sys.stdout.write(f""Most frequent characters: {', '.join(most_frequent_chars)} (Count: {max_frequency})\n"")

if __name__ == ""__main__"":
    main()","import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

public class CharacterFrequencyCounter {

    // Function to count character frequencies
    public static void countCharacterFrequencies(String s, int[] frequencies) {
        for (char c : s.toCharArray()) {
            if (c >= 'a' && c <= 'z') {
                frequencies[c - 'a']++;
            }
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String inputString = scanner.nextLine(); // Read entire line

        int[] frequencies = new int[26]; // Array of 26 integers, initialized to 0

        countCharacterFrequencies(inputString, frequencies);

        int maxFrequency = 0;
        // Find max frequency
        for (int count : frequencies) {
            if (count > maxFrequency) {
                maxFrequency = count;
            }
        }

        // Print all frequencies
        for (int i = 0; i < 26; i++) {
            if (frequencies[i] > 0) {
                char c = (char) ('a' + i);
                System.out.println(c + "": "" + frequencies[i]);
            }
        }

        // Print most frequent characters if any character appeared
        if (maxFrequency > 0) {
            System.out.println(); // Newline before most frequent section
            List<Character> mostFrequentChars = new ArrayList<>();
            for (int i = 0; i < 26; i++) {
                if (frequencies[i] == maxFrequency) {
                    mostFrequentChars.add((char) ('a' + i));
                }
            }

            if (mostFrequentChars.size() == 1) {
                System.out.println(""Most frequent character: "" + mostFrequentChars.get(0) + "" (Count: "" + maxFrequency + "")"");
            } else {
                StringBuilder sb = new StringBuilder();
                for (int i = 0; i < mostFrequentChars.size(); i++) {
                    sb.append(mostFrequentChars.get(i));
                    if (i < mostFrequentChars.size() - 1) {
                        sb.append("", "");
                    }
                }
                System.out.println(""Most frequent characters: "" + sb.toString() + "" (Count: "" + maxFrequency + "")"");
            }
        }

        scanner.close();
    }
}","function countCharacterFrequencies(s) {
    const frequencies = new Array(26).fill(0); // Initialize an array of 26 zeros

    for (let i = 0; i < s.length; i++) {
        const charCode = s.charCodeAt(i);
        if (charCode >= 'a'.charCodeAt(0) && charCode <= 'z'.charCodeAt(0)) {
            frequencies[charCode - 'a'.charCodeAt(0)]++;
        }
    }
    return frequencies;
}

// Main execution logic for Node.js environment
// Read input from stdin
let inputString = '';
process.stdin.on('data', data => {
    inputString += data.toString();
});

process.stdin.on('end', () => {
    const s = inputString.trim(); // Trim to remove any trailing newlines/whitespace
    const frequencies = countCharacterFrequencies(s);

    let maxFrequency = 0;
    // Find max frequency
    if (frequencies.length > 0) { // Check if frequencies array is not empty
        maxFrequency = Math.max(...frequencies); // Use spread operator for Math.max on array
    }

    // Print all frequencies
    for (let i = 0; i < 26; i++) {
        if (frequencies[i] > 0) {
            const char = String.fromCharCode('a'.charCodeAt(0) + i);
            console.log(`${char}: ${frequencies[i]}`);
        }
    }

    // Print most frequent characters if any character appeared
    if (maxFrequency > 0) { // Only print if there's at least one character counted
        const mostFrequentChars = [];
        for (let i = 0; i < 26; i++) {
            if (frequencies[i] === maxFrequency) {
                mostFrequentChars.push(String.fromCharCode('a'.charCodeAt(0) + i));
            }
        }
        
        console.log(''); // Newline before most frequent section
        if (mostFrequentChars.length === 1) {
            console.log(`Most frequent character: ${mostFrequentChars[0]} (Count: ${maxFrequency})`);
        } else {
            console.log(`Most frequent characters: ${mostFrequentChars.join(', ')} (Count: ${maxFrequency})`);
        }
    }
});","#include <iostream>
#include <string>
#include <vector>
#include <algorithm> // For std::max

// Function to count character frequencies
void countCharacterFrequencies(const std::string& s, std::vector<int>& frequencies) {
    for (char c : s) {
        if (c >= 'a' && c <= 'z') {
            frequencies[c - 'a']++;
        }
    }
}

int main() {
    std::ios_base::sync_with_stdio(false); // Optimize C++ streams
    std::cin.tie(NULL);

    std::string inputString;
    std::getline(std::cin, inputString); // Read entire line

    std::vector<int> frequencies(26, 0); // Initialize a vector of 26 zeros
    countCharacterFrequencies(inputString, frequencies);

    int maxFrequency = 0;
    // Find max frequency
    for (int count : frequencies) {
        if (count > maxFrequency) {
            maxFrequency = count;
        }
    }

    // Print all frequencies
    for (int i = 0; i < 26; i++) {
        if (frequencies[i] > 0) {
            char c = 'a' + i;
            std::cout << c << "": "" << frequencies[i] << std::endl;
        }
    }

    // Print most frequent characters if any character appeared
    if (maxFrequency > 0) {
        std::cout << std::endl; // Newline before most frequent section
        std::vector<char> mostFrequentChars;
        for (int i = 0; i < 26; i++) {
            if (frequencies[i] == maxFrequency) {
                mostFrequentChars.push_back('a' + i);
            }
        }

        if (mostFrequentChars.size() == 1) {
            std::cout << ""Most frequent character: "" << mostFrequentChars[0] << "" (Count: "" << maxFrequency << "")"" << std::endl;
        } else {
            std::cout << ""Most frequent characters: "";
            for (size_t i = 0; i < mostFrequentChars.size(); i++) {
                std::cout << mostFrequentChars[i];
                if (i < mostFrequentChars.size() - 1) {
                    std::cout << "", "";
                }
            }
            std::cout << "" (Count: "" << maxFrequency << "")"" << std::endl;
        }
    }

    return 0;
}",3.8
Yellow-93,Linear Search,"*   Arrays
*   Iteration (Loops)
*   Conditional Statements
*   Return Values","You are given an array of integers `nums` and a target integer `target`. Your task is to find the first occurrence of the `target` in the `nums` array. If the `target` is found, return its 0-based index. If the `target` is not present in the array, return -1.","*   `1 <= nums.length <= 1000`
*   `-10^9 <= nums[i] <= 10^9`
*   `-10^9 <= target <= 10^9`","**
`nums_size = 5`
`nums = [10, 20, 30, 40, 50]`
`target = 30`

**","**
`2`

**","Input: 5
10 20 30 40 50
30
Output: 2
Input: 4
5 15 25 35
10
Output: -1
Input: 7
1 2 3 4 5 6 7
1
Output: 0
Input: 6
90 80 70 60 50 40
40
Output: 5
Input: 5
11 22 33 22 44
22
Output: 1","#include <stdio.h>
#include <stdlib.h>

// Function to perform linear search
int linearSearch(int* nums, int numsSize, int target) {
    for (int i = 0; i < numsSize; i++) {
        if (nums[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}

int main() {
    int numsSize;
    scanf(""%d"", &numsSize); // Read the size of the array

    int* nums = (int*)malloc(numsSize * sizeof(int)); // Allocate memory for the array
    if (nums == NULL) {
        fprintf(stderr, ""Memory allocation failed\n"");
        return 1; // Error in memory allocation
    }

    // Read array elements
    for (int i = 0; i < numsSize; i++) {
        scanf(""%d"", &nums[i]);
    }

    int target;
    scanf(""%d"", &target); // Read the target value

    int result = linearSearch(nums, numsSize, target); // Call the linear search function
    printf(""%d\n"", result); // Print the result

    free(nums); // Free the allocated memory
    return 0;
}","def linear_search(nums, target):
    """"""
    Function to perform linear search.
    Args:
        nums (list): The list of integers to search within.
        target (int): The integer value to search for.
    Returns:
        int: The 0-based index of the first occurrence of the target,
             or -1 if the target is not found.
    """"""
    for i in range(len(nums)):
        if nums[i] == target:
            return i # Target found, return its index
    return -1 # Target not found

if __name__ == ""__main__"":
    nums_size = int(input()) # Read the size of the list
    # Read array elements. Assumes space-separated integers on one line.
    nums = list(map(int, input().split())) 
    
    target = int(input()) # Read the target value

    result = linear_search(nums, target) # Call the linear search function
    print(result) # Print the result","import java.util.Scanner;

public class Solution {

    // Function to perform linear search
    public static int linearSearch(int[] nums, int target) {
        for (int i = 0; i < nums.length; i++) {
            if (nums[i] == target) {
                return i; // Target found, return its index
            }
        }
        return -1; // Target not found
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int numsSize = scanner.nextInt(); // Read the size of the array
        int[] nums = new int[numsSize]; // Create an array of the given size

        // Read array elements
        for (int i = 0; i < numsSize; i++) {
            nums[i] = scanner.nextInt();
        }

        int target = scanner.nextInt(); // Read the target value

        int result = linearSearch(nums, target); // Call the linear search function
        System.out.println(result); // Print the result

        scanner.close();
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let inputLines = [];
rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    // Function to perform linear search
    function linearSearch(nums, target) {
        for (let i = 0; i < nums.length; i++) {
            if (nums[i] === target) {
                return i; // Target found, return its index
            }
        }
        return -1; // Target not found
    }

    let lineIndex = 0;
    const numsSize = parseInt(inputLines[lineIndex++]); // Read the size of the array
    const nums = inputLines[lineIndex++].split(' ').map(Number); // Read array elements
    const target = parseInt(inputLines[lineIndex++]); // Read the target value

    const result = linearSearch(nums, target); // Call the linear search function
    console.log(result); // Print the result
});","#include <iostream>
#include <vector>

// Function to perform linear search
int linearSearch(const std::vector<int>& nums, int target) {
    for (int i = 0; i < nums.size(); ++i) {
        if (nums[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}

int main() {
    std::ios_base::sync_with_stdio(false); // Optimize C++ standard streams for faster I/O
    std::cin.tie(NULL);

    int numsSize;
    std::cin >> numsSize; // Read the size of the array

    std::vector<int> nums(numsSize); // Create a vector of the given size
    // Read array elements
    for (int i = 0; i < numsSize; ++i) {
        std::cin >> nums[i];
    }

    int target;
    std::cin >> target; // Read the target value

    int result = linearSearch(nums, target); // Call the linear search function
    std::cout << result << std::endl; // Print the result

    return 0;
}",4.2
Yellow-94,Fibonacci (Recursive),"*   Recursion
*   Base Cases
*   Recursive Step
*   Mathematical Sequences","Imagine a magical garden where a special seedling grows its leaves in a unique pattern.
On **Day 0**, the seedling has **0** new leaves.
On **Day 1**, it grows **1** new leaf.
From **Day 2** onwards, the number of *new* leaves grown on any given day is the sum of the new leaves grown on the two preceding days. This creates a beautiful, ever-expanding pattern!

Your task is to write a function that calculates the number of *new* leaves the seedling grows on a specific **Day N**, using a recursive approach. The input `n` will represent the day number, where Day 0 corresponds to the 0th term in this magical growth sequence, Day 1 to the 1st term, and so on.","*   0 <= n <= 25 (The input `n` will be a non-negative integer, keeping the problem manageable.)","**
n = 5

**","**
5

**","Input: 0
Output: 0
Input: 1
Output: 1
Input: 2
Output: 1
Input: 7
Output: 13
Input: 10
Output: 55","#include <stdio.h>

// Function to calculate the number of new leaves on Day N recursively
int findLeaves(int n) {
    // Base cases
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    // Recursive step
    return findLeaves(n - 1) + findLeaves(n - 2);
}

int main() {
    int n;
    // Read input from stdin
    if (scanf(""%d"", &n) != 1) {
        return 1; // Error reading input
    }

    // Calculate and print result to stdout
    int result = findLeaves(n);
    printf(""%d\n"", result);

    return 0;
}","def findLeaves(n: int) -> int:
    """"""
    Calculates the number of new leaves grown on Day N recursively.
    """"""
    # Base cases
    if n == 0:
        return 0
    if n == 1:
        return 1
    # Recursive step
    return findLeaves(n - 1) + findLeaves(n - 2)

if __name__ == ""__main__"":
    # Read input from stdin
    n = int(input())

    # Calculate and print result to stdout
    result = findLeaves(n)
    print(result)","import java.util.Scanner;

public class Solution {

    // Function to calculate the number of new leaves on Day N recursively
    public static int findLeaves(int n) {
        // Base cases
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        // Recursive step
        return findLeaves(n - 1) + findLeaves(n - 2);
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // Read input from stdin
        int n = scanner.nextInt();
        scanner.close();

        // Calculate and print result to stdout
        int result = findLeaves(n);
        System.out.println(result);
    }
}","// Function to calculate the number of new leaves on Day N recursively
function findLeaves(n) {
    // Base cases
    if (n === 0) {
        return 0;
    }
    if (n === 1) {
        return 1;
    }
    // Recursive step
    return findLeaves(n - 1) + findLeaves(n - 2);
}

// Read input from stdin (Node.js specific)
// This setup assumes input will be provided line by line.
// For browser environments, input handling would be different.
let input = '';
process.stdin.on('data', data => {
    input += data;
});

process.stdin.on('end', () => {
    const n = parseInt(input.trim(), 10);
    // Calculate and print result to stdout
    const result = findLeaves(n);
    console.log(result);
});","#include <iostream>

// Function to calculate the number of new leaves on Day N recursively
int findLeaves(int n) {
    // Base cases
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    // Recursive step
    return findLeaves(n - 1) + findLeaves(n - 2);
}

int main() {
    int n;
    // Read input from stdin
    std::cin >> n;

    // Calculate and print result to stdout
    int result = findLeaves(n);
    std::cout << result << std::endl;

    return 0;
}",4.6
Yellow-95,Character Hashing,"*   **Character Hashing**: Using an array or a hash map to store the frequency of characters.
*   **Frequency Arrays**: Utilizing a fixed-size array (e.g., of size 26 for lowercase English letters) to count character occurrences.
*   **String Iteration**: Looping through strings to process characters.
*   **Basic Logic**: Conditional checks and loop structures.
*   **Case Conversion / Normalization**: Converting characters to a common case (e.g., lowercase) to ensure consistent comparison.
*   **Character Filtering**: Identifying and processing only specific types of characters (e.g., only alphabetic ones) while ignoring others.","You are given two strings, `s1` and `s2`. Your task is to determine if `s2` is an anagram of `s1`, **ignoring case and all non-alphabetic characters**. Two strings are considered anagrams if, after converting all alphabetic characters to a common case (e.g., lowercase) and disregarding any non-alphabetic characters (like digits, spaces, or punctuation), they contain the same set of alphabetic characters with the same frequencies.

For example, ""Listen!"" and ""silent"" are anagrams. After filtering and normalizing, both effectively become ""listen"", having one 'l', one 'i', one 's', one 't', one 'e', and one 'n'.","*   `1 <= s1.length, s2.length <= 1000`
*   Strings `s1` and `s2` can consist of uppercase and lowercase English letters, digits, spaces, and other punctuation characters.","s1 = ""Anagram!""
s2 = ""nagaram""",TRUE,"Input: Listen!
silent
Output: true

Input: Hello, World!
olleh dlrow
Output: true

Input: Anagram!
nagaram
Output: true

Input: Rat 123
car
Output: false

Input: Triangle
Integral
Output: true

Input: Foo Bar
Bar Foo
Output: true

Input: A1B2C3
cba
Output: true

Input: AAA.
AAa
Output: true

Input: Top Notch
potchoNT
Output: true

Input: Solver, is it?
Lovers is it
Output: true

Input: apple pie
apply pie
Output: false","#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <ctype.h> // For tolower and isalpha functions

bool areAnagrams(const char* s1, const char* s2) {
    int freq[26] = {0}; // Initialize frequency array for lowercase English letters

    // Populate frequency for s1, processing only alphabetic characters
    for (int i = 0; s1[i] != '\0'; i++) {
        if (isalpha(s1[i])) {
            freq[tolower(s1[i]) - 'a']++;
        }
    }

    // Decrement frequency for s2, processing only alphabetic characters
    for (int i = 0; s2[i] != '\0'; i++) {
        if (isalpha(s2[i])) {
            freq[tolower(s2[i]) - 'a']--;
        }
    }

    // Check if all frequencies are zero
    for (int i = 0; i < 26; i++) {
        if (freq[i] != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    char s1[1001];
    char s2[1001];

    // Read s1
    if (scanf(""%1000[^
]%*c"", s1) != 1) { // Read entire line until newline, then consume newline
        return 1; // Error reading input
    }
    // Read s2
    if (scanf(""%1000[^
]%*c"", s2) != 1) { // Read entire line until newline, then consume newline
        return 1; // Error reading input
    }

    if (areAnagrams(s1, s2)) {
        printf(""true\n"");
    } else {
        printf(""false\n"");
    }

    return 0;
}","def are_anagrams(s1: str, s2: str) -> bool:
    freq = [0] * 26  # Initialize frequency array for lowercase English letters

    # Populate frequency for s1, processing only alphabetic characters
    for char_s1 in s1:
        if char_s1.isalpha():
            freq[ord(char_s1.lower()) - ord('a')] += 1

    # Decrement frequency for s2, processing only alphabetic characters
    for char_s2 in s2:
        if char_s2.isalpha():
            freq[ord(char_s2.lower()) - ord('a')] -= 1

    # Check if all frequencies are zero
    for count in freq:
        if count != 0:
            return False

    return True

if __name__ == '__main__':
    s1 = input()
    s2 = input()
    result = are_anagrams(s1, s2)
    print(""true"" if result else ""false"")","import java.util.Scanner;
import java.util.Arrays;

public class Solution {

    public static boolean areAnagrams(String s1, String s2) {
        int[] freq = new int[26]; // Initialize frequency array for lowercase English letters

        // Populate frequency for s1, processing only alphabetic characters
        for (char c : s1.toCharArray()) {
            if (Character.isLetter(c)) {
                freq[Character.toLowerCase(c) - 'a']++;
            }
        }

        // Decrement frequency for s2, processing only alphabetic characters
        for (char c : s2.toCharArray()) {
            if (Character.isLetter(c)) {
                freq[Character.toLowerCase(c) - 'a']--;
            }
        }

        // Check if all frequencies are zero
        for (int count : freq) {
            if (count != 0) {
                return false;
            }
        }

        return true;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s1 = scanner.nextLine(); // Read entire line
        String s2 = scanner.nextLine(); // Read entire line
        scanner.close();

        if (areAnagrams(s1, s2)) {
            System.out.println(""true"");
        } else {
            System.out.println(""false"");
        }
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

function areAnagrams(s1, s2) {
    const freq = new Array(26).fill(0); // Initialize frequency array for lowercase English letters

    // Helper to check if a character is an English letter
    const isAlpha = (char) => {
        const code = char.charCodeAt(0);
        return (code >= 'a'.charCodeAt(0) && code <= 'z'.charCodeAt(0)) ||
               (code >= 'A'.charCodeAt(0) && code <= 'Z'.charCodeAt(0));
    };

    // Populate frequency for s1, processing only alphabetic characters
    for (let i = 0; i < s1.length; i++) {
        const char = s1[i];
        if (isAlpha(char)) {
            freq[char.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0)]++;
        }
    }

    // Decrement frequency for s2, processing only alphabetic characters
    for (let i = 0; i < s2.length; i++) {
        const char = s2[i];
        if (isAlpha(char)) {
            freq[char.toLowerCase().charCodeAt(0) - 'a'.charCodeAt(0)]--;
        }
    }

    // Check if all frequencies are zero
    for (let i = 0; i < 26; i++) {
        if (freq[i] !== 0) {
            return false;
        }
    }

    return true;
}

let lines = [];
rl.on('line', (line) => {
    lines.push(line);
}).on('close', () => {
    const s1 = lines[0];
    const s2 = lines[1];

    if (areAnagrams(s1, s2)) {
        console.log(""true"");
    } else {
        console.log(""false"");
    }
});","#include <iostream>
#include <string>
#include <vector>
#include <numeric>
#include <cctype> // For std::tolower and std::isalpha

bool areAnagrams(const std::string& s1, const std::string& s2) {
    std::vector<int> freq(26, 0); // Initialize frequency array for lowercase English letters

    // Populate frequency for s1, processing only alphabetic characters
    for (char c : s1) {
        if (std::isalpha(c)) {
            freq[std::tolower(c) - 'a']++;
        }
    }

    // Decrement frequency for s2, processing only alphabetic characters
    for (char c : s2) {
        if (std::isalpha(c)) {
            freq[std::tolower(c) - 'a']--;
        }
    }

    // Check if all frequencies are zero
    for (int count : freq) {
        if (count != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    std::string s1;
    std::string s2;

    // Read entire lines, which can contain spaces and punctuation
    std::getline(std::cin, s1);
    std::getline(std::cin, s2);

    if (areAnagrams(s1, s2)) {
        std::cout << ""true\n"";
    } else {
        std::cout << ""false\n"";
    }

    return 0;
}",4.2
Yellow-96,Character Hashing,"*   Character Hashing
*   Frequency Arrays (or Hash Maps)
*   String Manipulation
*   Basic Array Operations
*   Properties of Palindromes","Given a string `s`, determine if a permutation of `s` could form a palindrome. A palindrome is a word or phrase that reads the same forwards and backwards. A permutation is any re-arrangement of the characters of a string.

For example, if `s = ""aabb""`, a possible permutation is ""abba"", which is a palindrome. So, the answer for ""aabb"" would be `true`.
If `s = ""abc""`, no arrangement of its characters can form a palindrome. So, the answer for ""abc"" would be `false`.","*   `1 <= s.length <= 10^5`
*   String `s` consists only of lowercase English letters.","**
s = ""tactcoa""

**","**
true

**","Input: tactcoa
Output: true
Input: aabb
Output: true
Input: abc
Output: false
Input: a
Output: true
Input: topcoderopen
Output: false
Input: level
Output: true
Input: racecar
Output: true","#include <stdio.h>
#include <string.h>
#include <stdbool.h>

// Function to check if a permutation of a string can form a palindrome
bool canPermutePalindrome(const char* s) {
    // Frequency array for lowercase English letters (a-z)
    int char_counts[26] = {0};
    int len = strlen(s);

    // Increment counts for characters in s
    for (int i = 0; i < len; i++) {
        char_counts[s[i] - 'a']++;
    }

    int odd_frequency_count = 0;

    // Check how many characters have an odd frequency
    for (int i = 0; i < 26; i++) {
        if (char_counts[i] % 2 != 0) {
            odd_frequency_count++;
        }
    }

    // A palindrome can be formed if at most one character has an odd frequency
    return odd_frequency_count <= 1;
}

int main() {
    char s[100001]; // Max length 10^5 + null terminator

    // Read the string
    if (scanf(""%s"", s) != 1) {
        return 1; // Error reading input
    }

    if (canPermutePalindrome(s)) {
        printf(""true\n"");
    } else {
        printf(""false\n"");
    }

    return 0;
}","def canPermutePalindrome(s: str) -> bool:
    # Frequency list for lowercase English letters (a-z)
    char_counts = [0] * 26

    # Increment counts for characters in s
    for char_code in map(ord, s):
        char_counts[char_code - ord('a')] += 1

    odd_frequency_count = 0

    # Check how many characters have an odd frequency
    for count in char_counts:
        if count % 2 != 0:
            odd_frequency_count += 1

    # A palindrome can be formed if at most one character has an odd frequency
    return odd_frequency_count <= 1

if __name__ == ""__main__"":
    # Read the string
    s = input()

    if canPermutePalindrome(s):
        print(""true"")
    else:
        print(""false"")","import java.util.Scanner;
import java.util.Arrays;

public class Solution {

    // Function to check if a permutation of a string can form a palindrome
    public static boolean canPermutePalindrome(String s) {
        // Frequency array for lowercase English letters (a-z)
        int[] charCounts = new int[26];
        // Arrays.fill(charCounts, 0); // int arrays are default initialized to 0

        // Increment counts for characters in s
        for (char c : s.toCharArray()) {
            charCounts[c - 'a']++;
        }

        int oddFrequencyCount = 0;

        // Check how many characters have an odd frequency
        for (int count : charCounts) {
            if (count % 2 != 0) {
                oddFrequencyCount++;
            }
        }

        // A palindrome can be formed if at most one character has an odd frequency
        return oddFrequencyCount <= 1;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the string
        String s = scanner.next();

        if (canPermutePalindrome(s)) {
            System.out.println(""true"");
        } else {
            System.out.println(""false"");
        }

        scanner.close();
    }
}","// Function to check if a permutation of a string can form a palindrome
function canPermutePalindrome(s) {
    // Frequency array for lowercase English letters (a-z)
    // Initialize with 26 zeros
    const charCounts = new Array(26).fill(0);

    // Increment counts for characters in s
    for (let i = 0; i < s.length; i++) {
        charCounts[s.charCodeAt(i) - 'a'.charCodeAt(0)]++;
    }

    let oddFrequencyCount = 0;

    // Check how many characters have an odd frequency
    for (let i = 0; i < charCounts.length; i++) {
        if (charCounts[i] % 2 !== 0) {
            oddFrequencyCount++;
        }
    }

    // A palindrome can be formed if at most one character has an odd frequency
    return oddFrequencyCount <= 1;
}

// Node.js specific: handle input from stdin
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.on('line', (line) => {
    const s = line;

    if (canPermutePalindrome(s)) {
        console.log(""true"");
    } else {
        console.log(""false"");
    }
});","#include <iostream>
#include <string>
#include <vector>

// Function to check if a permutation of a string can form a palindrome
bool canPermutePalindrome(const std::string& s) {
    // Frequency vector for lowercase English letters (a-z)
    std::vector<int> char_counts(26, 0);

    // Increment counts for characters in s
    for (char c : s) {
        char_counts[c - 'a']++;
    }

    int odd_frequency_count = 0;

    // Check how many characters have an odd frequency
    for (int count : char_counts) {
        if (count % 2 != 0) {
            odd_frequency_count++;
        }
    }

    // A palindrome can be formed if at most one character has an odd frequency
    return odd_frequency_count <= 1;
}

int main() {
    // Optimize C++ standard streams for faster I/O
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    std::string s;

    // Read the string
    std::cin >> s;

    if (canPermutePalindrome(s)) {
        std::cout << ""true\n"";
    } else {
        std::cout << ""false\n"";
    }

    return 0;
}",4.2
Yellow-97,Character Hashing,"*   Character Hashing (using an array as a frequency map)
*   Iteration (loops)
*   Conditional logic (finding maximum and tie-breaking)
*   Basic String Manipulation","You are tasked with a common detective job: finding the most frequently occurring character in a given string. Your goal is to identify which character appears the highest number of times.

If there's a tie (multiple characters have the same maximum frequency), you should return the character that comes first alphabetically (i.e., has the smallest ASCII value).","*   The input string `s` will contain only ASCII characters (0-127).
*   The length of the string `s` will be between 1 and 1000 characters, inclusive.
*   The string `s` can contain uppercase letters, lowercase letters, digits, spaces, and special characters.","`s = ""hello world""`",`l`,"Input: programming
Output: g
Input: banana
Output: a
Input: Aabbcc
Output: b
Input: single
Output: e
Input: !@#$%^&*()!@#
Output: !","#include <stdio.h>
#include <string.h>
#include <limits.h>

// Function to find the most frequent character in a string
char findMostFrequentChar(const char* s) {
    int frequency[256] = {0}; // Initialize all counts to 0
    int i;
    
    // Step 1: Populate frequency array
    for (i = 0; s[i] != '\0'; i++) {
        frequency[(unsigned char)s[i]]++;
    }
    
    // Step 2: Find most frequent character
    int maxFrequency = -1;
    char resultChar = '\0'; // Default character if string is empty (though constraints say len >= 1)

    // Iterate through all possible ASCII characters (0 to 255)
    // The tie-breaking rule (smallest ASCII value) is naturally handled
    // by iterating from 0 upwards.
    for (i = 0; i < 256; i++) {
        if (frequency[i] > maxFrequency) {
            maxFrequency = frequency[i];
            resultChar = (char)i;
        }
    }
    
    return resultChar;
}

int main() {
    char s[1001]; // Max length 1000 + null terminator

    // Read input string from stdin
    // Use fgets to safely read a line including spaces
    if (fgets(s, sizeof(s), stdin) != NULL) {
        // Remove trailing newline character if present
        s[strcspn(s, ""\n"")] = '\0';
        
        // Handle empty string case if fgets reads an empty line
        // Though constraints say length >= 1, good practice
        if (strlen(s) == 0) {
            printf(""\n""); // Or some specific error/empty char indication
        } else {
            char dominantChar = findMostFrequentChar(s);
            printf(""%c\n"", dominantChar);
        }
    }
    
    return 0;
}","def find_most_frequent_char(s: str) -> str:
    # Using a list as a frequency map for ASCII characters (0-255)
    frequency = [0] * 256
    
    # Step 1: Populate frequency array
    for char_code in map(ord, s):
        frequency[char_code] += 1
    
    # Step 2: Find most frequent character
    max_frequency = -1
    result_char = '' # Initialize with an empty string or a placeholder

    # Iterate through all possible ASCII characters (0 to 255)
    # The tie-breaking rule (smallest ASCII value) is naturally handled
    # by iterating from 0 upwards.
    for i in range(256):
        if frequency[i] > max_frequency:
            max_frequency = frequency[i]
            result_char = chr(i)
            
    return result_char

if __name__ == '__main__':
    s = input() # Read input string from stdin
    
    dominant_char = find_most_frequent_char(s)
    print(dominant_char)","import java.util.Scanner;

public class Solution {

    // Function to find the most frequent character in a string
    public static char findMostFrequentChar(String s) {
        // Using an array as a frequency map for ASCII characters (0-255)
        int[] frequency = new int[256]; 
        
        // Step 1: Populate frequency array
        for (char c : s.toCharArray()) {
            frequency[c]++;
        }
        
        // Step 2: Find most frequent character
        int maxFrequency = -1;
        char resultChar = ' '; // Initialize with a default value

        // Iterate through all possible ASCII characters (0 to 255)
        // The tie-breaking rule (smallest ASCII value) is naturally handled
        // by iterating from 0 upwards.
        for (int i = 0; i < 256; i++) {
            if (frequency[i] > maxFrequency) {
                maxFrequency = frequency[i];
                resultChar = (char)i;
            }
        }
        
        return resultChar;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine(); // Read input string from stdin
        
        char dominantChar = findMostFrequentChar(s);
        System.out.println(dominantChar);
        
        scanner.close();
    }
}","function findMostFrequentChar(s) {
    // Using an array as a frequency map for ASCII characters (0-255)
    const frequency = new Array(256).fill(0);
    
    // Step 1: Populate frequency array
    for (let i = 0; i < s.length; i++) {
        const charCode = s.charCodeAt(i);
        frequency[charCode]++;
    }
    
    // Step 2: Find most frequent character
    let maxFrequency = -1;
    let resultChar = ''; // Initialize with a default value

    // Iterate through all possible ASCII characters (0 to 255)
    // The tie-breaking rule (smallest ASCII value) is naturally handled
    // by iterating from 0 upwards.
    for (let i = 0; i < 256; i++) {
        if (frequency[i] > maxFrequency) {
            maxFrequency = frequency[i];
            resultChar = String.fromCharCode(i);
        }
    }
    
    return resultChar;
}

// Main function to handle input/output
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    rl.on('line', (line) => {
        const dominantChar = findMostFrequentChar(line);
        console.log(dominantChar);
        rl.close();
    });
}

main();","#include <iostream>
#include <string>
#include <vector>
#include <limits>

// Function to find the most frequent character in a string
char findMostFrequentChar(const std::string& s) {
    // Using a vector as a frequency map for ASCII characters (0-255)
    std::vector<int> frequency(256, 0); 
    
    // Step 1: Populate frequency array
    for (char c : s) {
        frequency[static_cast<unsigned char>(c)]++;
    }
    
    // Step 2: Find most frequent character
    int maxFrequency = -1;
    char resultChar = '\0'; // Initialize with a default value

    // Iterate through all possible ASCII characters (0 to 255)
    // The tie-breaking rule (smallest ASCII value) is naturally handled
    // by iterating from 0 upwards.
    for (int i = 0; i < 256; ++i) {
        if (frequency[i] > maxFrequency) {
            maxFrequency = frequency[i];
            resultChar = static_cast<char>(i);
        }
    }
    
    return resultChar;
}

int main() {
    std::string s;
    // Read input string from stdin
    std::getline(std::cin, s);
    
    // The constraints ensure s is not empty. If it could be, handle here.
    char dominantChar = findMostFrequentChar(s);
    std::cout << dominantChar << std::endl;
    
    return 0;
}",4.4
Yellow-98,Tribonacci (Recursive),"*   Recursion
*   Multiple Base Cases
*   Function Call Stack
*   Time Complexity Analysis (for recursive solutions)
*   Space Complexity Analysis (for recursive solutions)","The Tribonacci sequence is a series of numbers where each number is the sum of the three preceding ones. It typically starts with 0, 1, 1. The sequence begins: 0, 1, 1, 2, 4, 7, 13, 24, ...

Your task is to write a function that calculates the Nth Tribonacci number using a recursive approach. The first Tribonacci number (T(0)) is 0, the second (T(1)) is 1, and the third (T(2)) is 1. For N > 2, the Nth Tribonacci number, T(N), is defined as T(N-1) + T(N-2) + T(N-3).",*   `0 <= N <= 20` (N will be a non-negative integer),"**
`N = 5`

**","**
`7`

**","Input: 0
Output: 0
Input: 1
Output: 1
Input: 2
Output: 1
Input: 3
Output: 2
Input: 5
Output: 7
Input: 10
Output: 149","#include <stdio.h>

// Function to calculate the Nth Tribonacci number recursively
int tribonacci(int n) {
    // Base cases
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 1;
    }
    // Recursive step
    return tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);
}

int main() {
    int n;
    // Read input from stdin
    if (scanf(""%d"", &n) != 1) {
        // Handle input error
        return 1;
    }
    
    // Calculate Tribonacci number
    int result = tribonacci(n);
    
    // Print result to stdout
    printf(""%d\n"", result);
    
    return 0;
}","import sys

def tribonacci(n: int) -> int:
    """"""
    Function to calculate the Nth Tribonacci number recursively.
    """"""
    # Base cases
    if n == 0:
        return 0
    if n == 1:
        return 1
    if n == 2:
        return 1
    # Recursive step
    return tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3)

if __name__ == ""__main__"":
    # Read input from stdin
    n = int(sys.stdin.readline().strip())
    
    # Calculate Tribonacci number
    result = tribonacci(n);
    
    # Print result to stdout
    sys.stdout.write(str(result) + ""\n"")","import java.util.Scanner;

public class Solution {

    // Function to calculate the Nth Tribonacci number recursively
    public int tribonacci(int n) {
        // Base cases
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        if (n == 2) {
            return 1;
        }
        // Recursive step
        return tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // Read input from stdin
        int n = scanner.nextInt();
        scanner.close();
        
        Solution sol = new Solution();
        // Calculate Tribonacci number
        int result = sol.tribonacci(n);
        
        // Print result to stdout
        System.out.println(result);
    }
}","function tribonacci(n) {
    // Base cases
    if (n === 0) {
        return 0;
    }
    if (n === 1) {
        return 1;
    }
    if (n === 2) {
        return 1;
    }
    // Recursive step
    return tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);
}

// Read input from stdin
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.on('line', (line) => {
    const n = parseInt(line.trim(), 10);
    
    // Calculate Tribonacci number
    const result = tribonacci(n);
    
    // Print result to stdout
    console.log(result);
    rl.close();
});","#include <iostream>

// Function to calculate the Nth Tribonacci number recursively
int tribonacci(int n) {
    // Base cases
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    if (n == 2) {
        return 1;
    }
    // Recursive step
    return tribonacci(n - 1) + tribonacci(n - 2) + tribonacci(n - 3);
}

int main() {
    int n;
    // Read input from stdin
    std::cin >> n;
    
    // Calculate Tribonacci number
    int result = tribonacci(n);
    
    // Print result to stdout
    std::cout << result << std::endl;
    
    return 0;
}",4.2
Yellow-99,Linear Search,"- Arrays
- Iteration (Loops)
- Conditional Statements
- Linear Search","You are given an array of integers `arr` and a target integer `target`. Your task is to find the index of the **first occurrence** of the `target` in the `arr`. If the `target` is not found in the array, you should return `-1`.","- `1 <= N <= 100` (where N is the length of the array)
- `-100 <= arr[i] <= 100`
- `-100 <= target <= 100`","**

5
10 20 30 40 20
20


**","**

1

**","Input:
5
1 2 3 4 5
1
Output:
0
Input:
5
1 2 3 4 5
5
Output:
4
Input:
5
1 2 3 4 5
6
Output:
-1
Input:
7
10 20 10 30 40 10 50
10
Output:
0
Input:
1
42
42
Output:
0","#include <stdio.h>
#include <stdlib.h>

// Function to perform linear search
int linearSearch(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}

int main() {
    int n;
    // Read the size of the array
    if (scanf(""%d"", &n) != 1 || n < 1 || n > 100) {
        fprintf(stderr, ""Invalid array size.\n"");
        return 1;
    }

    int arr[100]; // Declare a fixed-size array based on max constraint
    // Read array elements
    for (int i = 0; i < n; i++) {
        if (scanf(""%d"", &arr[i]) != 1) {
            fprintf(stderr, ""Invalid array element.\n"");
            return 1;
        }
    }

    int target;
    // Read the target value
    if (scanf(""%d"", &target) != 1) {
        fprintf(stderr, ""Invalid target value.\n"");
        return 1;
    }

    // Call the linear search function
    int result = linearSearch(arr, n, target);

    // Print the result
    printf(""%d\n"", result);

    return 0;
}","def linear_search(arr, target):
    """"""
    Performs a linear search to find the first occurrence of the target.
    Args:
        arr (list): The list of integers to search within.
        target (int): The integer to search for.
    Returns:
        int: The index of the first occurrence of the target, or -1 if not found.
    """"""
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # Target found, return its index
    return -1  # Target not found

if __name__ == ""__main__"":
    # Read the size of the array (though len(arr) can also be used)
    n = int(input())

    # Read array elements
    arr = list(map(int, input().split()))

    # Read the target value
    target = int(input())

    # Call the linear search function
    result = linear_search(arr, target)

    # Print the result
    print(result)","import java.util.Scanner;

public class Main {

    // Function to perform linear search
    public int linearSearch(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i; // Target found, return its index
            }n
        }
        return -1; // Target not found
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Main solution = new Main(); // Create an instance of the Main class to call linearSearch

        // Read the size of the array
        int n = scanner.nextInt();
        int[] arr = new int[n];

        // Read array elements
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        // Read the target value
        int target = scanner.nextInt();

        // Call the linear search function
        int result = solution.linearSearch(arr, target);

        // Print the result
        System.out.println(result);

        scanner.close();
    }
}","// Function to perform linear search
function linearSearch(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}

// Node.js specific input/output handling
let input = '';
process.stdin.on('data', data => {
    input += data.toString();
});

process.stdin.on('end', () => {
    const lines = input.trim().split('\n');
    let lineIndex = 0;

    // Read the size of the array (optional, can be inferred from array length)
    const n = parseInt(lines[lineIndex++], 10);

    // Read array elements
    const arr = lines[lineIndex++].split(' ').map(Number);

    // Read the target value
    const target = parseInt(lines[lineIndex++], 10);

    // Call the linear search function
    const result = linearSearch(arr, target);

    // Print the result
    console.log(result);
});","#include <iostream>
#include <vector>

// Function to perform linear search
int linearSearch(const std::vector<int>& arr, int target) {
    for (int i = 0; i < arr.size(); ++i) {
        if (arr[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}

int main() {
    std::ios_base::sync_with_stdio(false); // Optimize C++ standard streams
    std::cin.tie(NULL);                   // Untie cin from cout

    int n;
    // Read the size of the array
    std::cin >> n;

    std::vector<int> arr(n);
    // Read array elements
    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i];
    }

    int target;
    // Read the target value
    std::cin >> target;

    // Call the linear search function
    int result = linearSearch(arr, target);

    // Print the result
    std::cout << result << std::endl;

    return 0;
}",4
Orange-3,Counting Sort,"*   Counting Sort Algorithm
*   Frequency Arrays
*   Stable Sorting (implementation of Counting Sort can be made stable)
*   Time and Space Complexity Analysis (O(N + K) where N is number of elements and K is range of values)
*   Dynamic Array/List Handling",You are given an unsorted array of non-negative integers. Your task is to sort this array using the Counting Sort algorithm. Counting Sort is an efficient sorting algorithm for integers when the range of input values is not significantly larger than the number of items to be sorted. It works by counting the frequency of each distinct element in the array and then using this count information to place elements in their correct sorted positions.,"*   `1 <= N <= 10^5` (where `N` is the number of elements in the array)
*   `0 <= arr[i] <= 1000` (where `arr[i]` is an element in the array)
*   All elements are non-negative integers.","**
`7`
`4 2 2 8 3 3 1`

**","**
`1 2 2 3 3 4 8`","Input: 1
5
Output: 5
Input: 3
3 3 3
Output: 3 3 3
Input: 5
9 8 7 6 5
Output: 5 6 7 8 9
Input: 7
0 1000 500 1 999 2 500
Output: 0 1 2 500 500 999 1000
Input: 10
10 4 1 8 2 7 3 9 5 6
Output: 1 2 3 4 5 6 7 8 9 10","#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

// Function to find the maximum element in an array
int findMax(int arr[], int n) {
    int max_val = INT_MIN;
    for (int i = 0; i < n; i++) {
        if (arr[i] > max_val) {
            max_val = arr[i];
        }
    }
    return max_val;
}

// Function to perform Counting Sort
void countingSort(int arr[], int n) {
    if (n <= 1) return;

    int max_val = findMax(arr, n);

    // Create count array and initialize with 0
    // Size will be max_val + 1 to accommodate 0 to max_val
    int* count = (int*)calloc((max_val + 1), sizeof(int));
    if (count == NULL) {
        // Handle allocation error
        return;
    }

    // Create output array
    int* output = (int*)malloc(n * sizeof(int));
    if (output == NULL) {
        free(count);
        // Handle allocation error
        return;
    }

    // Store count of each character
    for (int i = 0; i < n; i++) {
        count[arr[i]]++;
    }

    // Change count[i] so that count[i] now contains actual
    // position of this character in output array
    for (int i = 1; i <= max_val; i++) {
        count[i] += count[i - 1];
    }

    // Build the output array
    // To make it stable, iterate from right to left
    for (int i = n - 1; i >= 0; i--) {
        output[count[arr[i]] - 1] = arr[i];
        count[arr[i]]--;
    }

    // Copy the output array to arr, so that arr now
    // contains sorted characters
    for (int i = 0; i < n; i++) {
        arr[i] = output[i];
    }

    free(count);
    free(output);
}

int main() {
    int n;
    scanf(""%d"", &n);

    int* arr = (int*)malloc(n * sizeof(int));
    if (arr == NULL) {
        return 1; // Indicate error
    }

    for (int i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]);
    }

    countingSort(arr, n);

    for (int i = 0; i < n; i++) {
        printf(""%d"", arr[i]);
        if (i < n - 1) {
            printf("" "");
        }
    }
    printf(""\n"");

    free(arr);

    return 0;
}","def counting_sort(arr):
    n = len(arr)
    if n <= 1: return

    # Find the maximum element to determine the range of values
    max_val = 0
    for x in arr:
        if x > max_val:
            max_val = x
    
    # Create count array and initialize with 0
    # Size will be max_val + 1 to accommodate 0 to max_val
    count = [0] * (max_val + 1)

    # Create output array
    output = [0] * n

    # Store count of each character
    for x in arr:
        count[x] += 1

    # Change count[i] so that count[i] now contains actual
    # position of this character in output array
    # (cumulative sum)
    for i in range(1, max_val + 1):
        count[i] += count[i - 1]

    # Build the output array
    # To make it stable, iterate from right to left
    for i in range(n - 1, -1, -1):
        output[count[arr[i]] - 1] = arr[i]
        count[arr[i]] -= 1

    # Copy the output array to arr, so that arr now
    # contains sorted characters
    for i in range(n):
        arr[i] = output[i]


if __name__ == '__main__':
    n = int(input())
    arr = list(map(int, input().split()))

    counting_sort(arr)

    print(*(arr))","import java.util.Scanner;
import java.util.Arrays;

public class Solution {

    // Function to perform Counting Sort
    public static void countingSort(int[] arr) {
        int n = arr.length;
        if (n <= 1) return;

        // Find the maximum element to determine the range of values
        int maxVal = 0;
        for (int x : arr) {
            if (x > maxVal) {
                maxVal = x;
            }
        }

        // Create count array and initialize with 0
        // Size will be maxVal + 1 to accommodate 0 to maxVal
        int[] count = new int[maxVal + 1];
        Arrays.fill(count, 0);

        // Create output array
        int[] output = new int[n];

        // Store count of each character
        for (int x : arr) {
            count[x]++;
        }

        // Change count[i] so that count[i] now contains actual
        // position of this character in output array
        // (cumulative sum)
        for (int i = 1; i <= maxVal; i++) {
            count[i] += count[i - 1];
        }

        // Build the output array
        // To make it stable, iterate from right to left
        for (int i = n - 1; i >= 0; i--) {
            output[count[arr[i]] - 1] = arr[i];
            count[arr[i]]--;
        }

        // Copy the output array to arr, so that arr now
        // contains sorted characters
        for (int i = 0; i < n; i++) {
            arr[i] = output[i];
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        countingSort(arr);

        for (int i = 0; i < n; i++) {
            System.out.print(arr[i]);
            if (i < n - 1) {
                System.out.print("" "");
            }
        }
        System.out.println();

        scanner.close();
    }
}","const fs = require('fs');

function countingSort(arr) {
    const n = arr.length;
    if (n <= 1) return arr;

    // Find the maximum element to determine the range of values
    let maxVal = 0;
    for (const x of arr) {
        if (x > maxVal) {
            maxVal = x;
        }
    }

    // Create count array and initialize with 0
    // Size will be maxVal + 1 to accommodate 0 to maxVal
    const count = new Array(maxVal + 1).fill(0);

    // Create output array
    const output = new Array(n);

    // Store count of each character
    for (const x of arr) {
        count[x]++;
    }

    // Change count[i] so that count[i] now contains actual
    // position of this character in output array
    // (cumulative sum)
    for (let i = 1; i <= maxVal; i++) {
        count[i] += count[i - 1];
    }

    // Build the output array
    // To make it stable, iterate from right to left
    for (let i = n - 1; i >= 0; i--) {
        output[count[arr[i]] - 1] = arr[i];
        count[arr[i]]--;
    }

    // Copy the output array to arr, so that arr now
    // contains sorted characters
    for (let i = 0; i < n; i++) {
        arr[i] = output[i];
    }

    return arr;
}

function main() {
    const input = fs.readFileSync(0, 'utf8').trim().split('\n');
    const n = parseInt(input[0], 10);
    const arr = input[1].split(' ').map(Number);

    countingSort(arr);

    console.log(arr.join(' '));
}

main();","#include <iostream>
#include <vector>
#include <algorithm>

// Function to perform Counting Sort
void countingSort(std::vector<int>& arr) {
    int n = arr.size();
    if (n <= 1) return;

    // Find the maximum element to determine the range of values
    int max_val = 0;
    for (int x : arr) {
        if (x > max_val) {
            max_val = x;
        }
    }

    // Create count array and initialize with 0
    // Size will be max_val + 1 to accommodate 0 to max_val
    std::vector<int> count(max_val + 1, 0);

    // Create output array
    std::vector<int> output(n);

    // Store count of each character
    for (int x : arr) {
        count[x]++;
    }

    // Change count[i] so that count[i] now contains actual
    // position of this character in output array
    // (cumulative sum)
    for (int i = 1; i <= max_val; i++) {
        count[i] += count[i - 1];
    }

    // Build the output array
    // To make it stable, iterate from right to left
    for (int i = n - 1; i >= 0; i--) {
        output[count[arr[i]] - 1] = arr[i];
        count[arr[i]]--;
    }

    // Copy the output array to arr, so that arr now
    // contains sorted characters
    for (int i = 0; i < n; i++) {
        arr[i] = output[i];
    }
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    std::vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        std::cin >> arr[i];
    }

    countingSort(arr);

    for (int i = 0; i < n; i++) {
        std::cout << arr[i];
        if (i < n - 1) {
            std::cout << "" "";
        }
    }
    std::cout << std::endl;

    return 0;
}",4.4
Yellow-100,Fibonacci (Recursive),"*   **Recursion:** The art of a function calling itself, still at the core!
*   **Base Cases:** Essential ""stopping points"" for your recursive helper.
*   **Iterative Loops:** Using `for` or `while` loops to repeat actions.
*   **Conditional Logic:** Employing `if` statements to check for even numbers.
*   **Accumulation:** Building a total sum step by step.
*   **Function Composition:** How multiple functions work together to solve a larger problem.
*   **Performance Considerations:** Understanding how combining recursion and iteration can impact execution time for certain problems, hinting at future optimization techniques.","Remember the captivating Fibonacci sequence, where each number is the sum of the two before it? We've climbed that ladder to find the `N`th number. Now, let's add a twist to our journey!

Your new quest, 'Harmony Hunter,' is to not only understand the `N`th Fibonacci number but to find the **sum of all even Fibonacci numbers** from `F(0)` up to `F(N)`. This means you'll need to figure out each Fibonacci number from `0` to `N`, check if it's an even number, and if it is, add it to your grand total!

You'll still use your magical recursive function to calculate individual Fibonacci numbers. But this time, you'll combine that power with an iterative loop to check and sum the even ones. It's a fantastic way to see how recursion can be a powerful building block within a larger problem-solving strategy!","*   `0 <= N <= 25` (We're still keeping `N` manageable to prevent our recursive spells from running too long. However, expect this challenge to take a bit more computational 'energy' than just finding a single `F(N)`!)
*   The final sum will comfortably fit into a standard integer type.","6

####","10

####","Input: 0
Output: 0
Input: 1
Output: 0
Input: 2
Output: 0
Input: 3
Output: 2
Input: 6
Output: 10
Input: 10
Output: 44
Input: 20
Output: 1770","#include <stdio.h>

// Recursive helper function to calculate the Nth Fibonacci number
int fibonacci(int n) {
    if (n <= 1) {
        return n;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

// Main function to sum even Fibonacci numbers up to N
int sumEvenFibonacciUpToN(int n) {
    int total_sum = 0;
    for (int i = 0; i <= n; i++) {
        int fib_num = fibonacci(i);
        if (fib_num % 2 == 0) {
            total_sum += fib_num;
        }
    }
    return total_sum;
}

int main() {
    int n;
    if (scanf(""%d"", &n) != 1) {
        return 1; // Error handling for input
    }
    printf(""%d\n"", sumEvenFibonacciUpToN(n));
    return 0;
}","def fibonacci(n):
    if n <= 1:
        return n
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)

def sum_even_fibonacci_up_to_n(n):
    total_sum = 0
    for i in range(n + 1):
        fib_num = fibonacci(i)
        if fib_num % 2 == 0:
            total_sum += fib_num
    return total_sum

if __name__ == ""__main__"":
    n = int(input())
    print(sum_even_fibonacci_up_to_n(n))","import java.util.Scanner;

public class Solution {

    // Recursive helper function to calculate the Nth Fibonacci number
    public static int fibonacci(int n) {
        if (n <= 1) {
            return n;
        } else {
            return fibonacci(n - 1) + fibonacci(n - 2);
        }
    }

    // Main function to sum even Fibonacci numbers up to N
    public static int sumEvenFibonacciUpToN(int n) {
        int totalSum = 0;
        for (int i = 0; i <= n; i++) {
            int fibNum = fibonacci(i);
            if (fibNum % 2 == 0) {
                totalSum += fibNum;
            }
        }
        return totalSum;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        System.out.println(sumEvenFibonacciUpToN(n));
        scanner.close();
    }
}","function fibonacci(n) {
    if (n <= 1) {
        return n;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

function sumEvenFibonacciUpToN(n) {
    let totalSum = 0;
    for (let i = 0; i <= n; i++) {
        const fibNum = fibonacci(i);
        if (fibNum % 2 === 0) {
            totalSum += fibNum;
        }
    }
    return totalSum;
}

// Read input from stdin
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.on('line', (line) => {
    const n = parseInt(line.trim(), 10);
    console.log(sumEvenFibonacciUpToN(n));
    rl.close();
});","#include <iostream>

// Recursive helper function to calculate the Nth Fibonacci number
int fibonacci(int n) {
    if (n <= 1) {
        return n;
    }
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// Main function to sum even Fibonacci numbers up to N
int sumEvenFibonacciUpToN(int n) {
    int total_sum = 0;
    for (int i = 0; i <= n; ++i) {
        int fib_num = fibonacci(i);
        if (fib_num % 2 == 0) {
            total_sum += fib_num;
        }
    }
    return total_sum;
}

int main() {
    int n;
    std::cin >> n;
    std::cout << sumEvenFibonacciUpToN(n) << std::endl;
    return 0;
}",4.4
Orange-4,Stability of Sorting,"*   Stability of Sorting Algorithms
*   Linear Scan / Iteration
*   Custom Data Structures (Pairs/Structs/Objects)","In sorting algorithms, 'stability' refers to how elements with identical values are treated. A sorting algorithm is stable if it preserves the relative order of equal elements in the input array. For example, if you have two students, Alice and Bob, both with a score of 90, and Alice appeared before Bob in the original list, a stable sort will ensure Alice still appears before Bob in the sorted list.

This problem asks you to determine if a given sequence of items, which is already sorted by its primary value, maintains this stability property. Each item in the sequence is represented as a pair: `(value, original_index)`. The `value` is the primary key for sorting, and `original_index` indicates its initial position in the array before any sorting occurred. If two items have the same `value`, their `original_index` must be in increasing order to be considered stable.","* `N`: The number of items in the sequence, `1 <= N <= 10^5`.
* `value`: The primary sorting key for an item, `1 <= value <= 10^9`.
* `original_index`: The unique original position of an item, `0 <= original_index < N`.
* The input sequence is guaranteed to be sorted by `value` in non-decreasing order.","4
10 0
10 2
20 1
30 3",TRUE,"Input:
1
100 0
Output: true

Input:
5
10 0
20 1
30 2
40 3
50 4
Output: true

Input:
5
7 0
7 1
7 3
7 2
7 4
Output: false","#include <stdio.h>
#include <stdbool.h>

typedef struct {
    int value;
    int original_index;
} Pair;

bool is_stable_sequence(Pair* pairs, int n) {
    if (n <= 1) {
        return true;
    }

    for (int i = 1; i < n; i++) {
        if (pairs[i].value == pairs[i-1].value) {
            if (pairs[i].original_index < pairs[i-1].original_index) {
                return false;
            }
        }
    }
    return true;
}

int main() {
    int n;
    scanf(""%d"", &n);

    Pair* pairs = (Pair*)malloc(n * sizeof(Pair));
    if (pairs == NULL) {
        return 1; // Allocation failed
    }

    for (int i = 0; i < n; i++) {
        scanf(""%d %d"", &pairs[i].value, &pairs[i].original_index);
    }

    if (is_stable_sequence(pairs, n)) {
        printf(""true\n"");
    } else {
        printf(""false\n"");
    }

    free(pairs);
    return 0;
}","def is_stable_sequence(pairs):
    if not pairs or len(pairs) <= 1:
        return True

    for i in range(1, len(pairs)):
        # If current value is same as previous value
        if pairs[i][0] == pairs[i-1][0]:
            # Check original indices
            # If current original_index is smaller than previous original_index,
            # then stability is violated.
            if pairs[i][1] < pairs[i-1][1]:
                return False # Unstable condition
        
    return True

if __name__ == '__main__':
    N = int(input())
    pairs = []
    for _ in range(N):
        value, original_index = map(int, input().split())
        pairs.append((value, original_index))

    result = is_stable_sequence(pairs)
    print(str(result).lower())","import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

class Pair {
    int value;
    int original_index;

    public Pair(int value, int original_index) {
        this.value = value;
        this.original_index = original_index;
    }
}

public class Solution {

    public static boolean isStableSequence(List<Pair> pairs) {
        if (pairs == null || pairs.size() <= 1) {
            return true;
        }

        for (int i = 1; i < pairs.size(); i++) {
            Pair current = pairs.get(i);
            Pair previous = pairs.get(i - 1);

            if (current.value == previous.value) {
                if (current.original_index < previous.original_index) {
                    return false; // Stability violated
                }
            }
        }
        return true;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();

        List<Pair> pairs = new ArrayList<>();
        for (int i = 0; i < n; i++) {
            int value = scanner.nextInt();
            int original_index = scanner.nextInt();
            pairs.add(new Pair(value, original_index));
        }

        if (isStableSequence(pairs)) {
            System.out.println(""true"");
        } else {
            System.out.println(""false"");
        }

        scanner.close();
    }
}","function isStableSequence(pairs) {
    if (pairs.length <= 1) {
        return true;
    }

    for (let i = 1; i < pairs.length; i++) {
        // If current value is same as previous value
        if (pairs[i][0] === pairs[i-1][0]) {
            // Check original indices
            // If current original_index is smaller than previous original_index,
            // then stability is violated.
            if (pairs[i][1] < pairs[i-1][1]) {
                return false; // Unstable condition
            }
        }
    }
    return true;
}

// Read input from stdin
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let lines = [];
rl.on('line', (line) => {
    lines.push(line);
}).on('close', () => {
    const N = parseInt(lines[0]);
    const pairs = [];
    for (let i = 1; i <= N; i++) {
        const [value, original_index] = lines[i].split(' ').map(Number);
        pairs.push([value, original_index]);
    }

    const result = isStableSequence(pairs);
    console.log(String(result).toLowerCase());
});","#include <iostream>
#include <vector>
#include <string>

struct Pair {
    int value;
    int original_index;
};

bool isStableSequence(const std::vector<Pair>& pairs) {
    if (pairs.size() <= 1) {
        return true;
    }

    for (size_t i = 1; i < pairs.size(); ++i) {
        if (pairs[i].value == pairs[i-1].value) {
            if (pairs[i].original_index < pairs[i-1].original_index) {
                return false; // Stability violated
            }
        }
    }
    return true;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    std::vector<Pair> pairs(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> pairs[i].value >> pairs[i].original_index;
    }

    if (isStableSequence(pairs)) {
        std::cout << ""true\n"";
    } else {
        std::cout << ""false\n"";
    }

    return 0;
}",4.2
Orange-5,Merge Sort,"- Divide and Conquer Paradigm
- Recursion
- Merge Sort Algorithm
- Array Manipulation
- Time and Space Complexity Analysis (O(n log n) time, O(n) space)","Given an unsorted array of integers, sort it in ascending order using the Merge Sort algorithm.

Merge Sort is a classic example of a ""Divide and Conquer"" algorithm. It works by recursively dividing the array into two halves until it cannot be divided further (i.e., when the sub-array contains only one element, which is by definition sorted). Then, it merges these sorted sub-arrays back together to produce a fully sorted array.","- `1 <= n <= 10^5` (where `n` is the number of elements in the array)
- `-10^9 <= arr[i] <= 10^9`
- The solution must implement Merge Sort and achieve its characteristic time and space complexity.","6
5 2 8 1 9 4","1 2 4 5 8 9


#### Example 2:","Input: 1
42
Output: 42
Input: 7
10 7 8 9 1 5 0
Output: 0 1 5 7 8 9 10
Input: 5
-5 -2 -8 -1 -9
Output: -9 -8 -5 -2 -1
Input: 8
1 1 2 2 3 3 0 0
Output: 0 0 1 1 2 2 3 3
Input: 4
-1000000000 0 1000000000 500000000
Output: -1000000000 0 500000000 1000000000","#include <stdio.h>
#include <stdlib.h>

// Function to merge two halves of an array
void merge(long long arr[], int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    // Create temporary arrays
    long long *L = (long long *)malloc(n1 * sizeof(long long));
    long long *R = (long long *)malloc(n2 * sizeof(long long));

    // Copy data to temporary arrays L[] and R[]
    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];

    // Merge the temporary arrays back into arr[left..right]
    int i = 0; // Initial index of first sub-array
    int j = 0; // Initial index of second sub-array
    int k = left; // Initial index of merged sub-array
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // Copy the remaining elements of L[], if any
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    // Copy the remaining elements of R[], if any
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }

    // Free dynamically allocated memory
    free(L);
    free(R);
}

// Main function that implements Merge Sort
void mergeSort(long long arr[], int left, int right) {
    if (left < right) {
        // Same as (left + right) / 2, but avoids overflow for large left and right
        int mid = left + (right - left) / 2;

        // Sort first and second halves
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);

        merge(arr, left, mid, right);
    }
}

int main() {
    int n;
    scanf(""%d"", &n);

    long long *arr = (long long *)malloc(n * sizeof(long long));
    if (arr == NULL) {
        return 1; // Error allocating memory
    }

    for (int i = 0; i < n; i++) {
        scanf(""%lld"", &arr[i]);
    }

    mergeSort(arr, 0, n - 1);

    for (int i = 0; i < n; i++) {
        printf(""%lld%c"", arr[i], (i == n - 1 ? '\n' : ' '));
    }

    free(arr);

    return 0;
}","def merge(arr, left, mid, right):
    n1 = mid - left + 1
    n2 = right - mid

    # Create temporary arrays
    L = [0] * n1
    R = [0] * n2

    # Copy data to temporary arrays L[] and R[]
    for i in range(n1):
        L[i] = arr[left + i]
    for j in range(n2):
        R[j] = arr[mid + 1 + j]

    # Merge the temporary arrays back into arr[left..right]
    i = 0  # Initial index of first sub-array
    j = 0  # Initial index of second sub-array
    k = left  # Initial index of merged sub-array
    while i < n1 and j < n2:
        if L[i] <= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    # Copy the remaining elements of L[], if any
    while i < n1:
        arr[k] = L[i]
        i += 1
        k += 1

    # Copy the remaining elements of R[], if any
    while j < n2:
        arr[k] = R[j]
        j += 1
        k += 1

def merge_sort(arr, left, right):
    if left < right:
        mid = left + (right - left) // 2

        # Sort first and second halves
        merge_sort(arr, left, mid)
        merge_sort(arr, mid + 1, right)

        merge(arr, left, mid, right)

if __name__ == '__main__':
    n = int(input())
    arr = list(map(int, input().split()))

    merge_sort(arr, 0, n - 1)

    print(*(arr))","import java.util.Scanner;

public class Solution {

    // Function to merge two halves of an array
    public void merge(long[] arr, int left, int mid, int right) {
        int n1 = mid - left + 1;
        int n2 = right - mid;

        // Create temporary arrays
        long[] L = new long[n1];
        long[] R = new long[n2];

        // Copy data to temporary arrays L[] and R[]
        for (int i = 0; i < n1; i++)
            L[i] = arr[left + i];
        for (int j = 0; j < n2; j++)
            R[j] = arr[mid + 1 + j];

        // Merge the temporary arrays back into arr[left..right]
        int i = 0; // Initial index of first sub-array
        int j = 0; // Initial index of second sub-array
        int k = left; // Initial index of merged sub-array
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            } else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }

        // Copy the remaining elements of L[], if any
        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }

        // Copy the remaining elements of R[], if any
        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }

    // Main function that implements Merge Sort
    public void mergeSort(long[] arr, int left, int right) {
        if (left < right) {
            // Same as (left + right) / 2, but avoids overflow for large left and right
            int mid = left + (right - left) / 2;

            // Sort first and second halves
            mergeSort(arr, left, mid);
            mergeSort(arr, mid + 1, right);

            merge(arr, left, mid, right);
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        long[] arr = new long[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextLong();
        }
        scanner.close();

        Solution sorter = new Solution();
        sorter.mergeSort(arr, 0, n - 1);

        for (int i = 0; i < n; i++) {
            System.out.print(arr[i] + (i == n - 1 ? """" : "" ""));
        }
        System.out.println();
    }
}","function merge(arr, left, mid, right) {
    const n1 = mid - left + 1;
    const n2 = right - mid;

    // Create temporary arrays
    const L = new Array(n1);
    const R = new Array(n2);

    // Copy data to temporary arrays L[] and R[]
    for (let i = 0; i < n1; i++) {
        L[i] = arr[left + i];
    }
    for (let j = 0; j < n2; j++) {
        R[j] = arr[mid + 1 + j];
    }

    // Merge the temporary arrays back into arr[left..right]
    let i = 0; // Initial index of first sub-array
    let j = 0; // Initial index of second sub-array
    let k = left; // Initial index of merged sub-array
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // Copy the remaining elements of L[], if any
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    // Copy the remaining elements of R[], if any
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

// Main function that implements Merge Sort
function mergeSort(arr, left, right) {
    if (left < right) {
        const mid = Math.floor(left + (right - left) / 2);

        // Sort first and second halves
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);

        merge(arr, left, mid, right);
    }
}

// Handle input and output
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let input = [];
    rl.on('line', (line) => {
        input.push(line);
    }).on('close', () => {
        const n = parseInt(input[0], 10);
        const arr = input[1].split(' ').map(Number);

        mergeSort(arr, 0, n - 1);

        console.log(arr.join(' '));
    });
}

main();","#include <iostream>
#include <vector>
#include <algorithm>

// Function to merge two halves of a vector
void merge(std::vector<long long>& arr, int left, int mid, int right) {
    int n1 = mid - left + 1;
    int n2 = right - mid;

    // Create temporary vectors
    std::vector<long long> L(n1);
    std::vector<long long> R(n2);

    // Copy data to temporary vectors L[] and R[]
    for (int i = 0; i < n1; i++)
        L[i] = arr[left + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[mid + 1 + j];

    // Merge the temporary vectors back into arr[left..right]
    int i = 0; // Initial index of first sub-array
    int j = 0; // Initial index of second sub-array
    int k = left; // Initial index of merged sub-array
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    // Copy the remaining elements of L[], if any
    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    // Copy the remaining elements of R[], if any
    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

// Main function that implements Merge Sort
void mergeSort(std::vector<long long>& arr, int left, int right) {
    if (left < right) {
        // Same as (left + right) / 2, but avoids overflow for large left and right
        int mid = left + (right - left) / 2;

        // Sort first and second halves
        mergeSort(arr, left, mid);
        mergeSort(arr, mid + 1, right);

        merge(arr, left, mid, right);
    }
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    std::vector<long long> arr(n);
    for (int i = 0; i < n; i++) {
        std::cin >> arr[i];
    }

    mergeSort(arr, 0, n - 1);

    for (int i = 0; i < n; i++) {
        std::cout << arr[i] << (i == n - 1 ? """" : "" "");
    }
    std::cout << std::endl;

    return 0;
}",4.2
Orange-6,Sliding Window Maximum (Deque),"*   Sliding Window
*   Deque (Double-Ended Queue)
*   Monotonic Queue
*   Array Manipulation","Given an array `nums` and an integer `k`, return the maximum sliding window. You should return an array of integers, where each element is the maximum in its corresponding sliding window.

A sliding window is a contiguous subarray of size `k`. As the window slides one position to the right, the element at the far left leaves the window and a new element enters from the far right. Your task is to find the maximum element within each such window.","* `1 <= nums.length <= 10^5`
* `1 <= k <= nums.length`
* `-10^4 <= nums[i] <= 10^4`","**

nums = [1,3,-1,-3,5,3,6,7], k = 3


**","**

[3,3,5,5,6,7]


**","Input: 1
1
1
Output: 1
Input: 3
7 2 4
2
Output: 7 4
Input: 6
1 3 1 2 0 5
3
Output: 3 3 2 5
Input: 4
4 3 2 1
1
Output: 4 3 2 1
Input: 9
9 8 7 6 5 4 3 2 1
4
Output: 9 8 7 6","#include <stdio.h>
#include <stdlib.h>

// Custom Deque structure for indices
typedef struct {
    int* arr;
    int front;
    int rear;
    int capacity;
    int size;
} Deque;

// Initialize Deque
Deque* createDeque(int capacity) {
    Deque* dq = (Deque*)malloc(sizeof(Deque));
    dq->capacity = capacity;
    dq->arr = (int*)malloc(dq->capacity * sizeof(int));
    dq->front = 0;
    dq->rear = -1;
    dq->size = 0;
    return dq;
}

// Check if Deque is empty
int isEmpty(Deque* dq) {
    return dq->size == 0;
}

// Add element to the back
void addRear(Deque* dq, int val) {
    if (dq->size == dq->capacity) {
        // This case should ideally not happen if capacity is >= k, for this problem
        // Or, it implies a dynamic resizing, which is not implemented here for simplicity
        return;
    }
    dq->rear = (dq->rear + 1) % dq->capacity;
    dq->arr[dq->rear] = val;
    dq->size++;
}

// Remove element from the front
void removeFront(Deque* dq) {
    if (isEmpty(dq)) return;
    dq->front = (dq->front + 1) % dq->capacity;
    dq->size--;
}

// Remove element from the back
void removeRear(Deque* dq) {
    if (isEmpty(dq)) return;
    dq->rear = (dq->rear - 1 + dq->capacity) % dq->capacity;
    dq->size--;
}

// Get front element
int getFront(Deque* dq) {
    if (isEmpty(dq)) return -1; // Error or sentinel value
    return dq->arr[dq->front];
}

// Get back element
int getRear(Deque* dq) {
    if (isEmpty(dq)) return -1; // Error or sentinel value
    return dq->arr[dq->rear];
}

// Free Deque memory
void freeDeque(Deque* dq) {
    free(dq->arr);
    free(dq);
}

/**
 * Note: The returned array must be malloced, assume caller calls free().
 */
int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize) {
    Deque* dq = createDeque(numsSize); // Deque can store at most numsSize indices
    int* result = (int*)malloc((numsSize - k + 1) * sizeof(int));
    *returnSize = 0;

    for (int i = 0; i < numsSize; i++) {
        // Remove elements from the front that are out of the current window
        if (!isEmpty(dq) && getFront(dq) <= i - k) {
            removeFront(dq);
        }

        // Remove elements from the back that are smaller than the current element
        // maintaining the monotonic decreasing property
        while (!isEmpty(dq) && nums[getRear(dq)] <= nums[i]) {
            removeRear(dq);
        }

        // Add current element's index to the back of the deque
        addRear(dq, i);

        // If the window has formed (i.e., i+1 >= k), add the maximum to the result
        if (i >= k - 1) {
            result[*returnSize] = nums[getFront(dq)];
            (*returnSize)++;
        }
    }

    freeDeque(dq);
    return result;
}

int main() {
    int n;
    scanf(""%d"", &n);

    int* nums = (int*)malloc(n * sizeof(int));
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &nums[i]);
    }

    int k;
    scanf(""%d"", &k);

    int returnSize;
    int* result = maxSlidingWindow(nums, n, k, &returnSize);

    for (int i = 0; i < returnSize; i++) {
        printf(""%d%s"", result[i], (i == returnSize - 1) ? """" : "" "");
    }
    printf(""\n"");

    free(nums);
    free(result);

    return 0;
}","import collections
import sys

class Solution:
    def maxSlidingWindow(self, nums: list[int], k: int) -> list[int]:
        dq = collections.deque()  # Stores indices of elements
        result = []

        for i in range(len(nums)):
            # Remove elements from the front that are out of the current window
            if dq and dq[0] == i - k:
                dq.popleft()

            # Remove elements from the back that are smaller than or equal to the current element
            # This maintains the monotonic decreasing property of elements' values in the deque
            while dq and nums[dq[-1]] <= nums[i]:
                dq.pop()

            # Add current element's index to the back of the deque
            dq.append(i)

            # If the window has formed (i.e., i + 1 >= k), the front of the deque holds the maximum
            if i >= k - 1:
                result.append(nums[dq[0]])
        
        return result

if __name__ == '__main__':
    input_lines = sys.stdin.readlines()
    
    # Read N
    n = int(input_lines[0].strip())
    
    # Read nums array
    nums = list(map(int, input_lines[1].strip().split()))
    
    # Read K
    k = int(input_lines[2].strip())

    sol = Solution()
    result = sol.maxSlidingWindow(nums, k)

    print(*result)","import java.util.ArrayDeque;
import java.util.Deque;
import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

class Solution {
    public int[] maxSlidingWindow(int[] nums, int k) {
        Deque<Integer> dq = new ArrayDeque<>(); // Stores indices of elements
        List<Integer> resultList = new ArrayList<>();

        for (int i = 0; i < nums.length; i++) {
            // Remove elements from the front that are out of the current window
            if (!dq.isEmpty() && dq.peekFirst() <= i - k) {
                dq.removeFirst();
            }

            // Remove elements from the back that are smaller than or equal to the current element
            // This maintains the monotonic decreasing property of elements' values in the deque
            while (!dq.isEmpty() && nums[dq.peekLast()] <= nums[i]) {
                dq.removeLast();
            }

            // Add current element's index to the back of the deque
            dq.addLast(i);

            // If the window has formed (i.e., i+1 >= k), the front of the deque holds the maximum
            if (i >= k - 1) {
                resultList.add(nums[dq.peekFirst()]);
            }
        }

        // Convert List<Integer> to int[]
        int[] result = new int[resultList.size()];
        for (int i = 0; i < resultList.size(); i++) {
            result[i] = resultList.get(i);
        }
        return result;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }

        int k = scanner.nextInt();

        Solution sol = new Solution();
        int[] result = sol.maxSlidingWindow(nums, k);

        for (int i = 0; i < result.length; i++) {
            System.out.print(result[i] + (i == result.length - 1 ? """" : "" ""));
        }
        System.out.println();

        scanner.close();
    }
}","class Solution {
    /**
     * @param {number[]} nums
     * @param {number} k
     * @return {number[]}
     */
    maxSlidingWindow(nums, k) {
        const dq = []; // Stores indices of elements
        const result = [];

        for (let i = 0; i < nums.length; i++) {
            // Remove elements from the front that are out of the current window
            if (dq.length > 0 && dq[0] === i - k) {
                dq.shift();
            }

            // Remove elements from the back that are smaller than or equal to the current element
            // This maintains the monotonic decreasing property of elements' values in the deque
            while (dq.length > 0 && nums[dq[dq.length - 1]] <= nums[i]) {
                dq.pop();
            }

            // Add current element's index to the back of the deque
            dq.push(i);

            // If the window has formed (i.e., i + 1 >= k), the front of the deque holds the maximum
            if (i >= k - 1) {
                result.push(nums[dq[0]]);
            }
        }

        return result;
    }
}

// Main function to handle input/output
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let input = [];
    rl.on('line', (line) => {
        input.push(line);
    }).on('close', () => {
        const n = parseInt(input[0], 10);
        const nums = input[1].split(' ').map(Number);
        const k = parseInt(input[2], 10);

        const sol = new Solution();
        const result = sol.maxSlidingWindow(nums, k);

        console.log(result.join(' '));
    });
}

main();","#include <iostream>
#include <vector>
#include <deque>
#include <algorithm>

class Solution {
public:
    std::vector<int> maxSlidingWindow(std::vector<int>& nums, int k) {
        std::deque<int> dq; // Stores indices of elements
        std::vector<int> result;

        for (int i = 0; i < nums.size(); ++i) {
            // Remove elements from the front that are out of the current window
            if (!dq.empty() && dq.front() == i - k) {
                dq.pop_front();
            }

            // Remove elements from the back that are smaller than or equal to the current element
            // This maintains the monotonic decreasing property of elements' values in the deque
            while (!dq.empty() && nums[dq.back()] <= nums[i]) {
                dq.pop_back();
            }

            // Add current element's index to the back of the deque
            dq.push_back(i);

            // If the window has formed (i.e., i+1 >= k), the front of the deque holds the maximum
            if (i >= k - 1) {
                result.push_back(nums[dq.front()]);
            }
        }

        return result;
    }
};

int main() {
    int n;
    std::cin >> n;
    std::vector<int> nums(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> nums[i];
    }
    int k;
    std::cin >> k;

    Solution sol;
    std::vector<int> result = sol.maxSlidingWindow(nums, k);

    for (int i = 0; i < result.size(); ++i) {
        std::cout << result[i] << (i == result.size() - 1 ? """" : "" "");
    }
    std::cout << std::endl;

    return 0;
}",3.6
Orange-7,Heap Sort,"*   Heap Data Structure (Max-Heap)
*   Heapify (Sift-down)
*   Array Representation of Binary Tree
*   In-place Sorting
*   Comparison Sorts","Heap Sort is a comparison-based sorting algorithm that uses a binary heap data structure. It's an in-place algorithm, but not a stable sort. The algorithm works by first building a max-heap from the input array. Once the heap is built, the largest element (which is at the root of the max-heap) is swapped with the last element of the heap. The heap size is then reduced by one, and the new root is heapified to restore the max-heap property. This process is repeated until the heap size becomes one, resulting in a sorted array.

Your task is to implement the Heap Sort algorithm to sort an array of integers in ascending order.","* The input array `nums` will contain between 0 and 10^5 elements (inclusive).
* Each element `nums[i]` will be an integer between -10^9 and 10^9 (inclusive).","`[4, 1, 3, 2, 16, 9, 10, 14, 8, 7]`","`[1, 2, 3, 4, 7, 8, 9, 10, 14, 16]`","Input: 1
5
Output: 5
Input: 5
1 2 3 4 5
Output: 1 2 3 4 5
Input: 5
5 4 3 2 1
Output: 1 2 3 4 5
Input: 6
-10 5 0 -2 8 5
Output: -10 -2 0 5 5 8
Input: 0

Output: ","#include <stdio.h>
#include <stdlib.h>

// Function to swap two integers
void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// Function to heapify a subtree rooted with node i which is an index in arr[]
// n is size of heap
void heapify(int arr[], int n, int i) {
    int largest = i;       // Initialize largest as root
    int left = 2 * i + 1;  // Left child
    int right = 2 * i + 2; // Right child

    // If left child is larger than root
    if (left < n && arr[left] > arr[largest])
        largest = left;

    // If right child is larger than largest so far
    if (right < n && arr[right] > arr[largest])
        largest = right;

    // If largest is not root
    if (largest != i) {
        swap(&arr[i], &arr[largest]);

        // Recursively heapify the affected sub-tree
        heapify(arr, n, largest);
    }
}

// Main function to do heap sort
void heapSort(int arr[], int n) {
    // Build heap (rearrange array)
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);

    // One by one extract an element from heap
    for (int i = n - 1; i > 0; i--) {
        // Move current root to end
        swap(&arr[0], &arr[i]);

        // Call max heapify on the reduced heap
        heapify(arr, i, 0);
    }
}

// Function to print an array
void printArray(int arr[], int n) {
    for (int i = 0; i < n; ++i)
        printf(""%d%s"", arr[i], (i == n - 1 ? """" : "" ""));
    printf(""\n"");
}

int main() {
    int n;
    // Read the number of elements
    if (scanf(""%d"", &n) != 1) return 1;

    // Handle empty array case
    if (n == 0) {
        printf(""\n"");
        return 0;
    }

    // Allocate memory for the array
    int *arr = (int *)malloc(n * sizeof(int));
    if (arr == NULL) return 1; // Memory allocation failed

    // Read array elements
    for (int i = 0; i < n; i++) {
        if (scanf(""%d"", &arr[i]) != 1) {
            free(arr);
            return 1;
        }
    }

    heapSort(arr, n);

    printArray(arr, n);

    free(arr);
    return 0;
}","def heapify(arr, n, i):
    largest = i  # Initialize largest as root
    left = 2 * i + 1  # Left child
    right = 2 * i + 2  # Right child

    # If left child is larger than root
    if left < n and arr[left] > arr[largest]:
        largest = left

    # If right child is larger than largest so far
    if right < n and arr[right] > arr[largest]:
        largest = right

    # If largest is not root
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # Swap

        # Recursively heapify the affected sub-tree
        heapify(arr, n, largest)

def heapSort(arr):
    n = len(arr)

    # Build max-heap
    # We start from the last non-leaf node and go up to the root
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # One by one extract elements
    for i in range(n - 1, 0, -1):
        # Move current root to end
        arr[i], arr[0] = arr[0], arr[i]  # Swap
        # Call max heapify on the reduced heap
        heapify(arr, i, 0)

if __name__ == '__main__':
    # Read the number of elements
    n = int(input())

    # Handle empty array case
    if n == 0:
        print()
    else:
        # Read array elements
        nums = list(map(int, input().split()))

        heapSort(nums)

        # Print the sorted array
        print(*nums)","import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

public class Solution {

    // Function to heapify a subtree rooted with node i which is an index in arr[]
    // n is size of heap
    static void heapify(int arr[], int n, int i) {
        int largest = i;       // Initialize largest as root
        int left = 2 * i + 1;  // Left child
        int right = 2 * i + 2; // Right child

        // If left child is larger than root
        if (left < n && arr[left] > arr[largest])
            largest = left;

        // If right child is larger than largest so far
        if (right < n && arr[right] > arr[largest])
            largest = right;

        // If largest is not root
        if (largest != i) {
            int swap = arr[i];
            arr[i] = arr[largest];
            arr[largest] = swap;

            // Recursively heapify the affected sub-tree
            heapify(arr, n, largest);
        }
    }

    // Main function to do heap sort
    public static void heapSort(int arr[]) {
        int n = arr.length;

        // Build heap (rearrange array)
        for (int i = n / 2 - 1; i >= 0; i--)
            heapify(arr, n, i);

        // One by one extract an element from heap
        for (int i = n - 1; i > 0; i--) {
            // Move current root to end
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;

            // Call max heapify on the reduced heap
            heapify(arr, i, 0);
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the number of elements
        int n = scanner.nextInt();

        // Handle empty array case
        if (n == 0) {
            System.out.println();
            scanner.close();
            return;
        }

        int[] arr = new int[n];
        // Read array elements
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        heapSort(arr);

        for (int i = 0; i < n; ++i) {
            System.out.print(arr[i] + (i == n - 1 ? """" : "" ""));
        }
        System.out.println();

        scanner.close();
    }
}","function swap(arr, i, j) {
    [arr[i], arr[j]] = [arr[j], arr[i]];
}

// Function to heapify a subtree rooted with node i which is an index in arr[]
// n is size of heap
function heapify(arr, n, i) {
    let largest = i;       // Initialize largest as root
    let left = 2 * i + 1;  // Left child
    let right = 2 * i + 2; // Right child

    // If left child is larger than root
    if (left < n && arr[left] > arr[largest])
        largest = left;

    // If right child is larger than largest so far
    if (right < n && arr[right] > arr[largest])
        largest = right;

    // If largest is not root
    if (largest !== i) {
        swap(arr, i, largest);

        // Recursively heapify the affected sub-tree
        heapify(arr, n, largest);
    }
}

// Main function to do heap sort
function heapSort(arr) {
    let n = arr.length;

    // Build heap (rearrange array)
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--)
        heapify(arr, n, i);

    // One by one extract an element from heap
    for (let i = n - 1; i > 0; i--) {
        // Move current root to end
        swap(arr, 0, i);

        // Call max heapify on the reduced heap
        heapify(arr, i, 0);
    }
    return arr;
}

// Standard input/output for competitive programming environments
let input = '';
process.stdin.on('data', data => {
    input += data;
});

process.stdin.on('end', () => {
    const lines = input.trim().split('\n');
    const n = parseInt(lines[0]);

    if (n === 0) {
        console.log('');
        return;
    }

    const nums = lines[1].split(' ').map(Number);

    const sortedNums = heapSort(nums);

    console.log(sortedNums.join(' '));
});","#include <iostream>
#include <vector>
#include <algorithm>

// Function to heapify a subtree rooted with node i which is an index in arr[]
// n is size of heap
void heapify(std::vector<int>& arr, int n, int i) {
    int largest = i;       // Initialize largest as root
    int left = 2 * i + 1;  // Left child
    int right = 2 * i + 2; // Right child

    // If left child is larger than root
    if (left < n && arr[left] > arr[largest])
        largest = left;

    // If right child is larger than largest so far
    if (right < n && arr[right] > arr[largest])
        largest = right;

    // If largest is not root
    if (largest != i) {
        std::swap(arr[i], arr[largest]);

        // Recursively heapify the affected sub-tree
        heapify(arr, n, largest);
    }
}

// Main function to do heap sort
void heapSort(std::vector<int>& arr) {
    int n = arr.size();

    // Build heap (rearrange array)
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);

    // One by one extract an element from heap
    for (int i = n - 1; i > 0; i--) {
        // Move current root to end
        std::swap(arr[0], arr[i]);

        // Call max heapify on the reduced heap
        heapify(arr, i, 0);
    }
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    // Handle empty array case
    if (n == 0) {
        std::cout << ""\n"";
        return 0;
    }

    std::vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        std::cin >> arr[i];
    }

    heapSort(arr);

    for (int i = 0; i < n; ++i) {
        std::cout << arr[i] << (i == n - 1 ? """" : "" "");
    }
    std::cout << ""\n"";

    return 0;
}",4.2
Orange-8,Quick Sort,"*   Quick Sort Algorithm
*   Partitioning
*   Recursion
*   Divide and Conquer","You are given an array of integers. Your task is to sort this array in ascending order using the Quick Sort algorithm.

Quick Sort is a highly efficient, comparison-based sorting algorithm. It works on the principle of divide and conquer. The main idea is to pick an element as a pivot and partition the given array around the picked pivot.","*   1 <= N <= 10^5 (where N is the number of elements in the array)
*   -10^9 <= arr[i] <= 10^9
*   The array may contain duplicate elements.","**
5
3 1 4 1 5

**","**
1 1 3 4 5","Input: 5
1 2 3 4 5
Output: 1 2 3 4 5
Input: 5
5 4 3 2 1
Output: 1 2 3 4 5
Input: 6
-5 0 -2 0 5 1
Output: -5 -2 0 0 1 5
Input: 1
42
Output: 42
Input: 2
8 2
Output: 2 8","#include <stdio.h>
#include <stdlib.h> // For swap

// A utility function to swap two elements
void swap(int* a, int* b) {
    int t = *a;
    *a = *b;
    *b = t;
}

/* This function takes last element as pivot, places
   the pivot element at its correct position in sorted
   array, and places all smaller (smaller than pivot)
   to left of pivot and all greater elements to right
   of pivot */
int partition(int arr[], int low, int high) {
    int pivot = arr[high]; // pivot
    int i = (low - 1);     // Index of smaller element

    for (int j = low; j <= high - 1; j++) {
        // If current element is smaller than or equal to pivot
        if (arr[j] <= pivot) {
            i++; // increment index of smaller element
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

/* The main function that implements QuickSort
  arr[] --> Array to be sorted,
  low  --> Starting index,
  high --> Ending index */
void quickSort(int arr[], int low, int high) {
    if (low < high) {
        /* pi is partitioning index, arr[p] is now
           at right place */
        int pi = partition(arr, low, high);

        // Separately sort elements before
        // partition and after partition
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int main() {
    int N;
    scanf(""%d"", &N);

    int *arr = (int *)malloc(N * sizeof(int));
    if (arr == NULL) {
        return 1; // Memory allocation failed
    }

    for (int i = 0; i < N; i++) {
        scanf(""%d"", &arr[i]);
    }

    quickSort(arr, 0, N - 1);

    for (int i = 0; i < N; i++) {
        printf(""%d%c"", arr[i], (i == N - 1 ? '\n' : ' '));
    }

    free(arr); // Free dynamically allocated memory
    return 0;
}","def swap(arr, i, j):
    arr[i], arr[j] = arr[j], arr[i]

def partition(arr, low, high):
    pivot = arr[high]  # pivot
    i = (low - 1)      # Index of smaller element

    for j in range(low, high):
        # If current element is smaller than or equal to pivot
        if arr[j] <= pivot:
            i += 1  # increment index of smaller element
            swap(arr, i, j)
    swap(arr, i + 1, high)
    return (i + 1)

def quick_sort(arr, low, high):
    if low < high:
        # pi is partitioning index, arr[pi] is now at right place
        pi = partition(arr, low, high)

        # Separately sort elements before partition and after partition
        quick_sort(arr, low, pi - 1)
        quick_sort(arr, pi + 1, high)

if __name__ == '__main__':
    N = int(input())
    arr = list(map(int, input().split()))

    quick_sort(arr, 0, N - 1)

    print(*(arr))","import java.util.Scanner;
import java.util.Arrays;

public class Main {

    // A utility function to swap two elements
    static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    /* This function takes last element as pivot, places
       the pivot element at its correct position in sorted
       array, and places all smaller (smaller than pivot)
       to left of pivot and all greater elements to right
       of pivot */
    static int partition(int[] arr, int low, int high) {
        int pivot = arr[high]; // pivot
        int i = (low - 1);     // Index of smaller element

        for (int j = low; j <= high - 1; j++) {
            // If current element is smaller than or equal to pivot
            if (arr[j] <= pivot) {
                i++; // increment index of smaller element
                swap(arr, i, j);
            }
        }
        swap(arr, i + 1, high);
        return (i + 1);
    }

    /* The main function that implements QuickSort
      arr[] --> Array to be sorted,
      low  --> Starting index,
      high --> Ending index */
    static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            /* pi is partitioning index, arr[p] is now
               at right place */
            int pi = partition(arr, low, high);

            // Separately sort elements before
            // partition and after partition
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int N = scanner.nextInt();
        int[] arr = new int[N];
        for (int i = 0; i < N; i++) {
            arr[i] = scanner.nextInt();
        }

        quickSort(arr, 0, N - 1);

        for (int i = 0; i < N; i++) {
            System.out.print(arr[i] + (i == N - 1 ? """" : "" ""));
        }
        System.out.println();

        scanner.close();
    }
}","function swap(arr, i, j) {
    let temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

/* This function takes last element as pivot, places
   the pivot element at its correct position in sorted
   array, and places all smaller (smaller than pivot)
   to left of pivot and all greater elements to right
   of pivot */
function partition(arr, low, high) {
    let pivot = arr[high]; // pivot
    let i = (low - 1);     // Index of smaller element

    for (let j = low; j <= high - 1; j++) {
        // If current element is smaller than or equal to pivot
        if (arr[j] <= pivot) {
            i++; // increment index of smaller element
            swap(arr, i, j);
        }
    }
    swap(arr, i + 1, high);
    return (i + 1);
}

/* The main function that implements QuickSort
  arr[] --> Array to be sorted,
  low  --> Starting index,
  high --> Ending index */
function quickSort(arr, low, high) {
    if (low < high) {
        /* pi is partitioning index, arr[p] is now
           at right place */
        let pi = partition(arr, low, high);

        // Separately sort elements before
        // partition and after partition
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

// Main part for reading input and printing output
let input = '';
process.stdin.on('data', chunk => {
    input += chunk;
});

process.stdin.on('end', () => {
    const lines = input.trim().split('\n');
    const N = parseInt(lines[0]);
    const arr = lines[1].split(' ').map(Number);

    quickSort(arr, 0, N - 1);

    process.stdout.write(arr.join(' ') + '\n');
});","#include <iostream>
#include <vector>
#include <algorithm> // For std::swap

// Function to swap two elements
void swap(int& a, int& b) {
    int temp = a;
    a = b;
    b = temp;
}

// This function takes last element as pivot, places
// the pivot element at its correct position in sorted
// array, and places all smaller (smaller than pivot)
// to left of pivot and all greater elements to right
// of pivot
int partition(std::vector<int>& arr, int low, int high) {
    int pivot = arr[high]; // pivot
    int i = (low - 1);     // Index of smaller element

    for (int j = low; j <= high - 1; j++) {
        // If current element is smaller than or equal to pivot
        if (arr[j] <= pivot) {
            i++; // increment index of smaller element
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return (i + 1);
}

// The main function that implements QuickSort
// arr[] --> Array to be sorted,
// low  --> Starting index,
// high --> Ending index
void quickSort(std::vector<int>& arr, int low, int high) {
    if (low < high) {
        // pi is partitioning index, arr[p] is now
        // at right place
        int pi = partition(arr, low, high);

        // Separately sort elements before
        // partition and after partition
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int N;
    std::cin >> N;

    std::vector<int> arr(N);
    for (int i = 0; i < N; i++) {
        std::cin >> arr[i];
    }

    quickSort(arr, 0, N - 1);

    for (int i = 0; i < N; i++) {
        std::cout << arr[i] << (i == N - 1 ? """" : "" "");
    }
    std::cout << std::endl;

    return 0;
}",3.6
Orange-9,Heap Sort,"- Binary Heap (specifically Max-Heap)
- Heapify operation
- Building a Heap from an array
- In-place sorting
- Tree data structure properties represented in an array","Heap Sort is an efficient, comparison-based sorting algorithm that leverages the Binary Heap data structure. It's an in-place sorting algorithm, meaning it doesn't require extra memory beyond a trivial amount for sorting. The core idea is to first transform the input array into a Max-Heap (where each parent node is greater than or equal to its children). Once the array is a Max-Heap, the largest element is at the root. We then swap this largest element with the last element of the array, effectively moving the largest element to its sorted position. The heap size is reduced, and the remaining elements are re-heapified to maintain the Max-Heap property. This process is repeated until the entire array is sorted.","- The input array will contain integers.
- The number of elements (N) in the array will be between 1 and 10^5.
- Each element's value will be between -10^9 and 10^9.
- The sorting should be done in ascending order.
- Expected time complexity: O(N log N)
- Expected auxiliary space complexity: O(1)","[4, 10, 3, 5, 1]","[1, 3, 4, 5, 10]","Input: 5
4 10 3 5 1
Output: 1 3 4 5 10,Input: 5
1 2 3 4 5
Output: 1 2 3 4 5,Input: 5
5 4 3 2 1
Output: 1 2 3 4 5,Input: 6
7 -2 1 0 5 -8
Output: -8 -2 0 1 5 7,Input: 1
9
Output: 9","#include <stdio.h>
#include <stdlib.h>

// Function to swap two elements
void swap(int* a, int* b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

// To heapify a subtree rooted with node i which is
// an index in arr[]. n is size of heap
void heapify(int arr[], int n, int i) {
    int largest = i;       // Initialize largest as root
    int left = 2 * i + 1;  // left child
    int right = 2 * i + 2; // right child

    // If left child is larger than root
    if (left < n && arr[left] > arr[largest])
        largest = left;

    // If right child is larger than largest so far
    if (right < n && arr[right] > arr[largest])
        largest = right;

    // If largest is not root
    if (largest != i) {
        swap(&arr[i], &arr[largest]);

        // Recursively heapify the affected sub-tree
        heapify(arr, n, largest);
    }
}

// Main function to do heap sort
void heapSort(int arr[], int n) {
    // Build heap (rearrange array)
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);

    // One by one extract an element from heap
    for (int i = n - 1; i > 0; i--) {
        // Move current root to end
        swap(&arr[0], &arr[i]);

        // call max heapify on the reduced heap
        heapify(arr, i, 0);
    }
}

// Function to print an array
void printArray(int arr[], int n) {
    for (int i = 0; i < n; ++i)
        printf(""%d%s"", arr[i], (i == n - 1) ? """" : "" "");
    printf(""\n"");
}

int main() {
    int n;
    scanf(""%d"", &n);

    int* arr = (int*)malloc(n * sizeof(int));
    if (arr == NULL) {
        return 1; // Memory allocation failed
    }

    for (int i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]);
    }

    heapSort(arr, n);
    printArray(arr, n);

    free(arr);
    return 0;
}","def heapify(arr, n, i):
    largest = i  # Initialize largest as root
    left = 2 * i + 1  # left child
    right = 2 * i + 2  # right child

    # If left child exists and is greater than root
    if left < n and arr[left] > arr[largest]:
        largest = left

    # If right child exists and is greater than largest so far
    if right < n and arr[right] > arr[largest]:
        largest = right

    # If largest is not root
    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # swap

        # Recursively heapify the affected sub-tree
        heapify(arr, n, largest)

def heap_sort(arr):
    n = len(arr)

    # Build a maxheap.
    # We start from the last non-leaf node and go up to the root
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    # One by one extract elements
    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # swap current root with last element
        heapify(arr, i, 0)  # call max heapify on the reduced heap

if __name__ == '__main__':
    n = int(input())
    arr = list(map(int, input().split()))

    heap_sort(arr)

    print(*arr)","import java.util.Scanner;
import java.util.ArrayList;

class Solution {

    // Function to heapify a subtree rooted with node i which is
    // an index in arr. n is size of heap
    void heapify(ArrayList<Integer> arr, int n, int i) {
        int largest = i;       // Initialize largest as root
        int left = 2 * i + 1;  // left child
        int right = 2 * i + 2; // right child

        // If left child is larger than root
        if (left < n && arr.get(left) > arr.get(largest))
            largest = left;

        // If right child is larger than largest so far
        if (right < n && arr.get(right) > arr.get(largest))
            largest = right;

        // If largest is not root
        if (largest != i) {
            // Swap elements
            int temp = arr.get(i);
            arr.set(i, arr.get(largest));
            arr.set(largest, temp);

            // Recursively heapify the affected sub-tree
            heapify(arr, n, largest);
        }
    }

    // Main function to do heap sort
    void heapSort(ArrayList<Integer> arr) {
        int n = arr.size();

        // Build heap (rearrange array)
        // Start from the last non-leaf node and go up to the root
        for (int i = n / 2 - 1; i >= 0; i--)
            heapify(arr, n, i);

        // One by one extract an element from heap
        for (int i = n - 1; i > 0; i--) {
            // Move current root to end
            int temp = arr.get(0);
            arr.set(0, arr.get(i));
            arr.set(i, temp);

            // call max heapify on the reduced heap
            heapify(arr, i, 0);
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        ArrayList<Integer> arr = new ArrayList<>(n);
        for (int i = 0; i < n; i++) {
            arr.add(scanner.nextInt());
        }

        Solution sorter = new Solution();
        sorter.heapSort(arr);

        for (int i = 0; i < n; i++) {
            System.out.print(arr.get(i) + (i == n - 1 ? """" : "" ""));
        }
        System.out.println();

        scanner.close();
    }
}","function swap(arr, i, j) {
    let temp = arr[i];
    arr[i] = arr[j];
    arr[j] = temp;
}

// Function to heapify a subtree rooted with node i which is
// an index in arr. n is size of heap
function heapify(arr, n, i) {
    let largest = i;       // Initialize largest as root
    let left = 2 * i + 1;  // left child
    let right = 2 * i + 2; // right child

    // If left child is larger than root
    if (left < n && arr[left] > arr[largest])
        largest = left;

    // If right child is larger than largest so far
    if (right < n && arr[right] > arr[largest])
        largest = right;

    // If largest is not root
    if (largest !== i) {
        swap(arr, i, largest);

        // Recursively heapify the affected sub-tree
        heapify(arr, n, largest);
    }
}

// Main function to do heap sort
function heapSort(arr) {
    let n = arr.length;

    // Build heap (rearrange array)
    // Start from the last non-leaf node and go up to the root
    for (let i = Math.floor(n / 2) - 1; i >= 0; i--)
        heapify(arr, n, i);

    // One by one extract an element from heap
    for (let i = n - 1; i > 0; i--) {
        // Move current root to end
        swap(arr, 0, i);

        // call max heapify on the reduced heap
        heapify(arr, i, 0);
    }
    return arr;
}

// Main execution for input/output
(function() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let inputLines = [];
    rl.on('line', (line) => {
        inputLines.push(line);
    });

    rl.on('close', () => {
        const n = parseInt(inputLines[0]);
        const arr = inputLines[1].split(' ').map(Number);

        heapSort(arr);

        console.log(arr.join(' '));
    });
})();","#include <iostream>
#include <vector>
#include <algorithm> // For std::swap

// Function to heapify a subtree rooted with node i which is
// an index in arr. n is size of heap
void heapify(std::vector<int>& arr, int n, int i) {
    int largest = i;       // Initialize largest as root
    int left = 2 * i + 1;  // left child
    int right = 2 * i + 2; // right child

    // If left child is larger than root
    if (left < n && arr[left] > arr[largest])
        largest = left;

    // If right child is larger than largest so far
    if (right < n && arr[right] > arr[largest])
        largest = right;

    // If largest is not root
    if (largest != i) {
        std::swap(arr[i], arr[largest]);

        // Recursively heapify the affected sub-tree
        heapify(arr, n, largest);
    }
}

// Main function to do heap sort
void heapSort(std::vector<int>& arr, int n) {
    // Build heap (rearrange array)
    // Start from the last non-leaf node and go up to the root
    for (int i = n / 2 - 1; i >= 0; i--)
        heapify(arr, n, i);

    // One by one extract an element from heap
    for (int i = n - 1; i > 0; i--) {
        // Move current root to end
        std::swap(arr[0], arr[i]);

        // call max heapify on the reduced heap
        heapify(arr, i, 0);
    }
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    std::vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i];
    }

    heapSort(arr, n);

    for (int i = 0; i < n; ++i) {
        std::cout << arr[i] << (i == n - 1 ? """" : "" "");
    }
    std::cout << std::endl;

    return 0;
}",3.6
Orange-10,"Binary Search on Answer (Aggressive Cows, Book Allocation)",,,,,,"[object Object],[object Object],[object Object],[object Object]","#include <stdio.h>
#include <stdlib.h>

int canPlaceCows(long long *stalls, int n, int k, long long minDist) {
    int cowsPlaced = 1;
    long long lastCowPos = stalls[0];
    for (int i = 1; i < n; i++) {
        if (stalls[i] - lastCowPos >= minDist) {
            cowsPlaced++;
            lastCowPos = stalls[i];
        }
    }
    return cowsPlaced >= k;
}

long long solve(long long *stalls, int n, int k) {
    long long left = 1, right = stalls[n - 1] - stalls[0];
    long long ans = 0;
    while (left <= right) {
        long long mid = left + (right - left) / 2;
        if (canPlaceCows(stalls, n, k, mid)) {
            ans = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return ans;
}

int main() {
    int n, k;
    scanf(""%d %d"", &n, &k);
    long long *stalls = (long long *)malloc(sizeof(long long) * n);
    for (int i = 0; i < n; i++) {
        scanf(""%lld"", &stalls[i]);
    }
    qsort(stalls, n, sizeof(long long), [](const void *a, const void *b) { 
        return *(long long *)a - *(long long *)b; 
    });
    printf(""%lld\n"", solve(stalls, n, k));
    free(stalls);
    return 0;
}","def canPlaceCows(stalls, n, k, minDist):
    cowsPlaced = 1
    lastCowPos = stalls[0]
    for i in range(1, n):
        if stalls[i] - lastCowPos >= minDist:
            cowsPlaced += 1
            lastCowPos = stalls[i]
    return cowsPlaced >= k

def solve(stalls, n, k):
    left = 1
    right = stalls[-1] - stalls[0]
    ans = 0
    while left <= right:
        mid = left + (right - left) // 2
        if canPlaceCows(stalls, n, k, mid):
            ans = mid
            left = mid + 1
        else:
            right = mid - 1
    return ans

if __name__ == ""__main__"":
    n, k = map(int, input().split())
    stalls = list(map(int, input().split()))
    stalls.sort()
    print(solve(stalls, n, k))","import java.util.*;

public class AggressiveCows {

    public static boolean canPlaceCows(long[] stalls, int n, int k, long minDist) {
        int cowsPlaced = 1;
        long lastCowPos = stalls[0];
        for (int i = 1; i < n; i++) {
            if (stalls[i] - lastCowPos >= minDist) {
                cowsPlaced++;
                lastCowPos = stalls[i];
            }
        }
        return cowsPlaced >= k;
    }

    public static long solve(long[] stalls, int n, int k) {
        long left = 1, right = stalls[n - 1] - stalls[0];
        long ans = 0;
        while (left <= right) {
            long mid = left + (right - left) / 2;
            if (canPlaceCows(stalls, n, k, mid)) {
                ans = mid;
                left = mid + 1;
            } else {
                right = mid - 1;
            }
        }
        return ans;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int k = sc.nextInt();
        long[] stalls = new long[n];
        for (int i = 0; i < n; i++) {
            stalls[i] = sc.nextLong();
        }
        Arrays.sort(stalls);
        System.out.println(solve(stalls, n, k));
        sc.close();
    }
}","function canPlaceCows(stalls, n, k, minDist) {
    let cowsPlaced = 1;
    let lastCowPos = stalls[0];
    for (let i = 1; i < n; i++) {
        if (stalls[i] - lastCowPos >= minDist) {
            cowsPlaced++;
            lastCowPos = stalls[i];
        }
    }
    return cowsPlaced >= k;
}

function solve(stalls, n, k) {
    let left = 1, right = stalls[n - 1] - stalls[0];
    let ans = 0;
    while (left <= right) {
        let mid = Math.floor(left + (right - left) / 2);
        if (canPlaceCows(stalls, n, k, mid)) {
            ans = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return ans;
}

const readline = require('readline').createInterface({
    input: process.stdin,
    output: process.stdout,
});

readline.on('line', (line) => {
    const [n, k] = line.split(' ').map(Number);
    readline.once('line', (line) => {
        const stalls = line.split(' ').map(Number);
        stalls.sort((a, b) => a - b);
        console.log(solve(stalls, n, k));
        readline.close();
    });
});","#include <iostream>
#include <algorithm>

using namespace std;

bool canPlaceCows(long long stalls[], int n, int k, long long minDist) {
    int cowsPlaced = 1;
    long long lastCowPos = stalls[0];
    for (int i = 1; i < n; i++) {
        if (stalls[i] - lastCowPos >= minDist) {
            cowsPlaced++;
            lastCowPos = stalls[i];
        }
    }
    return cowsPlaced >= k;
}

long long solve(long long stalls[], int n, int k) {
    long long left = 1, right = stalls[n - 1] - stalls[0];
    long long ans = 0;
    while (left <= right) {
        long long mid = left + (right - left) / 2;
        if (canPlaceCows(stalls, n, k, mid)) {
            ans = mid;
            left = mid + 1;
        } else {
            right = mid - 1;
        }
    }
    return ans;
}

int main() {
    int n, k;
    cin >> n >> k;
    long long stalls[n];
    for (int i = 0; i < n; i++) {
        cin >> stalls[i];
    }
    sort(stalls, stalls + n);
    cout << solve(stalls, n, k) << endl;
    return 0;
}",2.9
Orange-11,Next Greater/Smaller Element (Monotonic Stack),,,,,,"[object Object],[object Object],[object Object],[object Object],[object Object]","#include <stdio.h>
#include <stdlib.h>

int* nextGreaterElement(int* nums, int numsSize, int* returnSize) {
    int* result = (int*)malloc(numsSize * sizeof(int));
    *returnSize = numsSize;
    int stack[numsSize];
    int top = -1;

    for (int i = numsSize - 1; i >= 0; i--) {
        while (top >= 0 && nums[i] >= nums[stack[top]]) {
            top--;
        }
        result[i] = (top == -1) ? -1 : nums[stack[top]];
        stack[++top] = i;
    }
    return result;
}

int main() {
    int nums[] = {2, 1, 5, 6, 2, 3};
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    int returnSize;
    int* result = nextGreaterElement(nums, numsSize, &returnSize);
    for (int i = 0; i < returnSize; i++) {
        printf(""%d "", result[i]);
    }
    printf(""\n"");
    free(result);
    return 0;
}","def next_greater_element(nums):
    result = [-1] * len(nums)
    stack = []
    for i in range(len(nums) - 1, -1, -1):
        while stack and nums[i] >= stack[-1]:
            stack.pop()
        result[i] = stack[-1] if stack else -1
        stack.append(nums[i])
    return result

nums = [2, 1, 5, 6, 2, 3]
result = next_greater_element(nums)
print(result)","import java.util.Arrays;
import java.util.Stack;

public class NextGreaterElement {
    public int[] nextGreaterElement(int[] nums) {
        int[] result = new int[nums.length];
        Stack<Integer> stack = new Stack<>();
        for (int i = nums.length - 1; i >= 0; i--) {
            while (!stack.isEmpty() && nums[i] >= stack.peek()) {
                stack.pop();
            }
            result[i] = stack.isEmpty() ? -1 : stack.peek();
            stack.push(nums[i]);
        }
        return result;
    }

    public static void main(String[] args) {
        NextGreaterElement solution = new NextGreaterElement();
        int[] nums = {2, 1, 5, 6, 2, 3};
        int[] result = solution.nextGreaterElement(nums);
        System.out.println(Arrays.toString(result));
    }
}","function nextGreaterElement(nums) {
    const result = new Array(nums.length).fill(-1);
    const stack = [];
    for (let i = nums.length - 1; i >= 0; i--) {
        while (stack.length > 0 && nums[i] >= stack[stack.length - 1]) {
            stack.pop();
        }
        result[i] = stack.length === 0 ? -1 : stack[stack.length - 1];
        stack.push(nums[i]);
    }
    return result;
}

const nums = [2, 1, 5, 6, 2, 3];
const result = nextGreaterElement(nums);
console.log(result);","#include <iostream>
#include <vector>
#include <stack>

std::vector<int> nextGreaterElement(std::vector<int>& nums) {
    std::vector<int> result(nums.size());
    std::stack<int> s;
    for (int i = nums.size() - 1; i >= 0; --i) {
        while (!s.empty() && nums[i] >= s.top()) {
            s.pop();
        }
        result[i] = s.empty() ? -1 : s.top();
        s.push(nums[i]);
    }
    return result;
}

int main() {
    std::vector<int> nums = {2, 1, 5, 6, 2, 3};
    std::vector<int> result = nextGreaterElement(nums);
    for (int i = 0; i < result.size(); ++i) {
        std::cout << result[i] << "" "";
    }
    std::cout << std::endl;
    return 0;
}",1
Orange-12,Rat in a Maze,,,,,,"[object Object],[object Object],[object Object],[object Object]","#include <stdio.h>
#include <stdlib.h>

#define N 100

int maze[N][N];
int visited[N][N];
int path[N*N][2];
int path_len = 0;
int n;

int solve_maze(int row, int col){
    if(row < 0 || row >= n || col < 0 || col >= n || maze[row][col] == 0 || visited[row][col]) return 0;
    visited[row][col] = 1;
    path[path_len][0] = row;
    path[path_len][1] = col;
    path_len++;
    if(row == n-1 && col == n-1) return 1; 
    if(solve_maze(row+1, col) || solve_maze(row-1, col) || solve_maze(row, col+1) || solve_maze(row, col-1)) return 1; 
    path_len--;
    visited[row][col] = 0;
    return 0;
}

int main() {
    scanf(""%d"", &n);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            scanf(""%d"", &maze[i][j]);
        }
    }
    if (solve_maze(0, 0)) {
        for (int i = 0; i < path_len; i++) {
            printf(""(%d, %d) "", path[i][0], path[i][1]);
        }
        printf(""\n"");
    } else {
        printf(""No Path Exists\n"");
    }
    return 0;
}","def solve_maze_util(maze, visited, row, col, path):
    n = len(maze)
    if row < 0 or row >= n or col < 0 or col >= n or maze[row][col] == 0 or visited[row][col]:
        return False

    visited[row][col] = True
    path.append(f'({row}, {col})')

    if row == n - 1 and col == n - 1:
        return True

    if (solve_maze_util(maze, visited, row + 1, col, path) or
            solve_maze_util(maze, visited, row - 1, col, path) or
            solve_maze_util(maze, visited, row, col + 1, path) or
            solve_maze_util(maze, visited, row, col - 1, path)):
        return True

    path.pop()
    visited[row][col] = False
    return False


def main():
    n = int(input())
    maze = []
    for _ in range(n):
        maze.append(list(map(int, input().split())))
    visited = [[False for _ in range(n)] for _ in range(n)]
    path = []
    if solve_maze_util(maze, visited, 0, 0, path):
        print(' '.join(path))
    else:
        print(""No Path Exists"")

if __name__ == ""__main__"":
    main()","import java.util.*;

public class RatInMaze {
    private static boolean solveMazeUtil(int[][] maze, boolean[][] visited, int row, int col, List<String> path) {
        int n = maze.length;
        if (row < 0 || row >= n || col < 0 || col >= n || maze[row][col] == 0 || visited[row][col]) return false;

        visited[row][col] = true;
        path.add(""("" + row + "", "" + col + "")"");

        if (row == n - 1 && col == n - 1) return true;

        if (solveMazeUtil(maze, visited, row + 1, col, path) ||
            solveMazeUtil(maze, visited, row - 1, col, path) ||
            solveMazeUtil(maze, visited, row, col + 1, path) ||
            solveMazeUtil(maze, visited, row, col - 1, path)) {
            return true;
        }

        path.remove(path.size() - 1);
        visited[row][col] = false;
        return false;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] maze = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                maze[i][j] = sc.nextInt();
            }
        }
        boolean[][] visited = new boolean[n][n];
        List<String> path = new ArrayList<>();
        if (solveMazeUtil(maze, visited, 0, 0, path)) {
            for (String p : path) {
                System.out.print(p + "" "");
            }
            System.out.println();
        } else {
            System.out.println(""No Path Exists"");
        }
        sc.close();
    }
}","function solveMazeUtil(maze, visited, row, col, path) {
    const n = maze.length;
    if (row < 0 || row >= n || col < 0 || col >= n || maze[row][col] === 0 || visited[row][col]) return false;

    visited[row][col] = true;
    path.push(`(${row}, ${col})`);

    if (row === n - 1 && col === n - 1) return true;

    if (solveMazeUtil(maze, visited, row + 1, col, path) ||
        solveMazeUtil(maze, visited, row - 1, col, path) ||
        solveMazeUtil(maze, visited, row, col + 1, path) ||
        solveMazeUtil(maze, visited, row, col - 1, path)) {
        return true;
    }

    path.pop();
    visited[row][col] = false;
    return false;
}

function main() {
    const n = parseInt(readline());
    const maze = [];
    for (let i = 0; i < n; i++) {
        maze.push(readline().split(' ').map(Number));
    }
    const visited = Array.from(Array(n), () => new Array(n).fill(false));
    const path = [];
    if (solveMazeUtil(maze, visited, 0, 0, path)) {
        console.log(path.join(' '));
    } else {
        console.log(""No Path Exists"");
    }
}

main();","#include <iostream>
#include <vector>

using namespace std;

bool solveMazeUtil(vector<vector<int>>& maze, vector<vector<bool>>& visited, int row, int col, vector<pair<int, int>>& path) {
    int n = maze.size();
    if (row < 0 || row >= n || col < 0 || col >= n || maze[row][col] == 0 || visited[row][col]) return false;

    visited[row][col] = true;
    path.push_back({row, col});

    if (row == n - 1 && col == n - 1) return true;

    if (solveMazeUtil(maze, visited, row + 1, col, path) ||
        solveMazeUtil(maze, visited, row - 1, col, path) ||
        solveMazeUtil(maze, visited, row, col + 1, path) ||
        solveMazeUtil(maze, visited, row, col - 1, path)) {
        return true;
    }

    path.pop_back();
    visited[row][col] = false;
    return false;
}

int main() {
    int n; 
    cin >> n; 
    vector<vector<int>> maze(n, vector<int>(n));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> maze[i][j];
        }
    }
    vector<vector<bool>> visited(n, vector<bool>(n, false));
    vector<pair<int, int>> path;
    if (solveMazeUtil(maze, visited, 0, 0, path)) {
        for (const auto& p : path) {
            cout << ""("" << p.first << "", "" << p.second << "") "";
        }
        cout << endl;
    } else {
        cout << ""No Path Exists"" << endl;
    }
    return 0;
}",3.9
Orange-13,Generate All Permutations,,,,,,"[object Object],[object Object],[object Object]","c
#include <stdio.h>
#include <string.h>
#include <stdbool.h>

void permute(char *s, int l, int r, bool *used) {
    if (l == r) {
        printf(""%s\n"", s);
    } else {
        for (int i = 0; i <= r; i++) {
            if (!used[i]) {
                used[i] = true;
                char temp = s[l];
                s[l] = s[i];
                s[i] = temp;
                permute(s, l + 1, r, used);
                s[i] = s[l];
                s[l] = temp;
                used[i] = false;
            }
        }
    }
}

int main() {
    char s[11];
    scanf(""%s"", s);
    int n = strlen(s);
    bool used[n];
    for (int i = 0; i < n; i++) {
        used[i] = false;
    }
    permute(s, 0, n - 1, used);
    return 0;
}","python
from itertools import permutations

def solve():
    s = input()
    for p in permutations(s):
        print("""".join(p))

solve()","java
import java.util.*;

public class Permutations {

    public static void permute(String str, int l, int r) {
        if (l == r) {
            System.out.println(str);
        } else {
            for (int i = l; i <= r; i++) {
                str = swap(str, l, i);
                permute(str, l + 1, r);
                str = swap(str, l, i); // backtrack
            }
        }
    }

    public static String swap(String a, int i, int j) {
        char temp;
        char[] charArray = a.toCharArray();
        temp = charArray[i];
        charArray[i] = charArray[j];
        charArray[j] = temp;
        return String.valueOf(charArray);
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine();
        permute(s, 0, s.length() - 1);
        scanner.close();
    }
}","javascript
function permute(str, l, r) {
  if (l == r) {
    console.log(str);
  } else {
    for (let i = l; i <= r; i++) {
      str = swap(str, l, i);
      permute(str, l + 1, r);
      str = swap(str, l, i); // backtrack
    }
  }
}

function swap(a, i, j) {
  let temp;
  let charArray = a.split('');
  temp = charArray[i];
  charArray[i] = charArray[j];
  charArray[j] = temp;
  return charArray.join('');
}

let str = require('readline-sync').question();
permute(str, 0, str.length - 1);","cpp
#include <iostream>
#include <string>
#include <algorithm>

using namespace std;

void permute(string s, int l, int r) {
    if (l == r) {
        cout << s << endl;
    } else {
        for (int i = l; i <= r; i++) {
            swap(s[l], s[i]);
            permute(s, l + 1, r);
            swap(s[l], s[i]); // backtrack
        }
    }
}

int main() {
    string s;
    cin >> s;
    permute(s, 0, s.length() - 1);
    return 0;
}",3.3
Orange-14,Next Greater/Smaller Element (Monotonic Stack),,,,,,"[object Object],[object Object],[object Object],[object Object],[object Object]","c
#include <stdio.h>
#include <stdlib.h>

int* nextGreaterElements(int* nums, int numsSize, int* returnSize) {
    *returnSize = numsSize;
    int *result = (int*)malloc(numsSize * sizeof(int));
    for (int i = 0; i < numsSize; i++) result[i] = -1;

    int stack[numsSize];
    int top = -1;

    for (int i = 0; i < 2 * numsSize; i++) {
        int index = i % numsSize;
        while (top != -1 && nums[stack[top]] < nums[index]) {
            result[stack[top--]] = nums[index];
        }
        if (i < numsSize) stack[++top] = index;
    }
    return result;
}

int main() {
    int nums[] = {1, 2, 1};
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    int returnSize;
    int *result = nextGreaterElements(nums, numsSize, &returnSize);
    for (int i = 0; i < returnSize; i++) printf(""%d "", result[i]);
    printf(""\n"");
    free(result);
    return 0;
}","python
def nextGreaterElements(nums):
    n = len(nums)
    result = [-1] * n
    stack = []

    for i in range(2 * n):
        index = i % n
        while stack and nums[stack[-1]] < nums[index]:
            result[stack.pop()] = nums[index]
        if i < n:
            stack.append(index)
    return result

nums = [1, 2, 1]
result = nextGreaterElements(nums)
print(*result)","java
import java.util.*;

class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int n = nums.length;
        int[] result = new int[n];
        Arrays.fill(result, -1);
        Stack<Integer> stack = new Stack<>();

        for (int i = 0; i < 2 * n; ++i) {
            int index = i % n;
            while (!stack.isEmpty() && nums[stack.peek()] < nums[index]) {
                result[stack.pop()] = nums[index];
            }
            if (i < n) stack.push(index);
        }
        return result;
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        int[] nums = {1, 2, 1};
        int[] result = sol.nextGreaterElements(nums);
        for (int i = 0; i < result.length; i++) System.out.print(result[i] + "" "");
        System.out.println();
    }
}","javascript
function nextGreaterElements(nums) {
    const n = nums.length;
    const result = new Array(n).fill(-1);
    const stack = [];

    for (let i = 0; i < 2 * n; i++) {
        const index = i % n;
        while (stack.length > 0 && nums[stack[stack.length - 1]] < nums[index]) {
            result[stack.pop()] = nums[index];
        }
        if (i < n) {
            stack.push(index);
        }
    }
    return result;
}

const nums = [1, 2, 1];
const result = nextGreaterElements(nums);
console.log(...result);","cpp
#include <iostream>
#include <vector>
#include <stack>

std::vector<int> nextGreaterElements(std::vector<int>& nums) {
    int n = nums.size();
    std::vector<int> result(n, -1);
    std::stack<int> s;

    for (int i = 0; i < 2 * n; ++i) {
        int index = i % n;
        while (!s.empty() && nums[s.top()] < nums[index]) {
            result[s.top()] = nums[index];
            s.pop();
        }
        if (i < n) s.push(index);
    }
    return result;
}

int main() {
    std::vector<int> nums = {1, 2, 1};
    std::vector<int> result = nextGreaterElements(nums);
    for (int i = 0; i < result.size(); ++i) std::cout << result[i] << "" "";
    std::cout << std::endl;
    return 0;
}",3.9
Orange-15,Sliding Window Maximum (Deque),,,,,,"[object Object],[object Object],[object Object],[object Object],[object Object]","#include <stdio.h>
#include <stdlib.h>

int* maxSlidingWindow(int* nums, int numsSize, int k, int* returnSize){
    int *result = (int*)malloc(sizeof(int) * (numsSize - k + 1));
    *returnSize = numsSize - k + 1;
    int deque[numsSize];
    int head = 0, tail = -1;
    for(int i = 0; i < numsSize; i++){
        while(head <= tail && nums[i] >= nums[deque[tail]]) tail--;
        deque[++tail] = i;
        if(i >= k - 1){
            result[i - k + 1] = nums[deque[head]];
            if(deque[head] == i - k + 1) head++;
        }
    }
    return result;
}

int main(){
    int nums[] = {1,3,-1,-3,5,3,6,7};
    int k = 3;
    int returnSize;
    int *result = maxSlidingWindow(nums, sizeof(nums)/sizeof(nums[0]), k, &returnSize);
    for(int i = 0; i < returnSize; i++) printf(""%d "", result[i]);
    printf(""\n"");
    free(result);
    return 0;
}","from collections import deque

def maxSlidingWindow(nums, k):
    result = []
    dq = deque()
    for i, num in enumerate(nums):
        while dq and nums[dq[-1]] <= num:
            dq.pop()
        dq.append(i)
        if i >= k - 1:
            while dq and dq[0] <= i - k:
                dq.popleft()
            result.append(nums[dq[0]])
    return result

nums = [1, 3, -1, -3, 5, 3, 6, 7]
k = 3
result = maxSlidingWindow(nums, k)
print(*result) #prints elements separated by space","import java.util.*;

public class SlidingWindowMaximum {
    public int[] maxSlidingWindow(int[] nums, int k) {
        int n = nums.length;
        if (n * k == 0) return new int[0];
        int[] result = new int[n - k + 1];
        Deque<Integer> deque = new LinkedList<>();
        for (int i = 0; i < n; i++) {
            while (!deque.isEmpty() && nums[deque.peekLast()] <= nums[i]) {
                deque.pollLast();
            }
            deque.offerLast(i);
            if (i >= k - 1) {
                while (!deque.isEmpty() && deque.peekFirst() <= i - k) {
                    deque.pollFirst();
                }
                result[i - k + 1] = nums[deque.peekFirst()];
            }
        }
        return result;
    }

    public static void main(String[] args) {
        SlidingWindowMaximum solution = new SlidingWindowMaximum();
        int[] nums = {1, 3, -1, -3, 5, 3, 6, 7};
        int k = 3;
        int[] result = solution.maxSlidingWindow(nums, k);
        for (int i = 0; i < result.length; i++) {
            System.out.print(result[i] + "" "");
        }
        System.out.println();
    }
}","function maxSlidingWindow(nums, k) {
  const result = [];
  const deque = [];
  for (let i = 0; i < nums.length; i++) {
    while (deque.length > 0 && nums[deque[deque.length - 1]] <= nums[i]) {
      deque.pop();
    }
    deque.push(i);
    if (i >= k - 1) {
      while (deque.length > 0 && deque[0] <= i - k) {
        deque.shift();
      }
      result.push(nums[deque[0]]);
    }
  }
  return result;
}

const nums = [1, 3, -1, -3, 5, 3, 6, 7];
const k = 3;
const result = maxSlidingWindow(nums, k);
console.log(...result); //prints elements separated by space","#include <iostream>
#include <deque>
#include <vector>

std::vector<int> maxSlidingWindow(const std::vector<int>& nums, int k) {
    std::vector<int> result;
    std::deque<int> dq;
    for (int i = 0; i < nums.size(); ++i) {
        while (!dq.empty() && nums[dq.back()] <= nums[i]) {
            dq.pop_back();
        }
        dq.push_back(i);
        if (i >= k - 1) {
            while (!dq.empty() && dq.front() <= i - k) {
                dq.pop_front();
            }
            result.push_back(nums[dq.front()]);
        }
    }
    return result;
}

int main() {
    std::vector<int> nums = {1, 3, -1, -3, 5, 3, 6, 7};
    int k = 3;
    std::vector<int> result = maxSlidingWindow(nums, k);
    for (int i = 0; i < result.size(); ++i) {
        std::cout << result[i] << "" "";
    }
    std::cout << std::endl;
    return 0;
}",4
Orange-16,First/Last Occurrence in Sorted Array,,,,,,"[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]","#include <stdio.h>
#include <stdlib.h>

int findFirst(int arr[], int n, int target) {
    int low = 0, high = n - 1, first = -1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == target) {
            first = mid;
            high = mid - 1; // Continue searching on the left for the first occurrence
        } else if (arr[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return first;
}

int findLast(int arr[], int n, int target) {
    int low = 0, high = n - 1, last = -1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == target) {
            last = mid;
            low = mid + 1; // Continue searching on the right for the last occurrence
        } else if (arr[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return last;
}

int main() {
    int n, target;
    scanf(""%d %d"", &n, &target);
    int arr[n];
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]);
    }
    int first = findFirst(arr, n, target);
    int last = findLast(arr, n, target);
    printf(""[%d,%d]\n"", first, last);
    return 0;
}","def find_first(arr, target):
    low = 0
    high = len(arr) - 1
    first = -1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            first = mid
            high = mid - 1  # Continue searching on the left for the first occurrence
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return first


def find_last(arr, target):
    low = 0
    high = len(arr) - 1
    last = -1
    while low <= high:
        mid = (low + high) // 2
        if arr[mid] == target:
            last = mid
            low = mid + 1  # Continue searching on the right for the last occurrence
        elif arr[mid] < target:
            low = mid + 1
        else:
            high = mid - 1
    return last


if __name__ == ""__main__"":
    n, target = map(int, input().split())
    arr = list(map(int, input().split()))
    print(f""[{find_first(arr, target)},{find_last(arr, target)}]"")","import java.util.*;
import java.lang.*;

class Solution {
    public static int findFirst(int[] arr, int target) {
        int low = 0, high = arr.length - 1, first = -1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (arr[mid] == target) {
                first = mid;
                high = mid - 1; // Continue searching on the left for the first occurrence
            } else if (arr[mid] < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return first;
    }

    public static int findLast(int[] arr, int target) {
        int low = 0, high = arr.length - 1, last = -1;
        while (low <= high) {
            int mid = low + (high - low) / 2;
            if (arr[mid] == target) {
                last = mid;
                low = mid + 1; // Continue searching on the right for the last occurrence
            } else if (arr[mid] < target) {
                low = mid + 1;
            } else {
                high = mid - 1;
            }
        }
        return last;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int target = scanner.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
        System.out.println(""["" + findFirst(arr, target) + "","" + findLast(arr, target) + ""]"");
        scanner.close();
    }
}","function findFirst(arr, target) {
  let low = 0;
  let high = arr.length - 1;
  let first = -1;

  while (low <= high) {
    let mid = Math.floor((low + high) / 2);

    if (arr[mid] === target) {
      first = mid;
      high = mid - 1; // Continue searching on the left for the first occurrence
    } else if (arr[mid] < target) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }

  return first;
}

function findLast(arr, target) {
  let low = 0;
  let high = arr.length - 1;
  let last = -1;

  while (low <= high) {
    let mid = Math.floor((low + high) / 2);

    if (arr[mid] === target) {
      last = mid;
      low = mid + 1; // Continue searching on the right for the last occurrence
    } else if (arr[mid] < target) {
      low = mid + 1;
    } else {
      high = mid - 1;
    }
  }

  return last;
}

function main() {
  const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\n');
  const [n, target] = input[0].split(' ').map(Number);
  const arr = input[1].split(' ').map(Number);

  console.log(`[${findFirst(arr, target)},${findLast(arr, target)}]`);
}

main();","#include <iostream>
#include <vector>

using namespace std;

int findFirst(vector<int>& arr, int target) {
    int low = 0, high = arr.size() - 1, first = -1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == target) {
            first = mid;
            high = mid - 1; // Continue searching on the left for the first occurrence
        } else if (arr[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return first;
}

int findLast(vector<int>& arr, int target) {
    int low = 0, high = arr.size() - 1, last = -1;
    while (low <= high) {
        int mid = low + (high - low) / 2;
        if (arr[mid] == target) {
            last = mid;
            low = mid + 1; // Continue searching on the right for the last occurrence
        } else if (arr[mid] < target) {
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return last;
}

int main() {
    int n, target;
    cin >> n >> target;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }
    cout << ""["" << findFirst(arr, target) << "","" << findLast(arr, target) << ""]"" << endl;
    return 0;
}",3.2
Orange-17,Merge Two Sorted Lists,,,,,,"[object Object],[object Object],[object Object],[object Object],[object Object]","#include <stdio.h>
#include <stdlib.h>

struct ListNode {
    int val;
    struct ListNode *next;
};

struct ListNode* mergeTwoLists(struct ListNode* list1, struct ListNode* list2) {
    struct ListNode* dummyHead = (struct ListNode*)malloc(sizeof(struct ListNode));
    dummyHead->next = NULL;
    struct ListNode* tail = dummyHead;

    while (list1 != NULL && list2 != NULL) {
        if (list1->val <= list2->val) {
            tail->next = list1;
            list1 = list1->next;
        } else {
            tail->next = list2;
            list2 = list2->next;
        }
        tail = tail->next;
    }

    if (list1 != NULL) {
        tail->next = list1;
    } else {
        tail->next = list2;
    }

    struct ListNode* result = dummyHead->next;
    free(dummyHead);
    return result;
}

// Helper function to create a linked list from an array
struct ListNode* createList(int arr[], int size) {
    struct ListNode* head = NULL;
    struct ListNode* tail = NULL;

    for (int i = 0; i < size; i++) {
        struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
        newNode->val = arr[i];
        newNode->next = NULL;

        if (head == NULL) {
            head = newNode;
            tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
    }
    return head;
}

// Helper function to print a linked list
void printList(struct ListNode* head) {
    struct ListNode* current = head;
    while (current != NULL) {
        printf(""%d "", current->val);
        current = current->next;
    }
    printf(""\n"");
}

int main() {
    int arr1[] = {1, 2, 4};
    int size1 = sizeof(arr1) / sizeof(arr1[0]);
    struct ListNode* list1 = createList(arr1, size1);

    int arr2[] = {1, 3, 4};
    int size2 = sizeof(arr2) / sizeof(arr2[0]);
    struct ListNode* list2 = createList(arr2, size2);

    struct ListNode* mergedList = mergeTwoLists(list1, list2);

    printList(mergedList);

    // Free the allocated memory (important for C)
    struct ListNode* current = mergedList;
    while (current != NULL) {
        struct ListNode* temp = current;
        current = current->next;
        free(temp);
    }

    return 0;
}","class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def mergeTwoLists(list1, list2):
    dummy = ListNode()
    tail = dummy

    while list1 and list2:
        if list1.val <= list2.val:
            tail.next = list1
            list1 = list1.next
        else:
            tail.next = list2
            list2 = list2.next
        tail = tail.next

    if list1:
        tail.next = list1
    else:
        tail.next = list2

    return dummy.next

# Helper function to create a linked list from a list
def create_list(arr):
    head = None
    tail = None
    for val in arr:
        node = ListNode(val)
        if not head:
            head = node
            tail = node
        else:
            tail.next = node
            tail = node
    return head

# Helper function to print a linked list
def print_list(head):
    curr = head
    while curr:
        print(curr.val, end="" "")
        curr = curr.next
    print()

if __name__ == ""__main__"":
    list1_arr = [1, 2, 4]
    list2_arr = [1, 3, 4]

    list1 = create_list(list1_arr)
    list2 = create_list(list2_arr)

    merged_list = mergeTwoLists(list1, list2)
    print_list(merged_list)","import java.util.*;

class ListNode {
    int val;
    ListNode next;

    ListNode() {
    }

    ListNode(int val) {
        this.val = val;
    }

    ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}

class Solution {
    public ListNode mergeTwoLists(ListNode list1, ListNode list2) {
        ListNode dummyHead = new ListNode();
        ListNode tail = dummyHead;

        while (list1 != null && list2 != null) {
            if (list1.val <= list2.val) {
                tail.next = list1;
                list1 = list1.next;
            } else {
                tail.next = list2;
                list2 = list2.next;
            }
            tail = tail.next;
        }

        if (list1 != null) {
            tail.next = list1;
        } else {
            tail.next = list2;
        }

        return dummyHead.next;
    }

    // Helper function to create a linked list from an array
    public ListNode createList(int[] arr) {
        ListNode head = null;
        ListNode tail = null;

        for (int val : arr) {
            ListNode newNode = new ListNode(val);
            if (head == null) {
                head = newNode;
                tail = newNode;
            } else {
                tail.next = newNode;
                tail = newNode;
            }
        }
        return head;
    }

    // Helper function to print a linked list
    public void printList(ListNode head) {
        ListNode current = head;
        while (current != null) {
            System.out.print(current.val + "" "");
            current = current.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Solution sol = new Solution();

        int[] arr1 = {1, 2, 4};
        ListNode list1 = sol.createList(arr1);

        int[] arr2 = {1, 3, 4};
        ListNode list2 = sol.createList(arr2);

        ListNode mergedList = sol.mergeTwoLists(list1, list2);

        sol.printList(mergedList);
    }
}","function ListNode(val, next) {
    this.val = (val===undefined ? 0 : val)
    this.next = (next===undefined ? null : next)
}

function mergeTwoLists(list1, list2) {
    let dummy = new ListNode();
    let tail = dummy;

    while (list1 && list2) {
        if (list1.val <= list2.val) {
            tail.next = list1;
            list1 = list1.next;
        } else {
            tail.next = list2;
            list2 = list2.next;
        }
        tail = tail.next;
    }

    if (list1) {
        tail.next = list1;
    } else {
        tail.next = list2;
    }

    return dummy.next;
}

// Helper function to create a linked list from an array
function createList(arr) {
    let head = null;
    let tail = null;

    for (let val of arr) {
        let newNode = new ListNode(val);
        if (!head) {
            head = newNode;
            tail = newNode;
        } else {
            tail.next = newNode;
            tail = newNode;
        }
    }
    return head;
}

// Helper function to print a linked list
function printList(head) {
    let current = head;
    let result = """";
    while (current) {
        result += current.val + "" "";
        current = current.next;
    }
    console.log(result.trim());
}

// Example usage:
let list1Arr = [1, 2, 4];
let list2Arr = [1, 3, 4];

let list1 = createList(list1Arr);
let list2 = createList(list2Arr);

let mergedList = mergeTwoLists(list1, list2);
printList(mergedList);","#include <iostream>

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
    ListNode* dummyHead = new ListNode();
    ListNode* tail = dummyHead;

    while (list1 != nullptr && list2 != nullptr) {
        if (list1->val <= list2->val) {
            tail->next = list1;
            list1 = list1->next;
        } else {
            tail->next = list2;
            list2 = list2->next;
        }
        tail = tail->next;
    }

    if (list1 != nullptr) {
        tail->next = list1;
    } else {
        tail->next = list2;
    }

    ListNode* result = dummyHead->next;
    delete dummyHead;
    return result;
}

// Helper function to create a linked list from a vector
ListNode* createList(std::vector<int> arr) {
    ListNode* head = nullptr;
    ListNode* tail = nullptr;

    for (int val : arr) {
        ListNode* newNode = new ListNode(val);
        if (head == nullptr) {
            head = newNode;
            tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
    }
    return head;
}

// Helper function to print a linked list
void printList(ListNode* head) {
    ListNode* current = head;
    while (current != nullptr) {
        std::cout << current->val << "" "";
        current = current->next;
    }
    std::cout << std::endl;
}

int main() {
    std::vector<int> arr1 = {1, 2, 4};
    ListNode* list1 = createList(arr1);

    std::vector<int> arr2 = {1, 3, 4};
    ListNode* list2 = createList(arr2);

    ListNode* mergedList = mergeTwoLists(list1, list2);

    printList(mergedList);

    // Free the allocated memory (important for C++)
    ListNode* current = mergedList;
    while (current != nullptr) {
        ListNode* temp = current;
        current = current->next;
        delete temp;
    }

    return 0;
}",4.3
Orange-18,Next Greater/Smaller Element (Monotonic Stack),,,,,,"[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]","#include <stdio.h>
#include <stdlib.h>

int* nextGreaterElement(int arr[], int n) {
    int* result = (int*)malloc(n * sizeof(int));
    int* stack = (int*)malloc(n * sizeof(int));
    int top = -1;

    for (int i = n - 1; i >= 0; i--) {
        while (top >= 0 && arr[stack[top]] <= arr[i]) {
            top--;
        }

        result[i] = (top < 0) ? -1 : arr[stack[top]];
        stack[++top] = i;
    }

    free(stack);
    return result;
}

int main() {
    int n;
    scanf(""%d"", &n);

    int arr[n];
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]);
    }

    int* result = nextGreaterElement(arr, n);

    for (int i = 0; i < n; i++) {
        printf(""%d "", result[i]);
    }
    printf(""\n"");

    free(result);
    return 0;
}","def next_greater_element(arr):
    n = len(arr)
    result = [-1] * n
    stack = []

    for i in range(n - 1, -1, -1):
        while stack and arr[stack[-1]] <= arr[i]:
            stack.pop()

        if stack:
            result[i] = arr[stack[-1]]

        stack.append(i)

    return result

if __name__ == ""__main__"":
    n = int(input())
    arr = list(map(int, input().split()))
    result = next_greater_element(arr)
    print(*result)","import java.util.Arrays;
import java.util.Stack;
import java.util.Scanner;

class Solution {
    public static int[] nextGreaterElement(int[] arr) {
        int n = arr.length;
        int[] result = new int[n];
        Arrays.fill(result, -1);
        Stack<Integer> stack = new Stack<>();

        for (int i = n - 1; i >= 0; i--) {
            while (!stack.isEmpty() && arr[stack.peek()] <= arr[i]) {
                stack.pop();
            }

            if (!stack.isEmpty()) {
                result[i] = arr[stack.peek()];
            }

            stack.push(i);
        }

        return result;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        int[] result = nextGreaterElement(arr);

        for (int i = 0; i < n; i++) {
            System.out.print(result[i] + "" "");
        }
        System.out.println();
    }
}","function nextGreaterElement(arr) {
  const n = arr.length;
  const result = new Array(n).fill(-1);
  const stack = [];

  for (let i = n - 1; i >= 0; i--) {
    while (stack.length > 0 && arr[stack[stack.length - 1]] <= arr[i]) {
      stack.pop();
    }

    if (stack.length > 0) {
      result[i] = arr[stack[stack.length - 1]];
    }

    stack.push(i);
  }

  return result;
}


function main() {
  const n = parseInt(prompt());
  const arr = prompt().split("" "").map(Number);

  const result = nextGreaterElement(arr);
  console.log(result.join("" ""));
}

// Simulate prompt for testing purposes in environment where prompt is not available.
// Run: node your_file.js < input.txt
if (typeof prompt === 'undefined') {
    global.prompt = require('prompt-sync')();
}

main();","#include <iostream>
#include <vector>
#include <stack>

using namespace std;

vector<int> nextGreaterElement(vector<int>& arr) {
    int n = arr.size();
    vector<int> result(n, -1);
    stack<int> s;

    for (int i = n - 1; i >= 0; --i) {
        while (!s.empty() && arr[s.top()] <= arr[i]) {
            s.pop();
        }

        if (!s.empty()) {
            result[i] = arr[s.top()];
        }

        s.push(i);
    }

    return result;
}

int main() {
    int n;
    cin >> n;

    vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        cin >> arr[i];
    }

    vector<int> result = nextGreaterElement(arr);

    for (int i = 0; i < n; ++i) {
        cout << result[i] << "" "";
    }
    cout << endl;

    return 0;
}",4.3
Orange-19,Cycle Detection (Fast/Slow Pointers),,,,,,"[object Object],[object Object],[object Object],[object Object],[object Object]","c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

struct ListNode {
    int val;
    struct ListNode *next;
};

bool hasCycle(struct ListNode *head) {
    if (head == NULL || head->next == NULL) {
        return false;
    }

    struct ListNode *slow = head;
    struct ListNode *fast = head;

    while (fast != NULL && fast->next != NULL) {
        slow = slow->next;
        fast = fast->next->next;

        if (slow == fast) {
            return true;
        }
    }

    return false;
}

int main() {
    // Example Usage (Create a linked list with a cycle for testing)
    struct ListNode *head = malloc(sizeof(struct ListNode));
    head->val = 3;
    struct ListNode *node2 = malloc(sizeof(struct ListNode));
    node2->val = 2;
    struct ListNode *node3 = malloc(sizeof(struct ListNode));
    node3->val = 0;
    struct ListNode *node4 = malloc(sizeof(struct ListNode));
    node4->val = -4;

    head->next = node2;
    node2->next = node3;
    node3->next = node4;
    node4->next = node2; // Create a cycle: node4 points back to node2

    if (hasCycle(head)) {
        printf(""Cycle detected!\n"");
    } else {
        printf(""No cycle detected.\n"");
    }


   //Memory cleanup.  Crucial to prevent memory leaks.
    struct ListNode *current = head;
    struct ListNode *next;
    while(current != NULL){
        next = current->next;
        free(current);
        current = next;
    }

    return 0;
}","python
class ListNode:
    def __init__(self, x):
        self.val = x
        self.next = None

def hasCycle(head):
    if not head or not head.next:
        return False

    slow = head
    fast = head

    while fast and fast.next:
        slow = slow.next
        fast = fast.next.next

        if slow == fast:
            return True

    return False

if __name__ == '__main__':
    # Example Usage (Create a linked list with a cycle for testing)
    head = ListNode(3)
    node2 = ListNode(2)
    node3 = ListNode(0)
    node4 = ListNode(-4)

    head.next = node2
    node2.next = node3
    node3.next = node4
    node4.next = node2  # Create a cycle: node4 points back to node2

    if hasCycle(head):
        print(""Cycle detected!"")
    else:
        print(""No cycle detected."")","java
class ListNode {
    int val;
    ListNode next;

    ListNode(int x) {
        val = x;
        next = null;
    }
}

public class Solution {
    public boolean hasCycle(ListNode head) {
        if (head == null || head.next == null) {
            return false;
        }

        ListNode slow = head;
        ListNode fast = head;

        while (fast != null && fast.next != null) {
            slow = slow.next;
            fast = fast.next.next;

            if (slow == fast) {
                return true;
            }
        }

        return false;
    }

    public static void main(String[] args) {
        // Example Usage (Create a linked list with a cycle for testing)
        ListNode head = new ListNode(3);
        ListNode node2 = new ListNode(2);
        ListNode node3 = new ListNode(0);
        ListNode node4 = new ListNode(-4);

        head.next = node2;
        node2.next = node3;
        node3.next = node4;
        node4.next = node2; // Create a cycle: node4 points back to node2

        Solution solution = new Solution();
        if (solution.hasCycle(head)) {
            System.out.println(""Cycle detected!"");
        } else {
            System.out.println(""No cycle detected."");
        }
    }
}","javascript
function ListNode(val) {
  this.val = val;
  this.next = null;
}

function hasCycle(head) {
  if (!head || !head.next) {
    return false;
  }

  let slow = head;
  let fast = head;

  while (fast && fast.next) {
    slow = slow.next;
    fast = fast.next.next;

    if (slow === fast) {
      return true;
    }
  }

  return false;
}

// Example Usage (Create a linked list with a cycle for testing)
let head = new ListNode(3);
let node2 = new ListNode(2);
let node3 = new ListNode(0);
let node4 = new ListNode(-4);

head.next = node2;
node2.next = node3;
node3.next = node4;
node4.next = node2; // Create a cycle: node4 points back to node2

if (hasCycle(head)) {
  console.log(""Cycle detected!"");
} else {
  console.log(""No cycle detected."");
}","cpp
#include <iostream>

struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

bool hasCycle(ListNode *head) {
    if (head == nullptr || head->next == nullptr) {
        return false;
    }

    ListNode *slow = head;
    ListNode *fast = head;

    while (fast != nullptr && fast->next != nullptr) {
        slow = slow->next;
        fast = fast->next->next;

        if (slow == fast) {
            return true;
        }
    }

    return false;
}

int main() {
    // Example Usage (Create a linked list with a cycle for testing)
    ListNode *head = new ListNode(3);
    ListNode *node2 = new ListNode(2);
    ListNode *node3 = new ListNode(0);
    ListNode *node4 = new ListNode(-4);

    head->next = node2;
    node2->next = node3;
    node3->next = node4;
    node4->next = node2; // Create a cycle: node4 points back to node2

    if (hasCycle(head)) {
        std::cout << ""Cycle detected!"" << std::endl;
    } else {
        std::cout << ""No cycle detected."" << std::endl;
    }

    //Memory cleanup.
    ListNode *current = head;
    ListNode *next;
    while (current != nullptr) {
        next = current->next;
        delete current;
        current = next;
    }

    return 0;
}",4.1
Orange-20,Reverse a Linked List,,,,,,"[object Object],[object Object],[object Object],[object Object],[object Object]","#include <stdio.h>
#include <stdlib.h>

struct ListNode {
    int val;
    struct ListNode *next;
};

struct ListNode* reverseList(struct ListNode* head) {
    struct ListNode *prev = NULL;
    struct ListNode *current = head;
    struct ListNode *next = NULL;

    while (current != NULL) {
        next = current->next;
        current->next = prev;
        prev = current;
        current = next;
    }

    return prev;
}

// Helper function to create a linked list from an array
struct ListNode* createList(int arr[], int n) {
    struct ListNode *head = NULL;
    struct ListNode *tail = NULL;
    for (int i = 0; i < n; i++) {
        struct ListNode *newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
        newNode->val = arr[i];
        newNode->next = NULL;
        if (head == NULL) {
            head = newNode;
            tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
    }
    return head;
}

// Helper function to print a linked list
void printList(struct ListNode* head) {
    struct ListNode *current = head;
    while (current != NULL) {
        printf(""%d "", current->val);
        current = current->next;
    }
    printf(""\n"");
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    struct ListNode *head = createList(arr, n);

    printf(""Original List: "");
    printList(head);

    struct ListNode *reversedHead = reverseList(head);

    printf(""Reversed List: "");
    printList(reversedHead);

    // Free memory (important for avoiding memory leaks)
    struct ListNode *current = reversedHead; // Use reversedHead since head now points to the end
    while (current != NULL) {
        struct ListNode *temp = current;
        current = current->next;
        free(temp);
    }

    return 0;
}","class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def reverseList(head):
    prev = None
    current = head
    while current:
        next_node = current.next
        current.next = prev
        prev = current
        current = next_node
    return prev

# Helper function to create a linked list from a list
def create_list(arr):
    head = None
    tail = None
    for val in arr:
        new_node = ListNode(val)
        if not head:
            head = new_node
            tail = new_node
        else:
            tail.next = new_node
            tail = new_node
    return head

# Helper function to print a linked list
def print_list(head):
    current = head
    while current:
        print(current.val, end="" "")
        current = current.next
    print()

if __name__ == ""__main__"":
    arr = [1, 2, 3, 4, 5]
    head = create_list(arr)
    
    print(""Original List:"", end="" "")
    print_list(head)

    reversed_head = reverseList(head)

    print(""Reversed List:"", end="" "")
    print_list(reversed_head)","class ListNode {
    int val;
    ListNode next;

    ListNode() {}
    ListNode(int val) {
        this.val = val;
    }
    ListNode(int val, ListNode next) {
        this.val = val;
        this.next = next;
    }
}

public class ReverseLinkedList {

    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode current = head;
        ListNode next = null;

        while (current != null) {
            next = current.next;
            current.next = prev;
            prev = current;
            current = next;
        }

        return prev;
    }

    // Helper function to create a linked list from an array
    public ListNode createList(int arr[]) {
        ListNode head = null;
        ListNode tail = null;
        for (int i = 0; i < arr.length; i++) {
            ListNode newNode = new ListNode(arr[i]);
            if (head == null) {
                head = newNode;
                tail = newNode;
            } else {
                tail.next = newNode;
                tail = newNode;
            }
        }
        return head;
    }

    // Helper function to print a linked list
    public void printList(ListNode head) {
        ListNode current = head;
        while (current != null) {
            System.out.print(current.val + "" "");
            current = current.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        ReverseLinkedList solution = new ReverseLinkedList();
        int arr[] = {1, 2, 3, 4, 5};
        ListNode head = solution.createList(arr);

        System.out.print(""Original List: "");
        solution.printList(head);

        ListNode reversedHead = solution.reverseList(head);

        System.out.print(""Reversed List: "");
        solution.printList(reversedHead);
    }
}","function ListNode(val, next) {
    this.val = (val===undefined ? 0 : val)
    this.next = (next===undefined ? null : next)
}

function reverseList(head) {
    let prev = null;
    let current = head;

    while (current) {
        let next = current.next;
        current.next = prev;
        prev = current;
        current = next;
    }

    return prev;
}

// Helper function to create a linked list from an array
function createList(arr) {
    let head = null;
    let tail = null;
    for (let i = 0; i < arr.length; i++) {
        let newNode = new ListNode(arr[i]);
        if (!head) {
            head = newNode;
            tail = newNode;
        } else {
            tail.next = newNode;
            tail = newNode;
        }
    }
    return head;
}

// Helper function to print a linked list
function printList(head) {
    let current = head;
    let result = """";
    while (current) {
        result += current.val + "" "";
        current = current.next;
    }
    console.log(result);
}


// Example usage:
let arr = [1, 2, 3, 4, 5];
let head = createList(arr);

console.log(""Original List:"");
printList(head);

let reversedHead = reverseList(head);

console.log(""Reversed List:"");
printList(reversedHead);","#include <iostream>

struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* reverseList(ListNode* head) {
    ListNode *prev = nullptr;
    ListNode *current = head;
    ListNode *next = nullptr;

    while (current != nullptr) {
        next = current->next;
        current->next = prev;
        prev = current;
        current = next;
    }

    return prev;
}

// Helper function to create a linked list from an array
ListNode* createList(int arr[], int n) {
    ListNode *head = nullptr;
    ListNode *tail = nullptr;
    for (int i = 0; i < n; i++) {
        ListNode *newNode = new ListNode(arr[i]);
        if (head == nullptr) {
            head = newNode;
            tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
    }
    return head;
}

// Helper function to print a linked list
void printList(ListNode* head) {
    ListNode *current = head;
    while (current != nullptr) {
        std::cout << current->val << "" "";
        current = current->next;
    }
    std::cout << std::endl;
}

int main() {
    int arr[] = {1, 2, 3, 4, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    ListNode *head = createList(arr, n);

    std::cout << ""Original List: "";
    printList(head);

    ListNode *reversedHead = reverseList(head);

    std::cout << ""Reversed List: "";
    printList(reversedHead);

    // Free memory (important for avoiding memory leaks)
    ListNode *current = reversedHead; // Use reversedHead since head now points to the end
    while (current != nullptr) {
        ListNode *temp = current;
        current = current->next;
        delete temp;
    }

    return 0;
}",1
Yellow-101,Prefix & Suffix Sums,,,,,,"[object Object],[object Object],[object Object]","#include <stdio.h>

long long prefix_suffix_sum(long long arr[], int n, int l, int r) {
    long long prefix_sum = 0;
    long long suffix_sum = 0;
    
    long long prefix_arr[n];
    prefix_arr[0] = arr[0];
    for(int i = 1; i < n; i++) prefix_arr[i] = prefix_arr[i-1] + arr[i];

    long long suffix_arr[n];
    suffix_arr[n-1] = arr[n-1];
    for(int i = n-2; i >=0; i--) suffix_arr[i] = suffix_arr[i+1] + arr[i];

    if(l == 0) prefix_sum = 0; else prefix_sum = prefix_arr[l - 1];
    if(r > n -1) suffix_sum = 0; else suffix_sum = suffix_arr[r];
    
    return prefix_sum + suffix_sum;
}

int main() {
    int n, q;
    scanf(""%d"", &n);
    long long arr[n];
    for (int i = 0; i < n; i++) {
        scanf(""%lld"", &arr[i]);
    }
    scanf(""%d"", &q);
    for (int i = 0; i < q; i++) {
        int l, r;
        scanf(""%d %d"", &l, &r);
        printf(""%lld\n"", prefix_suffix_sum(arr, n, l -1, r));
    }
    return 0;
}","def prefix_suffix_sum(arr, l, r):
    prefix_sum = sum(arr[:l])
    suffix_sum = sum(arr[r:])
    return prefix_sum + suffix_sum

n = int(input())
arr = list(map(int, input().split()))
q = int(input())
for _ in range(q):
    l, r = map(int, input().split())
    print(prefix_suffix_sum(arr, l - 1, r))","import java.util.*;

public class PrefixSuffixSum {

    public static long prefixSuffixSum(long[] arr, int l, int r) {
        long prefixSum = 0;
        for (int i = 0; i < l; ++i) {
            prefixSum += arr[i];
        }
        long suffixSum = 0;
        for (int i = r; i < arr.length; ++i) {
            suffixSum += arr[i];
        }
        return prefixSum + suffixSum;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        long[] arr = new long[n];
        for (int i = 0; i < n; ++i) {
            arr[i] = sc.nextLong();
        }
        int q = sc.nextInt();
        for (int i = 0; i < q; ++i) {
            int l = sc.nextInt();
            int r = sc.nextInt();
            System.out.println(prefixSuffixSum(arr, l - 1, r));
        }
        sc.close();
    }
}","function prefixSuffixSum(arr, l, r) {
  let prefixSum = 0;
  for (let i = 0; i < l; i++) {
    prefixSum += arr[i];
  }
  let suffixSum = 0;
  for (let i = r; i < arr.length; i++) {
    suffixSum += arr[i];
  }
  return prefixSum + suffixSum;
}

const readline = require('readline').createInterface({
  input: process.stdin,
  output: process.stdout,
});

readline.question('', (n) => {
  readline.question('', (line) => {
    const arr = line.split(' ').map(Number);
    readline.question('', (q) => {
      for (let i = 0; i < parseInt(q); i++) {
        readline.question('', (line) => {
          const [l, r] = line.split(' ').map(Number);
          console.log(prefixSuffixSum(arr, l-1, r));
          if (i === parseInt(q) -1) readline.close();
        });
      }
    });
  });
});","#include <iostream>
#include <vector>

using namespace std;

long long prefix_suffix_sum(const vector<long long>& arr, int l, int r) {
    long long prefix_sum = 0;
    for (int i = 0; i < l; ++i) {
        prefix_sum += arr[i];
    }
    long long suffix_sum = 0;
    for (int i = r; i < arr.size(); ++i) {
        suffix_sum += arr[i];
    }
    return prefix_sum + suffix_sum;
}

int main() {
    int n, q;
    cin >> n;
    vector<long long> arr(n);
    for (int i = 0; i < n; ++i) {
        cin >> arr[i];
    }
    cin >> q;
    for (int i = 0; i < q; ++i) {
        int l, r;
        cin >> l >> r;
        cout << prefix_suffix_sum(arr, l -1, r) << endl;
    }
    return 0;
}",3.6
Orange-21,Heap Sort,,,,,,"[object Object],[object Object],[object Object],[object Object],[object Object]","#include <stdio.h>
#include <stdlib.h>

void heapify(int arr[], int n, int i) {
  int largest = i;
  int left = 2 * i + 1;
  int right = 2 * i + 2;

  if (left < n && arr[left] > arr[largest])
    largest = left;

  if (right < n && arr[right] > arr[largest])
    largest = right;

  if (largest != i) {
    int temp = arr[i];
    arr[i] = arr[largest];
    arr[largest] = temp;
    heapify(arr, n, largest);
  }
}

void heapSort(int arr[], int n) {
  for (int i = n / 2 - 1; i >= 0; i--)
    heapify(arr, n, i);

  for (int i = n - 1; i > 0; i--) {
    int temp = arr[0];
    arr[0] = arr[i];
    arr[i] = temp;
    heapify(arr, i, 0);
  }
}

int main() {
  int n, i;
  scanf(""%d"", &n);
  int arr[n];
  for(i=0; i<n; i++) scanf(""%d"", &arr[i]);

  heapSort(arr, n);

  for (i = 0; i < n; i++)
    printf(""%d "", arr[i]);
  printf(""\n"");
  return 0;
}","import sys

def heapify(arr, n, i):
    largest = i
    left = 2 * i + 1
    right = 2 * i + 2

    if left < n and arr[left] > arr[largest]:
        largest = left

    if right < n and arr[right] > arr[largest]:
        largest = right

    if largest != i:
        arr[i], arr[largest] = arr[largest], arr[i]  # Pythonic swap
        heapify(arr, n, largest)

def heapSort(arr):
    n = len(arr)
    for i in range(n // 2 - 1, -1, -1):
        heapify(arr, n, i)

    for i in range(n - 1, 0, -1):
        arr[i], arr[0] = arr[0], arr[i]  # Pythonic swap
        heapify(arr, i, 0)

input_line = sys.stdin.readline().strip().split()
arr = [int(x) for x in input_line]
heapSort(arr)
print(*arr) #Prints the array with spaces in between","import java.util.Arrays;
import java.util.Scanner;

public class HeapSort {

    public static void heapify(int[] arr, int n, int i) {
        int largest = i;
        int left = 2 * i + 1;
        int right = 2 * i + 2;

        if (left < n && arr[left] > arr[largest])
            largest = left;

        if (right < n && arr[right] > arr[largest])
            largest = right;

        if (largest != i) {
            int temp = arr[i];
            arr[i] = arr[largest];
            arr[largest] = temp;
            heapify(arr, n, largest);
        }
    }

    public static void heapSort(int[] arr) {
        int n = arr.length;
        for (int i = n / 2 - 1; i >= 0; i--)
            heapify(arr, n, i);

        for (int i = n - 1; i > 0; i--) {
            int temp = arr[0];
            arr[0] = arr[i];
            arr[i] = temp;
            heapify(arr, i, 0);
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String[] input = scanner.nextLine().split("" "");
        int[] arr = new int[input.length];
        for(int i=0; i<input.length; i++) arr[i] = Integer.parseInt(input[i]);
        heapSort(arr);
        System.out.println(Arrays.toString(arr).replaceAll(""[\[\],]"", """").trim());
    }
}","function heapify(arr, n, i) {
  let largest = i;
  let left = 2 * i + 1;
  let right = 2 * i + 2;

  if (left < n && arr[left] > arr[largest]) {
    largest = left;
  }

  if (right < n && arr[right] > arr[largest]) {
    largest = right;
  }

  if (largest != i) {
    [arr[i], arr[largest]] = [arr[largest], arr[i]]; // ES6 destructuring assignment for swap
    heapify(arr, n, largest);
  }
}

function heapSort(arr) {
  let n = arr.length;
  for (let i = Math.floor(n / 2) - 1; i >= 0; i--) {
    heapify(arr, n, i);
  }

  for (let i = n - 1; i > 0; i--) {
    [arr[i], arr[0]] = [arr[0], arr[i]]; // ES6 destructuring assignment for swap
    heapify(arr, i, 0);
  }
}

const input = require('readline-sync').question().split(' ');
const arr = input.map(Number);
heapSort(arr);
console.log(arr.join(' '));","#include <iostream>
#include <vector>

void heapify(std::vector<int>& arr, int n, int i) {
  int largest = i;
  int left = 2 * i + 1;
  int right = 2 * i + 2;

  if (left < n && arr[left] > arr[largest])
    largest = left;

  if (right < n && arr[right] > arr[largest])
    largest = right;

  if (largest != i) {
    std::swap(arr[i], arr[largest]);
    heapify(arr, n, largest);
  }
}

void heapSort(std::vector<int>& arr) {
  int n = arr.size();
  for (int i = n / 2 - 1; i >= 0; i--)
    heapify(arr, n, i);

  for (int i = n - 1; i > 0; i--) {
    std::swap(arr[0], arr[i]);
    heapify(arr, i, 0);
  }
}

int main() {
  int n; 
  std::cin >> n;
  std::vector<int> arr(n);
  for(int i=0; i<n; ++i) std::cin >> arr[i];

  heapSort(arr);

  for (int i = 0; i < n; i++)
    std::cout << arr[i] << "" "";
  std::cout << std::endl;
  return 0;
}",3.6
Orange-22,Generate All Subsets,,,,,,"[object Object],[object Object],[object Object],[object Object]","c
#include <stdio.h>
#include <stdlib.h>

int** generateSubsets(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {
    int numSubsets = 1 << numsSize;
    int** subsets = (int**)malloc(numSubsets * sizeof(int*));
    *returnSize = numSubsets;
    *returnColumnSizes = (int*)malloc(numSubsets * sizeof(int));

    for (int i = 0; i < numSubsets; i++) {
        int subsetSize = 0;
        for (int j = 0; j < numsSize; j++) {
            if ((i >> j) & 1) {
                subsetSize++;
            }
        }
        subsets[i] = (int*)malloc(subsetSize * sizeof(int));
        (*returnColumnSizes)[i] = subsetSize;
        int k = 0;
        for (int j = 0; j < numsSize; j++) {
            if ((i >> j) & 1) {
                subsets[i][k++] = nums[j];
            }
        }
    }
    return subsets;
}

int main(){
    int nums[] = {1,2,3};
    int numsSize = sizeof(nums)/sizeof(nums[0]);
    int returnSize;
    int *returnColumnSizes;
    int **subsets = generateSubsets(nums, numsSize, &returnSize, &returnColumnSizes);
    for(int i=0; i<returnSize; ++i){
        printf(""["");
        for(int j=0; j<returnColumnSizes[i]; ++j){
            printf(""%d "", subsets[i][j]);
        }
        printf(""]\n"");
    }
    return 0;
}","python
def generate_subsets(nums):
    n = len(nums)
    subsets = []
    for i in range(1 << n):
        subset = []
        for j in range(n):
            if (i >> j) & 1:
                subset.append(nums[j])
        subsets.append(subset)
    return subsets

nums = [1, 2, 3]
subsets = generate_subsets(nums)
for subset in subsets:
    print(subset)","java
import java.util.*;

public class GenerateSubsets {
    public List<List<Integer>> generateSubsets(int[] nums) {
        int n = nums.length;
        int numSubsets = 1 << n;
        List<List<Integer>> subsets = new ArrayList<>(numSubsets);

        for (int i = 0; i < numSubsets; i++) {
            List<Integer> subset = new ArrayList<>();
            for (int j = 0; j < n; j++) {
                if ((i >> j) & 1) {
                    subset.add(nums[j]);
                }
            }
            subsets.add(subset);
        }
        return subsets;
    }

    public static void main(String[] args) {
        GenerateSubsets generator = new GenerateSubsets();
        int[] nums = {1, 2, 3};
        List<List<Integer>> subsets = generator.generateSubsets(nums);
        for (List<Integer> subset : subsets) {
            System.out.println(subset);
        }
    }
}","javascript
function generateSubsets(nums) {
  const n = nums.length;
  const subsets = [];

  for (let i = 0; i < (1 << n); i++) {
    const subset = [];
    for (let j = 0; j < n; j++) {
      if ((i >> j) & 1) {
        subset.push(nums[j]);
      }
    }
    subsets.push(subset);
  }
  return subsets;
}

const nums = [1, 2, 3];
const subsets = generateSubsets(nums);
console.log(subsets);","cpp
#include <iostream>
#include <vector>

std::vector<std::vector<int>> generateSubsets(const std::vector<int>& nums) {
    int n = nums.size();
    int numSubsets = 1 << n;
    std::vector<std::vector<int>> subsets(numSubsets);

    for (int i = 0; i < numSubsets; ++i) {
        for (int j = 0; j < n; ++j) {
            if ((i >> j) & 1) {
                subsets[i].push_back(nums[j]);
            }
        }
    }
    return subsets;
}

int main() {
    std::vector<int> nums = {1, 2, 3};
    std::vector<std::vector<int>> subsets = generateSubsets(nums);
    for (const auto& subset : subsets) {
        std::cout << ""["";
        for (int i = 0; i < subset.size(); ++i) {
            std::cout << subset[i] << (i == subset.size() - 1 ? """" : "" "");
        }
        std::cout << ""]\n"";
    }
    return 0;
}",3.6
Orange-23,Generate All Permutations,,,,,,"[object Object],[object Object],[object Object],[object Object]","#include <stdio.h>
#include <string.h>
#include <stdlib.h>

void permute(char *str, int l, int r, char ***result, int *count) {
    if (l == r) {
        (*result) = realloc((*result), (*count + 1) * sizeof(char *));
        (*result)[(*count)] = strdup(str);
        (*count)++;
    } else {
        for (int i = l; i <= r; i++) {
            char temp = str[l];
            str[l] = str[i];
            str[i] = temp;

            permute(str, l + 1, r, result, count);

            temp = str[l];
            str[l] = str[i];
            str[i] = temp; // backtrack
        }
    }
}

int main() {
    char str[10];
    scanf(""%s"", str);
    int n = strlen(str);
    char **result = NULL;
    int count = 0;
    permute(str, 0, n - 1, &result, &count);
    for (int i = 0; i < count; i++) {
        printf(""%s\n"", result[i]);
        free(result[i]);
    }
    free(result);
    return 0;
}","import itertools

def generate_permutations(s):
    return list("""".join(p) for p in itertools.permutations(s))

if __name__ == ""__main__"":
    s = input()
    permutations = generate_permutations(s)
    for permutation in permutations:
        print(permutation)","import java.util.*;

public class Permutations {
    public static void permute(String str, int l, int r, List<String> result) {
        if (l == r) {
            result.add(str);
        } else {
            for (int i = l; i <= r; i++) {
                String swapped = swap(str, l, i);
                permute(swapped, l + 1, r, result);
            }
        }
    }

    public static String swap(String a, int i, int j) {
        char temp;
        char[] charArray = a.toCharArray();
        temp = charArray[i];
        charArray[i] = charArray[j];
        charArray[j] = temp;
        return String.valueOf(charArray);
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String str = scanner.nextLine();
        List<String> result = new ArrayList<>();
        permute(str, 0, str.length() - 1, result);
        for (String s : result) {
            System.out.println(s);
        }
        scanner.close();
    }
}","function permute(str, l, r, result) {
  if (l === r) {
    result.push(str);
  } else {
    for (let i = l; i <= r; i++) {
      let swapped = swap(str, l, i);
      permute(swapped, l + 1, r, result);
    }
  }
}

function swap(str, i, j) {
  let arr = str.split('');
  [arr[i], arr[j]] = [arr[j], arr[i]];
  return arr.join('');
}

let str = require('readline-sync').question();
let result = [];
permute(str, 0, str.length - 1, result);
result.forEach(s => console.log(s));","#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

using namespace std;

void permute(string str, int l, int r, vector<string>& result) {
    if (l == r) {
        result.push_back(str);
    } else {
        for (int i = l; i <= r; i++) {
            swap(str[l], str[i]);
            permute(str, l + 1, r, result);
            swap(str[l], str[i]); // backtrack
        }
    }
}

int main() {
    string str;
    cin >> str;
    vector<string> result;
    permute(str, 0, str.length() - 1, result);
    for (const string& s : result) {
        cout << s << endl;
    }
    return 0;
}",3.6
Orange-24,Rat in a Maze,,,,,,"[object Object],[object Object],[object Object]","#include <stdio.h>
#include <stdbool.h>

#define N 20

bool solveMazeUtil(int maze[N][N], int x, int y, int sol[N][N], int n);

void printSolution(int sol[N][N], int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++)
            printf(""%d "", sol[i][j]);
        printf(""\n"");
    }
}

bool solveMaze(int maze[N][N], int n) {
    int sol[N][N] = {{0}};
    if (solveMazeUtil(maze, 0, 0, sol, n) == false) {
        printf(""No Path Exists"");
        return false;
    }
    printSolution(sol, n);
    return true;
}

bool solveMazeUtil(int maze[N][N], int x, int y, int sol[N][N], int n) {
    if (x == n - 1 && y == n - 1 && maze[x][y] == 1) {
        sol[x][y] = 1;
        printf(""(%d,%d)\n"",x,y);
        return true;
    }

    if (x >= 0 && x < n && y >= 0 && y < n && maze[x][y] == 1) {
        sol[x][y] = 1;
        printf(""(%d,%d)\n"",x,y);
        if (solveMazeUtil(maze, x + 1, y, sol, n))
            return true;
        if (solveMazeUtil(maze, x, y + 1, sol, n))
            return true;
        if (solveMazeUtil(maze, x - 1, y, sol, n))
            return true;
        if (solveMazeUtil(maze, x, y - 1, sol, n))
            return true;
        sol[x][y] = 0; // Backtrack
    }
    return false;
}

int main() {
    int n;
    scanf(""%d"", &n);
    int maze[N][N];
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            scanf(""%d"", &maze[i][j]);
        }
    }
    solveMaze(maze, n);
    return 0;
}","def solve_maze_util(maze, x, y, sol, n):
    if x == n - 1 and y == n - 1 and maze[x][y] == 1:
        sol[x][y] = 1
        print(f'({x},{y})')
        return True

    if x >= 0 and x < n and y >= 0 and y < n and maze[x][y] == 1:
        sol[x][y] = 1
        print(f'({x},{y})')
        if solve_maze_util(maze, x + 1, y, sol, n):
            return True
        if solve_maze_util(maze, x, y + 1, sol, n):
            return True
        if solve_maze_util(maze, x - 1, y, sol, n):
            return True
        if solve_maze_util(maze, x, y - 1, sol, n):
            return True
        sol[x][y] = 0  # Backtrack
    return False


def solve_maze(maze, n):
    sol = [[0 for _ in range(n)] for _ in range(n)]
    if not solve_maze_util(maze, 0, 0, sol, n):
        print(""No Path Exists"")
        return False
    return True

if __name__ == ""__main__"":
    n = int(input())
    maze = []
    for _ in range(n):
        row = list(map(int, input().split()))
        maze.append(row)
    solve_maze(maze, n)","import java.util.Scanner;

public class RatInAMaze {

    private static final int N = 20;

    static boolean solveMazeUtil(int[][] maze, int x, int y, int[][] sol, int n) {
        if (x == n - 1 && y == n - 1 && maze[x][y] == 1) {
            sol[x][y] = 1;
            System.out.println(""("" + x + "","" + y + "")"");
            return true;
        }

        if (x >= 0 && x < n && y >= 0 && y < n && maze[x][y] == 1) {
            sol[x][y] = 1;
            System.out.println(""("" + x + "","" + y + "")"");
            if (solveMazeUtil(maze, x + 1, y, sol, n))
                return true;
            if (solveMazeUtil(maze, x, y + 1, sol, n))
                return true;
            if (solveMazeUtil(maze, x - 1, y, sol, n))
                return true;
            if (solveMazeUtil(maze, x, y - 1, sol, n))
                return true;
            sol[x][y] = 0; // Backtrack
        }
        return false;
    }

    static boolean solveMaze(int[][] maze, int n) {
        int[][] sol = new int[n][n];
        if (!solveMazeUtil(maze, 0, 0, sol, n)) {
            System.out.println(""No Path Exists"");
            return false;
        }
        return true;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[][] maze = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                maze[i][j] = sc.nextInt();
            }
        }
        solveMaze(maze, n);
        sc.close();
    }
}","//This solution uses a slightly different approach to output, as direct console output within a recursive function can be less manageable in JS.
function solveMazeUtil(maze, x, y, sol, n, path) {
    if (x === n - 1 && y === n - 1 && maze[x][y] === 1) {
        sol[x][y] = 1;
        path.push(`(${x},${y})`)
        return true;
    }

    if (x >= 0 && x < n && y >= 0 && y < n && maze[x][y] === 1) {
        sol[x][y] = 1;
        path.push(`(${x},${y})`)
        if (solveMazeUtil(maze, x + 1, y, sol, n, path))
            return true;
        if (solveMazeUtil(maze, x, y + 1, sol, n, path))
            return true;
        if (solveMazeUtil(maze, x - 1, y, sol, n, path))
            return true;
        if (solveMazeUtil(maze, x, y - 1, sol, n, path))
            return true;
        sol[x][y] = 0; // Backtrack
        path.pop();
    }
    return false;
}

function solveMaze(maze, n) {
    let sol = Array.from(Array(n), () => new Array(n).fill(0));
    let path = [];
    if (!solveMazeUtil(maze, 0, 0, sol, n, path)) {
        console.log(""No Path Exists"");
        return false;
    }
    console.log(path.join('\n'));
    return true;
}

const readline = require('readline').createInterface({
    input: process.stdin,
    output: process.stdout,
});

readline.question('', (n) => {
    n = parseInt(n);
    let maze = [];
    for (let i = 0; i < n; i++) {
        let row = readline.question('').trim().split(' ').map(Number);
        maze.push(row);
    }
    solveMaze(maze, n);
    readline.close();
});","#include <iostream>
#include <vector>

using namespace std;

bool solveMazeUtil(vector<vector<int>>& maze, int x, int y, vector<vector<int>>& sol, int n);

void printSolution(const vector<vector<int>>& sol, int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++)
            cout << sol[i][j] << "" "";
        cout << endl;
    }
}

bool solveMaze(vector<vector<int>>& maze, int n) {
    vector<vector<int>> sol(n, vector<int>(n, 0));
    if (!solveMazeUtil(maze, 0, 0, sol, n)) {
        cout << ""No Path Exists"" << endl;
        return false;
    }
    printSolution(sol, n);
    return true;
}

bool solveMazeUtil(vector<vector<int>>& maze, int x, int y, vector<vector<int>>& sol, int n) {
    if (x == n - 1 && y == n - 1 && maze[x][y] == 1) {
        sol[x][y] = 1;
        cout << ""("" << x << "","" << y << "")\n"";
        return true;
    }

    if (x >= 0 && x < n && y >= 0 && y < n && maze[x][y] == 1) {
        sol[x][y] = 1;
        cout << ""("" << x << "","" << y << "")\n"";
        if (solveMazeUtil(maze, x + 1, y, sol, n))
            return true;
        if (solveMazeUtil(maze, x, y + 1, sol, n))
            return true;
        if (solveMazeUtil(maze, x - 1, y, sol, n))
            return true;
        if (solveMazeUtil(maze, x, y - 1, sol, n))
            return true;
        sol[x][y] = 0; // Backtrack
    }
    return false;
}

int main() {
    int n;
    cin >> n;
    vector<vector<int>> maze(n, vector<int>(n));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cin >> maze[i][j];
        }
    }
    solveMaze(maze, n);
    return 0;
}",3.6
Orange-25,Next Greater/Smaller Element (Monotonic Stack),,,,,,"[object Object],[object Object],[object Object],[object Object]","#include <stdio.h>
#include <stdlib.h>

int* nextGreaterElements(int* nums, int numsSize, int* returnSize){
    int *result = (int*)malloc(sizeof(int) * numsSize);
    *returnSize = numsSize;
    int stack[numsSize];
    int top = -1;
    for(int i = 0; i < 2 * numsSize; i++){
        int index = i % numsSize;
        while(top != -1 && nums[stack[top]] < nums[index]){
            result[stack[top]] = nums[index];
            top--;
        }
        if(i < numsSize) stack[++top] = index;
    }
    while(top != -1){
        result[stack[top]] = -1;
        top--;
    }
    return result;
}

int main(){
    int nums[] = {1,2,1};
    int numsSize = sizeof(nums)/sizeof(nums[0]);
    int returnSize;
    int *result = nextGreaterElements(nums, numsSize, &returnSize);
    for(int i = 0; i < returnSize; i++){
        printf(""%d "", result[i]);
    }
    printf(""\n"");
    free(result);
    return 0;
}","def nextGreaterElements(nums):
    n = len(nums)
    result = [-1] * n
    stack = []
    for i in range(2 * n):
        index = i % n
        while stack and nums[stack[-1]] < nums[index]:
            result[stack.pop()] = nums[index]
        if i < n:
            stack.append(index)
    return result

nums = [1, 2, 1]
result = nextGreaterElements(nums)
print(*result)","import java.util.*;

class Solution {
    public int[] nextGreaterElements(int[] nums) {
        int n = nums.length;
        int[] result = new int[n];
        Arrays.fill(result, -1);
        Stack<Integer> stack = new Stack<>();
        for (int i = 0; i < 2 * n; ++i) {
            int index = i % n;
            while (!stack.isEmpty() && nums[stack.peek()] < nums[index]) {
                result[stack.pop()] = nums[index];
            }
            if (i < n) stack.push(index);
        }
        return result;
    }

    public static void main(String[] args) {
        Solution sol = new Solution();
        int[] nums = {1, 2, 1};
        int[] result = sol.nextGreaterElements(nums);
        for (int i = 0; i < result.length; ++i) {
            System.out.print(result[i] + "" "");
        }
        System.out.println();
    }
}","function nextGreaterElements(nums) {
  const n = nums.length;
  const result = new Array(n).fill(-1);
  const stack = [];
  for (let i = 0; i < 2 * n; ++i) {
    const index = i % n;
    while (stack.length > 0 && nums[stack[stack.length - 1]] < nums[index]) {
      result[stack.pop()] = nums[index];
    }
    if (i < n) {
      stack.push(index);
    }
  }
  return result;
}

const nums = [1, 2, 1];
const result = nextGreaterElements(nums);
console.log(...result);","#include <iostream>
#include <vector>
#include <stack>

std::vector<int> nextGreaterElements(std::vector<int>& nums) {
    int n = nums.size();
    std::vector<int> result(n, -1);
    std::stack<int> s;
    for (int i = 0; i < 2 * n; ++i) {
        int index = i % n;
        while (!s.empty() && nums[s.top()] < nums[index]) {
            result[s.top()] = nums[index];
            s.pop();
        }
        if (i < n) s.push(index);
    }
    return result;
}

int main() {
    std::vector<int> nums = {1, 2, 1};
    std::vector<int> result = nextGreaterElements(nums);
    for (int i = 0; i < result.size(); ++i) {
        std::cout << result[i] << "" "";
    }
    std::cout << std::endl;
    return 0;
}",4.2
Orange-26,Sliding Window Maximum (Deque) - Real-time Stock Prices,,,,,,"3 9
1 10
2 15
3 12
4 18
5 20
6 16
7 22
8 25
9 21
","#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

#include <limits.h>
#include <time.h>

//Structure to represent a pair (timestamp, price)
typedef struct {
    int timestamp;
    int price;
} DataPoint;

// Function to add a new data point and adjust the deque
void updateDeque(DataPoint *point, int k, DataPoint *dq, int *dq_size, int *dq_head){
    //Remove elements outside the window
    while(*dq_size > 0 && dq[*dq_head].timestamp <= point->timestamp -k){
        (*dq_size)--;
        (*dq_head)++;
    }
    // Remove smaller elements from the back of the deque
    while(*dq_size > 0 && dq[*dq_size + *dq_head-1].price < point->price){
        (*dq_size)--;
    }
    //Add the new point to the deque
    dq[*dq_size + *dq_head]= *point;
    (*dq_size)++;
}


int main() {
    int k, numPoints;
    scanf(""%d %d"", &k, &numPoints);

    DataPoint *points = (DataPoint *)malloc(numPoints * sizeof(DataPoint));
    for (int i = 0; i < numPoints; i++) {
        scanf(""%d %d"", &points[i].timestamp, &points[i].price);
    }

    DataPoint dq[numPoints]; //Deque to store data points
    int dq_size = 0; // Number of elements in the deque
    int dq_head = 0;  // Index of the head of the deque 

    for(int i = 0; i < numPoints; i++){
        updateDeque(&points[i], k, dq, &dq_size, &dq_head);
        if(i >= k-1){
            printf(""(%d, %d) "", points[i].timestamp, dq[dq_head].price);
        }
    }
    printf(""\n"");
    free(points);
    return 0;
}","from collections import deque

class DataPoint:
    def __init__(self, timestamp, price):
        self.timestamp = timestamp
        self.price = price

k, num_points = map(int, input().split())

points = []
for _ in range(num_points):
    timestamp, price = map(int, input().split())
    points.append(DataPoint(timestamp, price))

dq = deque()

for i in range(num_points):
    while dq and dq[0].timestamp <= points[i].timestamp - k:
        dq.popleft()
    while dq and dq[-1].price < points[i].price:
        dq.pop()
    dq.append(points[i])

    if i >= k - 1:
        print(f'({points[i].timestamp}, {dq[0].price}) ', end='')
print()","import java.util.*;

class DataPoint {
    int timestamp;
    int price;
    DataPoint(int timestamp, int price) {
        this.timestamp = timestamp;
        this.price = price;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int k = scanner.nextInt();
        int numPoints = scanner.nextInt();

        List<DataPoint> points = new ArrayList<>();
        for (int i = 0; i < numPoints; i++) {
            points.add(new DataPoint(scanner.nextInt(), scanner.nextInt()));
        }

        Deque<DataPoint> dq = new LinkedList<>();

        for (int i = 0; i < numPoints; i++) {
            while (!dq.isEmpty() && dq.peekFirst().timestamp <= points.get(i).timestamp - k) {
                dq.pollFirst();
            }
            while (!dq.isEmpty() && dq.peekLast().price < points.get(i).price) {
                dq.pollLast();
            }
            dq.offerLast(points.get(i));

            if (i >= k - 1) {
                System.out.print(""("" + points.get(i).timestamp + "", "" + dq.peekFirst().price + "") "");
            }
        }
        System.out.println();
        scanner.close();
    }
}","class DataPoint {
    constructor(timestamp, price) {
        this.timestamp = timestamp;
        this.price = price;
    }
}

function solve() {
    const readline = require('readline').createInterface({
        input: process.stdin,
        output: process.stdout,
    });

    readline.on('line', (line) => {
        const [k, numPoints] = line.split(' ').map(Number);
        const points = [];
        for (let i = 0; i < numPoints; i++) {
            const [timestamp, price] = readline.question().split(' ').map(Number);
            points.push(new DataPoint(timestamp, price));
        }

        const dq = [];
        for (let i = 0; i < numPoints; i++) {
            while (dq.length > 0 && dq[0].timestamp <= points[i].timestamp - k) {
                dq.shift();
            }
            while (dq.length > 0 && dq[dq.length - 1].price < points[i].price) {
                dq.pop();
            }
            dq.push(points[i]);
            if (i >= k - 1) {
                process.stdout.write(`(${points[i].timestamp}, ${dq[0].price}) `);
            }
        }
        process.stdout.write('\n');
        readline.close();
    });
}

solve();","#include <iostream>
#include <deque>
#include <vector>

using namespace std;

struct DataPoint {
    int timestamp;
    int price;
};

int main() {
    int k, numPoints;
    cin >> k >> numPoints;

    vector<DataPoint> points(numPoints);
    for (int i = 0; i < numPoints; i++) {
        cin >> points[i].timestamp >> points[i].price;
    }

    deque<DataPoint> dq;

    for (int i = 0; i < numPoints; i++) {
        // Remove elements outside the window
        while (!dq.empty() && dq.front().timestamp <= points[i].timestamp - k) {
            dq.pop_front();
        }
        // Remove smaller elements from the back
        while (!dq.empty() && dq.back().price < points[i].price) {
            dq.pop_back();
        }
        dq.push_back(points[i]);

        if (i >= k - 1) {
            cout << ""("" << points[i].timestamp << "", "" << dq.front().price << "") "";
        }
    }
    cout << endl;
    return 0;
}",3.8
Orange-27,Quick Sort,,,,,,"[object Object],[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]","#include <stdio.h>
#include <stdlib.h>
#include <time.h>

void swap(int *a, int *b) {
    int temp = *a;
    *a = *b;
    *b = temp;
}

int partition(int arr[], int low, int high) {
    srand(time(NULL));
    int pivotIndex = low + rand() % (high - low + 1);
    int pivot = arr[pivotIndex];
    swap(&arr[pivotIndex], &arr[high]);
    int i = (low - 1);
    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

void quickSort(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int main() {
    int arr[] = {10, 7, 8, 9, 1, 5};
    int n = sizeof(arr) / sizeof(arr[0]);
    quickSort(arr, 0, n - 1);
    for (int i = 0; i < n; i++)
        printf(""%d "", arr[i]);
    printf(""\n"");
    return 0;
}","import random

def partition(arr, low, high):
    pivot_index = random.randint(low, high)
    pivot = arr[pivot_index]
    arr[pivot_index], arr[high] = arr[high], arr[pivot_index]
    i = low - 1
    for j in range(low, high):
        if arr[j] < pivot:
            i += 1
            arr[i], arr[j] = arr[j], arr[i]
    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return i + 1

def quick_sort(arr, low, high):
    if low < high:
        pi = partition(arr, low, high)
        quick_sort(arr, low, pi - 1)
        quick_sort(arr, pi + 1, high)

arr = [10, 7, 8, 9, 1, 5]
quick_sort(arr, 0, len(arr) - 1)
print(*arr) #Prints the array elements separated by spaces","import java.util.Arrays;
import java.util.Random;

public class QuickSort {

    public static void quickSort(int[] arr, int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high);
            quickSort(arr, low, pi - 1);
            quickSort(arr, pi + 1, high);
        }
    }

    public static int partition(int[] arr, int low, int high) {
        Random rand = new Random();
        int pivotIndex = low + rand.nextInt(high - low + 1);
        int pivot = arr[pivotIndex];
        swap(arr, pivotIndex, high);
        int i = (low - 1);
        for (int j = low; j <= high - 1; j++) {
            if (arr[j] < pivot) {
                i++;
                swap(arr, i, j);
            }
        }
        swap(arr, i + 1, high);
        return (i + 1);
    }

    public static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    public static void main(String[] args) {
        int[] arr = {10, 7, 8, 9, 1, 5};
        quickSort(arr, 0, arr.length - 1);
        System.out.println(Arrays.toString(arr));
    }
}","function partition(arr, low, high) {
  const pivotIndex = Math.floor(Math.random() * (high - low + 1)) + low;
  const pivot = arr[pivotIndex];
  [arr[pivotIndex], arr[high]] = [arr[high], arr[pivotIndex]]; // Swap pivot to end
  let i = low - 1;
  for (let j = low; j < high; j++) {
    if (arr[j] < pivot) {
      i++;
      [arr[i], arr[j]] = [arr[j], arr[i]]; // Swap elements
    }
  }
  [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]]; // Swap pivot to its final position
  return i + 1;
}

function quickSort(arr, low, high) {
  if (low < high) {
    const pi = partition(arr, low, high);
    quickSort(arr, low, pi - 1);
    quickSort(arr, pi + 1, high);
  }
}

let arr = [10, 7, 8, 9, 1, 5];
quickSort(arr, 0, arr.length - 1);
console.log(arr.join("" "")); // Output array to console","#include <iostream>
#include <vector>
#include <algorithm>
#include <random>

using namespace std;

int partition(vector<int>& arr, int low, int high) {
    random_device rd;
    mt19937 g(rd());
    uniform_int_distribution<> distrib(low, high);
    int pivotIndex = distrib(g);
    int pivot = arr[pivotIndex];
    swap(arr[pivotIndex], arr[high]);
    int i = (low - 1);
    for (int j = low; j <= high - 1; j++) {
        if (arr[j] < pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return (i + 1);
}

void quickSort(vector<int>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSort(arr, low, pi - 1);
        quickSort(arr, pi + 1, high);
    }
}

int main() {
    vector<int> arr = {10, 7, 8, 9, 1, 5};
    quickSort(arr, 0, arr.size() - 1);
    for (int x : arr) cout << x << "" "";
    cout << endl;
    return 0;
}",3.9
Orange-28,Merge Sort,,,,,,"[object Object],[object Object],[object Object],[object Object],[object Object]","#include <stdio.h>
#include <stdlib.h>

void merge(int arr[], int l, int m, int r) {
    int i, j, k;
    int n1 = m - l + 1;
    int n2 = r - m;

    int L[n1], R[n2];

    for (i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];

    i = 0, j = 0, k = l;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

void mergeSort(int arr[], int l, int r) {
    if (l < r) {
        int m = l + (r - l) / 2;
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}

int main() {
    int n, i;
    scanf(""%d"", &n);
    int arr[n];
    for (i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]);
    }
    mergeSort(arr, 0, n - 1);
    for (i = 0; i < n; i++) {
        printf(""%d "", arr[i]);
    }
    printf(""\n"");
    return 0;
}","def merge(arr, l, m, r):
    n1 = m - l + 1
    n2 = r - m

    L = [0] * (n1)
    R = [0] * (n2)

    for i in range(0, n1):
        L[i] = arr[l + i]
    for j in range(0, n2):
        R[j] = arr[m + 1 + j]

    i = 0
    j = 0
    k = l
    while i < n1 and j < n2:
        if L[i] <= R[j]:
            arr[k] = L[i]
            i += 1
        else:
            arr[k] = R[j]
            j += 1
        k += 1

    while i < n1:
        arr[k] = L[i]
        i += 1
        k += 1

    while j < n2:
        arr[k] = R[j]
        j += 1
        k += 1

def mergeSort(arr, l, r):
    if l < r:
        m = l + (r - l) // 2
        mergeSort(arr, l, m)
        mergeSort(arr, m + 1, r)
        merge(arr, l, m, r)

n = int(input())
arr = list(map(int, input().split()))
mergeSort(arr, 0, n - 1)
print(*arr)","import java.util.*;

public class MergeSort {

    public static void merge(int[] arr, int l, int m, int r) {
        int n1 = m - l + 1;
        int n2 = r - m;

        int[] L = new int[n1];
        int[] R = new int[n2];

        System.arraycopy(arr, l, L, 0, n1);
        System.arraycopy(arr, m + 1, R, 0, n2);

        int i = 0, j = 0, k = l;
        while (i < n1 && j < n2) {
            if (L[i] <= R[j]) {
                arr[k] = L[i];
                i++;
            } else {
                arr[k] = R[j];
                j++;
            }
            k++;
        }

        while (i < n1) {
            arr[k] = L[i];
            i++;
            k++;
        }

        while (j < n2) {
            arr[k] = R[j];
            j++;
            k++;
        }
    }

    public static void mergeSort(int[] arr, int l, int r) {
        if (l < r) {
            int m = l + (r - l) / 2;
            mergeSort(arr, l, m);
            mergeSort(arr, m + 1, r);
            merge(arr, l, m, r);
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        mergeSort(arr, 0, n - 1);
        for (int i = 0; i < n; i++) {
            System.out.print(arr[i] + "" "");
        }
        System.out.println();
        sc.close();
    }
}","function merge(arr, l, m, r) {
    let n1 = m - l + 1;
    let n2 = r - m;

    let L = new Array(n1);
    let R = new Array(n2);

    for (let i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (let j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];

    let i = 0, j = 0, k = l;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

function mergeSort(arr, l, r) {
    if (l < r) {
        let m = l + Math.floor((r - l) / 2);
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}

let n = parseInt(process.argv[2]);
let arr = process.argv.slice(3).map(Number);
mergeSort(arr, 0, n - 1);
console.log(arr.join("" ""));","#include <iostream>
#include <vector>

void merge(std::vector<int>& arr, int l, int m, int r) {
    int n1 = m - l + 1;
    int n2 = r - m;

    std::vector<int> L(n1), R(n2);

    for (int i = 0; i < n1; i++)
        L[i] = arr[l + i];
    for (int j = 0; j < n2; j++)
        R[j] = arr[m + 1 + j];

    int i = 0, j = 0, k = l;
    while (i < n1 && j < n2) {
        if (L[i] <= R[j]) {
            arr[k] = L[i];
            i++;
        } else {
            arr[k] = R[j];
            j++;
        }
        k++;
    }

    while (i < n1) {
        arr[k] = L[i];
        i++;
        k++;
    }

    while (j < n2) {
        arr[k] = R[j];
        j++;
        k++;
    }
}

void mergeSort(std::vector<int>& arr, int l, int r) {
    if (l < r) {
        int m = l + (r - l) / 2;
        mergeSort(arr, l, m);
        mergeSort(arr, m + 1, r);
        merge(arr, l, m, r);
    }
}

int main() {
    int n;
    std::cin >> n;
    std::vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        std::cin >> arr[i];
    }
    mergeSort(arr, 0, n - 1);
    for (int i = 0; i < n; i++) {
        std::cout << arr[i] << "" "";
    }
    std::cout << std::endl;
    return 0;
}",3.8
Orange-29,Counting Sort,,,,,,"[object Object],[object Object],[object Object],[object Object]","#include <stdio.h>
#include <stdlib.h>

void countingSort(int arr[], int n) {
    int max = arr[0];
    for (int i = 1; i < n; i++) {
        if (arr[i] > max) {
            max = arr[i];
        }
    }

    int *count = (int *)calloc(max + 1, sizeof(int));
    for (int i = 0; i < n; i++) {
        count[arr[i]]++;
    }

    int k = 0;
    for (int i = 0; i <= max; i++) {
        for (int j = 0; j < count[i]; j++) {
            arr[k++] = i;
        }
    }
    free(count);
}

int main() {
    int n;
    scanf(""%d"", &n);
    int arr[n];
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]);
    }
    countingSort(arr, n);
    for (int i = 0; i < n; i++) {
        printf(""%d "", arr[i]);
    }
    printf(""\n"");
    return 0;
}","def counting_sort(arr):
    if not arr:
        return
    max_val = max(arr)
    count = [0] * (max_val + 1)
    for num in arr:
        count[num] += 1
    
    sorted_arr = []
    for i in range(len(count)):
        sorted_arr.extend([i] * count[i])
    return sorted_arr

n = int(input())
arr = list(map(int, input().split()))
sorted_arr = counting_sort(arr)
print(*sorted_arr)","import java.util.*;

public class CountingSort {
    public static void countingSort(int[] arr) {
        if (arr.length == 0) return;
        int max = arr[0];
        for (int x : arr) {
            if (x > max) max = x;
        }

        int[] count = new int[max + 1];
        for (int x : arr) {
            count[x]++;
        }

        int k = 0;
        for (int i = 0; i <= max; i++) {
            for (int j = 0; j < count[i]; j++) {
                arr[k++] = i;
            }
        }
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = sc.nextInt();
        }
        countingSort(arr);
        for (int i = 0; i < n; i++) {
            System.out.print(arr[i] + "" "");
        }
        System.out.println();
        sc.close();
    }
}","function countingSort(arr) {
  if (arr.length === 0) return [];
  let max = arr[0];
  for (let i = 1; i < arr.length; i++) {
    if (arr[i] > max) max = arr[i];
  }

  const count = new Array(max + 1).fill(0);
  for (let num of arr) {
    count[num]++;
  }

  const sortedArr = [];
  for (let i = 0; i <= max; i++) {
    for (let j = 0; j < count[i]; j++) {
      sortedArr.push(i);
    }
  }
  return sortedArr;
}

const n = parseInt(readline());
const arr = readline().split(' ').map(Number);
const sortedArr = countingSort(arr);
console.log(sortedArr.join(' '));","#include <iostream>
#include <vector>

void countingSort(std::vector<int>& arr) {
    if (arr.empty()) return;
    int max = arr[0];
    for (int x : arr) {
        if (x > max) max = x;
    }

    std::vector<int> count(max + 1, 0);
    for (int x : arr) {
        count[x]++;
    }

    int k = 0;
    for (int i = 0; i <= max; i++) {
        for (int j = 0; j < count[i]; j++) {
            arr[k++] = i;
        }
    }
}

int main() {
    int n;
    std::cin >> n;
    std::vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        std::cin >> arr[i];
    }
    countingSort(arr);
    for (int i = 0; i < n; i++) {
        std::cout << arr[i] << "" "";
    }
    std::cout << std::endl;
    return 0;
}",3.6
Orange-30,Cycle Detection (Fast/Slow Pointers),,,,,,"[{""input"":{""expectedPackets"":5,""stream"":[1,2,3,5]},""output"":""true""},{""input"":{""expectedPackets"":3,""stream"":[1,2,3]},""output"":""false""},{""input"":{""expectedPackets"":3,""stream"":[1,3,2]},""output"":""true""},{""input"":{""expectedPackets"":10,""stream"":[1,2,3,4,5,6,7,8,9,10]},""output"":""false""},{""input"":{""expectedPackets"":5,""stream"":[1,2,3,4,6,7]},""output"":""true""}]","#include <stdio.h>
#include <stdbool.h>

bool isDataCorrupted(int expectedPackets) {
    int expectedSeq = 1;
    int receivedPacket;
    for (int i = 0; i < expectedPackets; i++) {
        if (scanf(""%d"", &receivedPacket) != 1) return true; //Handle input failure
        if (receivedPacket != expectedSeq) return true;
        expectedSeq++;
    }
    return false;
}

int main() {
    int expectedPackets;
    scanf(""%d"", &expectedPackets);
    bool result = isDataCorrupted(expectedPackets);
    printf(""%s\n"", result ? ""true"" : ""false"");
    return 0;
}","def is_data_corrupted(expected_packets):
    expected_seq = 1
    for _ in range(expected_packets):
        try:
            received_packet = int(input())
        except ValueError:
            return True  #Handle input failure
        if received_packet != expected_seq:
            return True
        expected_seq += 1
    return False

if __name__ == ""__main__"":
    expected_packets = int(input())
    result = is_data_corrupted(expected_packets)
    print(""true"" if result else ""false"")","import java.util.Scanner;

public class DataCorruptionDetector {
    public static boolean isDataCorrupted(int expectedPackets) {
        Scanner scanner = new Scanner(System.in);
        int expectedSeq = 1;
        int receivedPacket;
        for (int i = 0; i < expectedPackets; i++) {
            if (!scanner.hasNextInt()) return true; //Handle input failure
            receivedPacket = scanner.nextInt();
            if (receivedPacket != expectedSeq) return true;
            expectedSeq++;
        }
        scanner.close();
        return false;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int expectedPackets = scanner.nextInt();
        boolean result = isDataCorrupted(expectedPackets);
        System.out.println(result ? ""true"" : ""false"");
        scanner.close();
    }
}","//This solution requires a way to input data sequentially. Node.js would use stdin.
function isDataCorrupted(expectedPackets) {
    let expectedSeq = 1;
    let receivedPacket;
    for (let i = 0; i < expectedPackets; i++) {
        //In a real Node.js app, you'd use readline or similar for stdin
        receivedPacket = parseInt(prompt()); //Replace with proper stdin reading
        if (isNaN(receivedPacket)) return true;//Handle input failure
        if (receivedPacket != expectedSeq) return true;
        expectedSeq++;
    }
    return false;
}

//Example usage (replace with stdin handling)
let expectedPackets = parseInt(prompt());
let result = isDataCorrupted(expectedPackets);
console.log(result ? ""true"" : ""false"");","#include <iostream>

bol isDataCorrupted(int expectedPackets) {
    int expectedSeq = 1;
    int receivedPacket;
    for (int i = 0; i < expectedPackets; i++) {
        if (!(std::cin >> receivedPacket)) return true; //Handle input failure
        if (receivedPacket != expectedSeq) return true;
        expectedSeq++;
    }
    return false;
}

int main() {
    int expectedPackets;
    std::cin >> expectedPackets;
    bool result = isDataCorrupted(expectedPackets);
    std::cout << (result ? ""true"" : ""false"") << std::endl;
    return 0;
}",2.4
Orange-31,First/Last Occurrence in Sorted Array,,,,,,"[{""matrix"": [[1, 3, 5], [2, 4, 8], [6, 10, 12]], ""min"": 3, ""max"": 8, ""expected"": [3, 4, 5, 6, 8]}, {""matrix"": [[1, 3, 5], [2, 4, 8], [6, 10, 12]], ""min"": 13, ""max"": 15, ""expected"": []}, {""matrix"": [], ""min"": 1, ""max"": 10, ""expected"": []}, {""matrix"": [[1,2],[3,4]], ""min"": 2, ""max"": 3, ""expected"": [2,3]}, {""matrix"": [[1,1,1],[1,1,1],[1,1,1]], ""min"": 1, ""max"": 1, ""expected"": [1]}]","#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

int compare_ints(const void *a, const void *b) {
    return *(int *)a - *(int *)b;
}

int* rangeSearch(int matrix[][100], int rows, int cols, int min, int max, int *count) {
    *count = 0; 
    int *result = malloc(rows * cols * sizeof(int));
    int i = 0, j = cols - 1; 
    while (i < rows && j >= 0) {
        if (matrix[i][j] >= min && matrix[i][j] <= max) {
            result[(*count)++] = matrix[i][j];
            i++; j--; 
        } else if (matrix[i][j] < min) {
            i++; 
        } else {
            j--;
        }
    }
    qsort(result, *count, sizeof(int), compare_ints); 
    return result;
}

int main() {
    int matrix[100][100], rows, cols, min, max, count; 
    scanf(""%d %d"", &rows, &cols);
    for (int i = 0; i < rows; i++) {
        for (int j = 0; j < cols; j++) {
            scanf(""%d"", &matrix[i][j]);
        }
    }
    scanf(""%d %d"", &min, &max);
    int *result = rangeSearch(matrix, rows, cols, min, max, &count); 
    for (int i = 0; i < count; i++) {
        printf(""%d "", result[i]);
    }
    printf(""\n"");
    free(result);
    return 0;
}","def range_search(matrix, min, max):
    result = []
    rows = len(matrix)
    if rows == 0:
        return result
    cols = len(matrix[0])
    i, j = 0, cols - 1
    while i < rows and j >= 0:
        if min <= matrix[i][j] <= max:
            result.append(matrix[i][j])
            i += 1
            j -= 1
        elif matrix[i][j] < min:
            i += 1
        else:
            j -= 1
    result.sort()
    return result

rows, cols = map(int, input().split())
matrix = []
for _ in range(rows):
    row = list(map(int, input().split()))
    matrix.append(row)
min, max = map(int, input().split())
result = range_search(matrix, min, max)
print(*result)","import java.util.ArrayList;
import java.util.Collections;
import java.util.Scanner;

public class RangeSearch {

    public static ArrayList<Integer> rangeSearch(int[][] matrix, int min, int max) {
        ArrayList<Integer> result = new ArrayList<>();
        int rows = matrix.length;
        if (rows == 0) return result;
        int cols = matrix[0].length;
        int i = 0, j = cols - 1;
        while (i < rows && j >= 0) {
            if (matrix[i][j] >= min && matrix[i][j] <= max) {
                result.add(matrix[i][j]);
                i++; j--;
            } else if (matrix[i][j] < min) {
                i++;
            } else {
                j--;
            }
        }
        Collections.sort(result);
        return result;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int rows = scanner.nextInt();
        int cols = scanner.nextInt();
        int[][] matrix = new int[rows][cols];
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < cols; j++) {
                matrix[i][j] = scanner.nextInt();
            }
        }
        int min = scanner.nextInt();
        int max = scanner.nextInt();
        ArrayList<Integer> result = rangeSearch(matrix, min, max);
        for (int num : result) {
            System.out.print(num + "" "");
        }
        System.out.println();
        scanner.close();
    }
}","function rangeSearch(matrix, min, max) {
    const result = [];
    const rows = matrix.length;
    if (rows === 0) return result;
    const cols = matrix[0].length;
    let i = 0, j = cols - 1;
    while (i < rows && j >= 0) {
        if (matrix[i][j] >= min && matrix[i][j] <= max) {
            result.push(matrix[i][j]);
            i++;
            j--;
        } else if (matrix[i][j] < min) {
            i++;
        } else {
            j--;
        }
    }
    result.sort((a, b) => a - b);
    return result;
}

const readline = require('readline').createInterface({
    input: process.stdin,
    output: process.stdout,
});

readline.question('Enter rows and cols: ', (input) => {
    const [rows, cols] = input.split(' ').map(Number);
    const matrix = [];
    for (let i = 0; i < rows; i++) {
        readline.question(`Enter row ${i + 1}: `, (rowInput) => {
            matrix.push(rowInput.split(' ').map(Number));
            if (matrix.length === rows) {
                readline.question('Enter min and max: ', (minmaxInput) => {
                    const [min, max] = minmaxInput.split(' ').map(Number);
                    const result = rangeSearch(matrix, min, max);
                    console.log(result.join(' '));
                    readline.close();
                });
            }
        });
    }
});","#include <iostream>
#include <vector>
#include <algorithm>

std::vector<int> rangeSearch(const std::vector<std::vector<int>>& matrix, int min, int max) {
    std::vector<int> result;
    int rows = matrix.size();
    if (rows == 0) return result;
    int cols = matrix[0].size();
    int i = 0, j = cols - 1;
    while (i < rows && j >= 0) {
        if (matrix[i][j] >= min && matrix[i][j] <= max) {
            result.push_back(matrix[i][j]);
            i++; j--;
        } else if (matrix[i][j] < min) {
            i++;
        } else {
            j--;
        }
    }
    std::sort(result.begin(), result.end());
    return result;
}

int main() {
    int rows, cols, min, max;
    std::cin >> rows >> cols;
    std::vector<std::vector<int>> matrix(rows, std::vector<int>(cols));
    for (int i = 0; i < rows; ++i) {
        for (int j = 0; j < cols; ++j) {
            std::cin >> matrix[i][j];
        }
    }
    std::cin >> min >> max;
    std::vector<int> result = rangeSearch(matrix, min, max);
    for (int num : result) {
        std::cout << num << "" "";
    }
    std::cout << std::endl;
    return 0;
}",3
Orange-32,"Collision Handling (Chaining, Open Addressing)",,,,,,"[object Object],[object Object],[object Object]","c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Separate Chaining Solution (Illustrative -  Needs linked list implementation)
// ... (C code for separate chaining would go here) ...

// Linear Probing Solution
#define TABLE_SIZE 10

typedef struct {
    int key;
    int occupied;
} Entry;

Entry table[TABLE_SIZE];

int hash(int key) {
    return key % TABLE_SIZE;
}

void insertLinearProbing(int key) {
    int index = hash(key);
    int i = 0;
    while (table[(index + i) % TABLE_SIZE].occupied && i < TABLE_SIZE) {
        i++;
    }
    if (i < TABLE_SIZE) {
        table[(index + i) % TABLE_SIZE].key = key;
        table[(index + i) % TABLE_SIZE].occupied = 1;
    }
}

int searchLinearProbing(int key) {
    int index = hash(key);
    int i = 0;
    while (table[(index + i) % TABLE_SIZE].occupied && i < TABLE_SIZE) {
        if (table[(index + i) % TABLE_SIZE].key == key) {
            return 1;
        }
        i++;
    }
    return 0;
}

void deleteLinearProbing(int key) {
    //Implementation for deletion in linear probing (mark as unoccupied)
}

int main() {
    char op[10];
    int key;
    for (int i = 0; i < TABLE_SIZE; i++) {
        table[i].occupied = 0;
    }
    while (scanf(""%s %d"", op, &key) == 2) {
        if (strcmp(op, ""INSERT"") == 0) {
            insertLinearProbing(key);
        } else if (strcmp(op, ""SEARCH"") == 0) {
            if (searchLinearProbing(key)) {
                printf(""FOUND\n"");
            } else {
                printf(""NOT FOUND\n"");
            }
        } else if (strcmp(op, ""DELETE"") == 0) {
            deleteLinearProbing(key);
        }
    }
    return 0;
}","python
# Separate Chaining (Illustrative - needs LinkedList implementation)
# ... (Python code for separate chaining would go here) ...

# Linear Probing
class LinearProbingHashTable:
    def __init__(self, size):
        self.size = size
        self.table = [None] * size

    def hash(self, key):
        return abs(key) % self.size

    def insert(self, key):
        index = self.hash(key)
        i = 0
        while self.table[(index + i) % self.size] is not None and i < self.size:
            i += 1
        if i < self.size:
            self.table[(index + i) % self.size] = key

    def search(self, key):
        index = self.hash(key)
        i = 0
        while self.table[(index + i) % self.size] is not None and i < self.size:
            if self.table[(index + i) % self.size] == key:
                return True
            i += 1
        return False

    def delete(self,key): #Implementation needed
        pass

if __name__ == ""__main__"":
    ht = LinearProbingHashTable(10) #Choose your implementation
    while True:
        try:
            op, key = input().split()
            key = int(key)
            if op == ""INSERT"":
                ht.insert(key)
            elif op == ""SEARCH"":
                print(""FOUND"" if ht.search(key) else ""NOT FOUND"")
            elif op == ""DELETE"":
                ht.delete(key)
        except EOFError:
            break","java
import java.util.*;

public class HashTableCollision {

    //Separate Chaining (Illustrative - needs LinkedList implementation)
    // ... (Java code for separate chaining would go here) ...

    //Linear Probing
    static class LinearProbingHashTable {
        Entry[] table;
        int size;

        static class Entry {
            int key;
            boolean occupied;
            Entry(int k) { key = k; occupied = true; }
        }

        LinearProbingHashTable(int size) {
            this.size = size;
            table = new Entry[size];
        }

        int hash(int key) {
            return Math.abs(key) % size;
        }

        void insert(int key) {
            int index = hash(key);
            int i = 0;
            while (table[ (index + i) % size] != null && i < size) {
                i++;
            }
            if (i < size) table[(index + i) % size] = new Entry(key);
        }

        boolean search(int key) {
            int index = hash(key);
            int i = 0;
            while (table[(index + i) % size] != null && i < size) {
                if (table[(index + i) % size].key == key) return true;
                i++;
            }
            return false;
        }

        void deleteKey(int key) { //Implementation needed }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        LinearProbingHashTable ht = new LinearProbingHashTable(10); //Choose your implementation
        while (scanner.hasNext()) {
            String op = scanner.next();
            int key = scanner.nextInt();
            if (op.equals(""INSERT"")) ht.insert(key);
            else if (op.equals(""SEARCH"")) System.out.println(ht.search(key) ? ""FOUND"" : ""NOT FOUND"");
            else if (op.equals(""DELETE"")) ht.deleteKey(key);
        }
        scanner.close();
    }
}","javascript
// Separate Chaining (Illustrative - needs LinkedList implementation)
// ... (JavaScript code for separate chaining would go here) ...

// Linear Probing
class LinearProbingHashTable {
    constructor(size) {
        this.size = size;
        this.table = new Array(size).fill(null);
    }

    hash(key) {
        return Math.abs(key) % this.size;
    }

    insert(key) {
        let index = this.hash(key);
        let i = 0;
        while (this.table[(index + i) % this.size] !== null && i < this.size) {
            i++;
        }
        if (i < this.size) this.table[(index + i) % this.size] = key;
    }

    search(key) {
        let index = this.hash(key);
        let i = 0;
        while (this.table[(index + i) % this.size] !== null && i < this.size) {
            if (this.table[(index + i) % this.size] === key) return true;
            i++;
        }
        return false;
    }
    delete(key){ //Implementation needed }
}

const readline = require('readline').createInterface({
    input: process.stdin,
    output: process.stdout,
});

let ht = new LinearProbingHashTable(10); //Choose your implementation
readline.on('line', (line) => {
    const [op, key] = line.split(' ');
    if (op === 'INSERT') ht.insert(parseInt(key));
    else if (op === 'SEARCH') console.log(ht.search(parseInt(key)) ? 'FOUND' : 'NOT FOUND');
    else if (op === 'DELETE') ht.delete(parseInt(key));
});","cpp
#include <iostream>
#include <vector>
#include <list>

using namespace std;

// Separate Chaining
class SeparateChainingHashTable {
public:
    SeparateChainingHashTable(int size) : table_(size) {}
    void insert(int key) { table_[hash(key)].push_back(key); }
    bool search(int key) { for (int k : table_[hash(key)]) if (k == key) return true; return false; }
    void remove(int key) {  //Implementation needed
    }
private:
    int hash(int key) { return key % table_.size(); }
    vector<list<int>> table_;
};

//Linear Probing
class LinearProbingHashTable {
public:
    LinearProbingHashTable(int size) : table_(size, {0, false}) {}
    void insert(int key) {
        int index = hash(key);
        while (table_[index].occupied) {
            index = (index + 1) % table_.size();
        }
        table_[index] = {key, true};
    }
    bool search(int key) {
        int index = hash(key);
        while (table_[index].occupied) {
            if (table_[index].key == key) return true;
            index = (index + 1) % table_.size();
        }
        return false;
    }
    void remove(int key){ //Implementation needed
    }
private:
    struct Entry { int key; bool occupied; };
    int hash(int key) { return key % table_.size(); }
    vector<Entry> table_;
};

int main() {
    string op; int key; 
    LinearProbingHashTable ht(10); //Choose your implementation
    while (cin >> op >> key) {
        if (op == ""INSERT"") ht.insert(key);
        else if (op == ""SEARCH"") cout << (ht.search(key) ? ""FOUND\n"" : ""NOT FOUND\n"");
        else if (op == ""DELETE"") ht.remove(key);
    }
    return 0;
}",3.6
Orange-33,Merge Sort,,,,,,"[object Object],[object Object],[object Object],[object Object],[object Object]","c
#include <stdio.h>
#include <stdlib.h>

long long mergeSortAndCount(int arr[], int temp[], int left, int right);
long long merge(int arr[], int temp[], int left, int mid, int right);

long long mergeSortAndCount(int arr[], int temp[], int left, int right) {
    long long inv_count = 0;
    if (right > left) {
        int mid = left + (right - left) / 2;
        inv_count += mergeSortAndCount(arr, temp, left, mid);
        inv_count += mergeSortAndCount(arr, temp, mid + 1, right);
        inv_count += merge(arr, temp, left, mid, right);
    }
    return inv_count;
}

long long merge(int arr[], int temp[], int left, int mid, int right) {
    int i, j, k;
    long long inv_count = 0;
    i = left; j = mid + 1; k = left;
    while ((i <= mid) && (j <= right)) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
            inv_count = inv_count + (mid - i + 1);
        }
    }
    while (i <= mid) temp[k++] = arr[i++];
    while (j <= right) temp[k++] = arr[j++];
    for (i = left; i <= right; i++) arr[i] = temp[i];
    return inv_count;
}

int main() {
    int arr[] = {1, 3, 5, 2, 4, 6};
    int n = sizeof(arr) / sizeof(arr[0]);
    int temp[n];
    long long invCount = mergeSortAndCount(arr, temp, 0, n - 1);
    printf(""Sorted array:"");
    for (int i = 0; i < n; i++) printf("" %d"", arr[i]);
    printf(""\nNumber of inversions: %lld\n"", invCount);
    return 0;
}","python
def merge_sort_and_count(arr, temp, left, right):
    inv_count = 0
    if right > left:
        mid = (left + right) // 2
        inv_count += merge_sort_and_count(arr, temp, left, mid)
        inv_count += merge_sort_and_count(arr, temp, mid + 1, right)
        inv_count += merge(arr, temp, left, mid, right)
    return inv_count

def merge(arr, temp, left, mid, right):
    i = j = k = left
    inv_count = 0
    while i <= mid and j <= right:
        if arr[i] <= arr[j]:
            temp[k] = arr[i]
            i += 1
        else:
            temp[k] = arr[j]
            j += 1
            inv_count += mid - i + 1
        k += 1
    while i <= mid:
        temp[k] = arr[i]
        i += 1
        k += 1
    while j <= right:
        temp[k] = arr[j]
        j += 1
        k += 1
    for i in range(left, right + 1):
        arr[i] = temp[i]
    return inv_count

arr = [1, 3, 5, 2, 4, 6]
temp = [0] * len(arr)
inv_count = merge_sort_and_count(arr, temp, 0, len(arr) - 1)
print(""Sorted array:"", arr)
print(""Number of inversions:"", inv_count)","java
import java.util.Arrays;

public class MergeSortInversions {

    public static long mergeSortAndCount(int[] arr, int[] temp, int left, int right) {
        long invCount = 0;
        if (right > left) {
            int mid = left + (right - left) / 2;
            invCount += mergeSortAndCount(arr, temp, left, mid);
            invCount += mergeSortAndCount(arr, temp, mid + 1, right);
            invCount += merge(arr, temp, left, mid, right);
        }
        return invCount;
    }

    public static long merge(int[] arr, int[] temp, int left, int mid, int right) {
        int i, j, k;
        long invCount = 0;
        i = left; j = mid + 1; k = left;
        while ((i <= mid) && (j <= right)) {
            if (arr[i] <= arr[j]) {
                temp[k++] = arr[i++];
            } else {
                temp[k++] = arr[j++];
                invCount = invCount + (mid - i + 1);
            }
        }
        while (i <= mid) temp[k++] = arr[i++];
        while (j <= right) temp[k++] = arr[j++];
        for (i = left; i <= right; i++) arr[i] = temp[i];
        return invCount;
    }

    public static void main(String[] args) {
        int[] arr = {1, 3, 5, 2, 4, 6};
        int[] temp = new int[arr.length];
        long invCount = mergeSortAndCount(arr, temp, 0, arr.length - 1);
        System.out.print(""Sorted array: "" + Arrays.toString(arr));
        System.out.println(""\nNumber of inversions: "" + invCount);
    }
}","javascript
function mergeSortAndCount(arr, temp, left, right) {
    let invCount = 0;
    if (right > left) {
        const mid = Math.floor(left + (right - left) / 2);
        invCount += mergeSortAndCount(arr, temp, left, mid);
        invCount += mergeSortAndCount(arr, temp, mid + 1, right);
        invCount += merge(arr, temp, left, mid, right);
    }
    return invCount;
}

function merge(arr, temp, left, mid, right) {
    let i = left, j = mid + 1, k = left;
    let invCount = 0;
    while (i <= mid && j <= right) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
            invCount += mid - i + 1;
        }
    }
    while (i <= mid) temp[k++] = arr[i++];
    while (j <= right) temp[k++] = arr[j++];
    for (i = left; i <= right; i++) arr[i] = temp[i];
    return invCount;
}

const arr = [1, 3, 5, 2, 4, 6];
const temp = new Array(arr.length);
const invCount = mergeSortAndCount(arr, temp, 0, arr.length - 1);
console.log('Sorted array:', arr);
console.log('Number of inversions:', invCount);","cpp
#include <iostream>
#include <vector>

long long mergeSortAndCount(std::vector<int>& arr, std::vector<int>& temp, int left, int right);
long long merge(std::vector<int>& arr, std::vector<int>& temp, int left, int mid, int right);

long long mergeSortAndCount(std::vector<int>& arr, std::vector<int>& temp, int left, int right) {
    long long inv_count = 0;
    if (right > left) {
        int mid = left + (right - left) / 2;
        inv_count += mergeSortAndCount(arr, temp, left, mid);
        inv_count += mergeSortAndCount(arr, temp, mid + 1, right);
        inv_count += merge(arr, temp, left, mid, right);
    }
    return inv_count;
}

long long merge(std::vector<int>& arr, std::vector<int>& temp, int left, int mid, int right) {
    int i, j, k;
    long long inv_count = 0;
    i = left; j = mid + 1; k = left;
    while ((i <= mid) && (j <= right)) {
        if (arr[i] <= arr[j]) {
            temp[k++] = arr[i++];
        } else {
            temp[k++] = arr[j++];
            inv_count = inv_count + (mid - i + 1);
        }
    }
    while (i <= mid) temp[k++] = arr[i++];
    while (j <= right) temp[k++] = arr[j++];
    for (i = left; i <= right; i++) arr[i] = temp[i];
    return inv_count;
}

int main() {
    std::vector<int> arr = {1, 3, 5, 2, 4, 6};
    std::vector<int> temp(arr.size());
    long long invCount = mergeSortAndCount(arr, temp, 0, arr.size() - 1);
    std::cout << ""Sorted array:"";
    for (int i = 0; i < arr.size(); i++) std::cout << "" "" << arr[i];
    std::cout << std::endl << ""Number of inversions: "" << invCount << std::endl;
    return 0;
}",3.8
Orange-34,Stability of Sorting,,,,,,"[object Object],[object Object],[object Object],[object Object],[object Object],[object Object]","c
#include <stdio.h>
#include <stdbool.h>

bool isStableSort(int arr[], int indices[], int n) {
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            if (arr[i] == arr[j]) {
                if (indices[i] > indices[j]) {
                    return false;
                }
            }
        }
    }
    return true;
}

int main() {
    int n;
    scanf(""%d"", &n);
    int arr[n], indices[n];
    for (int i = 0; i < n; i++) scanf(""%d"", &arr[i]);
    for (int i = 0; i < n; i++) scanf(""%d"", &indices[i]);
    if (isStableSort(arr, indices, n)) {
        printf(""true\n"");
    } else {
        printf(""false\n"");
    }
    return 0;
}","python
def is_stable_sort(arr, indices):
    for i in range(len(arr)):
        for j in range(i + 1, len(arr)):
            if arr[i] == arr[j]:
                if indices[i] > indices[j]:
                    return False
    return True

n = int(input())
arr = list(map(int, input().split()))
indices = list(map(int, input().split()))
print(""true"" if is_stable_sort(arr, indices) else ""false"")","java
import java.util.*;

public class StableSort {
    public static boolean isStableSort(int[] arr, int[] indices) {
        for (int i = 0; i < arr.length; i++) {
            for (int j = i + 1; j < arr.length; j++) {
                if (arr[i] == arr[j]) {
                    if (indices[i] > indices[j]) {
                        return false;
                    }
                }
            }
        }
        return true;
    }

    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        int[] arr = new int[n];
        int[] indices = new int[n];
        for (int i = 0; i < n; i++) arr[i] = sc.nextInt();
        for (int i = 0; i < n; i++) indices[i] = sc.nextInt();
        System.out.println(isStableSort(arr, indices));
        sc.close();
    }
}","javascript
function isStableSort(arr, indices) {
  for (let i = 0; i < arr.length; i++) {
    for (let j = i + 1; j < arr.length; j++) {
      if (arr[i] === arr[j]) {
        if (indices[i] > indices[j]) {
          return false;
        }
      }
    }
  }
  return true;
}

const readline = require('readline').createInterface({
    input: process.stdin,
    output: process.stdout,
});

readline.question('Enter the size of the array: ', (n) => {
    readline.question('Enter the sorted array: ', (arrStr) => {
        readline.question('Enter the original indices: ', (indicesStr) => {
            const arr = arrStr.split(' ').map(Number);
            const indices = indicesStr.split(' ').map(Number);
            console.log(isStableSort(arr, indices));
            readline.close();
        });
    });
});","cpp
#include <iostream>
#include <vector>

bool isStableSort(const std::vector<int>& arr, const std::vector<int>& indices) {
    for (size_t i = 0; i < arr.size(); ++i) {
        for (size_t j = i + 1; j < arr.size(); ++j) {
            if (arr[i] == arr[j]) {
                if (indices[i] > indices[j]) {
                    return false;
                }
            }
        }
    }
    return true;
}

int main() {
    int n; 
    std::cin >> n;
    std::vector<int> arr(n), indices(n);
    for (int i = 0; i < n; ++i) std::cin >> arr[i];
    for (int i = 0; i < n; ++i) std::cin >> indices[i];
    std::cout << (isStableSort(arr, indices) ? ""true"" : ""false"") << std::endl;
    return 0;
}",4.1
Orange-35,"Binary Search on Answer (Aggressive Cows, Book Allocation)",,,,,,"[object Object],[object Object],[object Object],[object Object],[object Object]","#include <stdio.h>
#include <stdlib.h>

// Function to compare two integers for sorting
int compare(const void *a, const void *b) {
  return (*(int*)a - *(int*)b);
}

// Function to check if it's possible to place 'c' cows with a minimum distance of 'dist'
int canPlaceCows(int stalls[], int n, int c, int dist) {
  int cowsPlaced = 1; // We always place the first cow in the first stall
  int lastPos = stalls[0];

  for (int i = 1; i < n; i++) {
    if (stalls[i] - lastPos >= dist) {
      cowsPlaced++;
      lastPos = stalls[i];
      if (cowsPlaced == c) {
        return 1; // Successfully placed all cows
      }
    }
  }
  return 0; // Could not place all cows
}

// Function to find the largest minimum distance between cows
int solveAggressiveCows(int stalls[], int n, int c) {
  // Sort the stall positions
  qsort(stalls, n, sizeof(int), compare);

  int low = 1; // Minimum possible distance
  int high = stalls[n - 1] - stalls[0]; // Maximum possible distance
  int ans = -1; // Initialize the answer

  while (low <= high) {
    int mid = low + (high - low) / 2; // Calculate the middle distance

    if (canPlaceCows(stalls, n, c, mid)) {
      // If we can place all cows with this distance, try a larger distance
      ans = mid;
      low = mid + 1;
    } else {
      // Otherwise, try a smaller distance
      high = mid - 1;
    }
  }
  return ans;
}

int main() {
  int n, c;
  scanf(""%d %d"", &n, &c);

  int stalls[n];
  for (int i = 0; i < n; i++) {
    scanf(""%d"", &stalls[i]);
  }

  int result = solveAggressiveCows(stalls, n, c);
  printf(""%d\n"", result);

  return 0;
}","def can_place_cows(stalls, n, c, dist):
    cows_placed = 1
    last_pos = stalls[0]

    for i in range(1, n):
        if stalls[i] - last_pos >= dist:
            cows_placed += 1
            last_pos = stalls[i]
            if cows_placed == c:
                return True
    return False


def solve_aggressive_cows(stalls, n, c):
    stalls.sort()

    low = 1
    high = stalls[n - 1] - stalls[0]
    ans = -1

    while low <= high:
        mid = low + (high - low) // 2

        if can_place_cows(stalls, n, c, mid):
            ans = mid
            low = mid + 1
        else:
            high = mid - 1

    return ans


if __name__ == ""__main__"":
    n, c = map(int, input().split())
    stalls = list(map(int, input().split()))

    result = solve_aggressive_cows(stalls, n, c)
    print(result)","import java.util.*;
import java.lang.*;

class Solution {

    // Function to check if it's possible to place 'c' cows with a minimum distance of 'dist'
    public static boolean canPlaceCows(int[] stalls, int n, int c, int dist) {
        int cowsPlaced = 1; // We always place the first cow in the first stall
        int lastPos = stalls[0];

        for (int i = 1; i < n; i++) {
            if (stalls[i] - lastPos >= dist) {
                cowsPlaced++;
                lastPos = stalls[i];
                if (cowsPlaced == c) {
                    return true; // Successfully placed all cows
                }
            }
        }
        return false; // Could not place all cows
    }

    // Function to find the largest minimum distance between cows
    public static int solveAggressiveCows(int[] stalls, int n, int c) {
        // Sort the stall positions
        Arrays.sort(stalls);

        int low = 1; // Minimum possible distance
        int high = stalls[n - 1] - stalls[0]; // Maximum possible distance
        int ans = -1; // Initialize the answer

        while (low <= high) {
            int mid = low + (high - low) / 2; // Calculate the middle distance

            if (canPlaceCows(stalls, n, c, mid)) {
                // If we can place all cows with this distance, try a larger distance
                ans = mid;
                low = mid + 1;
            } else {
                // Otherwise, try a smaller distance
                high = mid - 1;
            }
        }
        return ans;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int c = scanner.nextInt();

        int[] stalls = new int[n];
        for (int i = 0; i < n; i++) {
            stalls[i] = scanner.nextInt();
        }

        int result = solveAggressiveCows(stalls, n, c);
        System.out.println(result);
        scanner.close();
    }
}","function canPlaceCows(stalls, n, c, dist) {
    let cowsPlaced = 1;
    let lastPos = stalls[0];

    for (let i = 1; i < n; i++) {
        if (stalls[i] - lastPos >= dist) {
            cowsPlaced++;
            lastPos = stalls[i];
            if (cowsPlaced === c) {
                return true;
            }
        }
    }
    return false;
}

function solveAggressiveCows(stalls, n, c) {
    stalls.sort((a, b) => a - b);

    let low = 1;
    let high = stalls[n - 1] - stalls[0];
    let ans = -1;

    while (low <= high) {
        const mid = Math.floor(low + (high - low) / 2);

        if (canPlaceCows(stalls, n, c, mid)) {
            ans = mid;
            low = mid + 1;
        } else {
            high = mid - 1;
        }
    }
    return ans;
}

function main() {
    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\n');
    const [n, c] = input[0].split(' ').map(Number);
    const stalls = input[1].split(' ').map(Number);

    const result = solveAggressiveCows(stalls, n, c);
    console.log(result);
}

main();","#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// Function to check if it's possible to place 'c' cows with a minimum distance of 'dist'
bool canPlaceCows(const vector<int>& stalls, int n, int c, int dist) {
  int cowsPlaced = 1; // We always place the first cow in the first stall
  int lastPos = stalls[0];

  for (int i = 1; i < n; i++) {
    if (stalls[i] - lastPos >= dist) {
      cowsPlaced++;
      lastPos = stalls[i];
      if (cowsPlaced == c) {
        return true; // Successfully placed all cows
      }
    }
  }
  return false; // Could not place all cows
}

// Function to find the largest minimum distance between cows
int solveAggressiveCows(vector<int>& stalls, int n, int c) {
  // Sort the stall positions
  sort(stalls.begin(), stalls.end());

  int low = 1; // Minimum possible distance
  int high = stalls[n - 1] - stalls[0]; // Maximum possible distance
  int ans = -1; // Initialize the answer

  while (low <= high) {
    int mid = low + (high - low) / 2; // Calculate the middle distance

    if (canPlaceCows(stalls, n, c, mid)) {
      // If we can place all cows with this distance, try a larger distance
      ans = mid;
      low = mid + 1;
    } else {
      // Otherwise, try a smaller distance
      high = mid - 1;
    }
  }
  return ans;
}

int main() {
  int n, c;
  cin >> n >> c;

  vector<int> stalls(n);
  for (int i = 0; i < n; i++) {
    cin >> stalls[i];
  }

  int result = solveAggressiveCows(stalls, n, c);
  cout << result << endl;

  return 0;
}",4.2
Orange-36,Hash Tables & Hash Maps (intro),,,,,,"[object Object],[object Object],[object Object],[object Object],[object Object]","#include <stdio.h>
#include <stdlib.h>

int* twoSum(int* nums, int numsSize, int target, int* returnSize) {
    int* result = (int*)malloc(2 * sizeof(int));
    *returnSize = 2;

    for (int i = 0; i < numsSize; i++) {
        for (int j = i + 1; j < numsSize; j++) {
            if (nums[i] + nums[j] == target) {
                result[0] = i;
                result[1] = j;
                return result;
            }
        }
    }

    // No solution found (this should not happen according to the problem description)
    result[0] = -1;
    result[1] = -1;
    return result;
}

int main() {
    int nums[] = {2, 7, 11, 15};
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    int target = 9;
    int returnSize;

    int* result = twoSum(nums, numsSize, target, &returnSize);

    printf(""[%d, %d]\n"", result[0], result[1]);

    free(result);
    return 0;
}","def twoSum(nums, target):
    num_map = {}
    for i, num in enumerate(nums):
        complement = target - num
        if complement in num_map:
            return [num_map[complement], i]
        num_map[num] = i

# Example usage
if __name__ == ""__main__"":
    nums = [2, 7, 11, 15]
    target = 9
    result = twoSum(nums, target)
    print(result)","import java.util.HashMap;
import java.util.Map;

class Solution {
    public int[] twoSum(int[] nums, int target) {
        Map<Integer, Integer> numMap = new HashMap<>();
        for (int i = 0; i < nums.length; i++) {
            int complement = target - nums[i];
            if (numMap.containsKey(complement)) {
                return new int[] { numMap.get(complement), i };
            }
            numMap.put(nums[i], i);
        }
        throw new IllegalArgumentException(""No two sum solution"");
    }
}

public class Main {
    public static void main(String[] args) {
        Solution sol = new Solution();
        int[] nums = {2, 7, 11, 15};
        int target = 9;
        int[] result = sol.twoSum(nums, target);
        System.out.println(""["" + result[0] + "", "" + result[1] + ""]"");
    }
}","function twoSum(nums, target) {
    const numMap = new Map();
    for (let i = 0; i < nums.length; i++) {
        const complement = target - nums[i];
        if (numMap.has(complement)) {
            return [numMap.get(complement), i];
        }
        numMap.set(nums[i], i);
    }
}

// Example usage
const nums = [2, 7, 11, 15];
const target = 9;
const result = twoSum(nums, target);
console.log(result);","#include <iostream>
#include <vector>
#include <unordered_map>

using namespace std;

vector<int> twoSum(vector<int>& nums, int target) {
    unordered_map<int, int> numMap;
    for (int i = 0; i < nums.size(); ++i) {
        int complement = target - nums[i];
        if (numMap.count(complement)) {
            return {numMap[complement], i};
        }
        numMap[nums[i]] = i;
    }
    return {}; // Should not happen, as problem guarantees a solution
}

int main() {
    vector<int> nums = {2, 7, 11, 15};
    int target = 9;
    vector<int> result = twoSum(nums, target);
    cout << ""["" << result[0] << "", "" << result[1] << ""]"" << endl;
    return 0;
}",4.2
Orange-37,Quick Sort,,,,,,"[object Object],[object Object],[object Object],[object Object],[object Object]","#include <stdio.h>

void swap(int *a, int *b) {
    int t = *a;
    *a = *b;
    *b = t;
}

float calculateLuminance(int color) {
    int r = (color >> 16) & 0xFF;
    int g = (color >> 8) & 0xFF;
    int b = color & 0xFF;
    return (float)(r + g + b) / 3.0;
}

int partition(int arr[], int low, int high) {
    float pivotLuminance = calculateLuminance(arr[high]);
    int i = (low - 1);

    for (int j = low; j <= high - 1; j++) {
        if (calculateLuminance(arr[j]) < pivotLuminance) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

void quickSortHelper(int arr[], int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSortHelper(arr, low, pi - 1);
        quickSortHelper(arr, pi + 1, high);
    }
}

void quickSort(int arr[], int size){
    quickSortHelper(arr, 0, size-1);
}

void printArray(int arr[], int size) {
    for (int i = 0; i < size; i++)
        printf(""%d "", arr[i]);
    printf(""\n"");
}

int main() {
    int n;
    scanf(""%d"", &n);
    int arr[n];
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]);
    }

    quickSort(arr, n);
    printArray(arr, n);
    return 0;
}","def calculate_luminance(color):
    r = (color >> 16) & 0xFF
    g = (color >> 8) & 0xFF
    b = color & 0xFF
    return (r + g + b) / 3

def partition(arr, low, high):
    pivot_luminance = calculate_luminance(arr[high])
    i = (low - 1)

    for j in range(low, high):
        if calculate_luminance(arr[j]) < pivot_luminance:
            i = i + 1
            arr[i], arr[j] = arr[j], arr[i]

    arr[i + 1], arr[high] = arr[high], arr[i + 1]
    return (i + 1)

def quick_sort_helper(arr, low, high):
    if low < high:
        pi = partition(arr, low, high)
        quick_sort_helper(arr, low, pi - 1)
        quick_sort_helper(arr, pi + 1, high)

def quick_sort(arr):
    quick_sort_helper(arr, 0, len(arr)-1)

def print_array(arr):
    for i in range(len(arr)):
        print(arr[i], end="" "")
    print()

if __name__ == '__main__':
    n = int(input())
    arr = list(map(int, input().split()))

    quick_sort(arr)
    print_array(arr)","import java.util.Scanner;

class Solution {

    static void swap(int[] arr, int i, int j) {
        int temp = arr[i];
        arr[i] = arr[j];
        arr[j] = temp;
    }

    static float calculateLuminance(int color) {
        int r = (color >> 16) & 0xFF;
        int g = (color >> 8) & 0xFF;
        int b = color & 0xFF;
        return (float)(r + g + b) / 3.0;
    }

    static int partition(int[] arr, int low, int high) {
        float pivotLuminance = calculateLuminance(arr[high]);
        int i = (low - 1);

        for (int j = low; j <= high - 1; j++) {
            if (calculateLuminance(arr[j]) < pivotLuminance) {
                i++;
                swap(arr, i, j);
            }
        }
        swap(arr, i + 1, high);
        return (i + 1);
    }

    static void quickSortHelper(int[] arr, int low, int high) {
        if (low < high) {
            int pi = partition(arr, low, high);
            quickSortHelper(arr, low, pi - 1);
            quickSortHelper(arr, pi + 1, high);
        }
    }

    static void quickSort(int[] arr){
        quickSortHelper(arr, 0, arr.length -1);
    }

    static void printArray(int[] arr) {
        for (int i = 0; i < arr.length; i++)
            System.out.print(arr[i] + "" "");
        System.out.println();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        quickSort(arr);
        printArray(arr);
        scanner.close();
    }
}","function calculateLuminance(color) {
    const r = (color >> 16) & 0xFF;
    const g = (color >> 8) & 0xFF;
    const b = color & 0xFF;
    return (r + g + b) / 3;
}

function partition(arr, low, high) {
    const pivotLuminance = calculateLuminance(arr[high]);
    let i = (low - 1);

    for (let j = low; j <= high - 1; j++) {
        if (calculateLuminance(arr[j]) < pivotLuminance) {
            i++;
            [arr[i], arr[j]] = [arr[j], arr[i]];
        }
    }
    [arr[i + 1], arr[high]] = [arr[high], arr[i + 1]];
    return (i + 1);
}

function quickSortHelper(arr, low, high) {
    if (low < high) {
        const pi = partition(arr, low, high);
        quickSortHelper(arr, low, pi - 1);
        quickSortHelper(arr, pi + 1, high);
    }
}

function quickSort(arr){
    quickSortHelper(arr, 0, arr.length-1);
}

function printArray(arr) {
    let output = """";
    for (let i = 0; i < arr.length; i++) {
        output += arr[i] + "" "";
    }
    console.log(output.trim());
}

function main() {
    const readline = require('readline').createInterface({
        input: process.stdin,
        output: process.stdout,
    });

    let n;
    let arr;
    let lineCount = 0;

    readline.on('line', (line) => {
        lineCount++;
        if (lineCount === 1) {
            n = parseInt(line);
        } else if (lineCount === 2) {
            arr = line.split(' ').map(Number);
            quickSort(arr);
            printArray(arr);
            readline.close();
        }
    });
}

main();","#include <iostream>
#include <vector>

using namespace std;

void swap(int *a, int *b) {
    int t = *a;
    *a = *b;
    *b = t;
}

float calculateLuminance(int color) {
    int r = (color >> 16) & 0xFF;
    int g = (color >> 8) & 0xFF;
    int b = color & 0xFF;
    return (float)(r + g + b) / 3.0;
}

int partition(vector<int>& arr, int low, int high) {
    float pivotLuminance = calculateLuminance(arr[high]);
    int i = (low - 1);

    for (int j = low; j <= high - 1; j++) {
        if (calculateLuminance(arr[j]) < pivotLuminance) {
            i++;
            swap(&arr[i], &arr[j]);
        }
    }
    swap(&arr[i + 1], &arr[high]);
    return (i + 1);
}

void quickSortHelper(vector<int>& arr, int low, int high) {
    if (low < high) {
        int pi = partition(arr, low, high);
        quickSortHelper(arr, low, pi - 1);
        quickSortHelper(arr, pi + 1, high);
    }
}

void quickSort(vector<int>& arr){
    quickSortHelper(arr, 0, arr.size()-1);
}

void printArray(const vector<int>& arr) {
    for (int i = 0; i < arr.size(); i++)
        cout << arr[i] << "" "";
    cout << endl;
}

int main() {
    int n;
    cin >> n;
    vector<int> arr(n);
    for (int i = 0; i < n; i++) {
        cin >> arr[i];
    }

    quickSort(arr);
    printArray(arr);
    return 0;
}",4.2
