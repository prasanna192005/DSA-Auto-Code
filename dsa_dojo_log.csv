ID,Category,Concepts,Question,Constraints,Sample Input,Sample Output,Test Cases,Solution_C,Solution_Python,Solution_Java,Solution_Javascript,Solution_C++,QC Score
White-1,String Reversal,,Write a function that reverses a given string.  The function should take a string as input and return the reversed string.,"- The input string will only contain lowercase letters.
- The length of the input string will be between 1 and 1000 characters (inclusive).","**  ""hello""

**","** ""olleh""","abcde
hello
madam
a
racecar",,,,,,
White-2,Break & Continue,,"Given an array of integers, calculate the sum of only the even numbers. Skip odd numbers using a loop and the `continue` statement.  If the input array is empty, return 0.","- The array will contain only integers.
- The array size will be at most 100.
- Integers in the array will be within the range of -1000 to 1000.","** `[1, 2, 3, 4, 5, 6]`
**",** `12` (2 + 4 + 6),"[2, 4, 6, 8, 10]
[1, 3, 5, 7, 9]
[-2, 0, 2, 4]
[]
[-1, -2, -3, -4]",,,,,,
White-3,Modulo Arithmetic,,"Given two integers, `a` and `b`, find the remainder when `a` is divided by `b`.  This is the modulo operation (%).","- `1 ≤ a, b ≤ 1000`
- `b > 0`","**
`a = 17`
`b = 5`

**","**
`2`  (Because 17 divided by 5 leaves a remainder of 2)","10 3
25 7
100 11
5 5
1000 1",,,,,,
White-4,Intro to Recursion (factorial),,"Write a function that calculates the factorial of a non-negative integer using recursion. The factorial of a non-negative integer n, denoted by n!, is the product of all positive integers less than or equal to n. For example, 5! = 5 * 4 * 3 * 2 * 1 = 120.","- The input integer n will be non-negative (0 or greater).
- The input integer n will be less than or equal to 12 (to avoid potential integer overflow).",5,120,"10
0
7
12
1",,,,,,
White-5,Parameters & Arguments,,"Write a function that takes two integer parameters, `a` and `b`, and returns their sum.  However, there's a twist! The function should also print the value of 'a' before calculating and returning the sum.","* -1000 ≤ a, b ≤ 1000","**

5 10

**","**

5
15","15 20
-5 10
0 0
100 -50
-20 -30",,,,,,
White-6,Intro to Time & Space Complexity,,"Given an integer `n`, count the number of sheep from 1 to n.  This seems simple, but we'll focus on understanding the time complexity.",- 1 ≤ n ≤ 100000,5,15 (1 + 2 + 3 + 4 + 5 = 15),"10
100
10000
50000
78945",,,,,,
White-7,"Basic Array Operations (sum, max, min)",,"Given an array of integers, find the sum, maximum, and minimum values within the array.","* The array will contain at least one integer.
* The integers in the array will be within the range of a 32-bit integer.","[1, 5, 2, 8, 3]","Sum: 19, Max: 8, Min: 1","[10, 20, 30, 40, 50]
[-5, 0, 5, 10, -15]
[1, 1, 1, 1, 1]
[100, -10, 50, 20, -50]
[-1, -2, -3, -4, -5]",,,,,,
White-8,1D Array Declaration & Traversal,,"Given an array of integers, find the sum of all even numbers in the array.","* The array will contain at least one element.
* The array will contain only integers between -100 and 100 (inclusive).
* The size of the array will not exceed 100 elements.","**  `[1, 2, 3, 4, 5, 6]`
**",** `12` (2 + 4 + 6),"[1, 2, 3, 4, 5, 6]
[10, -20, 30, -40]
[-1, -2, -3, -4]
[1, 3, 5, 7, 9]
[2, 4, 6, 8, 10]",,,,,,
White-9,Bitwise Operators,,"Given an 8-bit unsigned integer, write a function that flips all its bits (0s become 1s and vice-versa).",- The input will always be an 8-bit unsigned integer (0-255).,10 (binary: 00001010),245 (binary: 11110101),"15
255
0
128
64",,,,,,
White-10,1D Array Declaration & Traversal,,"Given an array of integers, calculate the sum of all the digits present in each integer within the array.  For example, if the array contains [123, 45, 6], the function should return 1 + 2 + 3 + 4 + 5 + 6 = 21.","- The array will contain only positive integers.
- The array size will be between 1 and 100.
- Each integer in the array will be between 0 and 1000.","** [12, 4, 87]

**",** 22 (1 + 2 + 4 + 8 + 7),"[1,2,3]
[999,1]
[100,200,300]
[1,10,100,1000]
[5,5,5,5]",,,,,,
White-11,Bitwise Operators,,"Given an integer, determine if its binary representation is a palindrome. A palindrome is a sequence that reads the same backward as forward.",#NAME?,10,"true (Binary representation of 10 is 1010, which is a palindrome)

Input: 13","5
100
255
1023
0",,,,,,
White-12,1D Array Declaration & Traversal,,You're on a treasure hunt! The treasure map is encoded in a 1D array. Each element represents a location. Find the total number of locations visited before you stumble upon the 'X' marking the treasure spot.,"- The array will contain only lowercase English alphabets and 'X'.
- The array size will be between 1 and 100.
- 'X' will always be present in the array.","`['a', 'b', 'c', 'X', 'e']`",4 (4 locations visited before finding 'X'),"['a', 'b', 'X', 'd']
['p', 'q', 'r', 's', 'X', 'u']
['X']
['a', 'b', 'c', 'd', 'e', 'f']
['a','x','X','b']",,,,,,
White-13,Type Casting,,"You are given an integer representing the number of seconds since the start of a race.  Your task is to convert this total number of seconds into hours, minutes, and remaining seconds.  For example, 3700 seconds translates to 1 hour, 1 minute, and 40 seconds.",#NAME?,3700,1 1 40,"10000
3661
0
86400
4500",,,,,,
White-14,String Reversal,,Write a function that reverses a given string.  The function should take a string as input and return the reversed string.,"* The input string will contain only lowercase English letters.
* The input string will have a length between 1 and 1000 characters (inclusive).","**  ""hello""
**","** ""olleh""","madam
racecar
hello world
level
rotor",,,,,,
White-15,Parameters & Arguments,,"You're organizing your socks!  Given the number of red socks and blue socks, write a function that returns the total number of socks.",* The number of red and blue socks will be non-negative integers.,"red_socks = 5, blue_socks = 3",8,"Input: 10 20
Output: 30
Input: 0 5
Output: 5
Input: 15 0
Output: 15
Input: 25 75
Output: 100
Input: 100 100
Output: 200",,,,,,
White-16,Break & Continue,,"Given an array of integers, print only the positive numbers, skipping any zeros encountered. Use `break` and `continue` statements to control the flow of your loop.","- The array will contain integers between -100 and 100.
- The array size will be between 1 and 100.","[1, 0, 2, 0, 3, -1, 4, 0, 5]",1 2 3 4 5,"Input: [1, 2, 3, 4, 5]
Output: 1 2 3 4 5
Input: [0, 0, 0, 0, 0]
Output: 
Input: [-1, 0, 1, 2, 3]
Output: 
Input: [1, 0, -1, 2, 0, 3]
Output: 1",,,,,,
White-17,Best/Worst/Average Case Basics,,"Given an unsorted array of integers, determine the number of comparisons needed to find the minimum element in the array in the best, worst, and average cases.","- The array will contain at least one element.
- The elements of the array are integers.
- Assume the average case is the case when the minimum element is in the middle of the array","[3, 1, 4, 1, 5, 9, 2, 6]","Best Case: 0, Worst Case: 7, Average Case: 4","Input: [1, 2, 3, 4, 5]
Output: Best Case: 0, Worst Case: 4, Average Case: 2
Input: [5, 4, 3, 2, 1]
Output: Best Case: 0, Worst Case: 4, Average Case: 2
Input: [10, 5, 20, 15, 30]
Output: Best Case: 0, Worst Case: 4, Average Case: 2
Input: [1]
Output: Best Case: 0, Worst Case: 0, Average Case: 0",,,,,,
White-N/A,Function Definition & Call,,"You're designing a snack dispenser for a spaceship!  The dispenser has a limited number of snacks, and each snack has a unique code.  Your task is to write a function that checks if a given snack code is available in the dispenser.","- The snack codes are integers.
- The number of snacks in the dispenser is fixed and given as input.
- The available snack codes are given as an array.
- Assume that snack codes are always positive integers.
- The function should return `true` if the snack code is available, and `false` otherwise.","Available snacks: [1, 5, 3, 7], Snack code to check: 5","true

Input: Available snacks: [1, 5, 3, 7], Snack code to check: 9","Input: [1, 2, 3, 4, 5]
Output: true
Input: [10, 20, 30]
Output: false
Input: [5, 15, 25, 35, 5]
Output: true
Input: []
Output: false
Input: [1,1,1,1,1,2]
Output: true",,,,,,
White-N/A,"Conditionals (if-else, switch-case)",,"You're designing a software for a candy machine.  The machine dispenses different candies based on the code entered.  Your task is to write a program that takes a candy code as input and prints the name of the candy.  If the code is invalid, print ""Invalid Code"".","- The candy codes are integers between 1 and 5 (inclusive).
- Candy codes and their corresponding names:
    - 1: Chocolate
    - 2: Lollipop
    - 3: Gummy Bears
    - 4: Marshmallow
    - 5: Caramel",3,Gummy Bears,"Input: 1
Output: Chocolate
Input: 5
Output: Caramel
Input: 0
Output: Invalid Code
Input: 6
Output: Invalid Code
Input: 3
Output: Gummy Bears",,,,,,
White-N/A,Variables & Data Types,,"The Galactic Snack Bar is tracking its daily sales.  They sell three types of snacks: Fizzbangs, ZapZaps, and Glimmerglobs.  Given the number of each snack sold, calculate the total number of snacks sold.",* The number of each snack type sold will be a non-negative integer.,"Fizzbangs = 10, ZapZaps = 5, Glimmerglobs = 20",35,"Input: 15 25 35
Output: 75
Input: 0 10 0
Output: 10
Input: 100 200 300
Output: 600
Input: 5 5 5
Output: 15",,,,,,
White-18,Variables & Data Types,,"Given two strings, `str1` and `str2`, concatenate them and print the resulting string.  The concatenation should be done such that `str1` comes before `str2`.","- The length of each string will be between 1 and 100 characters (inclusive).
- The strings will only contain lowercase English alphabets.","str1 = ""hello"", str2 = ""world""",helloworld,"Input: abc def
Output: abcdef
Input: programming is
Output: programmingis
Input: hello world
Output: helloworld
Input: a b
Output: ab
Input: code forces
Output: codeforces",,,,,,
White-19,"Input: 15 25 35
Output: 75
Input: 0 10 0
Output: 10
Input: 100 200 300
Output: 600
Input: 5 5 5
Output: 15",,"The Galactic Snack Bar is tracking its daily sales.  They sell three types of snacks: Fizzbangs, ZapZaps, and Glimmerglobs.  Given the number of each snack sold, calculate the total number of snacks sold.",* The number of each snack type sold will be a non-negative integer.,"Fizzbangs = 10, ZapZaps = 5, Glimmerglobs = 20",35,Variables & Data Types,,,,,,
White-20,Prime Check,,"Determine if a given positive integer is a prime number. A prime number is a natural number greater than 1 that is not a product of two smaller natural numbers.  Your function should return `true` if the number is prime, and `false` otherwise.",* 2 ≤ n ≤ 1000,17,"true

Input: 15","Input: 2
Output: true
Input: 97
Output: true
Input: 100
Output: false
Input: 49
Output: false
Input: 29
Output: true",,,,,,
White-21,Input/Output,,Write a program that reads a line of text from the standard input and prints the same line to the standard output.,"- The input line will contain at most 1000 characters.
- The input line will not contain any leading or trailing spaces.","Hello, world!","Hello, world!","Input: This is a test.
Output: This is a test.
Input: 12345
Output: 12345
Input:  Leading and trailing spaces are removed.
Output: Leading and trailing spaces are removed.
Input: !@#$%^&*()
Output: !@#$%^&*()",,,,,,
White-N/A,"Operators (Arithmetic, Relational, Logical)",,"Given three integers, determine if their sum is greater than 100. If it is, return the sum; otherwise, return -1.","-1000 ≤ a, b, c ≤ 1000","a = 50, b = 50, c = 10","110

Input: a = 20, b = 30, c = 40","Input: 10 20 80
Output: 110
Input: 10 10 10
Output: -1
Input: 50 50 50
Output: 150
Input: -50, 0, 50
Output: -1
Input: 100, 1, 1
Output: 102",,,,,,
White-N/A,"Operators (Arithmetic, Relational, Logical)",,"Given three boolean variables, `a`, `b`, and `c`, determine if the expression `!(a && b) || c` evaluates to `true` or `false`.  Your program should read the boolean values of `a`, `b`, and `c` from standard input and print `true` or `false` to standard output.","- The input will consist of three lines, each containing either ""true"" or ""false"".
- You can assume the input is always valid.","true
false
true",TRUE,"Input: true
true
true
Output: true
Input: false
false
false
Output: true
Input: true
false
false
Output: true
Input: false
true
true
Output: true
Input: true
true
false
Output: false",,,,,,
White-22,"Input: 10 20 80
Output: 110
Input: 10 10 10
Output: -1
Input: 50 50 50
Output: 150
Input: -50, 0, 50
Output: -1
Input: 100, 1, 1
Output: 102",,"Given three integers, determine if their sum is greater than 100. If it is, return the sum; otherwise, return -1.","-1000 ≤ a, b, c ≤ 1000","a = 50, b = 50, c = 10","110

Input: a = 20, b = 30, c = 40","Operators (Arithmetic, Relational, Logical)",,,,,,
White-23,"Input: true
true
true
Output: true
Input: false
false
false
Output: true
Input: true
false
false
Output: true
Input: false
true
true
Output: true
Input: true
true
false
Output: false",,"Given three boolean variables, `a`, `b`, and `c`, determine if the expression `!(a && b) || c` evaluates to `true` or `false`.  Your program should read the boolean values of `a`, `b`, and `c` from standard input and print `true` or `false` to standard output.","- The input will consist of three lines, each containing either ""true"" or ""false"".
- You can assume the input is always valid.","true
false
true",TRUE,"Operators (Arithmetic, Relational, Logical)",,,,,,
White-24,"Loops (for, while)",,"Given a range of numbers (inclusive), calculate the sum of all even numbers within that range.","- The input will consist of two integers, representing the start and end of the range.
- The range will always be valid (start <= end).
- The numbers in the range will be between 1 and 1000 (inclusive).","1, 10",30 (2 + 4 + 6 + 8 + 10),"Input: 1, 5
Output: 6
Input: 10, 20
Output: 165
Input: 5, 15
Output: 50
Input: 1,1000
Output:250500",,,,,,
White-25,Modulo Arithmetic,,"Given two integers, `a` and `b`, find the remainder when `a` is divided by `b`.","* `1 <= a, b <= 1000`
* `b` will not be 0.","a = 10, b = 3",1,"Input: 15 4
Output: 3
Input: 20 5
Output: 0
Input: 100 7
Output: 2
Input: 999 10
Output: 9
Input: 1024 1000
Output: 24",,,,,,
White-26,Return Values,,Write a function that takes two integers as input and returns their sum.,* The input integers will be within the range of a 32-bit integer.,"5, 10",15,"Input: 25, 75
Output: 100
Input: -10, 10
Output: 0
Input: 1000, 2000
Output: 3000
Input: 0, 0
Output: 0",,,,,,
White-27,Palindrome Check,,"Given a string, determine if it's a palindrome (reads the same forwards and backward, ignoring case and non-alphanumeric characters).","- The input string will contain only ASCII characters.
- The string's length will be between 1 and 1000 characters.","""A man, a plan, a canal: Panama""","true

Input: ""race a car""","Input: ""Race car""
Output: true
Input: ""A man, a plan, a canal: Panama""
Output: true
Input: "".,""
Output: true
Input: ""1a2""
Output: false
Input: ""Was it a car or a cat I saw?""
Output: true",,,,,,
White-28,Bitwise Operators,,"Given two integers, `a` and `b`, determine if setting the least significant bit of `a` to 1 and clearing the least significant bit of `b` results in `a` being greater than `b`.",- `a` and `b` are non-negative integers.,"a = 5, b = 6","true

(Because 5 with its least significant bit set to 1 is 5 | 1 = 5, and 6 with its least significant bit cleared is 6 & ~1 = 4. 5 > 4, hence true.)","Input: 5 6
Output: true
Input: 10 12
Output: true
Input: 0 1
Output: true
Input: 7 7
Output: false
Input: 2 4
Output: false",,,,,,
White-N/A,Bitwise Operators,,"Given an integer `n`, count the total number of set bits (1s) in the binary representation of all numbers from 1 to n (inclusive).",* 1 ≤ n ≤ 10^6,n = 3,4,"Input: 5
Output: 7
Input: 10
Output: 17
Input: 1
Output: 1
Input: 100
Output: 266",,,,,,
White-N/A,1D Array Declaration & Traversal,,"Given an array of integers, calculate the sum of all elements in the array.","* The array will contain only integers.
* The array will have at least one element.
* The array will have at most 100 elements.
* The sum of the elements will not exceed the maximum integer value for the language.","[1, 2, 3, 4, 5]",15,"Input: [10, 20, 30]
Output: 60
Input: [-1, 0, 1]
Output: 0
Input: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Output: 10
Input: [100, -50, 25, 75]
Output: 150",,,,,,
White-29,Intro to Recursion (factorial),,"Write a function that calculates the factorial of a non-negative integer using recursion.  The factorial of a non-negative integer n, denoted by n!, is the product of all positive integers less than or equal to n. For example, 5! = 5 * 4 * 3 * 2 * 1 = 120.","- The input integer will be non-negative.
- The input integer will be less than or equal to 12 to avoid integer overflow in most languages.",5,120,"Input: 0
Output: 1
Input: 1
Output: 1
Input: 7
Output: 5040
Input: 10
Output: 3628800
Input: 12
Output: 479001600",,,,,,
White-30,GCD/LCM,,"Given two positive integers, determine if they are co-prime (i.e., their greatest common divisor (GCD) is 1).","- 1 ≤ a, b ≤ 1000","15, 22","Yes

Input: 12, 18","Input: 10, 15
Output: No
Input: 7, 11
Output: Yes
Input: 25, 35
Output: No
Input: 1, 2
Output: Yes
Input: 17, 23
Output: Yes",,,,,,
White-31,"Input: 5
Output: 7
Input: 10
Output: 17
Input: 1
Output: 1
Input: 100
Output: 266",,"Given an integer `n`, count the total number of set bits (1s) in the binary representation of all numbers from 1 to n (inclusive).",* 1 ≤ n ≤ 10^6,n = 3,4,Bitwise Operators,,,,,,
White-32,"Input: [10, 20, 30]
Output: 60
Input: [-1, 0, 1]
Output: 0
Input: [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
Output: 10
Input: [100, -50, 25, 75]
Output: 150",,"Given an array of integers, calculate the sum of all elements in the array.","* The array will contain only integers.
* The array will have at least one element.
* The array will have at most 100 elements.
* The sum of the elements will not exceed the maximum integer value for the language.","[1, 2, 3, 4, 5]",15,1D Array Declaration & Traversal,,,,,,
White-33,"Basic Array Operations (sum, max, min)",,"Given an array of integers, find the sum, maximum, and minimum values within the array.","* The array will contain at least one element.
* The array will only contain integers.
* The integers can be positive, negative, or zero.","[1, 5, 2, 8, 3]","Sum: 19, Max: 8, Min: 1","Input: [10, 20, 30, 40, 50]
Output: Sum: 150, Max: 50, Min: 10
Input: [-1, 0, 1]
Output: Sum: 0, Max: 1, Min: -1
Input: [5]
Output: Sum: 5, Max: 5, Min: 5
Input: [-5,-10,-15]
Output: Sum: -30, Max: -5, Min: -15",,,,,,
White-34,Intro to Time & Space Complexity,,"Given an integer `n`, count the number of sheep from 1 to n.  This seems simple, but let's analyze its time and space complexity!",- `n` will be a non-negative integer.,5,15 (1 + 2 + 3 + 4 + 5),"Input: 0
Output: 0
Input: 10
Output: 55
Input: 100
Output: 5050
Input: 1000
Output: 500500",,,,,,
White-35,"Basic Array Operations (sum, max, min)",,"Given an array of integers, find the sum, maximum, and minimum values.","- The array will contain at least one element.
- The array elements will be integers within the range of [-1000, 1000].
- The array size will not exceed 1000 elements.","[1, 5, 2, 8, 3]","Sum: 19, Max: 8, Min: 1","Input: [10, 20, 30, 40, 50]
Output: Sum: 150, Max: 50, Min: 10
Input: [-5, 0, 5, 10, -10]
Output: Sum: 0, Max: 10, Min: -10
Input: [1, 1, 1, 1, 1]
Output: Sum: 5, Max: 1, Min: 1
Input: [-1000, 1000]
Output: Sum: 0, Max: 1000, Min: -1000",,,,,,
White-36,Intro to Time & Space Complexity,,"Given an integer `n`, count the number of sheep from 1 to n.  This sounds simple, but let's analyze its efficiency!",- `n` will be a non-negative integer.,5,15 (1 + 2 + 3 + 4 + 5 = 15),"Input: 0
Output: 0
Input: 10
Output: 55
Input: 100
Output: 5050
Input: 1
Output: 1
Input: 7
Output: 28",,,,,,
White-37,Basic String Manipulation,,"Given a string, reverse only the vowel words within the string. A vowel word is defined as a word containing at least one vowel (a, e, i, o, u).  Words are separated by spaces.","- The input string will contain only lowercase letters and spaces.
- The input string will not be empty.
- The input string will not contain leading or trailing spaces.
- Words will be separated by single spaces.","""hello world amazing""",olleh dlrow gnizama,"Input: hello world amazing
Output: olleh dlrow gnizama
Input: this is a test
Output: siht is a tset
Input: quick brown rabbit
Output: quick nworb tibbar
Input: aeiou
Output: uoiea",,,,,,
White-38,"Conditionals (if-else, switch-case)",,"Write a program that takes a student's numerical score as input and outputs their letter grade based on the following scale:

* 90-100: A
* 80-89: B
* 70-79: C
* 60-69: D
* Below 60: F",* The input score will be an integer between 0 and 100 (inclusive).,85,B,"Input: 95
Output: A
Input: 78
Output: C
Input: 60
Output: D
Input: 55
Output: F
Input: 88
Output: B",,,,,,
White-39,"Basic Array Operations (sum, max, min)",,"Given an array of integers, find the sum, maximum, and minimum values.","- The array will contain at least one integer.
- The integers in the array will be within the range of your chosen language's integer type.","[1, 5, 2, 8, 3]","Sum: 19, Max: 8, Min: 1","Input: [10, 20, 30, 40, 50]
Output: Sum: 150, Max: 50, Min: 10
Input: [-1, 0, 1]
Output: Sum: 0, Max: 1, Min: -1
Input: [5]
Output: Sum: 5, Max: 5, Min: 5
Input: [-5, -10, -15]
Output: Sum: -30, Max: -5, Min: -15",,,,,,
White-40,GCD/LCM,,"Given two positive integers, find their greatest common divisor (GCD).","* 1 ≤ a, b ≤ 1000","a = 12, b = 18",6,"Input: 48 18
Output: 6
Input: 15 25
Output: 5
Input: 10 5
Output: 5
Input: 7 13
Output: 1",,,,,,
White-41,Variables & Data Types,,You're a programmer planning a tropical island hopping adventure!  You need to keep track of the number of islands visited and the total coconut count collected on your journey.  Write a program that takes the number of islands visited and coconuts collected as input and displays these values.,"- The number of islands visited must be a non-negative integer.
- The total number of coconuts collected must be a non-negative integer.",3 15,"Islands Visited: 3, Total Coconuts: 15","Input: 5 20
Output: Islands Visited: 5, Total Coconuts: 20
Input: 0 0
Output: Islands Visited: 0, Total Coconuts: 0
Input: 1 100
Output: Islands Visited: 1, Total Coconuts: 100
Input: 12 345
Output: Islands Visited: 12, Total Coconuts: 345",,,,,,
White-42,Type Casting,,"You are given an integer `n`. Your task is to convert this integer to a double, then to a float, then back to an integer, and finally print the final integer value.",* -1000 ≤ n ≤ 1000,123,123,"Input: 345
Output: 345
Input: -99
Output: -99
Input: 0
Output: 0
Input: 1000
Output: 1000
Input: -527
Output: -527",,,,,,
White-43,Break & Continue,,"You're navigating a digital labyrinth represented as a list of integers.  Your goal is to find the sum of all even numbers, but you must avoid certain numbers (marked as -1). If you encounter a -1, skip it using 'continue', and if the sum exceeds 100, break out of the loop using 'break'.","- The input list will contain integers between -1 and 1000 (inclusive).
- The list's length will be at most 100.","[2, 4, 6, -1, 8, 10, 12, 14, 16, 18, 20]",56,"Input: [1, 3, 5, 7, 9]
Output: 0
Input: [2, 4, 6, 8, 10, 12, 14, 16, 18, 20, 22]
Output: 110
Input: [100, -1, 50, 2, 4, 6, 8]
Output: 100
Input: [-1, -1, -1, 2, 4, 6]
Output: 12",,,,,,
White-44,"Loops (for, while)",,"Write a program that calculates the sum of all even numbers from 1 to N, where N is a positive integer provided as input.",- 1 ≤ N ≤ 1000,10,30 (2 + 4 + 6 + 8 + 10),"Input: 5
Output: 6
Input: 100
Output: 2550
Input: 1
Output: 0
Input: 7
Output: 12
Input: 1000
Output: 250500",,,,,,
White-45,"Operators (Arithmetic, Relational, Logical)",,"Given three integers, determine if the sum of any two of them is equal to the third.  If so, return 1; otherwise, return 0.","- All three integers will be within the range of [-100, 100].","5, 3, 8","1 (because 5 + 3 = 8)

Input: 2, 7, 10","Input: 10, 5, 15
Output: 1
Input: 2, 4, 6
Output: 1
Input: 1, 2, 4
Output: 0
Input: -5, 0, 5
Output: 1
Input: 100, -50, 50
Output: 1",,,,,,
White-46,"Operators (Arithmetic, Relational, Logical)",,"Given two integer inputs, `a` and `b`, determine if the following conditions are met simultaneously:

1. `a` is greater than 10.
2. `b` is less than or equal to 5.
3.  The logical AND of (`a` > 10) and (`b` <= 5) is true, but the logical OR of those same conditions is false.  This is a trick to check for understanding of logical operators.

Your program should output `true` if all three conditions are true; otherwise, output `false`.","-100 ≤ a ≤ 100
-100 ≤ b ≤ 100",15 3,"false

Input: 20 5","Input: 15 3
Output: false
Input: 20 5
Output: false
Input: 12 2
Output: false
Input: 5 10
Output: false
Input: 11 0
Output: false",,,,,,
White-47,Palindrome Check,,"Given a string, determine if it is a palindrome. A palindrome is a string that reads the same forwards and backward, ignoring case and non-alphanumeric characters.","- The input string will contain only ASCII characters.
- The length of the string will be between 1 and 1000 characters.","""A man, a plan, a canal: Panama""","true

Input: ""race a car""","Input: ""Racecar""
Output: true
Input: ""A man, a plan, a canal: Panama""
Output: true
Input: ""1a2""
Output: false
Input: "".""
Output: true
Input: "".,""
Output: true",,,,,,
White-48,Bitwise Operators,,"Given an integer `n`, determine if it's a power of 2.  A power of 2 is a number of the form 2<sup>k</sup> where k is a non-negative integer.",* 0 <= n <= 10<sup>9</sup>,16,"true

Input: 10","Input: 64
Output: true
Input: 0
Output: false
Input: 21845
Output: false
Input: 1
Output: true
Input: 1024
Output: true",,,,,,
White-49,String Reversal,,"Given a string containing words separated by spaces, reverse the order of the words.  Do not reverse the characters within each word.","- The input string will contain only lowercase alphabetical characters and spaces.
- There will be at least one word in the input string.
- Leading and trailing spaces should be ignored.
- Multiple spaces between words are allowed, but only single space should be in the output.","""hello world this is a sentence""","""sentence a is this world hello""","Input: This is a test
Output: test a is This
Input:  Leading and trailing spaces  
Output: spaces trailing and Leading
Input: Multiple spaces between words
Output: words between spaces Multiple
Input: a
Output: a
Input:One Word
Output:Word One",,,,,,
White-50,Function Definition & Call,,"Write a function that takes a planet's name and generates a personalized greeting. The greeting should be in the format: ""Greetings from [planet name]! Welcome to the Galactic Federation.""","- The planet name will be a non-empty string.
- The planet name can contain spaces.",Earth,Greetings from Earth! Welcome to the Galactic Federation.,"Input: Kepler-186f
Output: Greetings from Kepler-186f! Welcome to the Galactic Federation.
Input: Mars
Output: Greetings from Mars! Welcome to the Galactic Federation.
Input: Proxima Centauri b
Output: Greetings from Proxima Centauri b! Welcome to the Galactic Federation.
Input:  Alderaan
Output: Greetings from Alderaan! Welcome to the Galactic Federation.",,,,,,
White-51,Bitwise Operators,,"Given an integer, write a function that flips the least significant bit (LSB) of the integer. The LSB is the rightmost bit in the binary representation of the integer.",* The input integer will be within the range of a 32-bit signed integer.,10 (binary: 1010),"9 (binary: 1001)

Input: 5 (binary: 0101)","Input: 15
Output: 14
Input: 0
Output: 1
Input: -1
Output: 0
Input: 255
Output: 254
Input: 1023
Output: 1022",,,,,,
White-52,Return Values,,Write a function that takes two integers as input and returns their sum.  The function should handle both positive and negative integers.,"- The input integers will be within the range of a 32-bit integer.
- The sum of the two integers will also be within the range of a 32-bit integer.","5, 10","15

Input: -3, 7","Input: 15, 20
Output: 35
Input: -10, 5
Output: -5
Input: 0, 0
Output: 0
Input: -20, -30
Output: -50
Input: 100000, -50000
Output: 50000",,,,,,
White-53,Best/Worst/Average Case Basics,,"Given an unsorted array of integers, find the largest element in the array. Analyze the best, worst, and average-case time complexity of your solution.","- The array will contain at least one element.
- The elements in the array are integers.","[3, 1, 4, 1, 5, 9, 2, 6, 5, 3, 5]",9,"Input: [1, 5, 2, 8, 3]
Output: 8
Input: [9, 9, 9, 9, 9]
Output: 9
Input: [-1, -5, -2, -8, -3]
Output: -1
Input: [10, 20, 30, 40, 50, 60]
Output: 60",,,,,,
White-54,Best/Worst/Average Case Basics,,"Given an unsorted array of integers, find the maximum element in the array. Analyze the best, worst, and average-case time complexities.","- The array will contain at least one element.
- The elements in the array are integers.","[3, 1, 4, 1, 5, 9, 2, 6]",9,"Input: [1, 5, 2, 8, 3]
Output: 8
Input: [9, 9, 9, 9]
Output: 9
Input: [-1, -5, -2, -8, -3]
Output: -1
Input: [10]
Output: 10",,,,,,
White-55,Input/Output,,"Write a program that takes two inputs from the user: first, their name (a single word string), and then their age (an integer). After reading these inputs, the program should print a friendly greeting message that includes both the name and age.","- The name will be a single word (no spaces).
- The name will consist only of English alphabet characters.
- The age will be a positive integer between 1 and 120, inclusive.","Sarah
25",Hello Sarah! You are 25 years old.,"Input:
Bob
18
Output:
Hello Bob! You are 18 years old.
Input:
Alice
100
Output:
Hello Alice! You are 100 years old.
Input:
Zoe
7
Output:
Hello Zoe! You are 7 years old.",,,,,,
White-56,Parameters & Arguments,,"Welcome, future DSA expert! Your first mission is to build a friendly ""Greeting Machine."" You'll be given a person's name, and your program needs to generate a personalized greeting message. This exercise is all about understanding how to use **parameters** to pass information into a function and **arguments** as the actual values supplied when calling that function.

Imagine you have a robot that says ""Hello, [name]! Welcome to DSA!"". You need to teach your program to take a name, use it to complete the greeting, and then display the full message.","*   The input `name` will be a single word (no spaces).
*   The `name` will consist only of English alphabet characters (a-z, A-Z).
*   The length of the `name` will be between 1 and 50 characters, inclusive.","`Alice`

####","`Hello, Alice! Welcome to DSA!`","Input: Eve
Output: Hello, Eve! Welcome to DSA!
Input: MaximillianAlexander
Output: Hello, MaximillianAlexander! Welcome to DSA!
Input: dEvID
Output: Hello, dEvID! Welcome to DSA!
Input: Charlie
Output: Hello, Charlie! Welcome to DSA!",,,,,,
White-57,Basic String Manipulation,,"You are given a string `s` and a character `charToRemove`. Your task is to remove all occurrences of `charToRemove` from `s` and return the new string.

For example, if `s = ""hello world""` and `charToRemove = 'l'`, the result should be `""heo word""`.","* The input string `s` will consist of ASCII characters.
* The length of `s` will be between 0 and 1000 characters.
* The `charToRemove` will be a single ASCII character.
* The removal is case-sensitive.","string s = ""programming""
char charToRemove = 'g'","""proammin""","Input: programming
g
Output: proammin
Input: apple
p
Output: ale
Input: test string
x
Output: test string
Input: 
a
Output: 
Input: AAAAA
A
Output: 
Input: Hello World
l
Output: Heo Word",,,,,,
White-58,Prime Check,,"A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. In other words, a prime number has exactly two distinct positive divisors: 1 and the number itself.

Your task is to write a program that takes an integer `N` as input and determines whether it is a prime number. The program should output ""true"" if `N` is prime, and ""false"" otherwise.","- `0 <= N <= 1,000,000`","**
7

**","**
true

**","Input: 0
Output: false
Input: 2
Output: true
Input: 3
Output: true
Input: 9
Output: false
Input: 999983
Output: true",,,,,,
White-59,Intro to Recursion (factorial),,"The factorial of a non-negative integer `n`, denoted as `n!`, is the product of all positive integers less than or equal to `n`. For example, `5! = 5 * 4 * 3 * 2 * 1 = 120`. An important special case is `0!`, which is defined as `1`.

Your task is to write a function that calculates the factorial of a given non-negative integer `n` using recursion. This problem is designed to introduce you to the fundamental concepts of recursion: defining a base case and a recursive step.","*   `0 <= n <= 12` (The result for `n=13` and above might exceed the capacity of a standard 32-bit integer, and for larger values, the call stack might overflow, depending on the language and environment.)","**

5

**","**

120

**","Input: 0
Output: 1
Input: 1
Output: 1
Input: 3
Output: 6
Input: 7
Output: 5040
Input: 12
Output: 479001600",,,,,,
White-60,Parameters & Arguments,,You're building a simple program that greets users personally. Your task is to implement a function that takes a person's name as an input and then prints a friendly greeting using that name. This problem focuses on understanding how to define a function that accepts parameters and how to pass arguments to it.,"* The name will be a single line of text.
* The name will consist of English letters and spaces.
* The length of the name will be between 1 and 50 characters, inclusive.","Alice

####","Hello, Alice! Welcome to the program.","Input: Bob
Output: Hello, Bob! Welcome to the program.
Input: Charlie Brown
Output: Hello, Charlie Brown! Welcome to the program.
Input: Ada Lovelace
Output: Hello, Ada Lovelace! Welcome to the program.
Input: Z
Output: Hello, Z! Welcome to the program.
Input: SuperLongNameWithLotsOfCharactersToTestTheConstraints
Output: Hello, SuperLongNameWithLotsOfCharactersToTestTheConstraints! Welcome to the program.",,,,,,
White-61,1D Array Declaration & Traversal,,"You're given a list of `N` integers. Your task is to read these integers, store them in a 1D array, and then print them out in reverse order, with each number separated by a space.","*   `1 <= N <= 100`
*   `-1000 <= element <= 1000` (Each integer in the list)",,,"Input: 1
500
Output: 500
Input: 3
1 2 3
Output: 3 2 1
Input: 4
-5 0 10 -20
Output: -20 10 0 -5
Input: 6
100 200 300 400 500 600
Output: 600 500 400 300 200 100",,,,,,
White-62,1D Array Declaration & Traversal,,"You are given a list of `N` integers. Your task is to read these integers into a 1D array and then print them out in reverse order, separated by spaces.

For example, if the input integers are `10 20 30`, you should print `30 20 10`.","*   `1 <= N <= 100` (The number of integers will be between 1 and 100)
*   Each integer will be between `1` and `1000`.","3
10 20 30


####",30 20 10,"Input: 1
50
Output: 50
Input: 2
100 200
Output: 200 100
Input: 5
1 2 3 4 5
Output: 5 4 3 2 1
Input: 4
99 88 77 66
Output: 66 77 88 99",,,,,,
White-63,Modulo Arithmetic,,"Imagine a 24-hour clock. Given the current hour and a number of hours that will pass, your task is to determine what the hour will be after the duration has passed. The clock operates from 0 to 23 (e.g., 0 is midnight, 13 is 1 PM, 23 is 11 PM).","*   `0 <= current_hour <= 23`
*   `0 <= duration_hours <= 1000`
*   The final hour should also be between 0 and 23.","**

10
5

This means `current_hour = 10` and `duration_hours = 5`.

**","**

15","Input: 0
0
Output: 0
Input: 23
1
Output: 0
Input: 12
24
Output: 12
Input: 5
40
Output: 21
Input: 1
1000
Output: 17",,,,,,
White-64,Modulo Arithmetic,,"You are given three positive integers: `a`, `b`, and `m`. Your task is to find the sum of `a` and `b`, and then calculate the remainder when this sum is divided by `m`. In mathematical terms, you need to compute `(a + b) % m`.","*   `1 <= a, b, m <= 1000`","**
`a = 5`
`b = 7`
`m = 5`

**","**
`2`

**","Input: 1 1 10
Output: 2
Input: 5 5 10
Output: 0
Input: 9 8 5
Output: 2
Input: 1 1 1
Output: 0
Input: 1000 1000 999
Output: 2",,,,,,
White-65,Modulo Arithmetic,,"You are given two integers, `a` and `b`, and a modulus `m`. Your task is to calculate the sum of `a` and `b`, and then find the remainder when this sum is divided by `m`. In mathematical terms, you need to compute `(a + b) % m`.","* `0 <= a, b <= 10^9`
* `1 <= m <= 10^9`","5
7
3

####","0

####","Input: 10
15
7
Output: 4
Input: 1
1
2
Output: 0
Input: 1000000000
1000000000
999999999
Output: 2
Input: 0
0
5
Output: 0",,,,,,
White-66,Intro to Time & Space Complexity,,"You're given a positive integer `N`. Your task is to calculate the sum of all positive integers from 1 up to `N` (inclusive).

For example, if `N` is 3, the sum would be 1 + 2 + 3 = 6.",* `1 <= N <= 1000`,"3

####",6,"Input: 1
Output: 1
Input: 5
Output: 15
Input: 10
Output: 55
Input: 100
Output: 5050",,,,,,
White-67,Intro to Time & Space Complexity,,You are given an array of integers. Your task is to calculate the sum of all its elements. This is a great starting point to understand how to iterate through data structures and analyze the resources your code uses.,"* The array will contain between 1 and 100 integers, inclusive.
* Each integer in the array will be between -100 and 100, inclusive.","3
1 2 3


####","6


####","Input: 5
10 20 30 40 50
Output: 150
Input: 1
-7
Output: -7
Input: 4
-1 -2 -3 -4
Output: -10
Input: 2
0 0
Output: 0",,,,,,
White-68,Input/Output,,"You are given a single integer as input. Your task is to read this integer, calculate its square (the number multiplied by itself), and then print the result to standard output.

This problem is designed to introduce you to basic input/output operations and simple arithmetic in your chosen programming language.",*   The input integer `N` will be between 1 and 1000 (inclusive).,"5


####",25,"Input: 1
Output: 1
Input: 10
Output: 100
Input: 1000
Output: 1000000
Input: 50
Output: 2500",,,,,,
White-69,Best/Worst/Average Case Basics,,"You are given an array of integers and a target integer. Your task is to implement a linear search algorithm to find the target in the array. In addition to returning the index of the target (or -1 if not found), you must also count the total number of comparisons made during the search.

This problem helps you understand the concepts of Best, Worst, and Average case time complexity by observing how the number of comparisons changes based on the target's position.","- The array `nums` will have a length `N` between 1 and 100.
- Each element `nums[i]` will be an integer between -100 and 100.
- The target integer `target` will be between -100 and 100.","**
N = 5
nums = [10, 20, 30, 40, 50]
target = 30

**","**
Found at index 2 in 3 comparisons

**Input:**
N = 4
nums = [5, 15, 25, 35]
target = 40

**","Input:
7
1 2 3 4 5 6 7
1
Output:
Found at index 0 in 1 comparisons
Input:
5
-10 -5 0 5 10
10
Output:
Found at index 4 in 5 comparisons
Input:
6
100 90 80 70 60 50
45
Output:
Not found in 6 comparisons
Input:
1
42
42
Output:
Found at index 0 in 1 comparisons
Input:
1
42
99
Output:
Not found in 1 comparisons",,,,,,
White-70,String Reversal,,"Your task is to write a program that takes a given string and reverses the order of its characters. For example, if the input is ""hello"", the output should be ""olleh"". This is a fundamental problem that helps build a strong understanding of string manipulation and iteration.","*   The input string will contain printable ASCII characters (letters, numbers, symbols, and spaces).
*   The length of the input string will be between 0 and 1000 characters, inclusive.
*   An empty string should remain an empty string.",hello,"olleh



Input: world","Input: racecar
Output: racecar
Input: a
Output: a
Input: 
Output: 
Input: Hello World!
Output: !dlroW olleH
Input: 123456789
Output: 987654321",,,,,,
White-71,Bitwise Operators,,"You are given an integer `num` and a non-negative integer `n`. Your task is to toggle (flip) the `n`-th bit of `num` and return the new integer. The `n`-th bit is 0-indexed, meaning the 0-th bit is the rightmost (least significant) bit.","*   `0 <= num <= 10^9`
*   `0 <= n <= 30`","**

num = 4
n = 1


**Explanation:**
1.  The decimal number `4` in binary is `...0100`.
2.  The `n`-th bit is the 1st bit (0-indexed). In `...0100`, the 1st bit is currently `0`.
3.  To toggle this bit means to flip its value from `0` to `1`.
4.  After flipping, the binary representation becomes `...0110`.
5.  The binary `...0110` is `6` in decimal.

**","**

6","Input: 7 0
Output: 6
Input: 10 3
Output: 2
Input: 0 5
Output: 32
Input: 25 2
Output: 29
Input: 1 0
Output: 0",,,,,,
White-72,"Operators (Arithmetic, Relational, Logical)",,"You are given three integers: `num1`, `num2`, and `num3`. Your task is to perform two distinct calculations and print their results.

1.  **Arithmetic Calculation**: Calculate the value of `(num1 + num2) * num3`.
2.  **Logical Calculation**: Evaluate the boolean expression `(num1 > num2) && (num2 < num3)`.

Print the result of the arithmetic calculation on the first line, and the result of the logical calculation (as `true` or `false` or their equivalent in the respective language, e.g., `1` or `0` for C/C++, `True` or `False` for Python) on the second line.","- `1 <= num1, num2, num3 <= 1000`","10
5
20

####","300
true

####","Input: 1
2
3
Output: 9
false
Input: 100
50
25
Output: 3750
false
Input: 7
7
7
Output: 98
false
Input: 1000
1
500
Output: 500500
true",,,,,,
White-73,Prime Check,,"You've been tasked with a critical mission: to determine if a given positive integer is a prime number. A prime number is a natural number greater than 1 that has no positive divisors other than 1 and itself. Your program should read an integer and output ""Yes"" if it's prime, and ""No"" otherwise.","*   `1 <= N <= 1,000,000`","**
7

**","**
Yes

**Input:**
10

**","Input: 1
Output: No
Input: 2
Output: Yes
Input: 4
Output: No
Input: 13
Output: Yes
Input: 999983
Output: Yes",,,,,,
White-74,Parameters & Arguments,,Write a program that takes a string and an integer as input. The program should then print the given string the specified number of times.,"*   The input string will not contain any newlines.
*   The integer will be a non-negative integer.",Hello 3,"Hello
Hello
Hello","Input: Test 2
Output:
Test
Test
Input: Code 4
Output:
Code
Code
Code
Code
Input: Hello_World 1
Output:
Hello_World
Input: Empty 0
Output:
",,,,,,
White-75,Break & Continue,,"Given an integer `limit` and an integer `skip_value`, print all numbers from 1 to `limit` (inclusive), skipping the multiples of `skip_value`.","*   `1 <= limit <= 100`
*   `1 <= skip_value <= 10`",,,"Input: 10 3
Output: 1 2 4 5 7 8 10
Input: 15 5
Output: 1 2 3 4 6 7 8 9 11 12 13 14
Input: 7 2
Output: 1 3 5 7
Input: 5 1
Output: 
Input: 20 4
Output: 1 2 3 5 6 7 9 10 11 13 14 15 17 18 19",,,,,,
White-76,Type Casting,,"You are given an integer `A` and a double-precision floating-point number `B`. Your task is to perform specific type conversions and calculations:

1.  **Integer to Double:** Convert integer `A` to a `double` and store it in a new variable, say `double_A`.
2.  **Double to Integer:** Convert double `B` to an `integer` (truncating any decimal part) and store it in a new variable, say `int_B`.
3.  **Double Sum:** Calculate the sum of `double_A` (the converted `A`) and the original `double B`. Store this in `double_sum`.
4.  **Integer Sum:** Calculate the sum of the original `integer A` and `int_B` (the converted `B`). Store this in `int_sum`.

Finally, print the four resulting values (`double_A`, `int_B`, `double_sum`, `int_sum`) in the order specified, each on a new line. Floating-point numbers should be printed with two decimal places.","- `-1000 <= A <= 1000`
- `-1000.0 <= B <= 1000.0`
- Input will consist of a single line with `A` followed by `B`, separated by a space.",`10 5.75`,"10.00
5
15.75
15","Input: -7 3.14
Output: -7.00
3
-3.86
-4
Input: 0 0.99
Output: 0.00
0
0.99
0
Input: 999 999.99
Output: 999.00
999
1998.99
1998
Input: -1000 -10.5
Output: -1000.00
-10
-1010.50
-1010",,,,,,
White-77,Intro to Time & Space Complexity,,"Imagine you're tracking scores in a game, and you want to know how many players scored above a certain benchmark. Your task is to implement a function that takes a list of integer scores and a threshold integer. It should return the total count of scores that are strictly greater than the given threshold.","*   `1 <= N <= 100` (where `N` is the number of scores in the input list)
*   `0 <= score[i] <= 1000` (each individual score will be between 0 and 1000)
*   `0 <= threshold <= 1000` (the threshold will also be between 0 and 1000)","**
`scores = [10, 20, 5, 30, 15]`
`threshold = 12`

**","**
`3`

**","Input: 5
1 2 3 4 5
0
Output: 5
Input: 3
100 200 300
500
Output: 0
Input: 4
7 7 7 7
7
Output: 0
Input: 1
50
49
Output: 1
Input: 10
10 20 30 40 50 60 70 80 90 100
75
Output: 3",,,,,,
White-78,Variables & Data Types,,"Welcome, White Belt! In this problem, you'll practice one of the most fundamental concepts in programming: using variables to store different types of data and then displaying them. Your task is to read three distinct pieces of information from the user:
1. An integer number.
2. A floating-point number (a number with decimals).
3. A single word (a string).

After reading these inputs, you must store each of them in a variable of the appropriate data type. Finally, you will print all the stored values back to the console, following a specific format, and also show the integer value incremented by one.","*   The integer number will be between 1 and 100 (inclusive).
*   The floating-point number will be between 0.0 and 100.0 (inclusive).
*   The string will be a single word, containing only alphabetical characters, with a maximum length of 10 characters.","10
3.14
Hello


####","You entered:
Integer: 10
Float: 3.14
String: Hello
Next Integer: 11","Input: 5
1.23
World
Output: You entered:
Integer: 5
Float: 1.23
String: World
Next Integer: 6
Input: 99
99.99
Test
Output: You entered:
Integer: 99
Float: 99.99
String: Test
Next Integer: 100
Input: 1
0.0
Start
Output: You entered:
Integer: 1
Float: 0.00
String: Start
Next Integer: 2
Input: 50
25.5
MidPoint
Output: You entered:
Integer: 50
Float: 25.50
String: MidPoint
Next Integer: 51",,,,,,
White-79,Intro to Recursion (factorial),,"Welcome to your first dive into the world of recursion! Your task is to calculate the factorial of a given non-negative integer `n`. The factorial of a non-negative integer `n`, denoted by `n!`, is the product of all positive integers less than or equal to `n`. For example, `5! = 5 × 4 × 3 × 2 × 1 = 120`. A special case is `0!`, which is defined as `1`.

You must implement the factorial calculation **recursively**. This means your function should call itself to solve smaller sub-problems until it reaches a simple base case.","*   `0 <= n <= 12`
*   The input `n` will always be a non-negative integer.
*   The result will fit within a standard 64-bit integer type (like `long long` in C++ or `long` in Java).","**

5


**","**

120","Input: 0
Output: 1
Input: 1
Output: 1
Input: 3
Output: 6
Input: 7
Output: 5040
Input: 10
Output: 3628800",,,,,,
White-80,Function Definition & Call,,"You need to write a program that calculates a ""doubled sum"". Specifically, your program should read two integers, calculate their sum, and then multiply that sum by 2. This core logic must be encapsulated within a function. Your main program will read the inputs, call this function, and print the result.",- The input integers `num1` and `num2` will be between -1000 and 1000.,"5
3",16,"Input: 10
20
Output: 60
Input: -5
-3
Output: -16
Input: 10
-7
Output: 6
Input: 0
0
Output: 0
Input: 15
0
Output: 30",,,,,,
White-81,Return Values,,"You've been hired by a magical shop that specializes in duplicating items! Your first task is to write a program that calculates the ""doubled value"" of any given integer.

Specifically, you need to create a function that takes one integer as input, multiplies it by 2, and then returns the result. Your `main` (or equivalent) function should read an integer, call your duplicating function, and print the returned doubled value.","*   The input integer `N` will be between -1000 and 1000, inclusive.","5

####","10


####","Input: -7
Output: -14
Input: 0
Output: 0
Input: 500
Output: 1000
Input: -499
Output: -998",,,,,,
White-85,Type Casting,,"Welcome, White Belt coder! In this problem, you'll explore the fundamental concept of ""type casting,"" which is how you convert data from one type to another. You will be given two numbers: an integer and a floating-point number (decimal). Your task is to perform two specific type conversions and print the results.

Specifically, you need to:
1. Convert the given integer into a floating-point number.
2. Convert the given floating-point number into an integer.

Pay attention to how different languages handle these conversions and potential data loss when converting from a floating-point number to an integer.","- The input integer `N` will be within the range of standard integer types (e.g., -2 * 10^9 to 2 * 10^9).
- The input floating-point number `D` will be within the range of standard double/float types (e.g., -10^18 to 10^18).
- Inputs will always be valid numbers.","**
15
5.75

**","**
15.000000
5

_Note: The number of decimal places for the float output might vary slightly by language, but the value should be equivalent. We will aim for 6 decimal places where possible._","Input:
-10
-3.14
Output:
-10.000000
-3
Input:
0
0.0
Output:
0.000000
0
Input:
2147483647
12345.6789
Output:
2147483647.000000
12345
Input:
99
4.999999
Output:
99.000000
4
Input:
-5
9.123
Output:
-5.000000
9",,,,,,
Yellow-2,Insertion Sort,,"You are given an unsorted array of integers. Your task is to sort this array in ascending order using the Insertion Sort algorithm.

Insertion Sort works by taking one element at a time from the unsorted part and inserting it into its correct position within the already sorted part of the array. This process continues until all elements are in their sorted positions.","- `1 <= n <= 1000` (where `n` is the number of elements in the array)
- `-1000 <= arr[i] <= 1000` (where `arr[i]` is an element in the array)
- The input array will contain only integers.","6
5 2 4 6 1 3

####",1 2 3 4 5 6,"Input: 5
1 2 3 4 5
Output: 1 2 3 4 5
Input: 5
5 4 3 2 1
Output: 1 2 3 4 5
Input: 5
4 2 1 4 3
Output: 1 2 3 4 4
Input: 1
7
Output: 7
Input: 4
-3 0 -1 2
Output: -3 -1 0 2",,,,,,
White-88,"Operators (Arithmetic, Relational, Logical)",,"You are given two integers, `num1` and `num2`. Your task is to determine if both numbers collectively satisfy a specific set of criteria. You need to combine the results of several individual checks using logical operators.

The conditions are:
1.  `num1` must be an even number.
2.  `num2` must be a positive number (strictly greater than 0).
3.  The sum of `num1` and `num2` must be strictly less than 50.
4.  The product of `num1` and `num2` must be strictly greater than 0.

If all four conditions are met, your function should return `true`. Otherwise, it should return `false`.","*   `num1` and `num2` will be integers.
*   `-100 <= num1, num2 <= 100`","**

10
5


**","**

true


**","Input: 7
10
Output: false
Input: 4
-2
Output: false
Input: 20
30
Output: false
Input: 8
0
Output: false
Input: 2
20
Output: true",,,,,,
White-89,"Array, String",,"Given two string arrays word1 and word2, return true if the two arrays represent the same string, and false otherwise.

A string is represented by an array if the array elements concatenated in order forms the string.

Example 1:

Input: word1 = [""ab"", ""c""], word2 = [""a"", ""bc""]
Output: true
Explanation:
word1 represents string ""ab"" + ""c"" -> ""abc""
word2 represents string ""a"" + ""bc"" -> ""abc""
The strings are the same, so return true.

Example 2:

Input: word1 = [""a"", ""cb""], word2 = [""ab"", ""c""]
Output: false

Example 3:

Input: word1  = [""abc"", ""d"", ""defg""], word2 = [""abcddefg""]
Output: true

Constraints:

	1 3
	1 3
	1 3
	word1[i] and word2[i] consist of lowercase letters.",,,,"[""ab"", ""c""]
[""a"", ""bc""]
[""a"", ""cb""]
[""ab"", ""c""]
[""abc"", ""d"", ""defg""]
[""abcddefg""]",,,,,,
DELETE-89-check-if-two-string-arrays-are-equivalent,Deletion,N/A,Deleted folder: 89-check-if-two-string-arrays-are-equivalent,N/A,N/A,N/A,N/A,,,,,,
White-89,"Array, String, String Matching",,"Given an array of string words, return all strings in words that are a substring of another word. You can return the answer in any order.

Example 1:

Input: words = [""mass"",""as"",""hero"",""superhero""]
Output: [""as"",""hero""]
Explanation: ""as"" is substring of ""mass"" and ""hero"" is substring of ""superhero"".
[""hero"",""as""] is also a valid answer.

Example 2:

Input: words = [""leetcode"",""et"",""code""]
Output: [""et"",""code""]
Explanation: ""et"", ""code"" are substring of ""leetcode"".

Example 3:

Input: words = [""blue"",""green"",""bu""]
Output: []
Explanation: No string of words is substring of another string.

Constraints:

	1 
	1 
	words[i] contains only lowercase English letters.
	All the strings of words are unique.",,,,"[""mass"",""as"",""hero"",""superhero""]
[""leetcode"",""et"",""code""]
[""blue"",""green"",""bu""]",,,,,,
White-90,GCD/LCM,,"You are given two positive integers, `a` and `b`. Your task is to find their Greatest Common Divisor (GCD) and Least Common Multiple (LCM).

The Greatest Common Divisor (GCD) of two integers is the largest positive integer that divides both numbers without leaving a remainder. For example, the GCD of 12 and 18 is 6.

The Least Common Multiple (LCM) of two integers is the smallest positive integer that is a multiple of both numbers. For example, the LCM of 12 and 18 is 36.

You need to output both GCD and LCM for the given pair of numbers.","*   `1 <= a, b <= 10^5`
*   `a` and `b` are positive integers.","12 18

####","GCD: 6
LCM: 36","Input: 7 13
Output: GCD: 1
LCM: 91
Input: 100 75
Output: GCD: 25
LCM: 300
Input: 48 36
Output: GCD: 12
LCM: 144
Input: 5 5
Output: GCD: 5
LCM: 5",,,,,,
White-91,"Loops (for, while)",,"You are tasked with writing a program that calculates the sum of all even numbers up to a given positive integer `N`, inclusive. For example, if `N` is 7, the even numbers within the range [1, 7] are 2, 4, and 6, and their sum is 12.",* `1 <= N <= 1000`,"**

7

**","**

12","Input: 1
Output: 0
Input: 2
Output: 2
Input: 10
Output: 30
Input: 99
Output: 2450
Input: 1000
Output: 250500",,,,,,
Yellow-3,2D Arrays / Matrix Operations,,"You are given a 2D integer array (matrix). Your task is to calculate the sum of all elements that lie on the perimeter of the matrix. The perimeter includes all elements in the first row, last row, first column, and last column. Be careful not to double-count elements that are part of multiple perimeter segments (i.e., the corner elements).","*   `1 <= rows, cols <= 100` (where `rows` is the number of rows and `cols` is the number of columns).
*   `-1000 <= matrix[i][j] <= 1000` (elements can be positive, negative, or zero).","3 3
1 2 3
4 5 6
7 8 9

####","40


####","Input: 1 1
5
Output: 5
Input: 1 4
10 20 30 40
Output: 100
Input: 4 1
1
2
3
4
Output: 10
Input: 2 2
1 2
3 4
Output: 10
Input: 4 3
1 -2 3
4 5 6
7 8 9
-10 11 -12
Output: 1",,,,,,
Yellow-4,Sliding Window Intro,,You are given an array of integers `arr` and an integer `k`. Your task is to find the maximum sum of a subarray of `arr` that has a length exactly `k`. This means you need to consider all possible contiguous subarrays of size `k` and determine which one has the largest sum.,"*   `1 <= arr.length <= 10^5`
*   `1 <= k <= arr.length`
*   `0 <= arr[i] <= 1000` (Elements are non-negative to keep it simple for an intro problem)
*   The sum of any subarray will fit within a standard integer type.","**

6
2 1 5 1 3 2
3

**","**

9


**","Input: 5
1 2 3 4 5
3
Output: 12
Input: 1
100
1
Output: 100
Input: 7
10 2 3 4 5 6 7
4
Output: 22
Input: 8
1 1 1 1 1 1 1 1
2
Output: 2
Input: 6
1 2 3 4 5 0
3
Output: 12",,,,,,
Yellow-5,Doubly Linked List basics,,"You're tasked with enhancing a Doubly Linked List (DLL) by implementing a function to append a new node to its very end. Given the head and tail of an existing DLL (which might be empty) and an integer value, your goal is to create a new node with this value and add it as the new tail of the list. Remember to correctly update all `next` and `prev` pointers, including those of the old tail (if it exists) and the new node itself.","*   The input list can be empty.
*   The number of nodes `N` in the initial list will be between `0` and `1000`.
*   The value `V` to insert will be an integer between `-10^9` and `10^9`.
*   The `head` and `tail` pointers should always correctly point to the beginning and end of the list, respectively, after the operation.","**

1 2 3
4

(Initial DLL: `1 <-> 2 <-> 3`, Value to insert: `4`)

**","**

1 <-> 2 <-> 3 <-> 4


#### Example 2:
**Input:**

EMPTY
5

(Initial DLL: `Empty List`, Value to insert: `5`)

**","Input: 10
20
Output: 10 <-> 20
Input: 1 2 3 4 5
0
Output: 1 <-> 2 <-> 3 <-> 4 <-> 5 <-> 0
Input: -5 -4 -3
-2
Output: -5 <-> -4 <-> -3 <-> -2
Input: 7
7
Output: 7 <-> 7",,,,,,
Yellow-6,Stack Implementation (Array/LL),,"Your mission is to implement a basic Stack data structure that supports four fundamental operations: `push`, `pop`, `top`, and `isEmpty`. You will receive a sequence of commands, and your program must process them, outputting results for `pop`, `top`, and `isEmpty` operations.

The stack should adhere to the Last-In, First-Out (LIFO) principle. For operations that attempt to `pop` or retrieve `top` from an empty stack, a specific error value (`-1`) should be returned. Similarly, `push` operations should handle the case where the stack is at its maximum capacity.","*   The stack will have a maximum capacity of `1000` elements.
*   The number of operations `N` will be between `1` and `1000`.
*   Values pushed onto the stack will be integers between `-10^9` and `10^9`.
*   Operations will be one of the following strings:
    *   `push <value>`: Adds `value` to the top of the stack.
    *   `pop`: Removes and returns the top element.
    *   `top`: Returns the top element without removing it.
    *   `isEmpty`: Returns `true` if the stack is empty, `false` otherwise.","8
push 10
push 20
pop
top
isEmpty
pop
pop
isEmpty


####","20
10
false
10
-1
true","Input: 3
pop
top
isEmpty
Output: -1
-1
true
Input: 12
push 1
push 2
push 3
push 4
push 5
push 6
top
pop
top
pop
top
pop
isEmpty
Output: 5
5
4
4
3
3
false
Input: 7
push 100
pop
isEmpty
push 200
top
pop
isEmpty
Output: 100
true
200
200
true",,,,,,
Yellow-7,Bubble Sort,,"You are given an array of integers. Your task is to sort this array in ascending order using the Bubble Sort algorithm.

Bubble Sort is a simple sorting algorithm that repeatedly steps through the list, compares adjacent elements, and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted.","*   `1 <= N <= 1000` (where N is the number of elements in the array)
*   `-10^9 <= array[i] <= 10^9`
*   The array may contain duplicate elements.","**

5
5 1 4 2 8


**","**

1 2 4 5 8","Input: 5
1 2 3 4 5
Output: 1 2 3 4 5
Input: 5
5 4 3 2 1
Output: 1 2 3 4 5
Input: 7
3 1 4 1 5 9 2
Output: 1 1 2 3 4 5 9
Input: 1
42
Output: 42
Input: 2
7 3
Output: 3 7",,,,,,
Yellow-8,Bubble Sort,,"You've been given an array of integers. Your task is to sort this array in ascending order using the Bubble Sort algorithm. Bubble sort works by repeatedly stepping through the list, comparing adjacent elements and swapping them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted.","*   The number of elements `n` in the array will be between 1 and 1000.
*   Each element `arr[i]` will be an integer between -10000 and 10000.","`[5, 1, 4, 2, 8]`","`[1, 2, 4, 5, 8]`

**","Input: 5
1 2 3 4 5
Output: 1 2 3 4 5
Input: 5
5 4 3 2 1
Output: 1 2 3 4 5
Input: 8
3 1 4 1 5 9 2 6
Output: 1 1 2 3 4 5 6 9
Input: 1
7
Output: 7
Input: 5
-5 0 -2 3 1
Output: -5 -2 0 1 3",,,,,,
Yellow-9,Bubble Sort,,"You are tasked with sorting an array of integers in ascending order using the Bubble Sort algorithm. Bubble Sort is a simple comparison-based sorting algorithm. It works by repeatedly stepping through the list, comparing adjacent elements and swapping them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted.

Your program should read an integer `N`, followed by `N` integers representing the elements of the array. It should then apply Bubble Sort and print the sorted array.","*   `1 <= N <= 100`
*   `0 <= arr[i] <= 1000`","**

5
5 1 4 2 8


**","**

1 2 4 5 8","Input: 1
7
Output: 7
Input: 4
4 3 2 1
Output: 1 2 3 4
Input: 6
5 2 8 2 5 1
Output: 1 2 2 5 5 8
Input: 5
10 20 30 40 50
Output: 10 20 30 40 50
Input: 9
99 11 77 33 55 22 88 44 66
Output: 11 22 33 44 55 66 77 88 99",,,,,,
Yellow-10,Selection Sort,,You are given an array of integers. Your task is to sort this array in ascending order using the Selection Sort algorithm. Selection Sort works by repeatedly finding the minimum element from the unsorted part and putting it at the beginning of the unsorted part.,"* `1 <= n <= 1000` (where `n` is the number of elements in the array)
* `-1000 <= arr[i] <= 1000`
* The array may contain duplicate elements.","**
`[64, 25, 12, 22, 11]`

**","**
`[11, 12, 22, 25, 64]`

**","Input: 5
1 2 3 4 5
Output: 1 2 3 4 5
Input: 7
5 4 3 2 1 0 -1
Output: -1 0 1 2 3 4 5
Input: 6
4 2 1 4 3 5
Output: 1 2 3 4 4 5
Input: 4
-5 -2 0 -10
Output: -10 -5 -2 0
Input: 1
7
Output: 7",,,,,,
White-92,Intro to Time & Space Complexity,,"You are given a list (or array) of whole numbers. Your task is to find the single largest number within this list. For example, if the list is `[3, 1, 7, 4, 2]`, the largest number is `7`.","*   The input array will contain at least one element.
*   The number of elements in the array (N) will be between 1 and 1000.
*   Each element in the array will be an integer between -1000 and 1000.","**

5
5 2 9 1 7


**","**

9","Input: 5
10 20 5 30 15
Output: 30
Input: 3
-5 -1 -10
Output: -1
Input: 1
100
Output: 100
Input: 7
7 7 7 7 7 7 7
Output: 7
Input: 4
-10 0 10 -20
Output: 10",,,,,,
White-93,LeetCode,,,,,,"Input: [1,2,0]
Output: [0,1,2],Input: [2,0,1,0]
Output: [0,0,1,2],Input: [0,1,2,0,1,2]
Output: [0,0,1,1,2,2],Input: [2,1,0,1,2,0]
Output: [0,0,1,1,2,2],Input: []
Output: []",,,,,,
,,,,,,,,,,,,,
White-93,1D Array Declaration & Traversal,,"Given an integer array, traverse the array and print each element.","- The array will contain at least one element.
- The array will contain only integers.
- The maximum size of the array is 100.","[1, 2, 3, 4, 5]",1 2 3 4 5,"Input: [1, 2, 3]
Output: 1 2 3,Input: [10, 20, 30, 40, 50]
Output: 10 20 30 40 50,Input: [-1, 0, 1]
Output: -1 0 1,Input: [5, 4, 3, 2, 1]
Output: 5 4 3 2 1",,,,,,
Yellow-11,Naive Pattern Search,"- String manipulation
- Basic iteration
- Algorithm implementation
- Pattern matching","Implement a naive pattern searching algorithm to find all occurrences of a pattern within a text string.  The algorithm should iterate through the text and compare each character to the pattern. If a mismatch occurs, it moves to the next character in the text. If a match is found, the index of the match is recorded.","- The text and pattern will only contain lowercase English alphabet characters ('a' - 'z').
- The pattern's length will be less than or equal to the text's length.
- The pattern can appear multiple times in the text, possibly overlapping.",,,"Input: text = ""abcabcabc"", pattern = ""abc""
Output: [0, 3, 6],Input: text = ""abababab"", pattern = ""aba""
Output: [0, 2, 4],Input: text = ""hello world"", pattern = ""world""
Output: [6],Input: text = ""aaaa"", pattern = ""aa""
Output: [0, 1, 2],Input: text = ""mississippi"", pattern = ""issi""
Output: [4]",,,,,,
Yellow-11,Naive Pattern Search,,"Implement a naive pattern searching algorithm to find all occurrences of a pattern within a text string.  The algorithm should iterate through the text and compare each character to the pattern. If a mismatch occurs, it moves to the next character in the text. If a match is found, the index of the match is recorded.","- The text and pattern will only contain lowercase English alphabet characters ('a' - 'z').
- The pattern's length will be less than or equal to the text's length.
- The pattern can appear multiple times in the text, possibly overlapping.",,,"Input: text = ""abcabcabc"", pattern = ""abc""
Output: [0, 3, 6],Input: text = ""abababab"", pattern = ""aba""
Output: [0, 2, 4],Input: text = ""hello world"", pattern = ""world""
Output: [6],Input: text = ""aaaa"", pattern = ""aa""
Output: [0, 1, 2],Input: text = ""mississippi"", pattern = ""issi""
Output: [4]",,,,,,
Yellow-12,Recursive Power Function,"- Recursion
- Handling negative exponents
- Floating-point arithmetic",Write a function that calculates x raised to the power of n (xⁿ) recursively.  Handle both positive and negative exponents.,"- -100 ≤ x ≤ 100
- -10 ≤ n ≤ 10
- x != 0 when n < 0","x = 2, n = 3","8

Input: x = 5, n = -2","Input: 2 3
Output: 8.00
Input: 5 -2
Output: 0.04
Input: 3 0
Output: 1.00
Input: -2 3
Output: -8.00
Input: 10 2
Output: 100.00",,,,,,
Yellow-12,Recursive Power Function,,Write a function that calculates x raised to the power of n (xⁿ) recursively.  Handle both positive and negative exponents.,"- -100 ≤ x ≤ 100
- -10 ≤ n ≤ 10
- x != 0 when n < 0","x = 2, n = 3","8

Input: x = 5, n = -2","Input: 2 3
Output: 8.00
Input: 5 -2
Output: 0.04
Input: 3 0
Output: 1.00
Input: -2 3
Output: -8.00
Input: 10 2
Output: 100.00",,,,,,
Yellow-14,Binary Search,"*   **Binary Search**: This problem asks for the *minimum* `k` that satisfies a certain condition. The time it takes to eat all bananas is a monotonically decreasing function with respect to `k` (i.e., faster `k` means less time). This property makes it a perfect candidate for binary search on the answer space.
*   **Ceiling Division**: When calculating the time taken to eat a pile of `p` bananas at speed `k`, if `p` is not perfectly divisible by `k`, Koko still spends a full hour on the remaining bananas. This is equivalent to `ceil(p / k)`. In integer arithmetic, `ceil(a / b)` can be calculated as `(a + b - 1) / b` for positive integers `a` and `b`.
*   **Time Complexity Analysis**: Understanding how to calculate the overall time taken for an algorithm, considering the number of operations.
*   **Space Complexity Analysis**: Understanding the memory usage of an algorithm, excluding the input storage.","Koko loves to eat bananas. There are `n` piles of bananas, and the `i`-th pile has `piles[i]` bananas. Koko has to eat all the bananas within `h` hours.

Koko decides her eating speed `k` (bananas per hour). Each hour, she chooses one pile and eats `k` bananas from it. If a pile has less than `k` bananas, she eats all of them instead and will not eat any more bananas during that hour. She cannot start eating from a different pile in the same hour.

Koko wants to eat all the bananas, but she also wants to be slow enough to avoid suspicion. Your task is to find the minimum integer eating speed `k` such that she can eat all the bananas within `h` hours.","* `1 <= piles.length <= 10^4`
* `1 <= piles[i] <= 10^9`
* `piles.length <= h <= 10^9`","piles = [3,6,7,11]
h = 8",4,"Input: 4
3 6 7 11
8
Output: 4,Input: 5
30 11 23 4 20
5
Output: 30,Input: 5
30 11 23 4 20
6
Output: 23,Input: 1
1000000000
1
Output: 1000000000,Input: 4
1 1 1 999999999
10
Output: 142857143",,,,,,
Yellow-15,Frequency Count / Anagrams,"- Frequency Counting
- Character Arrays / Hash Maps
- String Manipulation","An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. For example, ""listen"" is an anagram of ""silent"".

Your task is to implement a function that determines if two given strings are anagrams of each other. The strings will consist only of lowercase English letters.","- Both input strings, `s1` and `s2`, will contain only lowercase English letters ('a'-'z').
- The length of `s1` and `s2` will be between 0 and 10^5 characters, inclusive.","s1 = ""rat""
s2 = ""art""",TRUE,"Input: listen
silent
Output: true
Input: hello
world
Output: false
Input: a
a
Output: true
Input: abc
bca
Output: true
Input: abc
ab
Output: false
Input: """"
""""
Output: true","#include <stdio.h>
#include <string.h>
#include <stdbool.h>

#define ALPHABET_SIZE 26

// Function to check if two strings are anagrams
bool areAnagrams(const char* s1, const char* s2) {
    int len1 = strlen(s1);
    int len2 = strlen(s2);

    // If lengths are different, they cannot be anagrams
    if (len1 != len2) {
        return false;
    }

    // Frequency array for lowercase English letters
    int counts[ALPHABET_SIZE] = {0}; // Initialize all to 0

    // Increment counts for characters in s1
    for (int i = 0; i < len1; i++) {
        counts[s1[i] - 'a']++;
    }

    // Decrement counts for characters in s2
    for (int i = 0; i < len2; i++) {
        counts[s2[i] - 'a']--;
    }

    // Check if all counts are zero
    for (int i = 0; i < ALPHABET_SIZE; i++) {
        if (counts[i] != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    char s1_buffer[100001]; // Max length + 1 for null terminator
    char s2_buffer[100001];

    // Read input strings
    if (scanf(""%s"", s1_buffer) != 1) return 1;
    if (scanf(""%s"", s2_buffer) != 1) return 1;

    // Call the core logic function
    if (areAnagrams(s1_buffer, s2_buffer)) {
        printf(""true\n"");
    } else {
        printf(""false\n"");
    }

    return 0;
}","def are_anagrams(s1: str, s2: str) -> bool:
    # If lengths are different, they cannot be anagrams
    if len(s1) != len(s2):
        return False

    # Frequency array (list) for lowercase English letters
    counts = [0] * 26

    # Increment counts for characters in s1
    for char_code in map(ord, s1):
        counts[char_code - ord('a')] += 1

    # Decrement counts for characters in s2
    for char_code in map(ord, s2):
        counts[char_code - ord('a')] -= 1

    # Check if all counts are zero
    for count in counts:
        if count != 0:
            return False

    return True

def main():
    s1 = input()
    s2 = input()

    # Call the core logic function
    if are_anagrams(s1, s2):
        print(""true"")
    else:
        print(""false"")

if __name__ == ""__main__"":
    main()","import java.util.Scanner;

public class Solution {

    // Function to check if two strings are anagrams
    public static boolean areAnagrams(String s1, String s2) {
        // If lengths are different, they cannot be anagrams
        if (s1.length() != s2.length()) {
            return false;
        }

        // Frequency array for lowercase English letters
        int[] counts = new int[26]; // Initialize all to 0 by default

        // Increment counts for characters in s1
        for (char c : s1.toCharArray()) {
            counts[c - 'a']++;
        }

        // Decrement counts for characters in s2
        for (char c : s2.toCharArray()) {
            counts[c - 'a']--;
        }

        // Check if all counts are zero
        for (int count : counts) {
            if (count != 0) {
                return false;
            }
        }

        return true;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read input strings
        String s1 = scanner.next();
        String s2 = scanner.next();

        // Call the core logic function
        if (areAnagrams(s1, s2)) {
            System.out.println(""true"");
        } else {
            System.out.println(""false"");
        }

        scanner.close();
    }
}","// Function to check if two strings are anagrams
function areAnagrams(s1, s2) {
    // If lengths are different, they cannot be anagrams
    if (s1.length !== s2.length) {
        return false;
    }

    // Frequency array for lowercase English letters
    const counts = new Array(26).fill(0);

    // Increment counts for characters in s1
    for (let i = 0; i < s1.length; i++) {
        counts[s1.charCodeAt(i) - 'a'.charCodeAt(0)]++;
    }

    // Decrement counts for characters in s2
    for (let i = 0; i < s2.length; i++) {
        counts[s2.charCodeAt(i) - 'a'.charCodeAt(0)]--;
    }

    // Check if all counts are zero
    for (let i = 0; i < counts.length; i++) {
        if (counts[i] !== 0) {
            return false;
        }
    }

    return true;
}

// Main function to handle I/O
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let lines = [];
    rl.on('line', (line) => {
        lines.push(line);
    }).on('close', () => {
        const s1 = lines[0];
        const s2 = lines[1];

        // Call the core logic function
        if (areAnagrams(s1, s2)) {
            console.log(""true"");
        } else {
            console.log(""false"");
        }
    });
}

// Invoke the main function
main();","#include <iostream>
#include <string>
#include <vector>

// Function to check if two strings are anagrams
bool areAnagrams(const std::string& s1, const std::string& s2) {
    // If lengths are different, they cannot be anagrams
    if (s1.length() != s2.length()) {
        return false;
    }

    // Frequency array for lowercase English letters
    std::vector<int> counts(26, 0); // Initialize all to 0

    // Increment counts for characters in s1
    for (char c : s1) {
        counts[c - 'a']++;
    }

    // Decrement counts for characters in s2
    for (char c : s2) {
        counts[c - 'a']--;
    }

    // Check if all counts are zero
    for (int count : counts) {
        if (count != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    std::ios_base::sync_with_stdio(false); // Optimize C++ I/O
    std::cin.tie(NULL);

    std::string s1, s2;

    // Read input strings
    std::cin >> s1 >> s2;

    // Call the core logic function
    if (areAnagrams(s1, s2)) {
        std::cout << ""true\n"";
    } else {
        std::cout << ""false\n"";
    }

    return 0;
}",
Yellow-16,LeetCode,"*   **Arrays**: Understanding how to store and access collections of data.
*   **Sorted Arrays**: Leveraging the property that elements are in order to optimize solutions.
*   **Iteration**: Traversing through an array to examine each element.
*   **Counting**: Keeping track of how many elements satisfy a certain condition.
*   **Binary Search (Advanced)**: For larger inputs, a more efficient search algorithm can be used to quickly find an element or a position in a sorted array based on a condition. This problem can be optimally solved using binary search by cleverly identifying a monotonic property related to missing numbers.","You are given a **strictly increasing** array `arr` of positive integers and an integer `k`.

Your task is to find the `k`-th positive integer that is **missing** from the array. Positive integers start from `1`.

For example, if `arr = [2,3,4,7,11]` and `k = 5`:
The positive integers are `1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, ...`
Numbers present in `arr`: `2, 3, 4, 7, 11`
Missing positive integers in order: `1, 5, 6, 8, 9, 10, 12, ...`
The 1st missing is `1`.
The 2nd missing is `5`.
The 3rd missing is `6`.
The 4th missing is `8`.
The 5th missing is `9`.
So, the output for this example would be `9`.","*   `1 <= arr.length <= 1000`
*   `1 <= arr[i] <= 1000 + k`
*   `1 <= k <= 1000`
*   `arr` is sorted in strictly increasing order.
*   All elements in `arr` are distinct.","arr = [2,3,4,7,11], k = 5",9,"Input: 5
2 3 4 7 11
5
Output: 9,Input: 2
10 20
5
Output: 5,Input: 4
1 2 3 4
2
Output: 6,Input: 1
1
1
Output: 2,Input: 1
2
1
Output: 1","#include <stdio.h>
#include <stdlib.h>

int findKthPositive(int* arr, int arrSize, int k) {
    int low = 0;
    int high = arrSize - 1;
    
    while (low <= high) {
        int mid = low + (high - low) / 2;
        // Count of missing numbers before arr[mid]
        // If all numbers from 1 to arr[mid] were present, there would be arr[mid] numbers.
        // But we only have (mid + 1) numbers (arr[0] to arr[mid]).
        // So, arr[mid] - (mid + 1) gives the count of missing numbers.
        if (arr[mid] - (mid + 1) < k) {
            low = mid + 1; // Not enough missing numbers, look in the right half
        } else {
            high = mid - 1; // Enough missing numbers, try to find an earlier position
        }
    }
    
    // After the loop, 'low' will be the index where the k-th missing number would be.
    // The k-th missing number is simply 'low + k'.
    return low + k;
}

int main() {
    int arr_size, k;

    // Read arr_size
    scanf(""%d"", &arr_size);

    // Allocate memory for the array
    int* arr = (int*)malloc(arr_size * sizeof(int));

    // Read array elements
    for (int i = 0; i < arr_size; i++) {
        scanf(""%d"", &arr[i]);
    }

    // Read k
    scanf(""%d"", &k);

    // Call the function and print the result
    int result = findKthPositive(arr, arr_size, k);
    printf(""%d\n"", result);

    // Free allocated memory
    free(arr);

    return 0;
}","class Solution:
    def findKthPositive(self, arr: list[int], k: int) -> int:
        low = 0
        high = len(arr) - 1
        
        while low <= high:
            mid = low + (high - low) // 2
            # Count of missing numbers before arr[mid]
            # If all numbers from 1 to arr[mid] were present, there would be arr[mid] numbers.
            # But we only have (mid + 1) numbers (arr[0] to arr[mid]).
            # So, arr[mid] - (mid + 1) gives the count of missing numbers.
            if arr[mid] - (mid + 1) < k:
                low = mid + 1  # Not enough missing numbers, look in the right half
            else:
                high = mid - 1 # Enough missing numbers, try to find an earlier position
            
        # After the loop, 'low' will be the index where the k-th missing number would be.
        # The k-th missing number is simply 'low + k'.
        return low + k

def main():
    # Read array size
    n = int(input())
    # Read array elements
    arr = list(map(int, input().split()))
    # Read k
    k = int(input())

    sol = Solution()
    result = sol.findKthPositive(arr, k)
    print(result)

if __name__ == ""__main__"":
    main()","import java.util.Scanner;

class Solution {
    public int findKthPositive(int[] arr, int k) {
        int low = 0;
        int high = arr.length - 1;
        
        while (low <= high) {
            int mid = low + (high - low) / 2;
            // Count of missing numbers before arr[mid]
            // If all numbers from 1 to arr[mid] were present, there would be arr[mid] numbers.
            // But we only have (mid + 1) numbers (arr[0] to arr[mid]).
            // So, arr[mid] - (mid + 1) gives the count of missing numbers.
            if (arr[mid] - (mid + 1) < k) {
                low = mid + 1; // Not enough missing numbers, look in the right half
            } else {
                high = mid - 1; // Enough missing numbers, try to find an earlier position
            }
        }
        
        // After the loop, 'low' will be the index where the k-th missing number would be.
        // The k-th missing number is simply 'low + k'.
        return low + k;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read array size
        int n = scanner.nextInt();
        int[] arr = new int[n];

        // Read array elements
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        // Read k
        int k = scanner.nextInt();

        Solution sol = new Solution();
        int result = sol.findKthPositive(arr, k);
        System.out.println(result);

        scanner.close();
    }
}","/**
 * @param {number[]} arr
 * @param {number} k
 * @return {number}
 */
var findKthPositive = function(arr, k) {
    let low = 0;
    let high = arr.length - 1;
    
    while (low <= high) {
        let mid = Math.floor(low + (high - low) / 2);
        // Count of missing numbers before arr[mid]
        // If all numbers from 1 to arr[mid] were present, there would be arr[mid] numbers.
        // But we only have (mid + 1) numbers (arr[0] to arr[mid]).
        // So, arr[mid] - (mid + 1) gives the count of missing numbers.
        if (arr[mid] - (mid + 1) < k) {
            low = mid + 1; // Not enough missing numbers, look in the right half
        } else {
            high = mid - 1; // Enough missing numbers, try to find an earlier position
        }
    }
    
    // After the loop, 'low' will be the index where the k-th missing number would be.
    // The k-th missing number is simply 'low + k'.
    return low + k;
};

// Main function for handling input/output
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let inputLines = [];
    rl.on('line', (line) => {
        inputLines.push(line);
    }).on('close', () => {
        let n = parseInt(inputLines[0]);
        let arr = inputLines[1].split(' ').map(Number);
        let k = parseInt(inputLines[2]);

        let result = findKthPositive(arr, k);
        console.log(result);
    });
}

// Call main to start the program
if (require.main === module) {
    main();
}","#include <iostream>
#include <vector>
#include <numeric>

class Solution {
public:
    int findKthPositive(std::vector<int>& arr, int k) {
        int low = 0;
        int high = arr.size() - 1;
        
        while (low <= high) {
            int mid = low + (high - low) / 2;
            // Count of missing numbers before arr[mid]
            // If all numbers from 1 to arr[mid] were present, there would be arr[mid] numbers.
            // But we only have (mid + 1) numbers (arr[0] to arr[mid]).
            // So, arr[mid] - (mid + 1) gives the count of missing numbers.
            if (arr[mid] - (mid + 1) < k) {
                low = mid + 1; // Not enough missing numbers, look in the right half
            } else {
                high = mid - 1; // Enough missing numbers, try to find an earlier position
            }
        }
        
        // After the loop, 'low' will be the index where the k-th missing number would be.
        // The k-th missing number is simply 'low + k'.
        return low + k;
    }
};

int main() {
    int n, k;
    std::cin >> n; // Read array size

    std::vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i]; // Read array elements
    }

    std::cin >> k; // Read k

    Solution sol;
    int result = sol.findKthPositive(arr, k);
    std::cout << result << std::endl;

    return 0;
}",
White-95,Basic String Manipulation,"*   String iteration
*   Conditional logic (if/else statements)
*   Character case checking (e.g., `is_lower`, `is_upper`)
*   Character case conversion (e.g., `to_lower`, `to_upper`)","Your task is to implement a function that takes a string as input and returns a new string where the case of each alphabetic character is swapped. This means all lowercase letters should become uppercase, and all uppercase letters should become lowercase. Non-alphabetic characters (numbers, symbols, spaces) should remain unchanged.","*   The input string will have a length between 0 and 100 characters, inclusive.
*   The string will consist of ASCII characters.","** `Hello World!`
**",** `hELLO wORLD!`,"Input: DSA CHALLENGE
Output: dsa challenge
Input: programmingisfun
Output: PROGRAMMINGISFUN
Input: 123Abc_DEF456
Output: 123aBC_def456
Input: 
Output: 
Input: !@#$%^&*()
Output: !@#$%^&*()","#include <stdio.h>
#include <string.h>
#include <ctype.h> // For islower, isupper, tolower, toupper
#include <stdlib.h> // For malloc, free

// Function to swap the case of characters in a string
char* swapCase(const char* s) {
    if (s == NULL) {
        return NULL;
    }

    size_t len = strlen(s);
    char* result = (char*)malloc(sizeof(char) * (len + 1)); // +1 for null terminator
    if (result == NULL) {
        return NULL; // Memory allocation failed
    }

    for (size_t i = 0; i < len; i++) {
        if (islower((unsigned char)s[i])) {
            result[i] = (char)toupper((unsigned char)s[i]);
        } else if (isupper((unsigned char)s[i])) {
            result[i] = (char)tolower((unsigned char)s[i]);
        } else {
            result[i] = s[i];
        }
    }
    result[len] = '\0'; // Null-terminate the result string
    return result;
}

int main() {
    char input[101]; // Max 100 chars + null terminator
    if (fgets(input, sizeof(input), stdin) == NULL) {
        return 1; // Error reading input
    }

    // Remove trailing newline character if present
    input[strcspn(input, ""\n"")] = 0;

    char* output = swapCase(input);
    if (output != NULL) {
        printf(""%s\n"", output);
        free(output); // Free allocated memory
    } else {
        // Handle error (e.g., malloc failed)
        return 1;
    }

    return 0;
}","def swapCase(s: str) -> str:
    """"""
    Swaps the case of each alphabetic character in a string.
    Lowercase letters become uppercase, and uppercase letters become lowercase.
    Non-alphabetic characters remain unchanged.
    """"""
    result_chars = []
    for char in s:
        if char.islower():
            result_chars.append(char.upper())
        elif char.isupper():
            result_chars.append(char.lower())
        else:
            result_chars.append(char)
    return """".join(result_chars)

if __name__ == ""__main__"":
    input_string = input()
    output_string = swapCase(input_string)
    print(output_string)","import java.util.Scanner;

public class Solution {

    // Function to swap the case of characters in a string
    public static String swapCase(String s) {
        if (s == null || s.isEmpty()) {
            return s;
        }

        StringBuilder result = new StringBuilder(s.length());
        for (char c : s.toCharArray()) {
            if (Character.isLowerCase(c)) {
                result.append(Character.toUpperCase(c));
            } else if (Character.isUpperCase(c)) {
                result.append(Character.toLowerCase(c));
            } else {
                result.append(c);
            }
        }
        return result.toString();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String input = scanner.nextLine();
        String output = swapCase(input);
        System.out.println(output);
        scanner.close();
    }
}","function swapCase(s) {
    if (!s) {
        return s;
    }

    let result = '';
    for (let i = 0; i < s.length; i++) {
        const char = s[i];
        // Check if the character is an alphabetic character
        if (char >= 'a' && char <= 'z') {
            result += char.toUpperCase();
        } else if (char >= 'A' && char <= 'Z') {
            result += char.toLowerCase();
        } else {
            result += char;
        }
    }
    return result;
}

// Read input from stdin
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.on('line', (line) => {
    const output = swapCase(line);
    console.log(output);
    rl.close();
});","#include <iostream>
#include <string>
#include <cctype> // For islower, isupper, tolower, toupper

// Function to swap the case of characters in a string
std::string swapCase(const std::string& s) {
    std::string result = """";
    for (char c : s) {
        if (std::islower(c)) {
            result += static_cast<char>(std::toupper(c));
        } else if (std::isupper(c)) {
            result += static_cast<char>(std::tolower(c));
        } else {
            result += c;
        }
    }
    return result;
}

int main() {
    std::string input;
    std::getline(std::cin, input);
    std::string output = swapCase(input);
    std::cout << output << std::endl;
    return 0;
}",
White-96,Basic String Manipulation,"*   String iteration
*   Character comparison
*   Basic loops (for, while)
*   Variables for counting",You will be given a string `s` and a single character `c`. Your task is to count how many times the character `c` appears in the string `s`. The count should be case-sensitive.,"*   The input string `s` will consist of printable ASCII characters (excluding spaces).
*   The length of `s` will be between 1 and 1000 characters.
*   The target character `c` will be a single printable ASCII character.
*   The count is case-sensitive (e.g., 'a' is different from 'A').","s = ""programming""
c = 'g'","2

#### Example 2:","Input: programming
g
Output: 2

Input: Apple
a
Output: 0

Input: Mississippi
i
Output: 4

Input: hello
z
Output: 0

Input: AAAAA
A
Output: 5","#include <stdio.h>
#include <string.h>

// Function to count occurrences of a character in a string
int countChar(const char* s, char c) {
    int count = 0;
    int len = strlen(s);
    for (int i = 0; i < len; i++) {
        if (s[i] == c) {
            count++;
        }
    }
    return count;
}

int main() {
    char s[1001]; // Max length 1000 + null terminator
    char c;

    // Read the string (assumes no spaces based on constraints)
    scanf(""%s"", s);

    // Read the character, with a space before %c to consume any leftover whitespace (like newline)
    scanf("" %c"", &c);

    int result = countChar(s, c);

    printf(""%d\n"", result);

    return 0;
}","def count_char(s: str, c: str) -> int:
    """"""
    Counts the occurrences of a character in a string.
    """"""
    count = 0
    for char in s:
        if char == c:
            count += 1
    return count

if __name__ == ""__main__"":
    # Read the string (assumes no spaces based on constraints)
    s = input()

    # Read the character (input() reads a line, so c will be a string of length 1)
    c = input()

    result = count_char(s, c)

    print(result)","import java.util.Scanner;

public class Solution {

    // Function to count occurrences of a character in a string
    public int countChar(String s, char c) {
        int count = 0;
        for (int i = 0; i < s.length(); i++) {
            if (s.charAt(i) == c) {
                count++;
            }
        }
        return count;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the string (assumes no spaces based on constraints)
        String s = scanner.next();

        // Read the character
        // scanner.next() reads the next token as a string, .charAt(0) takes its first character
        char c = scanner.next().charAt(0);

        Solution sol = new Solution();
        int result = sol.countChar(s, c);

        System.out.println(result);

        scanner.close();
    }
}","function countChar(s, c) {
    let count = 0;
    for (let i = 0; i < s.length; i++) {
        if (s[i] === c) {
            count++;
        }
    }
    return count;
}

// --- Standard competitive programming structure for JS on Node.js --- 
// Read all input lines
const inputLines = [];
require('readline').createInterface({
    input: process.stdin,
    output: process.stdout
}).on('line', line => {
    inputLines.push(line);
}).on('close', () => {
    // Once all input is read, call main logic
    main(inputLines);
});

function main(inputLines) {
    const s = inputLines[0]; // First line is the string
    const c = inputLines[1]; // Second line is the character (as a string of length 1)
    
    const result = countChar(s, c);
    console.log(result);
}","#include <iostream>
#include <string>
#include <vector>

// Function to count occurrences of a character in a string
int countChar(const std::string& s, char c) {
    int count = 0;
    for (char current_char : s) { // Use a range-based for loop for elegant iteration
        if (current_char == c) {
            count++;
        }
    }
    return count;
}

int main() {
    std::string s;
    char c;

    // Read the string (assumes no spaces based on constraints)
    std::cin >> s;

    // Read the character
    std::cin >> c;

    int result = countChar(s, c);

    std::cout << result << std::endl;

    return 0;
}",4
Yellow-17,Prefix & Suffix Sums,"*   Arrays
*   Prefix Sums (also known as Cumulative Sums)
*   Time Complexity Optimization
*   Basic I/O","You are given an array of integers `nums` and a list of `Q` queries. Each query consists of two indices, `start` and `end` (inclusive), representing a range within the `nums` array. Your task is to calculate the sum of all elements within each specified range `[start, end]` for every query. You need to do this efficiently, especially if there are many queries.","*   `1 <= N <= 1000` (length of `nums` array)
*   `-100 <= nums[i] <= 100`
*   `1 <= Q <= 100` (number of queries)
*   `0 <= start <= end < N` (query indices)","5
1 2 3 4 5
2
0 2
1 3


####","6
9


####","Input: 4
-1 -2 -3 -4
3
0 3
1 1
2 3
Output: -10
-2
-7
Input: 1
100
1
0 0
Output: 100
Input: 7
10 -5 20 -10 5 0 15
4
0 6
1 3
0 0
4 5
Output: 35
5
10
5
Input: 3
0 0 0
2
0 2
1 1
Output: 0
0","#include <stdio.h>
#include <stdlib.h> // For malloc

// Function to calculate range sums using prefix sums
void calculateRangeSums(int* nums, int N, int* queries, int Q) {
    // Create prefix sum array
    // prefixSum[i] stores the sum of nums[0]...nums[i-1]
    // prefixSum has size N+1
    long long* prefixSum = (long long*)malloc((N + 1) * sizeof(long long));
    if (prefixSum == NULL) {
        // Handle memory allocation failure
        return;
    }

    prefixSum[0] = 0;
    for (int i = 0; i < N; i++) {
        prefixSum[i + 1] = prefixSum[i] + nums[i];
    }

    // Process queries
    for (int i = 0; i < Q; i++) {
        int start = queries[i * 2];
        int end = queries[i * 2 + 1];
        // Sum for range [start, end] is prefixSum[end + 1] - prefixSum[start]
        long long sum = prefixSum[end + 1] - prefixSum[start];
        printf(""%lld\n"", sum);
    }

    free(prefixSum); // Free allocated memory
}

int main() {
    int N;
    scanf(""%d"", &N);

    int* nums = (int*)malloc(N * sizeof(int));
    if (nums == NULL) {
        // Handle memory allocation failure
        return 1;
    }
    for (int i = 0; i < N; i++) {
        scanf(""%d"", &nums[i]);
    }

    int Q;
    scanf(""%d"", &Q);

    // Queries are stored as pairs: [start1, end1, start2, end2, ...]
    int* queries = (int*)malloc(Q * 2 * sizeof(int));
    if (queries == NULL) {
        free(nums);
        return 1;
    }
    for (int i = 0; i < Q * 2; i += 2) {
        scanf(""%d %d"", &queries[i], &queries[i+1]);
    }

    calculateRangeSums(nums, N, queries, Q);

    free(nums);    // Free allocated memory
    free(queries); // Free allocated memory

    return 0;
}","import sys

# Function to calculate range sums using prefix sums
def calculate_range_sums(nums, queries):
    N = len(nums)
    # Create prefix sum list
    # prefix_sum[i] stores the sum of nums[0]...nums[i-1]
    # prefix_sum has size N+1
    prefix_sum = [0] * (N + 1)
    for i in range(N):
        prefix_sum[i + 1] = prefix_sum[i] + nums[i]

    # Process queries
    results = []
    for start, end in queries:
        # Sum for range [start, end] is prefix_sum[end + 1] - prefix_sum[start]
        current_sum = prefix_sum[end + 1] - prefix_sum[start]
        results.append(str(current_sum))
    
    sys.stdout.write(""\n"".join(results) + ""\n"")

if __name__ == ""__main__"":
    N = int(sys.stdin.readline())
    nums = list(map(int, sys.stdin.readline().split()))

    Q = int(sys.stdin.readline())
    queries = []
    for _ in range(Q):
        start, end = map(int, sys.stdin.readline().split())
        queries.append((start, end))

    calculate_range_sums(nums, queries)","import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

public class Main {

    // Function to calculate range sums using prefix sums
    public static void calculateRangeSums(int[] nums, List<int[]> queries) {
        int N = nums.length;
        // Create prefix sum array
        // prefixSum[i] stores the sum of nums[0]...nums[i-1]
        // prefixSum has size N+1
        long[] prefixSum = new long[N + 1];
        prefixSum[0] = 0;
        for (int i = 0; i < N; i++) {
            prefixSum[i + 1] = prefixSum[i] + nums[i];
        }

        // Process queries
        for (int[] query : queries) {
            int start = query[0];
            int end = query[1];
            // Sum for range [start, end] is prefixSum[end + 1] - prefixSum[start]
            long sum = prefixSum[end + 1] - prefixSum[start];
            System.out.println(sum);
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int N = scanner.nextInt();
        int[] nums = new int[N];
        for (int i = 0; i < N; i++) {
            nums[i] = scanner.nextInt();
        }

        int Q = scanner.nextInt();
        List<int[]> queries = new ArrayList<>();
        for (int i = 0; i < Q; i++) {
            int start = scanner.nextInt();
            int end = scanner.nextInt();
            queries.add(new int[]{start, end});
        }

        calculateRangeSums(nums, queries);

        scanner.close();
    }
}","// Function to calculate range sums using prefix sums
function calculateRangeSums(nums, queries) {
    const N = nums.length;
    // Create prefix sum array
    // prefixSum[i] stores the sum of nums[0]...nums[i-1]
    // prefixSum has size N+1
    const prefixSum = new Array(N + 1).fill(0);
    for (let i = 0; i < N; i++) {
        prefixSum[i + 1] = prefixSum[i] + nums[i];
    }

    // Process queries
    const results = [];
    for (const query of queries) {
        const start = query[0];
        const end = query[1];
        // Sum for range [start, end] is prefixSum[end + 1] - prefixSum[start]
        const sum = prefixSum[end + 1] - prefixSum[start];
        results.push(sum);
    }
    
    // Output results
    results.forEach(sum => console.log(sum));
}

// Main function to handle input and call the solver
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let lines = [];
    rl.on('line', (line) => {
        lines.push(line);
    }).on('close', () => {
        let lineIndex = 0;

        const N = parseInt(lines[lineIndex++]);
        const nums = lines[lineIndex++].split(' ').map(Number);

        const Q = parseInt(lines[lineIndex++]);
        const queries = [];
        for (let i = 0; i < Q; i++) {
            queries.push(lines[lineIndex++].split(' ').map(Number));
        }

        calculateRangeSums(nums, queries);
    });
}

main();","#include <iostream>
#include <vector>
#include <numeric> 

// Function to calculate range sums using prefix sums
void calculateRangeSums(const std::vector<int>& nums, const std::vector<std::pair<int, int>>& queries) {
    int N = nums.size();
    // Create prefix sum vector
    // prefixSum[i] stores the sum of nums[0]...nums[i-1]
    // prefixSum has size N+1
    std::vector<long long> prefixSum(N + 1, 0);
    for (int i = 0; i < N; ++i) {
        prefixSum[i + 1] = prefixSum[i] + nums[i];
    }

    // Process queries
    for (const auto& query : queries) {
        int start = query.first;
        int end = query.second;
        // Sum for range [start, end] is prefixSum[end + 1] - prefixSum[start]
        long long sum = prefixSum[end + 1] - prefixSum[start];
        std::cout << sum << std::endl;
    }
}

int main() {
    std::ios_base::sync_with_stdio(false); // Optimize C++ standard streams
    std::cin.tie(NULL);

    int N;
    std::cin >> N;

    std::vector<int> nums(N);
    for (int i = 0; i < N; ++i) {
        std::cin >> nums[i];
    }

    int Q;
    std::cin >> Q;

    std::vector<std::pair<int, int>> queries(Q);
    for (int i = 0; i < Q; ++i) {
        std::cin >> queries[i].first >> queries[i].second;
    }

    calculateRangeSums(nums, queries);

    return 0;
}",4
Yellow-18,Circular Queue basics,"*   Queue Data Structure (FIFO)
*   Array-based Implementation
*   Circular Array (using Modulo Arithmetic)
*   Pointers (Front and Rear) Management
*   Fixed-Size Data Structures","A standard queue follows a First-In-First-Out (FIFO) principle, where elements are added at the rear and removed from the front. However, when implemented with a fixed-size array, a standard queue can run into an issue where even if there's empty space at the beginning of the array, new elements cannot be added if the rear pointer reaches the end of the array.

A **Circular Queue** solves this problem by treating the array as if its ends are connected, forming a circle. When an element is added or removed, the pointers (`front` and `rear`) move in a circular fashion using the modulo operator. This allows for efficient reuse of space within a fixed-size array.

Your task is to implement a `MyCircularQueue` class that supports the following operations:
*   `MyCircularQueue(int k)`: Initializes the object with the size of the queue to be `k`.
*   `enqueue(int value)`: Inserts an element into the circular queue. Returns `true` if the operation is successful, `false` otherwise (if the queue is full).
*   `dequeue()`: Deletes an element from the circular queue. Returns `true` if the operation is successful, `false` otherwise (if the queue is empty).
*   `front()`: Gets the front item from the queue. Returns `-1` if the queue is empty.
*   `rear()`: Gets the last item from the queue. Returns `-1` if the queue is empty.
*   `isEmpty()`: Checks whether the circular queue is empty. Returns `true` if empty, `false` otherwise.
*   `isFull()`: Checks whether the circular queue is full. Returns `true` if full, `false` otherwise.","*   `1 <= k <= 1000` (Capacity of the circular queue)
*   `-1000 <= value <= 1000` (Value to enqueue)
*   At most `10000` calls will be made to `enqueue`, `dequeue`, `front`, `rear`, `isEmpty`, and `isFull`.
*   All values returned by `front()` and `rear()` for an empty queue should be `-1`.","**
MyCircularQueue 3
enqueue 1
enqueue 2
enqueue 3
enqueue 4
rear
isFull
dequeue
enqueue 4
rear
front
isEmpty
dequeue
dequeue
dequeue
isEmpty
front
exit

**","**
null
true
true
true
false
3
true
true
true
4
2
false
true
true
true
true
-1","Input: MyCircularQueue 1
enqueue 10
enqueue 20
front
rear
dequeue
front
rear
isEmpty
enqueue 30
front
rear
isFull
dequeue
exit
Output: null
true
false
10
10
true
-1
-1
true
true
30
30
true
true

Input: MyCircularQueue 5
enqueue 1
enqueue 2
enqueue 3
dequeue
dequeue
enqueue 4
enqueue 5
enqueue 6
enqueue 7
enqueue 8
front
rear
isEmpty
isFull
dequeue
dequeue
dequeue
dequeue
dequeue
dequeue
isEmpty
exit
Output: null
true
true
true
true
true
true
true
true
true
true
false
false
3
8
false
true
true
true
true
true
false
true

Input: MyCircularQueue 2
isEmpty
front
rear
enqueue 5
isEmpty
isFull
enqueue 10
enqueue 15
front
rear
dequeue
dequeue
isEmpty
dequeue
exit
Output: null
true
-1
-1
true
false
true
false
5
10
true
true
true
true","#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

typedef struct {
    int *data;
    int front;
    int rear;
    int capacity;
    int count;
} MyCircularQueue;

MyCircularQueue* myCircularQueueCreate(int k) {
    MyCircularQueue* obj = (MyCircularQueue*) malloc(sizeof(MyCircularQueue));
    obj->data = (int*) malloc(sizeof(int) * k);
    obj->capacity = k;
    obj->front = 0;
    obj->rear = 0; // rear points to the next available slot
    obj->count = 0;
    return obj;
}

bool myCircularQueueIsEmpty(MyCircularQueue* obj) {
    return obj->count == 0;
}

bool myCircularQueueIsFull(MyCircularQueue* obj) {
    return obj->count == obj->capacity;
}

bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) {
    if (myCircularQueueIsFull(obj)) {
        return false;
    }
    obj->data[obj->rear] = value;
    obj->rear = (obj->rear + 1) % obj->capacity;
    obj->count++;
    return true;
}

bool myCircularQueueDeQueue(MyCircularQueue* obj) {
    if (myCircularQueueIsEmpty(obj)) {
        return false;
    }
    obj->front = (obj->front + 1) % obj->capacity;
    obj->count--;
    return true;
}

int myCircularQueueFront(MyCircularQueue* obj) {
    if (myCircularQueueIsEmpty(obj)) {
        return -1;
    }
    return obj->data[obj->front];
}

int myCircularQueueRear(MyCircularQueue* obj) {
    if (myCircularQueueIsEmpty(obj)) {
        return -1;
    }
    // (obj->rear - 1 + obj->capacity) % obj->capacity handles when rear is 0
    return obj->data[(obj->rear - 1 + obj->capacity) % obj->capacity];
}

void myCircularQueueFree(MyCircularQueue* obj) {
    free(obj->data);
    free(obj);
}

int main() {
    char command[20];
    int k, value;
    MyCircularQueue* obj = NULL;

    while (scanf(""%s"", command) != EOF) {
        if (strcmp(command, ""MyCircularQueue"") == 0) {
            scanf(""%d"", &k);
            if (obj != NULL) {
                myCircularQueueFree(obj); // Free previous object if any
            }
            obj = myCircularQueueCreate(k);
            printf(""null\n"");
        } else if (obj == NULL) {
            // Should not happen based on problem constraints (MyCircularQueue will be called first)
            continue;
        } else if (strcmp(command, ""enqueue"") == 0) {
            scanf(""%d"", &value);
            printf(""%s\n"", myCircularQueueEnQueue(obj, value) ? ""true"" : ""false"");
        } else if (strcmp(command, ""dequeue"") == 0) {
            printf(""%s\n"", myCircularQueueDeQueue(obj) ? ""true"" : ""false"");
        } else if (strcmp(command, ""front"") == 0) {
            printf(""%d\n"", myCircularQueueFront(obj));
        } else if (strcmp(command, ""rear"") == 0) {
            printf(""%d\n"", myCircularQueueRear(obj));
        } else if (strcmp(command, ""isEmpty"") == 0) {
            printf(""%s\n"", myCircularQueueIsEmpty(obj) ? ""true"" : ""false"");
        } else if (strcmp(command, ""isFull"") == 0) {
            printf(""%s\n"", myCircularQueueIsFull(obj) ? ""true"" : ""false"");
        } else if (strcmp(command, ""exit"") == 0) {
            break;
        }
    }

    if (obj != NULL) {
        myCircularQueueFree(obj);
    }

    return 0;
}","class MyCircularQueue:
    def __init__(self, k: int):
        self.capacity = k
        self.data = [0] * k
        self.front = 0
        self.rear = 0 # rear points to the next available slot
        self.count = 0

    def enQueue(self, value: int) -> bool:
        if self.isFull():
            return False
        self.data[self.rear] = value
        self.rear = (self.rear + 1) % self.capacity
        self.count += 1
        return True

    def deQueue(self) -> bool:
        if self.isEmpty():
            return False
        self.front = (self.front + 1) % self.capacity
        self.count -= 1
        return True

    def Front(self) -> int:
        if self.isEmpty():
            return -1
        return self.data[self.front]

    def Rear(self) -> int:
        if self.isEmpty():
            return -1
        # (self.rear - 1 + self.capacity) % self.capacity handles when rear is 0
        return self.data[(self.rear - 1 + self.capacity) % self.capacity]

    def isEmpty(self) -> bool:
        return self.count == 0

    def isFull(self) -> bool:
        return self.count == self.capacity

def main():
    obj = None
    while True:
        try:
            line = input().split()
            command = line[0]

            if command == ""MyCircularQueue"":
                k = int(line[1])
                obj = MyCircularQueue(k)
                print(""null"")
            elif obj is None:
                # Should not happen based on problem constraints
                continue
            elif command == ""enqueue"":
                value = int(line[1])
                print(""true"" if obj.enQueue(value) else ""false"")
            elif command == ""dequeue"":
                print(""true"" if obj.deQueue() else ""false"")
            elif command == ""front"":
                print(obj.Front())
            elif command == ""rear"":
                print(obj.Rear())
            elif command == ""isEmpty"":
                print(""true"" if obj.isEmpty() else ""false"")
            elif command == ""isFull"":
                print(""true"" if obj.isFull() else ""false"")
            elif command == ""exit"":
                break
        except EOFError:
            break

if __name__ == ""__main__"":
    main()","import java.util.Scanner;

class MyCircularQueue {
    private int[] data;
    private int front;
    private int rear; // rear points to the next available slot
    private int capacity;
    private int count;

    public MyCircularQueue(int k) {
        capacity = k;
        data = new int[k];
        front = 0;
        rear = 0;
        count = 0;
    }

    public boolean enQueue(int value) {
        if (isFull()) {
            return false;
        }
        data[rear] = value;
        rear = (rear + 1) % capacity;
        count++;
        return true;
    }

    public boolean deQueue() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        count--;
        return true;
    }

    public int Front() {
        if (isEmpty()) {
            return -1;
        }
        return data[front];
    }

    public int Rear() {
        if (isEmpty()) {
            return -1;
        }
        // (rear - 1 + capacity) % capacity handles when rear is 0
        return data[(rear - 1 + capacity) % capacity];
    }

    public boolean isEmpty() {
        return count == 0;
    }

    public boolean isFull() {
        return count == capacity;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String command;
        int k, value;
        MyCircularQueue obj = null;

        while (scanner.hasNext()) {
            command = scanner.next();
            if (command.equals(""MyCircularQueue"")) {
                k = scanner.nextInt();
                obj = new MyCircularQueue(k);
                System.out.println(""null"");
            } else if (obj == null) {
                // Should not happen based on problem constraints
                continue;
            } else if (command.equals(""enqueue"")) {
                value = scanner.nextInt();
                System.out.println(obj.enQueue(value) ? ""true"" : ""false"");
            } else if (command.equals(""dequeue"")) {
                System.out.println(obj.deQueue() ? ""true"" : ""false"");
            } else if (command.equals(""front"")) {
                System.out.println(obj.Front());
            } else if (command.equals(""rear"")) {
                System.out.println(obj.Rear());
            } else if (command.equals(""isEmpty"")) {
                System.out.println(obj.isEmpty() ? ""true"" : ""false"");
            } else if (command.equals(""isFull"")) {
                System.out.println(obj.isFull() ? ""true"" : ""false"");
            } else if (command.equals(""exit"")) {
                break;
            }
        }
        scanner.close();
    }
}","class MyCircularQueue {
    /**
     * @param {number} k
     */
    constructor(k) {
        this.capacity = k;
        this.data = new Array(k);
        this.front = 0;
        this.rear = 0; // rear points to the next available slot
        this.count = 0;
    }

    /**
     * @param {number} value
     * @return {boolean}
     */
    enQueue(value) {
        if (this.isFull()) {
            return false;
        }
        this.data[this.rear] = value;
        this.rear = (this.rear + 1) % this.capacity;
        this.count++;
        return true;
    }

    /**
     * @return {boolean}
     */
    deQueue() {
        if (this.isEmpty()) {
            return false;
        }
        this.front = (this.front + 1) % this.capacity;
        this.count--;
        return true;
    }

    /**
     * @return {number}
     */
    Front() {
        if (this.isEmpty()) {
            return -1;
        }
        return this.data[this.front];
    }

    /**
     * @return {number}
     */
    Rear() {
        if (this.isEmpty()) {
            return -1;
        }
        // (this.rear - 1 + this.capacity) % this.capacity handles when rear is 0
        return this.data[(this.rear - 1 + this.capacity) % this.capacity];
    }

    /**
     * @return {boolean}
     */
    isEmpty() {
        return this.count === 0;
    }

    /**
     * @return {boolean}
     */
    isFull() {
        return this.count === this.capacity;
    }
}

// Main function for I/O handling
function main() {
    let obj = null;
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    rl.on('line', (line) => {
        const parts = line.split(' ');
        const command = parts[0];

        if (command === ""MyCircularQueue"") {
            const k = parseInt(parts[1]);
            obj = new MyCircularQueue(k);
            console.log(""null"");
        } else if (obj === null) {
            // Should not happen based on problem constraints
            return;
        } else if (command === ""enqueue"") {
            const value = parseInt(parts[1]);
            console.log(obj.enQueue(value) ? ""true"" : ""false"");
        } else if (command === ""dequeue"") {
            console.log(obj.deQueue() ? ""true"" : ""false"");
        } else if (command === ""front"") {
            console.log(obj.Front());
        } else if (command === ""rear"") {
            console.log(obj.Rear());
        } else if (command === ""isEmpty"") {
            console.log(obj.isEmpty() ? ""true"" : ""false"");
        } else if (command === ""isFull"") {
            console.log(obj.isFull() ? ""true"" : ""false"");
        } else if (command === ""exit"") {
            rl.close();
        }
    });
}

main();","#include <iostream>
#include <vector>
#include <string>

class MyCircularQueue {
private:
    std::vector<int> data;
    int front;
    int rear; // rear points to the next available slot
    int capacity;
    int count;

public:
    MyCircularQueue(int k) {
        capacity = k;
        data.resize(k);
        front = 0;
        rear = 0;
        count = 0;
    }

    bool enQueue(int value) {
        if (isFull()) {
            return false;
        }
        data[rear] = value;
        rear = (rear + 1) % capacity;
        count++;
        return true;
    }

    bool deQueue() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        count--;
        return true;
    }

    int Front() {
        if (isEmpty()) {
            return -1;
        }
        return data[front];
    }

    int Rear() {
        if (isEmpty()) {
            return -1;
        }
        // (rear - 1 + capacity) % capacity handles when rear is 0
        return data[(rear - 1 + capacity) % capacity];
    }

    bool isEmpty() {
        return count == 0;
    }

    bool isFull() {
        return count == capacity;
    }
};

int main() {
    std::string command;
    int k, value;
    MyCircularQueue* obj = nullptr;

    while (std::cin >> command) {
        if (command == ""MyCircularQueue"") {
            std::cin >> k;
            if (obj != nullptr) {
                delete obj; // Free previous object if any
            }
            obj = new MyCircularQueue(k);
            std::cout << ""null\n"";
        } else if (obj == nullptr) {
            continue; // Should not happen based on problem constraints
        } else if (command == ""enqueue"") {
            std::cin >> value;
            std::cout << (obj->enQueue(value) ? ""true"" : ""false"") << ""\n"";
        } else if (command == ""dequeue"") {
            std::cout << (obj->deQueue() ? ""true"" : ""false"") << ""\n"";
        } else if (command == ""front"") {
            std::cout << obj->Front() << ""\n"";
        } else if (command == ""rear"") {
            std::cout << obj->Rear() << ""\n"";
        } else if (command == ""isEmpty"") {
            std::cout << (obj->isEmpty() ? ""true"" : ""false"") << ""\n"";
        } else if (command == ""isFull"") {
            std::cout << (obj->isFull() ? ""true"" : ""false"") << ""\n"";
        } else if (command == ""exit"") {
            break;
        }
    }

    if (obj != nullptr) {
        delete obj;
    }

    return 0;
}",4
Yellow-19,Linear Search,"*   Arrays
*   Loops (for/while)
*   Conditional Statements (if)
*   Basic Iteration","You are given an array of integers `nums` and a `target` integer. Your task is to find the first occurrence of the `target` in the `nums` array. If the `target` is found, return its index. If the `target` is not present in the array, return `-1`.

This is a classic problem that introduces the concept of iterating through a list of items to find a specific one, also known as Linear Search.","*   `1 <= n <= 1000`, where `n` is the length of `nums`.
*   `-1000 <= nums[i] <= 1000`
*   `-1000 <= target <= 1000`","5
2
5
1
9
7
9",3,"Input:
5
10
20
30
40
50
10
Output:
0
Input:
4
-5
-1
0
8
8
Output:
3
Input:
6
1
2
3
2
1
4
2
Output:
1
Input:
1
5
5
Output:
0
Input:
1
5
10
Output:
-1","#include <stdio.h>
#include <stdlib.h>

// Function to perform linear search
int linearSearch(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}

int main() {
    int n;
    // Read the size of the array
    if (scanf(""%d"", &n) != 1 || n <= 0) {
        fprintf(stderr, ""Invalid array size.\n"");
        return 1;
    }

    int *arr = (int *)malloc(n * sizeof(int));
    if (arr == NULL) {
        fprintf(stderr, ""Memory allocation failed.\n"");
        return 1;
    }

    // Read array elements
    for (int i = 0; i < n; i++) {
        if (scanf(""%d"", &arr[i]) != 1) {
            fprintf(stderr, ""Invalid array element.\n"");
            free(arr);
            return 1;
        }
    }

    int target;
    // Read the target element
    if (scanf(""%d"", &target) != 1) {
        fprintf(stderr, ""Invalid target element.\n"");
        free(arr);
        return 1;
    }

    // Call the linear search function
    int result = linearSearch(arr, n, target);

    // Print the result
    printf(""%d\n"", result);

    free(arr); // Free allocated memory
    return 0;
}","import sys

def linear_search(arr, target):
    """"""
    Performs a linear search to find the target in the array.
    Returns the index of the target if found, otherwise -1.
    """"""
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # Target found, return its index
    return -1  # Target not found

if __name__ == ""__main__"":
    # Read the size of the array
    try:
        n = int(input())
    except ValueError:
        print(""Invalid array size."", file=sys.stderr)
        sys.exit(1)

    if n <= 0:
        print(""Invalid array size."", file=sys.stderr)
        sys.exit(1)

    arr = []
    # Read array elements one by one
    for _ in range(n):
        try:
            arr.append(int(input()))
        except ValueError:
            print(""Invalid array element."", file=sys.stderr)
            sys.exit(1)

    # Read the target element
    try:
        target = int(input())
    except ValueError:
        print(""Invalid target element."", file=sys.stderr)
        sys.exit(1)

    # Call the linear search function
    result = linear_search(arr, target)

    # Print the result
    print(result)","import java.util.Scanner;

public class Main {

    // Function to perform linear search
    public static int linearSearch(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i; // Target found, return its index
            }
        }
        return -1; // Target not found
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the size of the array
        int n = scanner.nextInt();
        if (n <= 0) {
            System.err.println(""Invalid array size."");
            scanner.close();
            return;
        }

        int[] arr = new int[n];
        // Read array elements
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        // Read the target element
        int target = scanner.nextInt();

        // Call the linear search function
        int result = linearSearch(arr, target);

        // Print the result
        System.out.println(result);

        scanner.close();
    }
}","// Function to perform linear search
function linearSearch(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}

// Main execution part for Node.js environment
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let input = [];
rl.on('line', (line) => {
    input.push(line);
}).on('close', () => {
    let lineIdx = 0;

    // Read the size of the array
    const n = parseInt(input[lineIdx++]);
    if (isNaN(n) || n <= 0) {
        console.error(""Invalid array size."");
        process.exit(1);
    }

    let arr = [];
    // Read array elements
    for (let i = 0; i < n; i++) {
        const num = parseInt(input[lineIdx++]);
        if (isNaN(num)) {
            console.error(""Invalid array element."");
            process.exit(1);
        }
        arr.push(num);
    }

    // Read the target element
    const target = parseInt(input[lineIdx++]);
    if (isNaN(target)) {
        console.error(""Invalid target element."");
        process.exit(1);
    }

    // Call the linear search function
    const result = linearSearch(arr, target);

    // Print the result
    console.log(result);
});","#include <iostream>
#include <vector>

// Function to perform linear search
int linearSearch(const std::vector<int>& arr, int target) {
    for (int i = 0; i < arr.size(); ++i) {
        if (arr[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    // Read the size of the array
    std::cin >> n;
    if (n <= 0) {
        std::cerr << ""Invalid array size.\n"";
        return 1;
    }

    std::vector<int> arr(n);
    // Read array elements
    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i];
    }

    int target;
    // Read the target element
    std::cin >> target;

    // Call the linear search function
    int result = linearSearch(arr, target);

    // Print the result
    std::cout << result << std::endl;

    return 0;
}",4
Yellow-20,Linear Search,"*   Arrays
*   Iteration (loops)
*   Conditional Statements
*   Basic Searching","You are given an array of integers and a target integer. Your task is to implement a function that finds the first occurrence of the target integer in the array. If the target is found, return its 0-based index. If the target is not present in the array, return -1.","*   `1 <= N <= 1000` (where N is the number of elements in the array)
*   `-1000 <= ` `array[i]` `<= 1000`
*   `-1000 <= ` `target` `<= 1000`","5
10 20 30 40 50
30

####","2

####","Input:
5
5 10 15 20 25
5
Output: 0
Input:
6
100 200 300 400 500 600
250
Output: -1
Input:
7
1 5 3 5 8 5 9
5
Output: 1
Input:
1
42
42
Output: 0
Input:
1
10
5
Output: -1","#include <stdio.h>
#include <stdlib.h> // Required for malloc and free

// Function to perform linear search
int linearSearch(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}

int main() {
    int n;
    // Read the number of elements
    scanf(""%d"", &n);

    // Dynamically allocate memory for the array
    int *arr = (int *)malloc(n * sizeof(int));
    if (arr == NULL) {
        return 1; // Memory allocation failed
    }

    // Read array elements
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]);
    }

    int target;
    // Read the target element
    scanf(""%d"", &target);

    // Call the linear search function
    int result = linearSearch(arr, n, target);

    // Print the result
    printf(""%d\n"", result);

    // Free the dynamically allocated memory
    free(arr);

    return 0;
}","def linear_search(arr, target):
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # Target found, return its index
    return -1  # Target not found

if __name__ == ""__main__"":
    # Read the number of elements
    n = int(input())

    # Read array elements
    arr = list(map(int, input().split()))

    # Read the target element
    target = int(input())

    # Call the linear search function
    result = linear_search(arr, target)

    # Print the result
    print(result)","import java.util.Scanner;

public class Main {

    // Function to perform linear search
    public static int linearSearch(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i; // Target found, return its index
            }
        }
        return -1; // Target not found
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the number of elements
        int n = scanner.nextInt();

        // Create an array and read elements
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        // Read the target element
        int target = scanner.nextInt();

        // Call the linear search function
        int result = linearSearch(arr, target);

        // Print the result
        System.out.println(result);

        scanner.close();
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let input = [];

rl.on('line', (line) => {
    input.push(line);
}).on('close', () => {
    // Function to perform linear search
    function linearSearch(arr, target) {
        for (let i = 0; i < arr.length; i++) {
            if (arr[i] === target) {
                return i; // Target found, return its index
            }
        }
        return -1; // Target not found
    }

    const n = parseInt(input[0]);
    const arr = input[1].split(' ').map(Number);
    const target = parseInt(input[2]);

    const result = linearSearch(arr, target);
    console.log(result);
});","#include <iostream>
#include <vector>

// Function to perform linear search
int linearSearch(const std::vector<int>& arr, int target) {
    for (int i = 0; i < arr.size(); ++i) {
        if (arr[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}

int main() {
    int n;
    // Read the number of elements
    std::cin >> n;

    // Create a vector and read elements
    std::vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i];
    }

    int target;
    // Read the target element
    std::cin >> target;

    // Call the linear search function
    int result = linearSearch(arr, target);

    // Print the result
    std::cout << result << std::endl;

    return 0;
}",4
Yellow-21,"Singly Linked List (creation, traversal, insertion, deletion)","- Singly Linked List: Node structure, creation, traversal.
- Pointer/Reference manipulation for deletion.
- Handling edge cases such as deleting the head node or an empty list.","You are tasked with a fundamental operation on singly linked lists. Given an array of integers, you must first construct a singly linked list from these values. After the list is created, you will be given a target integer. Your goal is to find the *first occurrence* of this target value in the linked list and delete the corresponding node. If the target value is not found, the list should remain unchanged. Finally, you need to return the head of the modified linked list.","- The number of nodes in the linked list will be between 0 and 1000.
- Each node's value will be an integer between -1000 and 1000.
- The target value will be an integer between -1000 and 1000.","**
Array: `[1, 2, 3, 4, 5]`
Target to delete: `3`

**Expected","**
Linked List: `1 -> 2 -> 4 -> 5`","Input: 1 2 3 4 5
6
Output: 1 2 3 4 5
Input: 10 20 30
10
Output: 20 30
Input: 5
5
Output: Empty
Input: 1 2 2 3
2
Output: 1 2 3
Input: 
5
Output: Empty","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Definition for singly-linked list.
typedef struct ListNode {
    int val;
    struct ListNode *next;
} ListNode;

// Function to create a new node
ListNode* createNode(int val) {
    ListNode* newNode = (ListNode*)malloc(sizeof(ListNode));
    if (newNode == NULL) {
        perror(""Failed to allocate memory for node"");
        exit(EXIT_FAILURE);
    }
    newNode->val = val;
    newNode->next = NULL;
    return newNode;
}

// Function to create a linked list from an array (represented as space-separated string)
ListNode* createListFromArray(const char* input_str) {
    ListNode* head = NULL;
    ListNode* tail = NULL;
    
    // Handle empty input string for an empty list
    if (input_str == NULL || strlen(input_str) == 0 || (strlen(input_str) == 1 && input_str[0] == '\n')) {
        return NULL;
    }

    char* str_copy = strdup(input_str); // Duplicate string for strtok_r
    if (str_copy == NULL) {
        perror(""Failed to duplicate string"");
        exit(EXIT_FAILURE);
    }
    
    char* token;
    char* rest = str_copy;

    while ((token = strtok_r(rest, "" "", &rest)) != NULL) {
        int val = atoi(token);
        ListNode* newNode = createNode(val);
        if (head == NULL) {
            head = newNode;
            tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
    }
    free(str_copy);
    return head;
}

// Function to delete the first occurrence of a node with a specific value
ListNode* deleteFirstOccurrence(ListNode* head, int target) {
    if (head == NULL) {
        return NULL;
    }

    // Case 1: Head node is the target
    if (head->val == target) {
        ListNode* temp = head;
        head = head->next;
        free(temp); // Free memory of the deleted node
        return head;
    }

    // Case 2: Target is in the rest of the list
    ListNode* current = head->next;
    ListNode* previous = head;

    while (current != NULL && current->val != target) {
        previous = current;
        current = current->next;
    }

    // If target found
    if (current != NULL) {
        previous->next = current->next;
        free(current); // Free memory of the deleted node
    }

    return head;
}

// Function to print the linked list
void printList(ListNode* head) {
    if (head == NULL) {
        printf(""Empty\n"");
        return;
    }
    ListNode* current = head;
    while (current != NULL) {
        printf(""%d"", current->val);
        if (current->next != NULL) {
            printf("" "");
        }
        current = current->next;
    }
    printf(""\n"");
}

// Function to free the linked list memory
void freeList(ListNode* head) {
    ListNode* current = head;
    while (current != NULL) {
        ListNode* next = current->next;
        free(current);
        current = next;
    }
}

int main() {
    char line[4000]; // Increased buffer size for potentially large inputs
    
    // Read array input
    if (fgets(line, sizeof(line), stdin) == NULL) {
        return 1;
    }
    line[strcspn(line, ""\n"")] = 0; // Remove newline character

    ListNode* head = createListFromArray(line);

    // Read target value
    int target;
    if (scanf(""%d"", &target) != 1) {
        freeList(head);
        return 1;
    }

    head = deleteFirstOccurrence(head, target);

    printList(head);
    freeList(head); // Free all allocated memory

    return 0;
}","class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def createListFromArray(self, arr):
        if not arr:
            return None
        head = ListNode(arr[0])
        tail = head
        for i in range(1, len(arr)):
            tail.next = ListNode(arr[i])
            tail = tail.next
        return head

    def deleteFirstOccurrence(self, head: ListNode, target: int) -> ListNode:
        if not head:
            return None

        # Case 1: Head node is the target
        if head.val == target:
            return head.next

        # Case 2: Target is in the rest of the list
        current = head.next
        previous = head

        while current and current.val != target:
            previous = current
            current = current.next

        # If target found
        if current:
            previous.next = current.next
        
        return head

    def printList(self, head: ListNode):
        if not head:
            print(""Empty"")
            return
        current = head
        result = []
        while current:
            result.append(str(current.val))
            current = current.next
        print("" "".join(result))

if __name__ == ""__main__"":
    sol = Solution()

    # Read array input
    line = input()
    arr = []
    if line.strip(): # Handle empty line for empty list case
        arr = list(map(int, line.split()))

    head = sol.createListFromArray(arr)

    # Read target value
    target = int(input())

    head = sol.deleteFirstOccurrence(head, target)

    sol.printList(head)","import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

// Definition for singly-linked list.
class ListNode {
    int val;
    ListNode next;

    ListNode(int x) {
        val = x;
        next = null;
    }
}

class Solution {

    // Function to create a linked list from an array
    public ListNode createListFromArray(List<Integer> arr) {
        if (arr == null || arr.isEmpty()) {
            return null;
        }
        ListNode head = new ListNode(arr.get(0));
        ListNode tail = head;
        for (int i = 1; i < arr.size(); i++) {
            tail.next = new ListNode(arr.get(i));
            tail = tail.next;
        }
        return head;
    }

    // Function to delete the first occurrence of a node with a specific value
    public ListNode deleteFirstOccurrence(ListNode head, int target) {
        if (head == null) {
            return null;
        }

        // Case 1: Head node is the target
        if (head.val == target) {
            return head.next;
        }

        // Case 2: Target is in the rest of the list
        ListNode current = head.next;
        ListNode previous = head;

        while (current != null && current.val != target) {
            previous = current;
            current = current.next;
        }

        // If target found
        if (current != null) {
            previous.next = current.next;
        }

        return head;
    }

    // Function to print the linked list
    public void printList(ListNode head) {
        if (head == null) {
            System.out.println(""Empty"");
            return;
        }
        ListNode current = head;
        StringBuilder sb = new StringBuilder();
        while (current != null) {
            sb.append(current.val);
            if (current.next != null) {
                sb.append("" "");
            }
            current = current.next;
        }
        System.out.println(sb.toString());
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Solution sol = new Solution();

        // Read array input
        String line = scanner.nextLine();
        List<Integer> arr = new ArrayList<>();
        if (!line.trim().isEmpty()) { // Handle empty line for empty list case
            String[] numStrs = line.split("" "");
            for (String s : numStrs) {
                arr.add(Integer.parseInt(s));
            }
        }
        

        ListNode head = sol.createListFromArray(arr);

        // Read target value
        int target = scanner.nextInt();

        head = sol.deleteFirstOccurrence(head, target);

        sol.printList(head);

        scanner.close();
    }
}","// Definition for singly-linked list.
function ListNode(val, next) {
    this.val = (val === undefined ? 0 : val);
    this.next = (next === undefined ? null : next);
}

class Solution {
    createListFromArray(arr) {
        if (!arr || arr.length === 0) {
            return null;
        }
        let head = new ListNode(arr[0]);
        let tail = head;
        for (let i = 1; i < arr.length; i++) {
            tail.next = new ListNode(arr[i]);
            tail = tail.next;
        }
        return head;
    }

    deleteFirstOccurrence(head, target) {
        if (!head) {
            return null;
        }

        // Case 1: Head node is the target
        if (head.val === target) {
            return head.next;
        }

        // Case 2: Target is in the rest of the list
        let current = head.next;
        let previous = head;

        while (current && current.val !== target) {
            previous = current;
            current = current.next;
        }

        // If target found
        if (current) {
            previous.next = current.next;
        }

        return head;
    }

    printList(head) {
        if (!head) {
            console.log(""Empty"");
            return;
        }
        let current = head;
        let result = [];
        while (current) {
            result.push(current.val);
            current = current.next;
        }
        console.log(result.join("" ""));
    }
}

// Main execution for JS environment
// This part handles input/output for a typical online judge setup
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let lines = [];
rl.on('line', (line) => {
    lines.push(line);
}).on('close', () => {
    const sol = new Solution();

    // Read array input
    const arrStr = lines[0];
    let arr = [];
    if (arrStr.trim() !== '') { // Handle empty line for empty list case
        arr = arrStr.split(' ').map(Number);
    }
    
    let head = sol.createListFromArray(arr);

    // Read target value
    const target = parseInt(lines[1]);

    head = sol.deleteFirstOccurrence(head, target);

    sol.printList(head);
});","#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <limits> // Required for numeric_limits

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode(int x) : val(x), next(nullptr) {}
};

// Function to create a linked list from a vector
ListNode* createListFromArray(const std::vector<int>& arr) {
    if (arr.empty()) {
        return nullptr;
    }
    ListNode* head = new ListNode(arr[0]);
    ListNode* tail = head;
    for (size_t i = 1; i < arr.size(); ++i) {
        tail->next = new ListNode(arr[i]);
        tail = tail->next;
    }
    return head;
}

// Function to delete the first occurrence of a node with a specific value
ListNode* deleteFirstOccurrence(ListNode* head, int target) {
    if (head == nullptr) {
        return nullptr;
    }

    // Case 1: Head node is the target
    if (head->val == target) {
        ListNode* temp = head;
        head = head->next;
        delete temp; // Free memory of the deleted node
        return head;
    }

    // Case 2: Target is in the rest of the list
    ListNode* current = head->next;
    ListNode* previous = head;

    while (current != nullptr && current->val != target) {
        previous = current;
        current = current->next;
    }

    // If target found
    if (current != nullptr) {
        previous->next = current->next;
        delete current; // Free memory of the deleted node
    }

    return head;
}

// Function to print the linked list
void printList(ListNode* head) {
    if (head == nullptr) {
        std::cout << ""Empty"" << std::endl;
        return;
    }
    ListNode* current = head;
    while (current != nullptr) {
        std::cout << current->val;
        if (current->next != nullptr) {
            std::cout << "" "";
        }
        current = current->next;
    }
    std::cout << std::endl;
}

// Function to free the linked list memory
void freeList(ListNode* head) {
    ListNode* current = head;
    while (current != nullptr) {
        ListNode* next = current->next;
        delete current;
        current = next;
    }
}

int main() {
    std::string line;
    std::getline(std::cin, line);

    std::vector<int> arr;
    if (!line.empty()) { // Handle empty line for empty list case
        std::stringstream ss(line);
        int val;
        while (ss >> val) {
            arr.push_back(val);
        }
    }

    ListNode* head = createListFromArray(arr);

    int target;
    std::cin >> target;

    // Clear the rest of the input buffer after reading target
    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');

    head = deleteFirstOccurrence(head, target);

    printList(head);
    freeList(head); // Free all allocated memory

    return 0;
}",4
Yellow-22,Intro to Backtracking,"*   Backtracking
*   Recursion
*   Decision Tree
*   State Space Search","Given two positive integers `n` and `k`, return all possible combinations of `k` numbers chosen from the range `[1, n]`.

You may return the answer in any order. The combinations themselves should have their elements sorted in ascending order.",*   `1 <= k <= n <= 15`,"**

n = 4, k = 2


**","**

[
  [1,2],
  [1,3],
  [1,4],
  [2,3],
  [2,4],
  [3,4]
]","Input: 3 1
Output: [
  [1],
  [2],
  [3]
]
Input: 3 3
Output: [
  [1,2,3]
]
Input: 5 2
Output: [
  [1,2],
  [1,3],
  [1,4],
  [1,5],
  [2,3],
  [2,4],
  [2,5],
  [3,4],
  [3,5],
  [4,5]
]
Input: 6 3
Output: [
  [1,2,3],
  [1,2,4],
  [1,2,5],
  [1,2,6],
  [1,3,4],
  [1,3,5],
  [1,3,6],
  [1,4,5],
  [1,4,6],
  [1,5,6],
  [2,3,4],
  [2,3,5],
  [2,3,6],
  [2,4,5],
  [2,4,6],
  [2,5,6],
  [3,4,5],
  [3,4,6],
  [3,5,6],
  [4,5,6]
]","#include <stdio.h>
#include <stdlib.h>

// Helper function for backtracking
void backtrack(int n, int k, int start, int* current_combination, int current_size,
               int*** results, int* result_count, int** result_col_sizes) {
    // Base case: if current_combination has k elements, add it to results
    if (current_size == k) {
        // Allocate space for the new combination
        (*results) = (int**)realloc(*results, (*result_count + 1) * sizeof(int*));
        if (*results == NULL) {
            perror(""Failed to reallocate results"");
            exit(EXIT_FAILURE);
        }
        (*results)[*result_count] = (int*)malloc(k * sizeof(int));
        if ((*results)[*result_count] == NULL) {
            perror(""Failed to allocate combination"");
            exit(EXIT_FAILURE);
        }

        // Copy current_combination to results
        for (int i = 0; i < k; i++) {
            (*results)[*result_count][i] = current_combination[i];
        }

        // Store column size
        (*result_col_sizes) = (int*)realloc(*result_col_sizes, (*result_count + 1) * sizeof(int));
        if (*result_col_sizes == NULL) {
            perror(""Failed to reallocate column sizes"");
            exit(EXIT_FAILURE);
        }
        (*result_col_sizes)[*result_count] = k;

        (*result_count)++;
        return;
    }

    // Optimization: if remaining elements are not enough to form a combination
    // (n - start + 1) is the count of numbers from 'start' to 'n'
    // (k - current_size) is the number of elements we still need
    if (k - current_size > n - start + 1) {
        return;
    }

    // Recursive step: iterate from start to n
    for (int i = start; i <= n; i++) {
        // Make a choice: add i to current_combination
        current_combination[current_size] = i;

        // Recurse: explore combinations starting from i + 1
        backtrack(n, k, i + 1, current_combination, current_size + 1,
                  results, result_count, result_col_sizes);
        
        // No explicit ""undo"" needed for simple values in C arrays when working with indices
        // The next iteration or a return will overwrite/ignore this index
    }
}

// Main function to find combinations
int** combine(int n, int k, int* returnSize, int** returnColumnSizes) {
    if (k <= 0 || k > n) {
        *returnSize = 0;
        *returnColumnSizes = NULL;
        return NULL;
    }

    int** results = NULL;
    *returnSize = 0;
    *returnColumnSizes = NULL;

    // current_combination acts as a temporary buffer for elements.
    // Max k is 15, so a small fixed-size array is safe for the stack.
    // If k could be very large, this would need to be dynamic.
    int* current_combination = (int*)malloc(k * sizeof(int));
    if (current_combination == NULL) {
        perror(""Failed to allocate current_combination buffer"");
        exit(EXIT_FAILURE);
    }

    backtrack(n, k, 1, current_combination, 0, &results, returnSize, returnColumnSizes);

    free(current_combination); // Free the temporary buffer
    return results;
}

// Helper to print results for main
void printCombinations(int** combinations, int numRows, int* colSizes) {
    printf(""[\n"");
    for (int i = 0; i < numRows; i++) {
        printf(""  ["");
        for (int j = 0; j < colSizes[i]; j++) {
            printf(""%d%s"", combinations[i][j], (j == colSizes[i] - 1) ? """" : "","");
        }
        printf(""]%s\n"", (i == numRows - 1) ? """" : "","");
    }
    printf(""]\n"");
}

int main() {
    int n, k;
    if (scanf(""%d %d"", &n, &k) != 2) {
        fprintf(stderr, ""Failed to read n and k\n"");
        return 1;
    }

    int returnSize;
    int* returnColumnSizes;
    int** result = combine(n, k, &returnSize, &returnColumnSizes);

    printCombinations(result, returnSize, returnColumnSizes);

    // Free allocated memory
    for (int i = 0; i < returnSize; i++) {
        free(result[i]);
    }
    free(result);
    free(returnColumnSizes);

    return 0;
}","import sys

class Solution:
    def combine(self, n: int, k: int) -> list[list[int]]:
        all_combinations = []
        current_combination = []

        if k <= 0 or k > n:
            return all_combinations

        def backtrack(start_num: int):
            # Base case: if current_combination has k elements, add it to results
            if len(current_combination) == k:
                all_combinations.append(list(current_combination)) # Add a copy
                return

            # Optimization: if remaining elements are not enough to form a combination
            # (n - start_num + 1) is the count of numbers from 'start_num' to 'n'
            # (k - len(current_combination)) is the number of elements we still need
            if k - len(current_combination) > n - start_num + 1:
                return

            # Recursive step: iterate from start_num to n
            for i in range(start_num, n + 1):
                # Make a choice: add i to current_combination
                current_combination.append(i)

                # Recurse: explore combinations starting from i + 1
                backtrack(i + 1)

                # Undo the choice (backtrack): remove i from current_combination
                current_combination.pop()
        
        backtrack(1)
        return all_combinations

def print_combinations(combinations: list[list[int]]):
    sys.stdout.write(""["")
    if len(combinations) > 0:
        sys.stdout.write(""\n"")
    for i, combination in enumerate(combinations):
        sys.stdout.write(""  ["")
        sys.stdout.write("","".join(map(str, combination)))
        sys.stdout.write(""]"")
        if i < len(combinations) - 1:
            sys.stdout.write("","")
        sys.stdout.write(""\n"")
    sys.stdout.write(""]\n"")

if __name__ == '__main__':
    lines = sys.stdin.readlines()
    n, k = map(int, lines[0].strip().split())

    sol = Solution()
    result = sol.combine(n, k)

    print_combinations(result)","import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

class Solution {
    List<List<Integer>> allCombinations;
    List<Integer> currentCombination;

    private void backtrack(int n, int k, int startNum) {
        // Base case: if currentCombination has k elements, add it to results
        if (currentCombination.size() == k) {
            allCombinations.add(new ArrayList<>(currentCombination)); // Add a copy
            return;
        }

        // Optimization: if remaining elements are not enough to form a combination
        // (n - startNum + 1) is the count of numbers from 'startNum' to 'n'
        // (k - currentCombination.size()) is the number of elements we still need
        if (k - currentCombination.size() > n - startNum + 1) {
            return;
        }

        // Recursive step: iterate from startNum to n
        for (int i = startNum; i <= n; i++) {
            // Make a choice: add i to currentCombination
            currentCombination.add(i);

            // Recurse: explore combinations starting from i + 1
            backtrack(n, k, i + 1);

            // Undo the choice (backtrack): remove i from currentCombination
            currentCombination.remove(currentCombination.size() - 1);
        }
    }

    public List<List<Integer>> combine(int n, int k) {
        allCombinations = new ArrayList<>();
        currentCombination = new ArrayList<>();

        if (k <= 0 || k > n) {
            return allCombinations; // Return empty list
        }

        backtrack(n, k, 1);
        return allCombinations;
    }
}

public class Main {
    public static void printCombinations(List<List<Integer>> combinations) {
        System.out.println(""["");
        for (int i = 0; i < combinations.size(); i++) {
            System.out.print(""  ["");
            List<Integer> combination = combinations.get(i);
            for (int j = 0; j < combination.size(); j++) {
                System.out.print(combination.get(j));
                if (j < combination.size() - 1) {
                    System.out.print("","");
                }
            }
            System.out.print(""]"");
            if (i < combinations.size() - 1) {
                System.out.print("","");
            }
            System.out.println();
        }
        System.out.println(""]"");
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int k = scanner.nextInt();
        scanner.close();

        Solution sol = new Solution();
        List<List<Integer>> result = sol.combine(n, k);

        printCombinations(result);
    }
}","const readline = require('readline');

// The Solution class structure
class Solution {
    constructor() {
        this.allCombinations = [];
        this.currentCombination = [];
    }

    backtrack(n, k, startNum) {
        // Base case: if currentCombination has k elements, add it to results
        if (this.currentCombination.length === k) {
            this.allCombinations.push([...this.currentCombination]); // Add a copy
            return;
        }

        // Optimization: if remaining elements are not enough to form a combination
        // (n - startNum + 1) is the count of numbers from 'startNum' to 'n'
        // (k - this.currentCombination.length) is the number of elements we still need
        if (k - this.currentCombination.length > n - startNum + 1) {
            return;
        }

        // Recursive step: iterate from startNum to n
        for (let i = startNum; i <= n; i++) {
            // Make a choice: add i to currentCombination
            this.currentCombination.push(i);

            // Recurse: explore combinations starting from i + 1
            this.backtrack(n, k, i + 1);

            // Undo the choice (backtrack): remove i from currentCombination
            this.currentCombination.pop();
        }
    }

    combine(n, k) {
        this.allCombinations = []; // Clear for new calls
        this.currentCombination = []; // Clear for new calls

        if (k <= 0 || k > n) {
            return this.allCombinations; // Return empty array
        }

        this.backtrack(n, k, 1);
        return this.allCombinations;
    }
}

// Function to print combinations in the specified format
function printCombinations(combinations) {
    let output = ""["";
    if (combinations.length > 0) {
        output += ""\n"";
    }
    for (let i = 0; i < combinations.length; i++) {
        output += ""  ["";
        output += combinations[i].join("","");
        output += ""]"";
        if (i < combinations.length - 1) {
            output += "","";
        }
        output += ""\n"";
    }
    output += ""]\n"";
    console.log(output);
}

// Main execution block to handle input and output
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let inputLines = [];

rl.on('line', (line) => {
    inputLines.push(line);
}).on('close', () => {
    const [n, k] = inputLines[0].split(' ').map(Number);

    const sol = new Solution();
    const result = sol.combine(n, k);

    printCombinations(result);
});","#include <iostream>
#include <vector>
#include <algorithm> 

class Solution {
private:
    std::vector<std::vector<int>> allCombinations;
    std::vector<int> currentCombination;

    void backtrack(int n, int k, int start_num) {
        // Base case: if currentCombination has k elements, add it to results
        if (currentCombination.size() == k) {
            allCombinations.push_back(currentCombination);
            return;
        }

        // Optimization: if remaining elements are not enough to form a combination
        // (n - start_num + 1) is the count of numbers from 'start_num' to 'n'
        // (k - currentCombination.size()) is the number of elements we still need
        if (k - currentCombination.size() > n - start_num + 1) {
            return;
        }

        // Recursive step: iterate from start_num to n
        for (int i = start_num; i <= n; ++i) {
            // Make a choice: add i to currentCombination
            currentCombination.push_back(i);

            // Recurse: explore combinations starting from i + 1
            backtrack(n, k, i + 1);

            // Undo the choice (backtrack): remove i from currentCombination
            currentCombination.pop_back();
        }
    }

public:
    std::vector<std::vector<int>> combine(int n, int k) {
        allCombinations.clear(); 
        currentCombination.clear(); 

        if (k <= 0 || k > n) {
            return allCombinations; 
        }

        backtrack(n, k, 1);
        return allCombinations;
    }
};

void printCombinations(const std::vector<std::vector<int>>& combinations) {
    std::cout << ""[\n"";
    for (size_t i = 0; i < combinations.size(); ++i) {
        std::cout << ""  ["";
        for (size_t j = 0; j < combinations[i].size(); ++j) {
            std::cout << combinations[i][j] << (j == combinations[i].size() - 1 ? """" : "","");
        }
        std::cout << ""]"" << (i == combinations.size() - 1 ? """" : "","") << ""\n"";
    }
    std::cout << ""]\n"";
}

int main() {
    int n, k;
    if (!(std::cin >> n >> k)) {
        std::cerr << ""Failed to read n and k\n"";
        return 1;
    }

    Solution sol;
    std::vector<std::vector<int>> result = sol.combine(n, k);

    printCombinations(result);

    return 0;
}",4
Yellow-23,Circular Queue basics,"*   **Arrays:** Using a fixed-size array to store queue elements.
*   **Pointers/Indices:** Managing `front` and `rear` pointers (or indices) to keep track of the queue's boundaries.
*   **Modulo Operator:** Essential for wrapping around the array and implementing the circular behavior.
*   **Queue Data Structure:** Understanding the FIFO principle and basic queue operations.
*   **Edge Cases:** Handling conditions like an empty queue, a full queue, and transitions between these states.","Welcome to the Queue Carousel! Your task is to implement a `MyCircularQueue` class that supports all the standard operations of a circular queue. A circular queue, also known as a ring buffer, is a linear data structure that operates on the FIFO (First-In, First-Out) principle. Unlike a regular queue, it reuses empty spaces by connecting the rear of the queue to the front, forming a circular structure. This makes it efficient for fixed-size buffers.

You will need to implement the following methods:

*   `MyCircularQueue(k)`: Constructor, initializes the queue with a maximum capacity of `k` elements.
*   `enqueue(value)`: Inserts an element into the circular queue. Returns `true` if the operation is successful, `false` otherwise (e.g., if the queue is full).
*   `dequeue()`: Deletes an element from the circular queue. Returns `true` if the operation is successful, `false` otherwise (e.g., if the queue is empty).
*   `front()`: Gets the front item from the queue. Returns the element if the queue is not empty, otherwise returns `-1`.
*   `rear()`: Gets the last item from the queue. Returns the element if the queue is not empty, otherwise returns `-1`.
*   `isEmpty()`: Checks whether the circular queue is empty. Returns `true` if empty, `false` otherwise.
*   `isFull()`: Checks whether the circular queue is full. Returns `true` if full, `false` otherwise.","*   `1 <= k <= 1000` (The capacity of the queue)
*   `0 <= value <= 1000` (The value to enqueue)
*   At most `3000` calls will be made to `enqueue`, `dequeue`, `front`, `rear`, `isEmpty`, and `isFull`.
*   All values returned by `front()` and `rear()` for an empty queue should be `-1`.","**

3
MyCircularQueue enqueue 1
MyCircularQueue enqueue 2
MyCircularQueue enqueue 3
MyCircularQueue isFull
MyCircularQueue dequeue
MyCircularQueue enqueue 4
MyCircularQueue front
MyCircularQueue rear
MyCircularQueue isEmpty
MyCircularQueue dequeue
MyCircularQueue dequeue
MyCircularQueue dequeue
MyCircularQueue isEmpty
MyCircularQueue front
MyCircularQueue enqueue 5
MyCircularQueue rear


**","**

true
true
true
true
1
3
false
true
true
true
-1
5","Input: 1
MyCircularQueue enqueue 10
MyCircularQueue isFull
MyCircularQueue front
MyCircularQueue rear
MyCircularQueue dequeue
MyCircularQueue isEmpty
MyCircularQueue enqueue 20
MyCircularQueue front
Output: true
true
10
10
true
false
20

Input: 2
MyCircularQueue enqueue 1
MyCircularQueue enqueue 2
MyCircularQueue isFull
MyCircularQueue enqueue 3
MyCircularQueue front
MyCircularQueue rear
MyCircularQueue dequeue
MyCircularQueue dequeue
MyCircularQueue isEmpty
MyCircularQueue dequeue
MyCircularQueue front
Output: true
true
true
false
1
2
true
true
true
false
-1

Input: 5
MyCircularQueue front
MyCircularQueue rear
MyCircularQueue isEmpty
MyCircularQueue dequeue
MyCircularQueue enqueue 10
MyCircularQueue enqueue 20
MyCircularQueue enqueue 30
MyCircularQueue front
MyCircularQueue rear
MyCircularQueue isEmpty
MyCircularQueue isFull
MyCircularQueue dequeue
MyCircularQueue enqueue 40
MyCircularQueue rear
MyCircularQueue front
Output: -1
-1
true
false
true
true
true
10
30
false
false
true
true
40
20","#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

typedef struct {
    int* data;
    int front;
    int rear;
    int capacity;
    int currentSize;
} MyCircularQueue;

MyCircularQueue* myCircularQueueCreate(int k) {
    MyCircularQueue* obj = (MyCircularQueue*)malloc(sizeof(MyCircularQueue));
    obj->data = (int*)malloc(sizeof(int) * k);
    obj->capacity = k;
    obj->front = 0;
    obj->rear = -1; // -1 indicates an empty queue, rear will become 0 upon first enqueue
    obj->currentSize = 0;
    return obj;
}

bool myCircularQueueIsEmpty(MyCircularQueue* obj) {
    return obj->currentSize == 0;
}

bool myCircularQueueIsFull(MyCircularQueue* obj) {
    return obj->currentSize == obj->capacity;
}

bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) {
    if (myCircularQueueIsFull(obj)) {
        return false;
    }
    obj->rear = (obj->rear + 1) % obj->capacity;
    obj->data[obj->rear] = value;
    obj->currentSize++;
    return true;
}

bool myCircularQueueDeQueue(MyCircularQueue* obj) {
    if (myCircularQueueIsEmpty(obj)) {
        return false;
    }
    obj->front = (obj->front + 1) % obj->capacity;
    obj->currentSize--;
    return true;
}

int myCircularQueueFront(MyCircularQueue* obj) {
    if (myCircularQueueIsEmpty(obj)) {
        return -1;
    }
    return obj->data[obj->front];
}

int myCircularQueueRear(MyCircularQueue* obj) {
    if (myCircularQueueIsEmpty(obj)) {
        return -1;
    }
    return obj->data[obj->rear];
}

void myCircularQueueFree(MyCircularQueue* obj) {
    free(obj->data);
    free(obj);
}

int main() {
    int k;
    scanf(""%d"", &k);

    MyCircularQueue* obj = myCircularQueueCreate(k);

    char command[50];
    char operation[20];
    int value;

    while (scanf(""%s"", command) != EOF) {
        scanf(""%s"", operation);
        if (strcmp(operation, ""enqueue"") == 0) {
            scanf(""%d"", &value);
            printf(""%s\n"", myCircularQueueEnQueue(obj, value) ? ""true"" : ""false"");
        } else if (strcmp(operation, ""dequeue"") == 0) {
            printf(""%s\n"", myCircularQueueDeQueue(obj) ? ""true"" : ""false"");
        } else if (strcmp(operation, ""front"") == 0) {
            printf(""%d\n"", myCircularQueueFront(obj));
        } else if (strcmp(operation, ""rear"") == 0) {
            printf(""%d\n"", myCircularQueueRear(obj));
        } else if (strcmp(operation, ""isEmpty"") == 0) {
            printf(""%s\n"", myCircularQueueIsEmpty(obj) ? ""true"" : ""false"");
        } else if (strcmp(operation, ""isFull"") == 0) {
            printf(""%s\n"", myCircularQueueIsFull(obj) ? ""true"" : ""false"");
        }
    }

    myCircularQueueFree(obj);

    return 0;
}","import sys

class MyCircularQueue:

    def __init__(self, k: int):
        self.data = [0] * k
        self.capacity = k
        self.front = 0
        self.rear = -1  # -1 indicates an empty queue, rear will become 0 upon first enqueue
        self.current_size = 0

    def enQueue(self, value: int) -> bool:
        if self.isFull():
            return False
        self.rear = (self.rear + 1) % self.capacity
        self.data[self.rear] = value
        self.current_size += 1
        return True

    def deQueue(self) -> bool:
        if self.isEmpty():
            return False
        self.front = (self.front + 1) % self.capacity
        self.current_size -= 1
        return True

    def Front(self) -> int:
        if self.isEmpty():
            return -1
        return self.data[self.front]

    def Rear(self) -> int:
        if self.isEmpty():
            return -1
        return self.data[self.rear]

    def isEmpty(self) -> bool:
        return self.current_size == 0

    def isFull(self) -> bool:
        return self.current_size == self.capacity

def main():
    k = int(sys.stdin.readline().strip())
    obj = MyCircularQueue(k)

    for line in sys.stdin:
        parts = line.strip().split()
        # The problem statement example has 'MyCircularQueue' prefix, ignore it.
        operation = parts[1]

        if operation == ""enqueue"":
            value = int(parts[2])
            print(str(obj.enQueue(value)).lower())
        elif operation == ""dequeue"":
            print(str(obj.deQueue()).lower())
        elif operation == ""front"":
            print(obj.Front())
        elif operation == ""rear"":
            print(obj.Rear())
        elif operation == ""isEmpty"":
            print(str(obj.isEmpty()).lower())
        elif operation == ""isFull"":
            print(str(obj.isFull()).lower())

if __name__ == '__main__':
    main()","import java.util.Scanner;

class MyCircularQueue {
    private int[] data;
    private int front;
    private int rear;
    private int capacity;
    private int currentSize;

    public MyCircularQueue(int k) {
        data = new int[k];
        capacity = k;
        front = 0;
        rear = -1; // -1 indicates an empty queue, rear will become 0 upon first enqueue
        currentSize = 0;
    }

    public boolean enQueue(int value) {
        if (isFull()) {
            return false;
        }
        rear = (rear + 1) % capacity;
        data[rear] = value;
        currentSize++;
        return true;
    }

    public boolean deQueue() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        currentSize--;
        return true;
    }

    public int Front() {
        if (isEmpty()) {
            return -1;
        }
        return data[front];
    }

    public int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return data[rear];
    }

    public boolean isEmpty() {
        return currentSize == 0;
    }

    public boolean isFull() {
        return currentSize == capacity;
    }
}

public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int k = scanner.nextInt();
        scanner.nextLine(); // Consume the newline

        MyCircularQueue obj = new MyCircularQueue(k);

        while (scanner.hasNextLine()) {
            String line = scanner.nextLine().trim();
            if (line.isEmpty()) {
                continue;
            }
            String[] parts = line.split("" "");
            String operation = parts[1];

            switch (operation) {
                case ""enqueue"":
                    int value = Integer.parseInt(parts[2]);
                    System.out.println(obj.enQueue(value) ? ""true"" : ""false"");
                    break;
                case ""dequeue"":
                    System.out.println(obj.deQueue() ? ""true"" : ""false"");
                    break;
                case ""front"":
                    System.out.println(obj.Front());
                    break;
                case ""rear"":
                    System.out.println(obj.Rear());
                    break;
                case ""isEmpty"":
                    System.out.println(obj.isEmpty() ? ""true"" : ""false"");
                    break;
                case ""isFull"":
                    System.out.println(obj.isFull() ? ""true"" : ""false"");
                    break;
            }
        }
        scanner.close();
    }
}","class MyCircularQueue {
    /**
     * @param {number} k
     */
    constructor(k) {
        this.data = new Array(k);
        this.capacity = k;
        this.front = 0;
        this.rear = -1; // -1 indicates an empty queue, rear will become 0 upon first enqueue
        this.currentSize = 0;
    }

    /**
     * @param {number} value
     * @return {boolean}
     */
    enQueue(value) {
        if (this.isFull()) {
            return false;
        }
        this.rear = (this.rear + 1) % this.capacity;
        this.data[this.rear] = value;
        this.currentSize++;
        return true;
    }

    /**
     * @return {boolean}
     */
    deQueue() {
        if (this.isEmpty()) {
            return false;
        }
        this.front = (this.front + 1) % this.capacity;
        this.currentSize--;
        return true;
    }

    /**
     * @return {number}
     */
    Front() {
        if (this.isEmpty()) {
            return -1;
        }
        return this.data[this.front];
    }

    /**
     * @return {number}
     */
    Rear() {
        if (this.isEmpty()) {
            return -1;
        }
        return this.data[this.rear];
    }

    /**
     * @return {boolean}
     */
    isEmpty() {
        return this.currentSize === 0;
    }

    /**
     * @return {boolean}
     */
    isFull() {
        return this.currentSize === this.capacity;
    }
}

function processInput() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let k = -1;
    let circularQueue = null;
    let lineCount = 0;

    rl.on('line', (line) => {
        if (line.trim() === '') return;

        if (lineCount === 0) {
            k = parseInt(line.trim());
            circularQueue = new MyCircularQueue(k);
        } else {
            const parts = line.trim().split(' ');
            const operation = parts[1];

            let result;
            switch (operation) {
                case 'enqueue':
                    const value = parseInt(parts[2]);
                    result = circularQueue.enQueue(value);
                    console.log(result ? 'true' : 'false');
                    break;
                case 'dequeue':
                    result = circularQueue.deQueue();
                    console.log(result ? 'true' : 'false');
                    break;
                case 'front':
                    result = circularQueue.Front();
                    console.log(result);
                    break;
                case 'rear':
                    result = circularQueue.Rear();
                    console.log(result);
                    break;
                case 'isEmpty':
                    result = circularQueue.isEmpty();
                    console.log(result ? 'true' : 'false');
                    break;
                case 'isFull':
                    result = circularQueue.isFull();
                    console.log(result ? 'true' : 'false');
                    break;
            }
        }
        lineCount++;
    });

    rl.on('close', () => {
        // All input processed
    });
}

processInput();","#include <iostream>
#include <vector>
#include <string>

class MyCircularQueue {
private:
    std::vector<int> data;
    int front;
    int rear;
    int capacity;
    int currentSize;

public:
    MyCircularQueue(int k) {
        data.resize(k);
        capacity = k;
        front = 0;
        rear = -1; // -1 indicates an empty queue, rear will become 0 upon first enqueue
        currentSize = 0;
    }

    bool enQueue(int value) {
        if (isFull()) {
            return false;
        }
        rear = (rear + 1) % capacity;
        data[rear] = value;
        currentSize++;
        return true;
    }

    bool deQueue() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        currentSize--;
        return true;
    }

    int Front() {
        if (isEmpty()) {
            return -1;
        }
        return data[front];
    }

    int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return data[rear];
    }

    bool isEmpty() {
        return currentSize == 0;
    }

    bool isFull() {
        return currentSize == capacity;
    }
};

int main() {
    int k;
    std::cin >> k;

    MyCircularQueue* obj = new MyCircularQueue(k);

    std::string command_prefix; // To consume 'MyCircularQueue'
    std::string operation;
    int value;

    while (std::cin >> command_prefix >> operation) {
        if (operation == ""enqueue"") {
            std::cin >> value;
            std::cout << (obj->enQueue(value) ? ""true"" : ""false"") << std::endl;
        } else if (operation == ""dequeue"") {
            std::cout << (obj->deQueue() ? ""true"" : ""false"") << std::endl;
        } else if (operation == ""front"") {
            std::cout << obj->Front() << std::endl;
        } else if (operation == ""rear"") {
            std::cout << obj->Rear() << std::endl;
        } else if (operation == ""isEmpty"") {
            std::cout << (obj->isEmpty() ? ""true"" : ""false"") << std::endl;
        } else if (operation == ""isFull"") {
            std::cout << (obj->isFull() ? ""true"" : ""false"") << std::endl;
        }
    }

    delete obj;

    return 0;
}",4
Yellow-24,LeetCode,"- **Matrix Traversal**: Iterating through elements of a 2D array.
- **In-place Modification**: Changing the input data directly without creating a new data structure to store the result.
- **Space Optimization**: Finding ways to solve a problem using minimal additional memory.
- **Conditional Logic**: Using `if` statements to make decisions based on element values.
- **Two-Pass Approach**: Solving the problem by iterating through the data multiple times, each pass performing a specific step.
- **Edge Cases**: Handling scenarios like matrices with only one row/column, or matrices where the first row/column contains a zero.","You are given an `m x n` integer matrix. Your task is to modify the matrix *in-place*. If any element in the matrix is `0`, its entire row and its entire column must be set to `0`s. This modification should happen simultaneously, meaning if a `0` at `(r, c)` causes `(r, c')` to become `0`, and then `(r, c')` in turn causes its column to become `0`, this is *not* the intended behavior. Instead, consider all original `0`s, and based on their positions, determine which rows and columns should be zeroed out.

Your solution should aim to be space-efficient, ideally using only constant extra space.","- `m == matrix.length`
- `n == matrix[0].length`
- `1 <= m, n <= 200`
- `-10^9 <= matrix[i][j] <= 10^9`","[[1,1,1],
 [1,0,1],
 [1,1,1]]","[[1,0,1],
 [0,0,0],
 [1,0,1]]

**","Input: 3 3
1 1 1
1 0 1
1 1 1
Output: 1 0 1
0 0 0
1 0 1,Input: 3 4
0 1 2 0
3 4 5 2
1 3 1 5
Output: 0 0 0 0
0 4 5 0
0 3 1 0,Input: 2 2
1 0
1 1
Output: 0 0
1 0,Input: 2 2
1 2
3 4
Output: 1 2
3 4,Input: 1 3
1 0 1
Output: 0 0 0","#include <stdio.h>
#include <stdbool.h>
#include <stdlib.h>

// Function to set matrix zeroes in-place with O(1) extra space
void setZeroes(int** matrix, int matrixSize, int* matrixColSize) {
    if (matrixSize == 0 || *matrixColSize == 0) {
        return;
    }

    int m = matrixSize;
    int n = *matrixColSize;

    bool firstRowHasZero = false;
    bool firstColHasZero = false;

    // Check if first row has any zero
    for (int j = 0; j < n; j++) {
        if (matrix[0][j] == 0) {
            firstRowHasZero = true;
            break;
        }
    }

    // Check if first column has any zero
    for (int i = 0; i < m; i++) {
        if (matrix[i][0] == 0) {
            firstColHasZero = true;
            break;
        }
    }

    // Use first row and first column as markers
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            if (matrix[i][j] == 0) {
                matrix[i][0] = 0; // Mark row i
                matrix[0][j] = 0; // Mark column j
            }
        }
    }

    // Zero out cells based on markers in first row/col
    for (int i = 1; i < m; i++) {
        for (int j = 1; j < n; j++) {
            if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                matrix[i][j] = 0;
            }
        }
    }

    // Zero out first row if needed
    if (firstRowHasZero) {
        for (int j = 0; j < n; j++) {
            matrix[0][j] = 0;
        }
    }

    // Zero out first column if needed
    if (firstColHasZero) {
        for (int i = 0; i < m; i++) {
            matrix[i][0] = 0;
        }
    }
}

int main() {
    int m, n;
    scanf(""%d %d"", &m, &n);

    // Dynamically allocate matrix
    int** matrix = (int**)malloc(m * sizeof(int*));
    int* matrixColSizes = (int*)malloc(m * sizeof(int)); // To pass to setZeroes

    for (int i = 0; i < m; i++) {
        matrix[i] = (int*)malloc(n * sizeof(int));
        matrixColSizes[i] = n; // All rows have 'n' columns
        for (int j = 0; j < n; j++) {
            scanf(""%d"", &matrix[i][j]);
        }
    }

    setZeroes(matrix, m, &matrixColSizes[0]); // Pass the size of one column, as all are same

    // Print the modified matrix
    for (int i = 0; i < m; i++) {
        for (int j = 0; j < n; j++) {
            printf(""%d%c"", matrix[i][j], (j == n - 1) ? '\n' : ' ');
        }
    }

    // Free allocated memory
    for (int i = 0; i < m; i++) {
        free(matrix[i]);
    }
    free(matrix);
    free(matrixColSizes);

    return 0;
}","class Solution:
    def setZeroes(self, matrix: list[list[int]]) -> None:
        """"""
        Do not return anything, modify matrix in-place instead.
        """"""
        if not matrix or not matrix[0]:
            return

        m = len(matrix)
        n = len(matrix[0])

        first_row_has_zero = False
        first_col_has_zero = False

        # Check if first row has any zero
        for j in range(n):
            if matrix[0][j] == 0:
                first_row_has_zero = True
                break
        
        # Check if first column has any zero
        for i in range(m):
            if matrix[i][0] == 0:
                first_col_has_zero = True
                break
        
        # Use first row and first column as markers
        # Iterate from (1,1) to avoid confusing markers with actual zeros in first row/col
        for i in range(1, m):
            for j in range(1, n):
                if matrix[i][j] == 0:
                    matrix[i][0] = 0  # Mark row i
                    matrix[0][j] = 0  # Mark column j
        
        # Zero out cells based on markers in first row/col
        # Iterate from (1,1) again
        for i in range(1, m):
            for j in range(1, n):
                if matrix[i][0] == 0 or matrix[0][j] == 0:
                    matrix[i][j] = 0
        
        # Zero out first row if needed
        if first_row_has_zero:
            for j in range(n):
                matrix[0][j] = 0
        
        # Zero out first column if needed
        if first_col_has_zero:
            for i in range(m):
                matrix[i][0] = 0

def main():
    m, n = map(int, input().split())
    matrix = []
    for _ in range(m):
        matrix.append(list(map(int, input().split())))
    
    sol = Solution()
    sol.setZeroes(matrix)
    
    for i in range(m):
        print(*(matrix[i]))

if __name__ == '__main__':
    main()","import java.util.Scanner;

class Solution {
    public void setZeroes(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return;
        }

        int m = matrix.length;
        int n = matrix[0].length;

        boolean firstRowHasZero = false;
        boolean firstColHasZero = false;

        // Check if first row has any zero
        for (int j = 0; j < n; j++) {
            if (matrix[0][j] == 0) {
                firstRowHasZero = true;
                break;
            }
        }

        // Check if first column has any zero
        for (int i = 0; i < m; i++) {
            if (matrix[i][0] == 0) {
                firstColHasZero = true;
                break;
            }
        }

        // Use first row and first column as markers
        // Iterate from (1,1) to avoid confusing markers with actual zeros in first row/col
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][j] == 0) {
                    matrix[i][0] = 0; // Mark row i
                    matrix[0][j] = 0; // Mark column j
                }
            }
        }

        // Zero out cells based on markers in first row/col
        // Iterate from (1,1) again
        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                    matrix[i][j] = 0;
                }
            }
        }

        // Zero out first row if needed
        if (firstRowHasZero) {
            for (int j = 0; j < n; j++) {
                matrix[0][j] = 0;
            }
        }

        // Zero out first column if needed
        if (firstColHasZero) {
            for (int i = 0; i < m; i++) {
                matrix[i][0] = 0;
            }
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int m = scanner.nextInt();
        int n = scanner.nextInt();

        int[][] matrix = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = scanner.nextInt();
            }
        }

        Solution sol = new Solution();
        sol.setZeroes(matrix);

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(matrix[i][j] + (j == n - 1 ? """" : "" ""));
            }
            System.out.println();
        }

        scanner.close();
    }
}","// Function to set matrix zeroes in-place with O(1) extra space
var setZeroes = function(matrix) {
    if (!matrix || matrix.length === 0 || matrix[0].length === 0) {
        return;
    }

    let m = matrix.length;
    let n = matrix[0].length;

    let firstRowHasZero = false;
    let firstColHasZero = false;

    // Check if first row has any zero
    for (let j = 0; j < n; j++) {
        if (matrix[0][j] === 0) {
            firstRowHasZero = true;
            break;
        }
    }

    // Check if first column has any zero
    for (let i = 0; i < m; i++) {
        if (matrix[i][0] === 0) {
            firstColHasZero = true;
            break;
        }
    }

    // Use first row and first column as markers
    // Iterate from (1,1) to avoid confusing markers with actual zeros in first row/col
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            if (matrix[i][j] === 0) {
                matrix[i][0] = 0; // Mark row i
                matrix[0][j] = 0; // Mark column j
            }
        }
    }

    // Zero out cells based on markers in first row/col
    // Iterate from (1,1) again
    for (let i = 1; i < m; i++) {
        for (let j = 1; j < n; j++) {
            if (matrix[i][0] === 0 || matrix[0][j] === 0) {
                matrix[i][j] = 0;
            }
        }
    }

    // Zero out first row if needed
    if (firstRowHasZero) {
        for (let j = 0; j < n; j++) {
            matrix[0][j] = 0;
        }
    }

    // Zero out first column if needed
    if (firstColHasZero) {
        for (let i = 0; i < m; i++) {
            matrix[i][0] = 0;
        }
    }
    // No return value, matrix is modified in-place.
};

// Main function for I/O handling
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let lines = [];
    rl.on('line', (line) => {
        lines.push(line);
    }).on('close', () => {
        const [m, n] = lines[0].split(' ').map(Number);
        let matrix = [];
        for (let i = 1; i <= m; i++) {
            matrix.push(lines[i].split(' ').map(Number));
        }

        setZeroes(matrix);

        for (let i = 0; i < m; i++) {
            console.log(matrix[i].join(' '));
        }
    });
}

main();","#include <iostream>
#include <vector>

// Function to set matrix zeroes in-place with O(1) extra space
void setZeroes(std::vector<std::vector<int>>& matrix) {
    if (matrix.empty() || matrix[0].empty()) {
        return;
    }

    int m = matrix.size();
    int n = matrix[0].size();

    bool firstRowHasZero = false;
    bool firstColHasZero = false;

    // Check if first row has any zero
    for (int j = 0; j < n; ++j) {
        if (matrix[0][j] == 0) {
            firstRowHasZero = true;
            break;
        }
    }

    // Check if first column has any zero
    for (int i = 0; i < m; ++i) {
        if (matrix[i][0] == 0) {
            firstColHasZero = true;
            break;
        }
    }

    // Use first row and first column as markers
    // Iterate from (1,1) to avoid confusing markers with actual zeros in first row/col
    for (int i = 1; i < m; ++i) {
        for (int j = 1; j < n; ++j) {
            if (matrix[i][j] == 0) {
                matrix[i][0] = 0; // Mark row i
                matrix[0][j] = 0; // Mark column j
            }
        }
    }

    // Zero out cells based on markers in first row/col
    // Iterate from (1,1) again
    for (int i = 1; i < m; ++i) {
        for (int j = 1; j < n; ++j) {
            if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                matrix[i][j] = 0;
            }
        }
    }

    // Zero out first row if needed
    if (firstRowHasZero) {
        for (int j = 0; j < n; ++j) {
            matrix[0][j] = 0;
        }
    }

    // Zero out first column if needed
    if (firstColHasZero) {
        for (int i = 0; i < m; ++i) {
            matrix[i][0] = 0;
        }
    }
}

int main() {
    int m, n;
    std::cin >> m >> n;

    std::vector<std::vector<int>> matrix(m, std::vector<int>(n));
    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            std::cin >> matrix[i][j];
        }
    }

    setZeroes(matrix);

    for (int i = 0; i < m; ++i) {
        for (int j = 0; j < n; ++j) {
            std::cout << matrix[i][j] << (j == n - 1 ? """" : "" "");
        }
        std::cout << std::endl;
    }

    return 0;
}",4
White-97,Modulo Arithmetic,"* Modulo Arithmetic
* Basic Integer Operations","Imagine a circular track with a specific number of positions, labeled from 0 up to `N-1`. You start at position 0. If you take `K` steps clockwise around the track, what will be your final position?

Your task is to write a program that takes the total number of positions `N` and the number of steps `K` as input, and returns the final position.","* `1 <= N <= 1000` (Total number of positions)
* `0 <= K <= 10000` (Number of steps taken)","N = 5
K = 7

####","2

####","Input: 10
3
Output: 3
Input: 7
14
Output: 0
Input: 1
5
Output: 0
Input: 100
0
Output: 0
Input: 13
20
Output: 7","#include <stdio.h>

// Function to calculate the final position on a circular track
int calculateFinalPosition(int n, int k) {
    // The modulo operator (%) naturally handles the wrap-around behavior.
    // If K steps are taken on a track with N positions (0 to N-1)
    // starting from 0, the final position is K % N.
    return k % n;
}

int main() {
    int n, k;

    // Read input for N (total positions) and K (steps taken)
    if (scanf(""%d"", &n) != 1) return 1;
    if (scanf(""%d"", &k) != 1) return 1;

    // Calculate the final position
    int finalPosition = calculateFinalPosition(n, k);

    // Print the result
    printf(""%d\n"", finalPosition);

    return 0;
}","def calculate_final_position(n: int, k: int) -> int:
    # The modulo operator (%) naturally handles the wrap-around behavior.
    # If K steps are taken on a track with N positions (0 to N-1)
    # starting from 0, the final position is K % N.
    return k % n

if __name__ == ""__main__"":
    # Read input for N (total positions) and K (steps taken)
    n = int(input())
    k = int(input())

    # Calculate the final position
    final_position = calculate_final_position(n, k)

    # Print the result
    print(final_position)","import java.util.Scanner;

public class Solution {

    // Function to calculate the final position on a circular track
    public static int calculateFinalPosition(int n, int k) {
        // The modulo operator (%) naturally handles the wrap-around behavior.
        // If K steps are taken on a track with N positions (0 to N-1)
        // starting from 0, the final position is K % N.
        return k % n;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read input for N (total positions) and K (steps taken)
        int n = scanner.nextInt();
        int k = scanner.nextInt();

        // Calculate the final position
        int finalPosition = calculateFinalPosition(n, k);

        // Print the result
        System.out.println(finalPosition);

        scanner.close();
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let input = [];

rl.on('line', (line) => {
    input.push(parseInt(line));
});

rl.on('close', () => {
    const n = input[0];
    const k = input[1];

    // Function to calculate the final position on a circular track
    function calculateFinalPosition(n, k) {
        // The modulo operator (%) naturally handles the wrap-around behavior.
        // If K steps are taken on a track with N positions (0 to N-1)
        // starting from 0, the final position is K % N.
        return k % n;
    }

    // Calculate the final position
    const finalPosition = calculateFinalPosition(n, k);

    // Print the result
    console.log(finalPosition);
});","#include <iostream>

// Function to calculate the final position on a circular track
int calculateFinalPosition(int n, int k) {
    // The modulo operator (%) naturally handles the wrap-around behavior.
    // If K steps are taken on a track with N positions (0 to N-1)
    // starting from 0, the final position is K % N.
    return k % n;
}

int main() {
    int n, k;

    // Read input for N (total positions) and K (steps taken)
    std::cin >> n >> k;

    // Calculate the final position
    int finalPosition = calculateFinalPosition(n, k);

    // Print the result
    std::cout << finalPosition << std::endl;

    return 0;
}",4
White-98,Modulo Arithmetic,"*   Modulo Operator
*   Basic Arithmetic Operations","Imagine a standard 12-hour clock. You are given the current hour and a certain number of hours that have passed. Your task is to determine what hour it will be after those hours have elapsed. Remember that a 12-hour clock cycles from 1 to 12.

For example, if it's 3 o'clock and 5 hours pass, it will be 8 o'clock. If it's 10 o'clock and 4 hours pass, it will be 2 o'clock (because 10 + 4 = 14, and on a 12-hour clock, 14 hours past 12 is 2).","*   `1 <= startHour <= 12` (The starting hour is between 1 and 12, inclusive)
*   `0 <= hoursPassed <= 1000` (The number of hours passed is non-negative)","**

startHour = 10
hoursPassed = 4


**","**

2


**","Input: 1
0
Output: 1
Input: 12
0
Output: 12
Input: 5
12
Output: 5
Input: 1
11
Output: 12
Input: 7
1000
Output: 11","#include <stdio.h>

// Function to calculate the new hour on a 12-hour clock
int calculateNewHour(int startHour, int hoursPassed) {
    // Adjust startHour to be 0-indexed (0-11) for easier modulo calculation
    int zeroIndexedStartHour = startHour - 1;

    // Calculate total hours passed in a 0-indexed system
    int totalZeroIndexedHours = zeroIndexedStartHour + hoursPassed;

    // Apply modulo 12 to find the new 0-indexed hour
    int newZeroIndexedHour = totalZeroIndexedHours % 12;

    // Convert back to 1-indexed (1-12) clock hour
    int newHour = newZeroIndexedHour + 1;

    return newHour;
}

int main() {
    int startHour, hoursPassed;

    // Read input
    if (scanf(""%d"", &startHour) != 1) return 1;
    if (scanf(""%d"", &hoursPassed) != 1) return 1;

    // Calculate and print the result
    int result = calculateNewHour(startHour, hoursPassed);
    printf(""%d\n"", result);

    return 0;
}","def calculate_new_hour(start_hour: int, hours_passed: int) -> int:
    """"""
    Calculates the new hour on a 12-hour clock after a certain number of hours have passed.

    Args:
        start_hour (int): The starting hour (1-12).
        hours_passed (int): The number of hours that have passed (non-negative).

    Returns:
        int: The new hour on the 12-hour clock (1-12).
    """"""
    # Adjust start_hour to be 0-indexed (0-11) for easier modulo calculation
    zero_indexed_start_hour = start_hour - 1

    # Calculate total hours passed in a 0-indexed system
    total_zero_indexed_hours = zero_indexed_start_hour + hours_passed

    # Apply modulo 12 to find the new 0-indexed hour
    new_zero_indexed_hour = total_zero_indexed_hours % 12

    # Convert back to 1-indexed (1-12) clock hour
    new_hour = new_zero_indexed_hour + 1

    return new_hour

if __name__ == ""__main__"":
    start_hour = int(input())
    hours_passed = int(input())

    result = calculate_new_hour(start_hour, hours_passed)
    print(result)","import java.util.Scanner;

public class Solution {

    // Function to calculate the new hour on a 12-hour clock
    public static int calculateNewHour(int startHour, int hoursPassed) {
        // Adjust startHour to be 0-indexed (0-11) for easier modulo calculation
        int zeroIndexedStartHour = startHour - 1;

        // Calculate total hours passed in a 0-indexed system
        int totalZeroIndexedHours = zeroIndexedStartHour + hoursPassed;

        // Apply modulo 12 to find the new 0-indexed hour
        int newZeroIndexedHour = totalZeroIndexedHours % 12;

        // Convert back to 1-indexed (1-12) clock hour
        int newHour = newZeroIndexedHour + 1;

        return newHour;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read input
        int startHour = scanner.nextInt();
        int hoursPassed = scanner.nextInt();

        // Calculate and print the result
        int result = calculateNewHour(startHour, hoursPassed);
        System.out.println(result);

        scanner.close();
    }
}","/**
 * Calculates the new hour on a 12-hour clock after a certain number of hours have passed.
 * @param {number} startHour The starting hour (1-12).
 * @param {number} hoursPassed The number of hours that have passed (non-negative).
 * @returns {number} The new hour on the 12-hour clock (1-12).
 */
function calculateNewHour(startHour, hoursPassed) {
    // Adjust startHour to be 0-indexed (0-11) for easier modulo calculation
    let zeroIndexedStartHour = startHour - 1;

    // Calculate total hours passed in a 0-indexed system
    let totalZeroIndexedHours = zeroIndexedStartHour + hoursPassed;

    // Apply modulo 12 to find the new 0-indexed hour
    let newZeroIndexedHour = totalZeroIndexedHours % 12;

    // Convert back to 1-indexed (1-12) clock hour
    let newHour = newZeroIndexedHour + 1;

    return newHour;
}

// Node.js specific input/output handling
// For competitive programming platforms, this part might need adjustment
// depending on how they provide input (e.g., process.argv, specific readline libraries)

const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let inputLines = [];
rl.on('line', (line) => {
    inputLines.push(parseInt(line));
});

rl.on('close', () => {
    const startHour = inputLines[0];
    const hoursPassed = inputLines[1];
    const result = calculateNewHour(startHour, hoursPassed);
    console.log(result);
});","#include <iostream>

// Function to calculate the new hour on a 12-hour clock
int calculateNewHour(int startHour, int hoursPassed) {
    // Adjust startHour to be 0-indexed (0-11) for easier modulo calculation
    int zeroIndexedStartHour = startHour - 1;

    // Calculate total hours passed in a 0-indexed system
    int totalZeroIndexedHours = zeroIndexedStartHour + hoursPassed;

    // Apply modulo 12 to find the new 0-indexed hour
    int newZeroIndexedHour = totalZeroIndexedHours % 12;

    // Convert back to 1-indexed (1-12) clock hour
    int newHour = newZeroIndexedHour + 1;

    return newHour;
}

int main() {
    int startHour, hoursPassed;

    // Read input
    std::cin >> startHour >> hoursPassed;

    // Calculate and print the result
    int result = calculateNewHour(startHour, hoursPassed);
    std::cout << result << std::endl;

    return 0;
}",4.4
White-99,Modulo Arithmetic,"*   Modulo Operator (`%`)
*   Integer Division
*   Basic Arithmetic Operations
*   Conditional Logic","You are given two positive integers, `N` and `K`. Your task is to find the smallest integer `X` such that `X` is greater than or equal to `N` and `X` is perfectly divisible by `K`.","*   `1 <= N <= 1000`
*   `1 <= K <= 100`","N = 10
K = 3",12,"Input: 7 5
Output: 10
Input: 20 4
Output: 20
Input: 1 10
Output: 10
Input: 99 11
Output: 99
Input: 42 8
Output: 48","#include <stdio.h>

// Function to find the nearest multiple
int findNearestMultiple(int n, int k) {
    // Constraints state 1 <= K <= 100, so k will never be 0.
    int remainder = n % k;
    if (remainder == 0) {
        return n;
    } else {
        return n + (k - remainder);
    }
}

int main() {
    int n, k;
    // Assuming N and K are provided on separate lines or space-separated on one line
    if (scanf(""%d %d"", &n, &k) != 2) {
        // Handle potential input error
        return 1; 
    }
    int result = findNearestMultiple(n, k);
    printf(""%d\n"", result);
    return 0;
}","def find_nearest_multiple(n, k):
    # Constraints state 1 <= K <= 100, so k will never be 0.
    remainder = n % k
    if remainder == 0:
        return n
    else:
        return n + (k - remainder)

def main():
    # Assuming N and K are provided on separate lines
    n = int(input())
    k = int(input())
    result = find_nearest_multiple(n, k)
    print(result)

if __name__ == ""__main__"":
    main()","import java.util.Scanner;

public class Main {

    // Function to find the nearest multiple
    public static int findNearestMultiple(int n, int k) {
        // Constraints state 1 <= K <= 100, so k will never be 0.
        int remainder = n % k;
        if (remainder == 0) {
            return n;
        } else {
            return n + (k - remainder);
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int k = scanner.nextInt();
        int result = findNearestMultiple(n, k);
        System.out.println(result);
        scanner.close();
    }
}","// Function to find the nearest multiple
function findNearestMultiple(n, k) {
    // Constraints state 1 <= K <= 100, so k will never be 0.
    let remainder = n % k;
    if (remainder === 0) {
        return n;
    } else {
        return n + (k - remainder);
    }
}

// Main function to handle input/output
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let inputLines = [];
    rl.on('line', (line) => {
        inputLines.push(line);
    }).on('close', () => {
        const n = parseInt(inputLines[0]);
        const k = parseInt(inputLines[1]);
        const result = findNearestMultiple(n, k);
        console.log(result);
    });
}

main();","#include <iostream>

// Function to find the nearest multiple
int findNearestMultiple(int n, int k) {
    // Constraints state 1 <= K <= 100, so k will never be 0.
    int remainder = n % k;
    if (remainder == 0) {
        return n;
    } else {
        return n + (k - remainder);
    }
}

int main() {
    int n, k;
    std::cin >> n >> k;
    int result = findNearestMultiple(n, k);
    std::cout << result << std::endl;
    return 0;
}",4.2
White-100,Basic String Manipulation,"- String iteration (looping through characters)
- Conditional logic (if statements)
- String building / concatenation
- Basic I/O (reading strings and characters)","Write a program that reads a string and a single character from the input. Your task is to create a new string by removing all occurrences of that specific character from the original string. Finally, print the modified string.","- The input string will contain only lowercase English letters.
- The length of the input string will be between 1 and 100 characters.
- The character to be removed will be a single lowercase English letter.
- The output string should not contain the specified character.","hello
l",heo,"Input:
programming
g
Output:
programmin
Input:
apple
p
Output:
ale
Input:
banana
a
Output:
bnn
Input:
test
x
Output:
test","#include <stdio.h>
#include <string.h>

// Function to remove all occurrences of a character from a string
void filterString(const char *original, char charToRemove, char *result) {
    int i = 0;
    int j = 0;
    while (original[i] != '\0') {
        if (original[i] != charToRemove) {
            result[j] = original[i];
            j++;
        }
        i++;
    }
    result[j] = '\0'; // Null-terminate the new string
}

int main() {
    char inputString[101]; // Max 100 chars + null terminator
    char charToRemove;
    char filteredString[101];

    // Read the input string
    scanf(""%s"", inputString);

    // Read the character to remove (note the space before %c to consume newline)
    scanf("" %c"", &charToRemove);

    // Call the logic function
    filterString(inputString, charToRemove, filteredString);

    // Print the result
    printf(""%s\n"", filteredString);

    return 0;
}","def filter_string(original_string, char_to_remove):
    """"""
    Removes all occurrences of a specific character from a string.
    """"""
    result = [] # Using a list of characters for efficient building, then join
    for char in original_string:
        if char != char_to_remove:
            result.append(char)
    return """".join(result)

def main():
    # Read the input string
    input_string = input()

    # Read the character to remove
    # input() reads a string, take the first character
    char_to_remove = input()[0]

    # Call the logic function
    filtered_string = filter_string(input_string, char_to_remove)

    # Print the result
    print(filtered_string)

if __name__ == ""__main__"":
    main()","import java.util.Scanner;

public class Main {

    // Function to remove all occurrences of a character from a string
    public static String filterString(String original, char charToRemove) {
        StringBuilder result = new StringBuilder();
        for (char c : original.toCharArray()) {
            if (c != charToRemove) {
                result.append(c);
            }
        }
        return result.toString();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the input string
        String inputString = scanner.next();

        // Read the character to remove
        char charToRemove = scanner.next().charAt(0);

        // Call the logic function
        String filteredString = filterString(inputString, charToRemove);

        // Print the result
        System.out.println(filteredString);

        scanner.close();
    }
}","// For Node.js environment
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let inputLines = [];

rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    main();
});

// Function to remove all occurrences of a character from a string
function filterString(original, charToRemove) {
    let result = '';
    for (let i = 0; i < original.length; i++) {
        if (original[i] !== charToRemove) {
            result += original[i];
        }
    }
    return result;
}

function main() {
    const inputString = inputLines[0];
    // charToRemove will be the first character of the second input line
    const charToRemove = inputLines[1][0]; 

    // Call the logic function
    const filteredString = filterString(inputString, charToRemove);

    // Print the result
    console.log(filteredString);
}","#include <iostream>
#include <string>

// Function to remove all occurrences of a character from a string
std::string filterString(const std::string& original, char charToRemove) {
    std::string result = """"; // Initialize an empty string
    for (char c : original) {
        if (c != charToRemove) {
            result += c; // Append character if it's not the one to remove
        }
    }
    return result;
}

int main() {
    std::string inputString;
    char charToRemove;

    // Read the input string
    std::cin >> inputString;

    // Read the character to remove
    std::cin >> charToRemove;

    // Call the logic function
    std::string filteredString = filterString(inputString, charToRemove);

    // Print the result
    std::cout << filteredString << std::endl;

    return 0;
}",4.2
Yellow-25,Frequency Count / Anagrams,"*   Frequency Counting (using arrays as hash maps)
*   String Manipulation
*   Basic Algorithm Design
*   Conditional Logic","Given two strings, `s1` and `s2`, determine if `s2` is an anagram of `s1`. An anagram is a word or phrase formed by rearranging the letters of another, using all the original letters exactly once. For example, ""listen"" and ""silent"" are anagrams. The comparison should be case-sensitive and assume strings consist only of lowercase English letters.","*   `s1` and `s2` will consist of lowercase English letters ('a'-'z') only.
*   The length of both `s1` and `s2` will be between 1 and 1000 characters, inclusive.","**
s1 = ""listen""
s2 = ""silent""

**","**
true

**","Input: hello
olleh
Output: true
Input: programming
gramproingm
Output: false
Input: race
care
Output: true
Input: cat
actt
Output: false
Input: a
a
Output: true","#include <stdio.h>
#include <string.h>
#include <stdbool.h>

// Core logic function
bool areAnagrams(const char* s1, const char* s2) {
    int len1 = strlen(s1);
    int len2 = strlen(s2);

    if (len1 != len2) {
        return false;
    }

    int freq[26] = {0}; // Initialize all counts to 0

    // Count characters in s1
    for (int i = 0; i < len1; i++) {
        freq[s1[i] - 'a']++;
    }

    // Decrement counts for characters in s2
    for (int i = 0; i < len2; i++) {
        freq[s2[i] - 'a']--;
    }

    // Check if all counts are zero
    for (int i = 0; i < 26; i++) {
        if (freq[i] != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    char s1[1001]; // Max length 1000 + null terminator
    char s2[1001];

    // Read input strings
    if (scanf(""%s"", s1) != 1) return 1;
    if (scanf(""%s"", s2) != 1) return 1;

    // Call the core logic function
    bool result = areAnagrams(s1, s2);

    // Print the result
    if (result) {
        printf(""true\n"");
    } else {
        printf(""false\n"");
    }

    return 0;
}","import sys

def areAnagrams(s1: str, s2: str) -> bool:
    if len(s1) != len(s2):
        return False

    freq = [0] * 26 # Initialize all counts to 0

    # Count characters in s1
    for char_code in map(ord, s1):
        freq[char_code - ord('a')] += 1

    # Decrement counts for characters in s2
    for char_code in map(ord, s2):
        freq[char_code - ord('a')] -= 1

    # Check if all counts are zero
    for count in freq:
        if count != 0:
            return False

    return True

if __name__ == ""__main__"":
    # Read input strings from stdin
    s1 = sys.stdin.readline().strip()
    s2 = sys.stdin.readline().strip()

    # Call the core logic function
    result = areAnagrams(s1, s2)

    # Print the result as lowercase 'true' or 'false'
    print(str(result).lower())","import java.util.Scanner;

public class Solution {

    // Core logic function
    public boolean areAnagrams(String s1, String s2) {
        if (s1.length() != s2.length()) {
            return false;
        }

        int[] freq = new int[26]; // All elements initialized to 0 by default

        // Count characters in s1
        for (char c : s1.toCharArray()) {
            freq[c - 'a']++;
        }

        // Decrement counts for characters in s2
        for (char c : s2.toCharArray()) {
            freq[c - 'a']--;
        }

        // Check if all counts are zero
        for (int count : freq) {
            if (count != 0) {
                return false;
            }
        }

        return true;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read input strings
        String s1 = scanner.next();
        String s2 = scanner.next();

        // Create an instance of the Solution class to call the non-static method
        Solution sol = new Solution();
        boolean result = sol.areAnagrams(s1, s2);

        // Print the result
        System.out.println(result);

        scanner.close();
    }
}","// Core logic function
function areAnagrams(s1, s2) {
    if (s1.length !== s2.length) {
        return false;
    }

    const freq = new Array(26).fill(0); // Initialize all counts to 0

    // Count characters in s1
    for (let i = 0; i < s1.length; i++) {
        freq[s1.charCodeAt(i) - 'a'.charCodeAt(0)]++;
    }

    // Decrement counts for characters in s2
    for (let i = 0; i < s2.length; i++) {
        freq[s2.charCodeAt(i) - 'a'.charCodeAt(0)]--;
    }

    // Check if all counts are zero
    for (let i = 0; i < freq.length; i++) {
        if (freq[i] !== 0) {
            return false;
        }
    }

    return true;
}

// Main function to handle I/O
function main() {
    // Node.js specific way to read input from stdin
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let lines = [];
    rl.on('line', (line) => {
        lines.push(line);
    });

    rl.on('close', () => {
        const s1 = lines[0];
        const s2 = lines[1];

        // Call the core logic function
        const result = areAnagrams(s1, s2);

        // Print the result
        console.log(result);
    });
}

main();","#include <iostream>
#include <string>
#include <vector>
#include <numeric>

// Core logic function
bool areAnagrams(const std::string& s1, const std::string& s2) {
    if (s1.length() != s2.length()) {
        return false;
    }

    std::vector<int> freq(26, 0); // Initialize all counts to 0

    // Count characters in s1
    for (char c : s1) {
        freq[c - 'a']++;
    }

    // Decrement counts for characters in s2
    for (char c : s2) {
        freq[c - 'a']--;
    }

    // Check if all counts are zero
    for (int count : freq) {
        if (count != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    std::string s1, s2;

    // Read input strings
    std::cin >> s1 >> s2;

    // Call the core logic function
    bool result = areAnagrams(s1, s2);

    // Print the result
    if (result) {
        std::cout << ""true\n"";
    } else {
        std::cout << ""false\n"";
    }

    return 0;
}",4.4
Yellow-26,Linear Search,"- Arrays
- Iteration (Loops)
- Conditional Statements
- Basic Search Algorithms (Linear Search)","You are given an array of integers `arr` and a target integer `target`. Your task is to implement a function that finds the first occurrence of the `target` integer in the `arr` and returns its index. If the `target` is not found anywhere in the array, the function should return -1.","- `1 <= arr.length <= 1000`
- `-10^9 <= arr[i] <= 10^9`
- `-10^9 <= target <= 10^9`","6
4 2 7 1 9 3
1

Explanation:
- The first line `6` indicates the size of the array.
- The second line `4 2 7 1 9 3` represents the elements of the array.
- The third line `1` is the target element to search for.

####",3,"Input:
5
10 20 30 40 50
10
Output: 0
Input:
6
1 5 9 13 17 21
21
Output: 5
Input:
4
100 200 300 400
150
Output: -1
Input:
7
5 8 12 8 20 3 8
8
Output: 1
Input:
1
42
42
Output: 0","#include <stdio.h>
#include <stdlib.h>

// Function to perform linear search
int findElement(int arr[], int size, int target) {
    for (int i = 0; i < size; i++) {
        if (arr[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}

int main() {
    int N;
    // Read the size of the array
    if (scanf(""%d"", &N) != 1) {
        return 1; // Error reading N
    }

    // Allocate memory for the array
    int *arr = (int *)malloc(N * sizeof(int));
    if (arr == NULL) {
        return 1; // Memory allocation failed
    }

    // Read array elements
    for (int i = 0; i < N; i++) {
        if (scanf(""%d"", &arr[i]) != 1) {
            free(arr); // Free allocated memory before exiting
            return 1; // Error reading array element
        }
    }

    int target;
    // Read the target element
    if (scanf(""%d"", &target) != 1) {
        free(arr); // Free allocated memory before exiting
        return 1; // Error reading target
    }

    // Call the linear search function
    int result = findElement(arr, N, target);

    // Print the result
    printf(""%d\n"", result);

    // Free allocated memory
    free(arr);

    return 0;
}","def find_element(arr, target):
    """"""
    Performs a linear search to find the first occurrence of the target in the array.

    Args:
        arr (list): A list of integers.
        target (int): The integer to search for.

    Returns:
        int: The index of the first occurrence of the target, or -1 if not found.
    """"""
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # Target found, return its index
    return -1  # Target not found

if __name__ == ""__main__"":
    # Read the size of the array (not strictly necessary for Python list, but good practice for consistency)
    N = int(input())

    # Read array elements
    arr = list(map(int, input().split()))

    # Read the target element
    target = int(input())

    # Call the linear search function
    result = find_element(arr, target)

    # Print the result
    print(result)","import java.util.Scanner;

public class Solution {

    // Function to perform linear search
    public int findElement(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i; // Target found, return its index
            }
        }
        return -1; // Target not found
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the size of the array
        int N = scanner.nextInt();

        int[] arr = new int[N];
        // Read array elements
        for (int i = 0; i < N; i++) {
            arr[i] = scanner.nextInt();
        }

        // Read the target element
        int target = scanner.nextInt();

        // Create an instance of the Solution class
        Solution sol = new Solution();

        // Call the linear search function
        int result = sol.findElement(arr, target);

        // Print the result
        System.out.println(result);

        scanner.close();
    }
}","// For competitive programming environments, input usually comes from stdin
// using the 'readline' module or similar.
// This example assumes a setup where input is read line by line.

let input = """";
process.stdin.on('data', data => {
    input += data;
});

process.stdin.on('end', () => {
    const lines = input.trim().split('\n');

    // The first line is N (size of array), though not strictly used in JS like C/Java
    // const N = parseInt(lines[0]); 

    // The second line contains the array elements
    const arr = lines[1].split(' ').map(Number);

    // The third line contains the target
    const target = parseInt(lines[2]);

    // Call the function and print the result
    console.log(findElement(arr, target));
});

/**
 * Performs a linear search to find the first occurrence of the target in the array.
 * @param {number[]} arr The array of numbers to search in.
 * @param {number} target The number to search for.
 * @returns {number} The index of the first occurrence of the target, or -1 if not found.
 */
function findElement(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}","#include <iostream>
#include <vector>

// Function to perform linear search
int findElement(const std::vector<int>& arr, int target) {
    for (int i = 0; i < arr.size(); ++i) {
        if (arr[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int N;
    // Read the size of the array
    std::cin >> N;

    std::vector<int> arr(N);
    // Read array elements
    for (int i = 0; i < N; ++i) {
        std::cin >> arr[i];
    }

    int target;
    // Read the target element
    std::cin >> target;

    // Call the linear search function
    int result = findElement(arr, target);

    // Print the result
    std::cout << result << std::endl;

    return 0;
}",4.3
Yellow-27,Kadane’s Algorithm,"*   Kadane's Algorithm
*   Dynamic Programming (implicitly)
*   Array Traversal
*   Handling negative numbers in sums","You're given an array of integers, which can contain both positive and negative numbers. Your task is to find the contiguous subarray (a sequence of elements that are adjacent in the array) that has the largest possible sum. You need to return this maximum sum. If all numbers are negative, you should return the largest single negative number.","*   `1 <= nums.length <= 10^5`
*   `-10^4 <= nums[i] <= 10^4`","**
`[-2, 1, -3, 4, -1, 2, 1, -5, 4]`

**","**
`6`

**","Input: 1
1
Output: 1
Input: 3
-1 -2 -3
Output: -1
Input: 5
5 4 -1 7 8
Output: 23
Input: 8
-2 -3 4 -1 -2 1 5 -3
Output: 7
Input: 1
10
Output: 10","#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

// Function to find the maximum of two integers
int max(int a, int b) {
    return (a > b) ? a : b;
}

// Function implementing Kadane's Algorithm
int maxSubArraySum(int* nums, int numsSize) {
    if (numsSize == 0) {
        return 0; // Or handle as an error, based on specific requirements
    }

    int max_so_far = nums[0];
    int current_max = nums[0];

    for (int i = 1; i < numsSize; i++) {
        current_max = max(nums[i], current_max + nums[i]);
        max_so_far = max(max_so_far, current_max);
    }

    return max_so_far;
}

int main() {
    int n;
    // Read the number of elements
    if (scanf(""%d"", &n) != 1) {
        return 1;
    }

    if (n <= 0) {
        printf(""0\n""); // Constraints say 1 <= n
        return 0;
    }

    int* nums = (int*)malloc(n * sizeof(int));
    if (nums == NULL) {
        return 1; // Malloc failed
    }

    // Read the array elements
    for (int i = 0; i < n; i++) {
        if (scanf(""%d"", &nums[i]) != 1) {
            free(nums);
            return 1;
        }
    }

    // Calculate and print the result
    int result = maxSubArraySum(nums, n);
    printf(""%d\n"", result);

    free(nums);
    return 0;
}","import sys

def max_subarray_sum(nums: list[int]) -> int:
    if not nums:
        return 0 # Constraints say 1 <= n

    max_so_far = nums[0]
    current_max = nums[0]

    for i in range(1, len(nums)):
        current_max = max(nums[i], current_max + nums[i])
        max_so_far = max(max_so_far, current_max)

    return max_so_far

if __name__ == '__main__':
    # Read the number of elements
    n = int(sys.stdin.readline())

    if n <= 0:
        print(0) # Constraints say 1 <= n
    else:
        # Read the array elements
        # Assuming elements are space-separated on a single line
        nums_str = sys.stdin.readline().strip().split()
        nums = [int(x) for x in nums_str]

        # Calculate and print the result
        result = max_subarray_sum(nums)
        print(result)","import java.util.Scanner;

public class Solution {

    // Function implementing Kadane's Algorithm
    public static int maxSubArraySum(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0; // Or throw an exception, based on specific requirements
        }

        int maxSoFar = nums[0];
        int currentMax = nums[0];

        for (int i = 1; i < nums.length; i++) {
            currentMax = Math.max(nums[i], currentMax + nums[i]);
            maxSoFar = Math.max(maxSoFar, currentMax);
        }

        return maxSoFar;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the number of elements
        int n = scanner.nextInt();

        if (n <= 0) {
            System.out.println(0); // Constraints say 1 <= n
            scanner.close();
            return;
        }

        int[] nums = new int[n];
        // Read the array elements
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }

        // Calculate and print the result
        int result = maxSubArraySum(nums);
        System.out.println(result);

        scanner.close();
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

// Function implementing Kadane's Algorithm
function maxSubarraySum(nums) {
    if (!nums || nums.length === 0) {
        return 0; // Or handle as an error, based on specific requirements
    }

    let maxSoFar = nums[0];
    let currentMax = nums[0];

    for (let i = 1; i < nums.length; i++) {
        currentMax = Math.max(nums[i], currentMax + nums[i]);
        maxSoFar = Math.max(maxSoFar, currentMax);
    }

    return maxSoFar;
}

let inputLines = [];
rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    const n = parseInt(inputLines[0], 10);

    if (n <= 0) {
        console.log(0); // Constraints say 1 <= n
        return;
    }

    // Assuming elements are space-separated on the second line
    const nums = inputLines[1].split(' ').map(Number);

    // Calculate and print the result
    const result = maxSubarraySum(nums);
    console.log(result);
});","#include <iostream>
#include <vector>
#include <algorithm> // Required for std::max
#include <limits>    // Required for std::numeric_limits

// Function implementing Kadane's Algorithm
int maxSubArraySum(const std::vector<int>& nums) {
    if (nums.empty()) {
        return 0; // Or throw an exception, based on specific requirements
    }

    int max_so_far = nums[0];
    int current_max = nums[0];

    for (size_t i = 1; i < nums.size(); ++i) {
        current_max = std::max(nums[i], current_max + nums[i]);
        max_so_far = std::max(max_so_far, current_max);
    }

    return max_so_far;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    // Read the number of elements
    std::cin >> n;

    if (n <= 0) {
        std::cout << 0 << std::endl; // Constraints say 1 <= n
        return 0;
    }

    std::vector<int> nums(n);
    // Read the array elements
    for (int i = 0; i < n; ++i) {
        std::cin >> nums[i];
    }

    // Calculate and print the result
    int result = maxSubArraySum(nums);
    std::cout << result << std::endl;

    return 0;
}",4.4
Yellow-28,"Singly Linked List (creation, traversal, insertion, deletion)","*   Singly Linked List structure
*   Node creation and manipulation
*   Traversal through a linked list
*   Insertion of a node at the end
*   Deletion of a specific node by value","A singly linked list is a fundamental data structure consisting of a sequence of nodes, where each node contains data and a pointer (or reference) to the next node in the sequence. The last node points to `NULL` (or `None`).

Your task is to implement a basic singly linked list and perform common operations on it:
1.  **Insertion at the End**: Add a new node with a given value to the end of the list.
2.  **Deletion of a Specific Node**: Remove the first occurrence of a node with a given value from the list. If the value is not found, the list remains unchanged.
3.  **Traversal and Printing**: Print all elements of the list, separated by spaces. If the list is empty, print nothing.

You will receive a series of commands:
*   `insert <value>`: Inserts `value` at the end of the list.
*   `delete <value>`: Deletes the first node found with `value`.
*   `print`: Prints the current state of the list.","*   The number of operations `N` will be between 1 and 100.
*   Node values will be integers between -1000 and 1000.
*   The `delete` command may target a value that does not exist in the list.
*   An empty line will be considered as an empty list for `print` command.","insert 5
insert 10
print
delete 5
insert 20
print
delete 100
print","5 10
10 20
10 20","Input:
insert 1
insert 2
insert 3
print
delete 2
print
delete 1
print
delete 3
print
Output:
1 2 3
1 3
3

Input:
insert 100
delete 50
print
insert 200
delete 100
print
delete 200
print
Output:
100
200

Input:
insert 1
insert 1
insert 2
print
delete 1
print
insert 3
delete 1
print
Output:
1 1 2
1 2
2 3

Input:
print
insert 7
print
delete 7
print
delete 5
print
Output:

7
","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define Node structure
typedef struct Node {
    int value;
    struct Node* next;
} Node;

// Define LinkedList structure
typedef struct LinkedList {
    Node* head;
} LinkedList;

// Function to create a new Node
Node* createNode(int value) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    if (newNode == NULL) {
        fprintf(stderr, ""Memory allocation failed\n"");
        exit(EXIT_FAILURE);
    }
    newNode->value = value;
    newNode->next = NULL;
    return newNode;
}

// Function to initialize a LinkedList
void initLinkedList(LinkedList* list) {
    list->head = NULL;
}

// Function to insert a node at the end of the list
void insertAtEnd(LinkedList* list, int value) {
    Node* newNode = createNode(value);
    if (list->head == NULL) {
        list->head = newNode;
    } else {
        Node* current = list->head;
        while (current->next != NULL) {
            current = current->next;
        }
        current->next = newNode;
    }
}

// Function to delete the first occurrence of a node with a given value
void deleteNode(LinkedList* list, int value) {
    Node* current = list->head;
    Node* previous = NULL;

    // If head node itself holds the value to be deleted
    if (current != NULL && current->value == value) {
        list->head = current->next; // Changed head
        free(current);             // Free old head
        return;
    }

    // Search for the value to be deleted, keep track of the previous node
    while (current != NULL && current->value != value) {
        previous = current;
        current = current->next;
    }

    // If value was not present in the list
    if (current == NULL) {
        return;
    }

    // Unlink the node from the linked list
    previous->next = current->next;
    free(current); // Free memory
}

// Function to print the linked list
void printList(LinkedList* list) {
    Node* current = list->head;
    if (current == NULL) {
        printf(""\n""); // Print newline for empty list
        return;
    }
    while (current != NULL) {
        printf(""%d"", current->value);
        current = current->next;
        if (current != NULL) {
            printf("" "");
        }
    }
    printf(""\n"");
}

// Function to free all nodes in the list (destructor equivalent)
void freeList(LinkedList* list) {
    Node* current = list->head;
    Node* next;
    while (current != NULL) {
        next = current->next;
        free(current);
        current = next;
    }
    list->head = NULL;
}

int main() {
    LinkedList mylist;
    initLinkedList(&mylist);

    char command[10];
    int value;

    while (scanf(""%s"", command) != EOF) {
        if (strcmp(command, ""insert"") == 0) {
            scanf(""%d"", &value);
            insertAtEnd(&mylist, value);
        } else if (strcmp(command, ""delete"") == 0) {
            scanf(""%d"", &value);
            deleteNode(&mylist, value);
        } else if (strcmp(command, ""print"") == 0) {
            printList(&mylist);
        }
    }

    freeList(&mylist); // Clean up allocated memory
    return 0;
}","class Node:
    def __init__(self, value):
        self.value = value
        self.next = None

class LinkedList:
    def __init__(self):
        self.head = None

    def insertAtEnd(self, value):
        new_node = Node(value)
        if self.head is None:
            self.head = new_node
        else:
            current = self.head
            while current.next:
                current = current.next
            current.next = new_node

    def deleteNode(self, value):
        current = self.head
        previous = None

        # If head node itself holds the value to be deleted
        if current is not None and current.value == value:
            self.head = current.next
            return

        # Search for the value to be deleted, keep track of the previous node
        while current is not None and current.value != value:
            previous = current
            current = current.next

        # If value was not present in the list
        if current is None:
            return

        # Unlink the node from the linked list
        previous.next = current.next

    def printList(self):
        current = self.head
        elements = []
        while current:
            elements.append(str(current.value))
            current = current.next
        print("" "".join(elements))

if __name__ == '__main__':
    mylist = LinkedList()
    
    import sys
    for line in sys.stdin:
        parts = line.strip().split()
        command = parts[0]

        if command == ""insert"":
            value = int(parts[1])
            mylist.insertAtEnd(value);
        elif command == ""delete"":
            value = int(parts[1])
            mylist.deleteNode(value)
        elif command == ""print"":
            mylist.printList()","import java.util.Scanner;

// Define Node class
class Node {
    int value;
    Node next;

    Node(int val) {
        value = val;
        next = null;
    }
}

// Define LinkedList class
class LinkedList {
    Node head;

    public LinkedList() {
        head = null;
    }

    // Function to insert a node at the end of the list
    public void insertAtEnd(int value) {
        Node newNode = new Node(value);
        if (head == null) {
            head = newNode;
        } else {
            Node current = head;
            while (current.next != null) {
                current = current.next;
            }
            current.next = newNode;
        }
    }

    // Function to delete the first occurrence of a node with a given value
    public void deleteNode(int value) {
        Node current = head;
        Node previous = null;

        // If head node itself holds the value to be deleted
        if (current != null && current.value == value) {
            head = current.next; // Changed head
            return;
        }

        // Search for the value to be deleted, keep track of the previous node
        while (current != null && current.value != value) {
            previous = current;
            current = current.next;
        }

        // If value was not present in the list
        if (current == null) {
            return;
        }

        // Unlink the node from the linked list
        previous.next = current.next;
    }

    // Function to print the linked list
    public void printList() {
        Node current = head;
        if (current == null) {
            System.out.println();
            return;
        }
        StringBuilder sb = new StringBuilder();
        while (current != null) {
            sb.append(current.value);
            current = current.next;
            if (current != null) {
                sb.append("" "");
            }
        }
        System.out.println(sb.toString());
    }
}

public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        LinkedList mylist = new LinkedList();

        while (scanner.hasNext()) {
            String command = scanner.next();
            if (command.equals(""insert"")) {
                int value = scanner.nextInt();
                mylist.insertAtEnd(value);
            } else if (command.equals(""delete"")) {
                int value = scanner.nextInt();
                mylist.deleteNode(value);
            } else if (command.equals(""print"")) {
                mylist.printList();
            }
        }
        scanner.close();
    }
}","class Node {
    constructor(value) {
        this.value = value;
        this.next = null;
    }
}

class LinkedList {
    constructor() {
        this.head = null;
    }

    // Function to insert a node at the end of the list
    insertAtEnd(value) {
        const newNode = new Node(value);
        if (this.head === null) {
            this.head = newNode;
        } else {
            let current = this.head;
            while (current.next !== null) {
                current = current.next;
            }K
            current.next = newNode;
        }
    }

    // Function to delete the first occurrence of a node with a given value
    deleteNode(value) {
        let current = this.head;
        let previous = null;

        // If head node itself holds the value to be deleted
        if (current !== null && current.value === value) {
            this.head = current.next; // Changed head
            return;
        }

        // Search for the value to be deleted, keep track of the previous node
        while (current !== null && current.value !== value) {
            previous = current;
            current = current.next;
        }

        // If value was not present in the list
        if (current === null) {
            return;
        }

        // Unlink the node from the linked list
        previous.next = current.next;
    }

    // Function to print the linked list
    printList() {
        let current = this.head;
        const elements = [];
        while (current !== null) {
            elements.push(current.value);
            current = current.next;
        }
        console.log(elements.join("" ""));
    }
}

// Main execution logic to handle input/output
function main() {
    const mylist = new LinkedList();
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
        terminal: false
    });

    rl.on('line', (line) => {
        const parts = line.trim().split(' ');
        const command = parts[0];

        if (command === ""insert"") {
            const value = parseInt(parts[1], 10);
            mylist.insertAtEnd(value);
        } else if (command === ""delete"") {
            const value = parseInt(parts[1], 10);
            mylist.deleteNode(value);
        } else if (command === ""print"") {
            mylist.printList();
        }
    });

    // Handle end of input for cases where rl.on('close') might be needed for a final print or cleanup
    // For this problem, commands are processed line by line, so no explicit 'close' handling is strictly necessary
    // for functional correctness if input ends after the last command.
}

main();","#include <iostream>
#include <string>
#include <sstream>

// Define Node structure
struct Node {
    int value;
    Node* next;

    Node(int val) : value(val), next(nullptr) {}
};

// Define LinkedList class
class LinkedList {
public:
    Node* head;

    LinkedList() : head(nullptr) {}

    ~LinkedList() {
        Node* current = head;
        Node* nextNode;
        while (current != nullptr) {
            nextNode = current->next;
            delete current;
            current = nextNode;
        }
        head = nullptr; // Ensure head is null after destruction
    }

    // Function to insert a node at the end of the list
    void insertAtEnd(int value) {
        Node* newNode = new Node(value);
        if (head == nullptr) {
            head = newNode;
        } else {
            Node* current = head;
            while (current->next != nullptr) {
                current = current->next;
            }
            current->next = newNode;
        }
    }

    // Function to delete the first occurrence of a node with a given value
    void deleteNode(int value) {
        Node* current = head;
        Node* previous = nullptr;

        // If head node itself holds the value to be deleted
        if (current != nullptr && current->value == value) {
            head = current->next; // Changed head
            delete current;       // Free old head
            return;
        }

        // Search for the value to be deleted, keep track of the previous node
        while (current != nullptr && current->value != value) {
            previous = current;
            current = current->next;
        }

        // If value was not present in the list
        if (current == nullptr) {
            return;
        }

        // Unlink the node from the linked list
        previous->next = current->next;
        delete current; // Free memory
    }

    // Function to print the linked list
    void printList() {
        Node* current = head;
        if (current == nullptr) {
            std::cout << std::endl;
            return;
        }
        while (current != nullptr) {
            std::cout << current->value;
            current = current->next;
            if (current != nullptr) {
                std::cout << "" "";
            }
        }
        std::cout << std::endl;
    }
};

int main() {
    LinkedList mylist;
    std::string line;
    std::string command;
    int value;

    while (std::cin >> command) {
        if (command == ""insert"") {
            std::cin >> value;
            mylist.insertAtEnd(value);
        } else if (command == ""delete"") {
            std::cin >> value;
            mylist.deleteNode(value);
        } else if (command == ""print"") {
            mylist.printList();
        }
    }

    return 0;
}",4.1
Yellow-29,"Singly Linked List (creation, traversal, insertion, deletion)","*   Singly Linked List structure (Node, head pointer)
*   Linked List Traversal
*   Node Insertion (specifically at the end)
*   Node Deletion (at a specific index, handling head deletion)","You are tasked with implementing a basic singly linked list and performing a series of operations on it. Your program should be able to:
1.  **Insert a node at the end** of the list.
2.  **Delete a node at a specific 0-indexed position**. If the index is out of bounds, no deletion should occur.
3.  **Print the current state of the linked list**. If the list is empty, print ""List is empty.""

Your program will receive a sequence of commands. Each command starts with a character indicating the operation:
*   `I <value>`: Insert `value` at the end of the list.
*   `D <index>`: Delete the node at `index`.
*   `P`: Print the current list.","*   The number of operations `N` will be between 1 and 20.
*   Values inserted will be integers between 0 and 100.
*   Indices for deletion will be between 0 and `N-1` (where N is current list size).
*   The list will not contain duplicate values (for simplicity, not an implementation constraint).
*   The list size will not exceed 20 elements at any point.","I 10
I 20
P
I 30
D 1
P
D 5
P


####","10 20
10 30
10","Input: P
I 5
P
D 0
P
I 100
D 1
P
Output: List is empty.
5
List is empty.
100

Input: I 1
I 2
I 3
I 4
P
D 2
P
D 2
P
D 0
P
Output: 1 2 3 4
1 2 4
1 2
2

Input: I 10
I 20
P
D 0
D 0
P
D 0
P
I 5
I 15
I 25
P
D 1
P
D 1
P
D 1
P
D 0
P
Output: 10 20
List is empty.
List is empty.
5 15 25
5 25
5
5
List is empty.","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Node structure for singly linked list
struct Node {
    int data;
    struct Node* next;
};

// Function to create a new node
struct Node* createNode(int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    if (newNode == NULL) {
        perror(""Failed to allocate memory for new node"");
        exit(EXIT_FAILURE);
    }
    newNode->data = data;
    newNode->next = NULL;
    return newNode;
}

// Function to insert a node at the end of the list
struct Node* insertEnd(struct Node* head, int data) {
    struct Node* newNode = createNode(data);
    if (head == NULL) {
        return newNode; // New node becomes the head
    } else {
        struct Node* current = head;
        while (current->next != NULL) {
            current = current->next;
        }
        current->next = newNode;
        return head;
    }
}

// Function to delete a node at a specific index
struct Node* deleteAtIndex(struct Node* head, int index) {
    if (head == NULL) {
        return NULL; // List is empty
    }

    if (index == 0) {
        struct Node* temp = head;
        head = head->next;
        free(temp); // Free the old head
        return head;
    }

    struct Node* current = head;
    struct Node* prev = NULL;
    int count = 0;

    while (current != NULL && count < index) {
        prev = current;
        current = current->next;
        count++;
    }

    if (current == NULL) {
        // Index out of bounds
        return head;
    }

    // current is the node to be deleted
    prev->next = current->next;
    free(current);
    return head;
}

// Function to print the linked list
void printList(struct Node* head) {
    if (head == NULL) {
        printf(""List is empty.\n"");
        return;
    }
    struct Node* current = head;
    while (current != NULL) {
        printf(""%d"", current->data);
        current = current->next;
        if (current != NULL) {
            printf("" "");
        }
    }
    printf(""\n"");
}

// Function to free all nodes in the list
void freeList(struct Node* head) {
    struct Node* current = head;
    struct Node* next;
    while (current != NULL) {
        next = current->next;
        free(current);
        current = next;
    }
}

int main() {
    struct Node* head = NULL;
    char command[10];
    int value, index;

    while (scanf(""%s"", command) != EOF) {
        if (strcmp(command, ""I"") == 0) {
            scanf(""%d"", &value);
            head = insertEnd(head, value);
        } else if (strcmp(command, ""D"") == 0) {
            scanf(""%d"", &index);
            head = deleteAtIndex(head, index);
        } else if (strcmp(command, ""P"") == 0) {
            printList(head);
        } else {
            break; // Unknown command or end of input stream
        }
    }

    freeList(head); // Clean up memory
    return 0;
}","import sys

class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class SinglyLinkedList:
    def __init__(self):
        self.head = None

    def insert_end(self, data):
        new_node = Node(data)
        if self.head is None:
            self.head = new_node
        else:
            current = self.head
            while current.next is not None:
                current = current.next
            current.next = new_node

    def delete_at_index(self, index):
        if self.head is None:
            return # List is empty

        if index == 0:
            self.head = self.head.next
            return

        current = self.head
        prev = None
        count = 0

        while current is not None and count < index:
            prev = current
            current = current.next
            count += 1

        if current is None:
            # Index out of bounds
            return

        # current is the node to be deleted
        prev.next = current.next

    def print_list(self):
        if self.head is None:
            print(""List is empty."")
            return
        
        elements = []
        current = self.head
        while current is not None:
            elements.append(str(current.data))
            current = current.next
        print("" "".join(elements))

# Main logic for reading input and executing commands
def main():
    list_obj = SinglyLinkedList()

    for line in sys.stdin:
        parts = line.strip().split()
        if not parts:
            continue
        
        command = parts[0]
        if command == 'I':
            value = int(parts[1])
            list_obj.insert_end(value)
        elif command == 'D':
            index = int(parts[1])
            list_obj.delete_at_index(index)
        elif command == 'P':
            list_obj.print_list()
        else:
            break # Unknown command or end of input

if __name__ == ""__main__"":
    main()","import java.util.Scanner;

// Node class for singly linked list
class Node {
    int data;
    Node next;

    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}

// LinkedList class to manage operations
class SinglyLinkedList {
    Node head;

    public SinglyLinkedList() {
        this.head = null;
    }

    // Method to insert a node at the end of the list
    public void insertEnd(int data) {
        Node newNode = new Node(data);
        if (this.head == null) {
            this.head = newNode;
        } else {
            Node current = this.head;
            while (current.next != null) {
                current = current.next;
            }
            current.next = newNode;
        }
    }

    // Method to delete a node at a specific index
    public void deleteAtIndex(int index) {
        if (this.head == null) {
            return; // List is empty
        }

        if (index == 0) {
            this.head = this.head.next;
            return;
        }

        Node current = this.head;
        Node prev = null;
        int count = 0;

        while (current != null && count < index) {
            prev = current;
            current = current.next;
            count++;
        }

        if (current == null) {
            // Index out of bounds
            return;
        }

        // current is the node to be deleted
        prev.next = current.next;
    }

    // Method to print the linked list
    public void printList() {
        if (this.head == null) {
            System.out.println(""List is empty."");
            return;
        }
        Node current = this.head;
        StringBuilder sb = new StringBuilder();
        while (current != null) {
            sb.append(current.data);
            current = current.next;
            if (current != null) {
                sb.append("" "");
            }
        }
        System.out.println(sb.toString());
    }
}

public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        SinglyLinkedList list = new SinglyLinkedList();

        while (scanner.hasNext()) {
            String command = scanner.next();
            if (command.equals(""I"")) {
                int value = scanner.nextInt();
                list.insertEnd(value);
            } else if (command.equals(""D"")) {
                int index = scanner.nextInt();
                list.deleteAtIndex(index);
            } else if (command.equals(""P"")) {
                list.printList();
            } else {
                break; // Unknown command or end of input stream
            }
        }
        scanner.close();
    }
}","// Node class for singly linked list
class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

// LinkedList class to manage operations
class SinglyLinkedList {
    constructor() {
        this.head = null;
    }

    // Method to insert a node at the end of the list
    insertEnd(data) {
        const newNode = new Node(data);
        if (this.head === null) {
            this.head = newNode;
        } else {
            let current = this.head;
            while (current.next !== null) {
                current = current.next;
            }
            current.next = newNode;
        }
    }

    // Method to delete a node at a specific index
    deleteAtIndex(index) {
        if (this.head === null) {
            return; // List is empty
        }

        if (index === 0) {
            this.head = this.head.next;
            return;
        }

        let current = this.head;
        let prev = null;
        let count = 0;

        while (current !== null && count < index) {
            prev = current;
            current = current.next;
            count++;
        }

        if (current === null) {
            // Index out of bounds
            return;
        }

        // current is the node to be deleted
        prev.next = current.next;
    }

    // Method to print the linked list
    printList() {
        if (this.head === null) {
            console.log(""List is empty."");
            return;
        }
        let elements = [];
        let current = this.head;
        while (current !== null) {
            elements.push(current.data);
            current = current.next;
        }
        console.log(elements.join("" ""));
    }
}

// Main logic for reading input and executing commands
function main() {
    const list = new SinglyLinkedList();
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout,
        terminal: false
    });

    rl.on('line', (line) => {
        const parts = line.trim().split(' ');
        if (parts.length === 0) {
            return;
        }

        const command = parts[0];
        if (command === 'I') {
            const value = parseInt(parts[1], 10);
            list.insertEnd(value);
        } else if (command === 'D') {
            const index = parseInt(parts[1], 10);
            list.deleteAtIndex(index);
        } else if (command === 'P') {
            list.printList();
        }
    });

    rl.on('close', () => {
        // Any final cleanup if needed
    });
}

// Call the main function to start execution
main();","#include <iostream>
#include <string>

// Node structure for singly linked list
struct Node {
    int data;
    Node* next;

    Node(int val) : data(val), next(nullptr) {}
};

// Function to insert a node at the end of the list
Node* insertEnd(Node* head, int data) {
    Node* newNode = new Node(data);
    if (head == nullptr) {
        return newNode; // New node becomes the head
    } else {
        Node* current = head;
        while (current->next != nullptr) {
            current = current->next;
        }
        current->next = newNode;
        return head;
    }
}

// Function to delete a node at a specific index
Node* deleteAtIndex(Node* head, int index) {
    if (head == nullptr) {
        return nullptr; // List is empty
    }

    if (index == 0) {
        Node* temp = head;
        head = head->next;
        delete temp; // Free the old head
        return head;
    }

    Node* current = head;
    Node* prev = nullptr;
    int count = 0;

    while (current != nullptr && count < index) {
        prev = current;
        current = current->next;
        count++;
    }

    if (current == nullptr) {
        // Index out of bounds
        return head;
    }

    // current is the node to be deleted
    prev->next = current->next;
    delete current;
    return head;
}

// Function to print the linked list
void printList(Node* head) {
    if (head == nullptr) {
        std::cout << ""List is empty."" << std::endl;
        return;
    }
    Node* current = head;
    while (current != nullptr) {
        std::cout << current->data;
        current = current->next;
        if (current != nullptr) {
            std::cout << "" "";
        }
    }
    std::cout << std::endl;
}

// Function to free all nodes in the list
void freeList(Node* head) {
    Node* current = head;
    Node* next;
    while (current != nullptr) {
        next = current->next;
        delete current;
        current = next;
    }
}

int main() {
    Node* head = nullptr;
    std::string command;
    int value, index;

    while (std::cin >> command) {
        if (command == ""I"") {
            std::cin >> value;
            head = insertEnd(head, value);
        } else if (command == ""D"") {
            std::cin >> index;
            head = deleteAtIndex(head, index);
        } else if (command == ""P"") {
            printList(head);
        } else {
            break; // Unknown command or end of input stream
        }
    }

    freeList(head); // Clean up memory
    return 0;
}",4.2
Yellow-30,Kadane’s Algorithm,"*   Dynamic Programming
*   Greedy Approach
*   Kadane's Algorithm
*   Array Traversal","You are given an array of integers, `nums`. Your task is to find the sum of a contiguous subarray (a subarray that occupies consecutive positions within the original array) which has the largest sum. This subarray must contain at least one number.

For example, if the array is `[-2, 1, -3, 4, -1, 2, 1, -5, 4]`, the contiguous subarray `[4, -1, 2, 1]` has the largest sum, which is `6`.","* `1 <= nums.length <= 10^5`
* `-100 <= nums[i] <= 100`",-2 1 -3 4 -1 2 1 -5 4,6,"Input: 1
Output: 1
Input: -1
Output: -1
Input: -5 -1 -3
Output: -1
Input: 1 2 3 -2 5
Output: 9
Input: 5 4 -1 7 8
Output: 23","#include <stdio.h>
#include <stdlib.h>
#include <limits.h>

// Function to find the maximum of two integers
int max(int a, int b) {
    return (a > b) ? a : b;
}

// Function to find the maximum subarray sum using Kadane's Algorithm
int maxSubArraySum(int* nums, int numsSize) {
    if (numsSize == 0) {
        return 0; // Or handle error as per problem constraints
    }

    int max_so_far = nums[0];
    int current_max = nums[0];

    for (int i = 1; i < numsSize; i++) {
        current_max = max(nums[i], current_max + nums[i]);
        max_so_far = max(max_so_far, current_max);
    }

    return max_so_far;
}

int main() {
    int* nums = NULL;
    int capacity = 10; // Initial capacity
    int numsSize = 0;
    int num;

    nums = (int*)malloc(capacity * sizeof(int));
    if (nums == NULL) {
        return 1; // Malloc failed
    }

    // Read space-separated integers from stdin until newline or EOF
    while (scanf(""%d"", &num) == 1) {
        if (numsSize == capacity) {
            capacity *= 2;
            int* temp = (int*)realloc(nums, capacity * sizeof(int));
            if (temp == NULL) {
                free(nums);
                return 1; // Realloc failed
            }
            nums = temp;
        }
        nums[numsSize++] = num;

        // Check for newline character, assuming input is on a single line
        char next_char = getchar();
        if (next_char == '\n' || next_char == EOF) {
            ungetc(next_char, stdin); // Put it back if it's EOF for potential future reads (though not needed here)
            break;
        }
        ungetc(next_char, stdin); // Put back any non-space/non-digit character to be re-read if it's not a separator
    }

    // Consume the rest of the line to clear buffer if any chars are left (like a final newline not caught by scanf)
    while (getchar() != '\n' && !feof(stdin));

    printf(""%d\n"", maxSubArraySum(nums, numsSize));

    free(nums);
    return 0;
}","import sys

def max_sub_array_sum(nums: list[int]) -> int:
    if not nums:
        return 0 # Or handle error as per problem constraints

    max_so_far = nums[0]
    current_max = nums[0]

    for i in range(1, len(nums)):
        current_max = max(nums[i], current_max + nums[i])
        max_so_far = max(max_so_far, current_max)
    
    return max_so_far

if __name__ == '__main__':
    # Read space-separated integers from stdin
    line = sys.stdin.readline().strip()
    nums = list(map(int, line.split()))
    
    result = max_sub_array_sum(nums)
    print(result)","import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

public class Solution {

    // Function to find the maximum subarray sum using Kadane's Algorithm
    public int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0; // Or handle error as per problem constraints
        }

        int maxSoFar = nums[0];
        int currentMax = nums[0];

        for (int i = 1; i < nums.length; i++) {
            currentMax = Math.max(nums[i], currentMax + nums[i]);
            maxSoFar = Math.max(maxSoFar, currentMax);
        }

        return maxSoFar;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        List<Integer> numList = new ArrayList<>();

        String line = scanner.nextLine();
        String[] strNums = line.trim().split(""\\s+""); // Split by one or more spaces

        for (String strNum : strNums) {
            if (!strNum.isEmpty()) {
                numList.add(Integer.parseInt(strNum));
            }
        }

        int[] nums = new int[numList.size()];
        for (int i = 0; i < numList.size(); i++) {
            nums[i] = numList.get(i);
        }

        Solution sol = new Solution();
        System.out.println(sol.maxSubArray(nums));

        scanner.close();
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

// Function to find the maximum subarray sum using Kadane's Algorithm
function maxSubArraySum(nums) {
    if (nums.length === 0) {
        return 0; // Or handle error as per problem constraints
    }

    let maxSoFar = nums[0];
    let currentMax = nums[0];

    for (let i = 1; i < nums.length; i++) {
        currentMax = Math.max(nums[i], currentMax + nums[i]);
        maxSoFar = Math.max(maxSoFar, currentMax);
    }

    return maxSoFar;
}

rl.on('line', (line) => {
    const nums = line.split(' ').map(Number);
    const result = maxSubArraySum(nums);
    console.log(result);
    rl.close();
});","#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <sstream>

// Function to find the maximum subarray sum using Kadane's Algorithm
int maxSubArraySum(const std::vector<int>& nums) {
    if (nums.empty()) {
        return 0; // Or handle error as per problem constraints
    }

    int max_so_far = nums[0];
    int current_max = nums[0];

    for (size_t i = 1; i < nums.size(); ++i) {
        current_max = std::max(nums[i], current_max + nums[i]);
        max_so_far = std::max(max_so_far, current_max);
    }

    return max_so_far;
}

int main() {
    std::string line;
    std::getline(std::cin, line);
    std::stringstream ss(line);
    std::vector<int> nums;
    int num;

    while (ss >> num) {
        nums.push_back(num);
    }

    std::cout << maxSubArraySum(nums) << std::endl;

    return 0;
}",4.5
Yellow-31,Prefix & Suffix Sums,"*   Arrays
*   Prefix Sums (Cumulative Sums)
*   Time Complexity Optimization
*   Basic I/O","You're the commander of a data analysis unit, and your team has collected a long sequence of numbers. You need to process various queries asking for the sum of elements within specific ranges (segments) of this sequence. A naive approach of summing elements for each query would be too slow given the potentially large number of queries and the sequence length. Your mission is to implement an efficient system that can quickly respond to these range sum queries.

Given an array of `n` integers and `q` queries, each query consists of two indices, `L` and `R` (0-indexed). For each query, you must find the sum of all elements in the array from index `L` to `R`, inclusive.","*   `1 <= n <= 10^5` (size of the array)
*   `1 <= q <= 10^5` (number of queries)
*   `-10^9 <= arr[i] <= 10^9` (value of array elements)
*   `0 <= L <= R < n` (query indices are valid)
*   The sum of elements in a range can exceed the capacity of a 32-bit integer, so use a 64-bit integer type (e.g., `long long` in C++/C, `long` in Java, standard integers in Python/JS).","**

5
1 2 3 4 5
2
0 2
2 4


**","**

6
12


**","Input:
1
100
1
0 0
Output:
100
Input:
7
-5 2 -10 8 1 3 -7
3
0 6
1 3
4 5
Output:
-8
0
4
Input:
10
1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000 1000000000
2
0 9
5 5
Output:
10000000000
1000000000
Input:
6
0 0 0 0 0 0
2
0 5
2 3
Output:
0
0","#include <stdio.h>
#include <stdlib.h>

// Function to calculate prefix sums and handle queries
void solve() {
    int n;
    scanf(""%d"", &n);

    long long *arr = (long long *)malloc(n * sizeof(long long));
    long long *prefix_sum = (long long *)malloc((n + 1) * sizeof(long long));

    if (arr == NULL || prefix_sum == NULL) {
        // Handle memory allocation failure
        if (arr) free(arr);
        if (prefix_sum) free(prefix_sum);
        return;
    }

    prefix_sum[0] = 0;
    for (int i = 0; i < n; i++) {
        scanf(""%lld"", &arr[i]);
        prefix_sum[i + 1] = prefix_sum[i] + arr[i];
    }

    int q;
    scanf(""%d"", &q);

    for (int k = 0; k < q; k++) {
        int L, R;
        scanf(""%d %d"", &L, &R);
        long long range_sum = prefix_sum[R + 1] - prefix_sum[L];
        printf(""%lld\n"", range_sum);
    }

    free(arr);
    free(prefix_sum);
}

int main() {
    solve();
    return 0;
}","def solve():
    n = int(input())
    arr = list(map(int, input().split()))

    # Python integers handle arbitrary size, so no explicit long long equivalent is needed.
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + arr[i]

    q = int(input())

    results = []
    for _ in range(q):
        L, R = map(int, input().split())
        range_sum = prefix_sum[R + 1] - prefix_sum[L]
        results.append(str(range_sum))
    
    # Print all results at once for potentially faster output with many queries.
    print(""\n"".join(results))

if __name__ == ""__main__"":
    solve()","import java.util.Scanner;

public class Solution {

    // Function to calculate prefix sums and handle queries
    public static void solve() {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        // Using long for array elements and prefix sums to prevent overflow
        // as elements can be 10^9 and N can be 10^5, sum can be 10^14.
        long[] arr = new long[n];
        long[] prefixSum = new long[n + 1];

        prefixSum[0] = 0;
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextLong();
            prefixSum[i + 1] = prefixSum[i] + arr[i];
        }

        int q = scanner.nextInt();

        for (int k = 0; k < q; k++) {
            int L = scanner.nextInt();
            int R = scanner.nextInt();
            long rangeSum = prefixSum[R + 1] - prefixSum[L];
            System.out.println(rangeSum);
        }

        scanner.close();
    }

    public static void main(String[] args) {
        solve();
    }
}","function solve() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let lines = [];
    rl.on('line', (line) => {
        lines.push(line);
    }).on('close', () => {
        let lineIndex = 0;

        const n = parseInt(lines[lineIndex++]);
        const arr = lines[lineIndex++].split(' ').map(Number);

        // JavaScript numbers can represent large integers accurately up to 2^53 - 1.
        // 10^14 is within this safe integer limit, so standard Numbers are fine.
        const prefixSum = new Array(n + 1).fill(0);
        for (let i = 0; i < n; i++) {
            prefixSum[i + 1] = prefixSum[i] + arr[i];
        }

        const q = parseInt(lines[lineIndex++]);
        const results = [];

        for (let k = 0; k < q; k++) {
            const [L, R] = lines[lineIndex++].split(' ').map(Number);
            const rangeSum = prefixSum[R + 1] - prefixSum[L];
            results.push(rangeSum);
        }
        console.log(results.join('\n'));
    });
}

solve(); // Call the main solve function","#include <iostream>
#include <vector>

// Function to calculate prefix sums and handle queries
void solve() {
    int n;
    std::cin >> n;

    // Using long long for array elements and prefix sums to prevent overflow
    // as elements can be 10^9 and N can be 10^5, sum can be 10^14.
    std::vector<long long> arr(n);
    std::vector<long long> prefix_sum(n + 1, 0); // Initialize with 0s

    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i];
        prefix_sum[i + 1] = prefix_sum[i] + arr[i];
    }

    int q;
    std::cin >> q;

    for (int k = 0; k < q; ++k) {
        int L, R;
        std::cin >> L >> R;
        long long range_sum = prefix_sum[R + 1] - prefix_sum[L];
        std::cout << range_sum << ""\n"";
    }
}

int main() {
    // Optimize C++ standard streams for faster input/output.
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    solve();
    return 0;
}",3.9
White-101,Modulo Arithmetic,"*   Modulo Arithmetic
*   Integer Arithmetic","You are given a starting day of the week (represented by a number from 0 for Monday to 6 for Sunday) and a number of days that have passed. Your task is to calculate and return the day of the week it will be after those days have passed.

For example, if today is Wednesday (day 2) and 3 days pass, it will be Saturday (day 5).
If today is Friday (day 4) and 4 days pass, it will be Tuesday (day 1).","*   `0 <= startDay <= 6` (representing Monday to Sunday)
*   `0 <= daysPassed <= 1000`","2
5

(startDay = 2, daysPassed = 5)

####",0,"Input: 0
0
Output: 0
Input: 6
1
Output: 0
Input: 3
7
Output: 3
Input: 2
15
Output: 3
Input: 5
1000
Output: 6","#include <stdio.h>

// Function to calculate the future day of the week
int calculateFutureDay(int startDay, int daysPassed) {
    // Calculate the total number of days from Monday (day 0)
    // Then use modulo 7 to find the equivalent day in the 0-6 range
    return (startDay + daysPassed) % 7;
}

int main() {
    int startDay, daysPassed;

    // Read the starting day from stdin
    scanf(""%d"", &startDay);

    // Read the number of days passed from stdin
    scanf(""%d"", &daysPassed);

    // Calculate the future day
    int futureDay = calculateFutureDay(startDay, daysPassed);

    // Print the result to stdout
    printf(""%d\n"", futureDay);

    return 0;
}","def calculate_future_day(start_day, days_passed):
    # Calculate the total number of days from Monday (day 0)
    # Then use modulo 7 to find the equivalent day in the 0-6 range
    return (start_day + days_passed) % 7

if __name__ == ""__main__"":
    # Read the starting day from stdin
    start_day = int(input())

    # Read the number of days passed from stdin
    days_passed = int(input())

    # Calculate the future day
    future_day = calculate_future_day(start_day, days_passed)

    # Print the result to stdout
    print(future_day)","import java.util.Scanner;

public class Solution {

    // Function to calculate the future day of the week
    public static int calculateFutureDay(int startDay, int daysPassed) {
        // Calculate the total number of days from Monday (day 0)
        // Then use modulo 7 to find the equivalent day in the 0-6 range
        return (startDay + daysPassed) % 7;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the starting day from stdin
        int startDay = scanner.nextInt();

        // Read the number of days passed from stdin
        int daysPassed = scanner.nextInt();

        // Calculate the future day
        int futureDay = calculateFutureDay(startDay, daysPassed);

        // Print the result to stdout
        System.out.println(futureDay);

        scanner.close();
    }
}","function calculateFutureDay(startDay, daysPassed) {
    // Calculate the total number of days from Monday (day 0)
    // Then use modulo 7 to find the equivalent day in the 0-6 range
    return (startDay + daysPassed) % 7;
}

// Read input from stdin
// For typical competitive programming environments in JS, input is often read line by line.
// This example assumes two lines of input, one for startDay and one for daysPassed.
let input = '';
process.stdin.on('data', data => {
    input += data;
});

process.stdin.on('end', () => {
    const lines = input.trim().split('\n');
    const startDay = parseInt(lines[0], 10);
    const daysPassed = parseInt(lines[1], 10);

    const futureDay = calculateFutureDay(startDay, daysPassed);
    console.log(futureDay);
});","#include <iostream>

// Function to calculate the future day of the week
int calculateFutureDay(int startDay, int daysPassed) {
    // Calculate the total number of days from Monday (day 0)
    // Then use modulo 7 to find the equivalent day in the 0-6 range
    return (startDay + daysPassed) % 7;
}

int main() {
    int startDay, daysPassed;

    // Read the starting day from stdin
    std::cin >> startDay;

    // Read the number of days passed from stdin
    std::cin >> daysPassed;

    // Calculate the future day
    int futureDay = calculateFutureDay(startDay, daysPassed);

    // Print the result to stdout
    std::cout << futureDay << std::endl;

    return 0;
}",4.0
Yellow-32,Intro to Backtracking,"-   **Backtracking:** A general algorithm for finding all (or some) solutions to computational problems, that incrementally builds candidates to the solutions, and abandons a candidate (""backtracks"") as soon as it determines that the candidate cannot possibly be completed to a valid solution.
-   **Recursion:** A function calling itself to solve smaller instances of the same problem.
-   **Power Set:** The set of all possible subsets of a given set, including the empty set and the set itself.","Given an integer array `nums` that contains distinct elements, return all possible subsets (the power set). The solution set must not contain duplicate subsets. The order of subsets and the order of elements within a subset can be arbitrary.","- `0 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`
- All the elements of `nums` are unique.","`nums = [1,2,3]`","[]
[1]
[1 2]
[1 2 3]
[1 3]
[2]
[2 3]
[3]

(The order of subsets and elements within subsets shown above is just one possible valid output based on the provided solution.)","Input: 1 2 3
Output: [] [1] [1 2] [1 2 3] [1 3] [2] [2 3] [3]
Input: 4 5
Output: [] [4] [4 5] [5]
Input: -1
Output: [] [-1]
Input: 
Output: []
Input: 10 -5 0
Output: [] [10] [10 -5] [10 -5 0] [10 0] [-5] [-5 0] [0]","#include <stdio.h>
#include <stdlib.h> // For malloc, free, atoi
#include <string.h> // For strtok

// Global variables for the current subset and its size for simpler C management.
// This is a common simplification for Yellow Belt C problems with recursion
// that would otherwise require complex dynamic array management.
// For a production system, these would typically be passed as parameters or use a struct.
int currentSubset_c[10]; // Max subset size based on constraints
int currentSubsetSize_c = 0;

// Helper function to print a subset
void printSubset_c(int* subset, int size) {
    printf(""["");
    for (int i = 0; i < size; i++) {
        printf(""%d"", subset[i]);
        if (i < size - 1) {
            printf("" "");
        }
    }
    printf(""]\n"");
}

// Core logic: Backtracking function to generate and print all subsets
void generateSubsetsRecursive_c(int* nums, int numsSize, int startIndex) {
    // Base Case: Add the current subset to the result (print it)
    printSubset_c(currentSubset_c, currentSubsetSize_c);

    // Recursive Step: Explore choices
    for (int i = startIndex; i < numsSize; i++) {
        // Include nums[i]
        currentSubset_c[currentSubsetSize_c++] = nums[i];

        // Recurse with the next element
        generateSubsetsRecursive_c(nums, numsSize, i + 1);

        // Backtrack: Remove nums[i]
        currentSubsetSize_c--;
    }
}

// Main function to initiate the process
void findAllSubsets_c(int* nums, int numsSize) {
    currentSubsetSize_c = 0; // Reset for each call to findAllSubsets
    generateSubsetsRecursive_c(nums, numsSize, 0);
}

int main() {
    int nums[10]; // Max 10 elements based on constraints
    int count = 0;
    char line[100]; // Buffer to read a line, max length for 10 elements and spaces/signs

    // Read input line (space-separated integers) from stdin
    if (fgets(line, sizeof(line), stdin) != NULL) {
        // Remove trailing newline character if present
        line[strcspn(line, ""\n"")] = 0;

        // Tokenize the string to extract numbers
        char *token = strtok(line, "" "");
        while (token != NULL && count < 10) {
            nums[count++] = atoi(token);
            token = strtok(NULL, "" "");
        }
    }

    findAllSubsets_c(nums, count);

    return 0;
}","import sys

class Solution:
    def _generate_subsets_recursive(self, result, current_subset, nums, start_index):
        # Base Case: Add a copy of the current subset to the result
        result.append(list(current_subset))

        # Recursive Step: Explore choices
        for i in range(start_index, len(nums)):
            # Include nums[i]
            current_subset.append(nums[i])

            # Recurse with the next element
            self._generate_subsets_recursive(result, current_subset, nums, i + 1)

            # Backtrack: Remove nums[i]
            current_subset.pop()

    def find_all_subsets(self, nums):
        result = []
        current_subset = []
        self._generate_subsets_recursive(result, current_subset, nums, 0)
        return result

def main():
    line = sys.stdin.readline().strip()
    
    nums = []
    if line: # Handle empty line for an empty array
        nums = list(map(int, line.split()))

    sol = Solution()
    subsets = sol.find_all_subsets(nums)

    # Print the results
    for subset in subsets:
        print(""["", end="""")
        print(*subset, sep="" "", end="""") # Pythonic way to print list elements space-separated
        print(""]"")

if __name__ == ""__main__"":
    main()","import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;
// import java.util.Arrays; // Not strictly needed, but common for array operations

public class Solution {

    // Core logic: Backtracking function to generate all subsets
    private void generateSubsetsRecursive(List<List<Integer>> result,
                                          List<Integer> currentSubset,
                                          int[] nums,
                                          int startIndex) {
        // Base Case: Add a copy of the current subset to the result
        result.add(new ArrayList<>(currentSubset));

        // Recursive Step: Explore choices
        for (int i = startIndex; i < nums.length; i++) {
            // Include nums[i]
            currentSubset.add(nums[i]);

            // Recurse with the next element
            generateSubsetsRecursive(result, currentSubset, nums, i + 1);

            // Backtrack: Remove nums[i]
            currentSubset.remove(currentSubset.size() - 1);
        }
    }

    // Main function to initiate the process and return all subsets
    public List<List<Integer>> findAllSubsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();
        generateSubsetsRecursive(result, currentSubset, nums, 0);
        return result;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String line = scanner.nextLine();
        scanner.close();

        // Parse input string into an array of integers
        int[] nums;
        if (line.trim().isEmpty()) {
            nums = new int[0];
        } else {
            String[] numStrings = line.trim().split("" "");
            nums = new int[numStrings.length];
            for (int i = 0; i < numStrings.length; i++) {
                nums[i] = Integer.parseInt(numStrings[i]);
            }
        }

        Solution sol = new Solution();
        List<List<Integer>> subsets = sol.findAllSubsets(nums);

        // Print the results
        for (List<Integer> subset : subsets) {
            System.out.print(""["");
            for (int i = 0; i < subset.size(); i++) {
                System.out.print(subset.get(i));
                if (i < subset.size() - 1) {
                    System.out.print("" "");
                }
            }
            System.out.println(""]"");
        }
    }
}","const readline = require('readline');

// Core logic: Backtracking function to generate all subsets
function generateSubsetsRecursive(result, currentSubset, nums, startIndex) {
    // Base Case: Add a copy of the current subset to the result
    result.push([...currentSubset]); // Use spread operator for shallow copy

    // Recursive Step: Explore choices
    for (let i = startIndex; i < nums.length; i++) {
        // Include nums[i]
        currentSubset.push(nums[i]);

        // Recurse with the next element
        generateSubsetsRecursive(result, currentSubset, nums, i + 1);

        // Backtrack: Remove nums[i]
        currentSubset.pop();
    }
}

// Main function to initiate the process and return all subsets
function findAllSubsets(nums) {
    const result = [];
    const currentSubset = [];
    generateSubsetsRecursive(result, currentSubset, nums, 0);
    return result;
}

// Set up readline interface for input
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.on('line', (line) => {
    let nums = [];
    if (line.trim() !== """") {
        nums = line.split(' ').map(Number);
    }

    const subsets = findAllSubsets(nums);

    // Print the results
    for (const subset of subsets) {
        console.log(`[${subset.join(' ')}]`);
    }

    rl.close();
});","#include <iostream>
#include <vector>
#include <string>
#include <sstream>
#include <algorithm> // Not strictly needed, but common for array operations

// Core logic: Backtracking function to generate all subsets
void generateSubsetsRecursive(std::vector<std::vector<int>>& result,
                               std::vector<int>& currentSubset,
                               const std::vector<int>& nums,
                               int startIndex) {
    // Base Case: Add a copy of the current subset to the result
    result.push_back(currentSubset);

    // Recursive Step: Explore choices
    for (int i = startIndex; i < nums.size(); ++i) {
        // Include nums[i]
        currentSubset.push_back(nums[i]);

        // Recurse with the next element
        generateSubsetsRecursive(result, currentSubset, nums, i + 1);

        // Backtrack: Remove nums[i]
        currentSubset.pop_back();
    }
}

// Main function to initiate the process and return all subsets
std::vector<std::vector<int>> findAllSubsets(const std::vector<int>& nums) {
    std::vector<std::vector<int>> result;
    std::vector<int> currentSubset;
    generateSubsetsRecursive(result, currentSubset, nums, 0);
    return result;
}

int main() {
    std::vector<int> nums;
    std::string line;
    
    // Read the entire line from stdin
    std::getline(std::cin, line);
    
    // Use stringstream to parse space-separated integers
    std::stringstream ss(line);
    int number;
    while (ss >> number) {
        nums.push_back(number);
    }

    std::vector<std::vector<int>> subsets = findAllSubsets(nums);

    // Print the results
    for (const auto& subset : subsets) {
        std::cout << ""["";
        for (size_t i = 0; i < subset.size(); ++i) {
            std::cout << subset[i];
            if (i < subset.size() - 1) {
                std::cout << "" "";
            }
        }
        std::cout << ""]"" << std::endl;
    }

    return 0;
}",4.2
White-102,Basic String Manipulation,"- String iteration (looping through characters)
- Character comparison
- Counter variable
- Basic I/O (reading string and char)",Write a program that reads a string and a single character from the input. Your task is to count how many times that specific character appears in the given string. The comparison should be case-sensitive.,"- The string will contain only ASCII characters.
- The string length will be between 1 and 1000 characters.
- The target character will be a single ASCII character.","**
Hello World
o

**","**
2","Input: Programming
x
Output: 0
Input: banana
a
Output: 3
Input: Apple
a
Output: 0
Input: Hello World!
!
Output: 1","#include <stdio.h>
#include <string.h>

// Function to count occurrences of a character in a string
int countChar(const char* str, char target) {
    int count = 0;
    for (int i = 0; str[i] != '\0'; i++) {
        if (str[i] == target) {
            count++;
        }
    }
    return count;
}

int main() {
    char inputString[1001]; // Max length 1000 + null terminator
    char targetChar;

    // Read the string
    // Using fgets to read the whole line including spaces
    if (fgets(inputString, sizeof(inputString), stdin) == NULL) {
        return 1; // Error reading input
    }

    // Remove the trailing newline character if present
    inputString[strcspn(inputString, ""\n"")] = 0;

    // Read the target character
    if (scanf("" %c"", &targetChar) != 1) { // Space before %c to consume any leftover newline
        return 1; // Error reading input
    }

    // Call the core logic function
    int occurrences = countChar(inputString, targetChar);

    // Print the result
    printf(""%d\n"", occurrences);

    return 0;
}","def count_char(s: str, target: str) -> int:
    """"""
    Counts the occurrences of a target character in a string.
    """"""
    count = 0
    for char in s:
        if char == target:
            count += 1
    return count

if __name__ == ""__main__"":
    # Read the string
    input_string = input()

    # Read the target character
    target_char = input()

    # Call the core logic function
    occurrences = count_char(input_string, target_char)

    # Print the result
    print(occurrences)","import java.util.Scanner;

public class Main {

    // Function to count occurrences of a character in a string
    public static int countChar(String str, char target) {
        int count = 0;
        for (int i = 0; i < str.length(); i++) {
            if (str.charAt(i) == target) {
                count++;
            }
        }
        return count;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the string
        String inputString = scanner.nextLine();

        // Read the target character
        // Read next token and get its first character
        char targetChar = scanner.next().charAt(0);

        // Call the core logic function
        int occurrences = countChar(inputString, targetChar);

        // Print the result
        System.out.println(occurrences);

        scanner.close();
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let inputLines = [];

// Function to count occurrences of a character in a string
function countChar(str, target) {
    let count = 0;
    for (let i = 0; i < str.length; i++) {
        if (str[i] === target) {
            count++;
        }
    }
    return count;
}

rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    const inputString = inputLines[0];
    const targetChar = inputLines[1];

    // Call the core logic function
    const occurrences = countChar(inputString, targetChar);

    // Print the result
    console.log(occurrences);
});","#include <iostream>
#include <string>

// Function to count occurrences of a character in a string
int countChar(const std::string& str, char target) {
    int count = 0;
    for (char c : str) {
        if (c == target) {
            count++;
        }
    }
    return count;
}

int main() {
    std::string inputString;
    char targetChar;

    // Read the string (can contain spaces)
    std::getline(std::cin, inputString);

    // Read the target character
    std::cin >> targetChar;

    // Call the core logic function
    int occurrences = countChar(inputString, targetChar);

    // Print the result
    std::cout << occurrences << std::endl;

    return 0;
}",3.9
Orange-1,"Binary Search on Answer (Aggressive Cows, Book Allocation)","- Binary Search
- Predicate Function (or Check Function)
- Search Space Definition (Lower Bound, Upper Bound)","You are given an array of integers `tasks` representing the complexity or size of `n` tasks, and an integer `k` representing the number of workers available. Your goal is to assign all tasks to these `k` workers. The tasks must be assigned contiguously, meaning if `tasks` is split into `k` contiguous segments, each segment is assigned to one worker. You need to find a way to assign tasks such that the maximum total complexity assigned to any single worker is minimized. Return this minimum possible maximum complexity.","- `1 <= n (length of tasks) <= 10^5`
- `1 <= tasks[i] <= 10^9`
- `1 <= k <= n`
- The sum of `tasks` can exceed `2^31 - 1`, so use 64-bit integers for sums where applicable.","tasks = [10, 20, 30, 40]
k = 2",60,"Input:
5
1 2 3 4 5
1
Output:
15
Input:
4
100 200 50 300
4
Output:
300
Input:
3
1000000000 1000000000 1000000000
2
Output:
2000000000
Input:
5
50 50 50 50 50
3
Output:
100
Input:
1
77
1
Output:
77","#include <stdio.h>
#include <stdlib.h> // For malloc, free

// Function to check if it's possible to distribute tasks such that no worker's load exceeds max_load_limit
int canDistribute(const int* tasks, int n, int k, long long max_load_limit) {
    long long current_worker_load = 0;
    int workers_needed = 1;

    for (int i = 0; i < n; ++i) {
        // If adding the current task exceeds the limit, assign it to a new worker
        if (current_worker_load + tasks[i] > max_load_limit) {
            workers_needed++;
            current_worker_load = tasks[i];
        } else {
            current_worker_load += tasks[i];
        }
    }
    return workers_needed <= k;
}

// Main logic function
long long minimalMaxLoad(const int* tasks, int n, int k) {
    if (n == 0) {
        return 0;
    }

    long long low = 0;
    long long high = 0;
    
    // Calculate initial low (max individual task) and high (total sum of tasks)
    for (int i = 0; i < n; ++i) {
        if (tasks[i] > low) { // find max task
            low = tasks[i];
        }
        high += tasks[i]; // sum of all tasks
    }

    long long ans = high; // Initialize answer with the maximum possible load (sum of all tasks)

    // Binary search for the minimal possible maximum load
    while (low <= high) {
        long long mid = low + (high - low) / 2; // Prevent overflow for large low, high
        if (canDistribute(tasks, n, k, mid)) {
            ans = mid; // mid is a possible answer, try for a smaller one in the left half
            high = mid - 1;
        } else {
            low = mid + 1; // mid is too small, need a larger limit, search in the right half
        }
    }
    return ans;
}

int main() {
    int n;
    scanf(""%d"", &n); // Read number of tasks

    int* tasks = (int*)malloc(n * sizeof(int));
    if (tasks == NULL) {
        return 1; // Error handling for memory allocation
    }

    for (int i = 0; i < n; ++i) {
        scanf(""%d"", &tasks[i]); // Read task complexities
    }

    int k;
    scanf(""%d"", &k); // Read number of workers

    long long result = minimalMaxLoad(tasks, n, k);
    printf(""%lld\n"", result);

    free(tasks); // Free allocated memory
    return 0;
}","import sys

def can_distribute(tasks, k, max_load_limit):
    current_worker_load = 0
    workers_needed = 1

    for task in tasks:
        # If adding the current task exceeds the limit, assign it to a new worker
        if current_worker_load + task > max_load_limit:
            workers_needed += 1
            current_worker_load = task
        else:
            current_worker_load += task
    return workers_needed <= k

def minimal_max_load(tasks, k):
    if not tasks:
        return 0

    low = 0
    high = 0
    
    # Calculate initial low (max individual task) and high (total sum of tasks)
    for task in tasks:
        low = max(low, task) # Max individual task
        high += task # Sum of all tasks

    ans = high # Initialize answer with the maximum possible load (sum of all tasks)

    # Binary search for the minimal possible maximum load
    while low <= high:
        mid = low + (high - low) // 2 # Prevent overflow for large low, high
        if can_distribute(tasks, k, mid):
            ans = mid # mid is a possible answer, try for a smaller one in the left half
            high = mid - 1
        else:
            low = mid + 1 # mid is too small, need a larger limit, search in the right half
    return ans

if __name__ == ""__main__"":
    n = int(sys.stdin.readline()) # Read number of tasks
    tasks = list(map(int, sys.stdin.readline().split())) # Read task complexities

    k = int(sys.stdin.readline()) # Read number of workers

    result = minimal_max_load(tasks, k)
    sys.stdout.write(str(result) + ""\n"")","import java.util.Scanner;
import java.util.Arrays;

public class Main {

    // Function to check if it's possible to distribute tasks such that no worker's load exceeds max_load_limit
    public static boolean canDistribute(int[] tasks, int k, long max_load_limit) {
        long current_worker_load = 0;
        int workers_needed = 1;

        for (int task : tasks) {
            // If adding the current task exceeds the limit, assign it to a new worker
            if (current_worker_load + task > max_load_limit) {
                workers_needed++;
                current_worker_load = task;
            } else {
                current_worker_load += task;
            }
        }
        return workers_needed <= k;
    }

    // Main logic function
    public static long minimalMaxLoad(int[] tasks, int k) {
        if (tasks.length == 0) {
            return 0;
        }

        long low = 0;
        long high = 0;
        
        // Calculate initial low (max individual task) and high (total sum of tasks)
        for (int task : tasks) {
            low = Math.max(low, (long)task); // Max individual task
            high += task; // Sum of all tasks
        }

        long ans = high; // Initialize answer with the maximum possible load (sum of all tasks)

        // Binary search for the minimal possible maximum load
        while (low <= high) {
            long mid = low + (high - low) / 2; // Prevent overflow for large low, high
            if (canDistribute(tasks, k, mid)) {
                ans = mid; // mid is a possible answer, try for a smaller one in the left half
                high = mid - 1;
            } else {
                low = mid + 1; // mid is too small, need a larger limit, search in the right half
            }
        }
        return ans;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt(); // Read number of tasks
        int[] tasks = new int[n];
        for (int i = 0; i < n; ++i) {
            tasks[i] = scanner.nextInt(); // Read task complexities
        }

        int k = scanner.nextInt(); // Read number of workers

        long result = minimalMaxLoad(tasks, k);
        System.out.println(result);

        scanner.close();
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

// Function to check if it's possible to distribute tasks such that no worker's load exceeds max_load_limit
function canDistribute(tasks, k, maxLoadLimit) {
    let currentWorkerLoad = 0;
    let workersNeeded = 1;

    for (let i = 0; i < tasks.length; i++) {
        const task = tasks[i];
        // If adding the current task exceeds the limit, assign it to a new worker
        if (currentWorkerLoad + task > maxLoadLimit) {
            workersNeeded++;
            currentWorkerLoad = task;
        } else {
            currentWorkerLoad += task;
        }
    }
    return workersNeeded <= k;
}

// Main logic function
function minimalMaxLoad(tasks, k) {
    if (tasks.length === 0) {
        return 0;
    }

    let low = 0;
    let high = 0;
    
    // Calculate initial low (max individual task) and high (total sum of tasks)
    for (let i = 0; i < tasks.length; i++) {
        low = Math.max(low, tasks[i]); // Max individual task
        high += tasks[i]; // Sum of all tasks
    }

    let ans = high; // Initialize answer with the maximum possible load (sum of all tasks)

    // Binary search for the minimal possible maximum load
    while (low <= high) {
        let mid = Math.floor(low + (high - low) / 2); // Prevent overflow for large low, high
        if (canDistribute(tasks, k, mid)) {
            ans = mid; // mid is a possible answer, try for a smaller one in the left half
            high = mid - 1;
        } else {
            low = mid + 1; // mid is too small, need a larger limit, search in the right half
        }
    }
    return ans;
}

let inputLines = [];
rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    const n = parseInt(inputLines[0]);
    const tasks = inputLines[1].split(' ').map(Number);
    const k = parseInt(inputLines[2]);

    const result = minimalMaxLoad(tasks, k);
    console.log(result);
});","#include <iostream>
#include <vector>
#include <numeric>
#include <algorithm>

// Function to check if it's possible to distribute tasks such that no worker's load exceeds max_load_limit
bool canDistribute(const std::vector<int>& tasks, int k, long long max_load_limit) {
    long long current_worker_load = 0;
    int workers_needed = 1;

    for (int task : tasks) {
        // If adding the current task exceeds the limit, assign it to a new worker
        if (current_worker_load + task > max_load_limit) {
            workers_needed++;
            current_worker_load = task;
        } else {
            current_worker_load += task;
        }
    }
    return workers_needed <= k;
}

// Main logic function
long long minimalMaxLoad(const std::vector<int>& tasks, int k) {
    if (tasks.empty()) {
        return 0;
    }

    long long low = 0;
    long long high = 0;
    
    // Calculate initial low (max individual task) and high (total sum of tasks)
    for (int task : tasks) {
        low = std::max(low, (long long)task); // Max individual task
        high += task; // Sum of all tasks
    }

    long long ans = high; // Initialize answer with the maximum possible load (sum of all tasks)

    // Binary search for the minimal possible maximum load
    while (low <= high) {
        long long mid = low + (high - low) / 2; // Prevent overflow for large low, high
        if (canDistribute(tasks, k, mid)) {
            ans = mid; // mid is a possible answer, try for a smaller one in the left half
            high = mid - 1;
        } else {
            low = mid + 1; // mid is too small, need a larger limit, search in the right half
        }
    }
    return ans;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n; // Read number of tasks

    std::vector<int> tasks(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> tasks[i]; // Read task complexities
    }

    int k;
    std::cin >> k; // Read number of workers

    long long result = minimalMaxLoad(tasks, k);
    std::cout << result << std::endl;

    return 0;
}",4.0
Yellow-33,Recursive Fibonacci,"*   Recursion
*   Base Cases
*   Recursive Step
*   Mathematical Sequences","The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. The sequence begins: 0, 1, 1, 2, 3, 5, 8, 13, 21, and so on.

Your task is to write a recursive function that calculates the Nth number in the Fibonacci sequence. The sequence starts at index 0 (so F(0) = 0, F(1) = 1, F(2) = 1, etc.).",*   `0 <= N <= 20` (N is a non-negative integer),"**
`N = 5`

**","**
`5`

**","Input: 0
Output: 0
Input: 1
Output: 1
Input: 2
Output: 1
Input: 6
Output: 8
Input: 10
Output: 55
Input: 15
Output: 610
Input: 20
Output: 6765","#include <stdio.h>

// Function to calculate the Nth Fibonacci number recursively
long long fibonacci(int n) {
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

int main() {
    int n;
    // Read input from stdin
    scanf(""%d"", &n);

    // Calculate and print the Nth Fibonacci number
    printf(""%lld\n"", fibonacci(n));

    return 0;
}","import sys

# Function to calculate the Nth Fibonacci number recursively
def fibonacci(n):
    if n == 0:
        return 0
    elif n == 1:
        return 1
    else:
        return fibonacci(n - 1) + fibonacci(n - 2)

if __name__ == '__main__':
    # Read input from stdin
    n = int(sys.stdin.readline().strip())

    # Calculate and print the Nth Fibonacci number
    print(fibonacci(n))","import java.util.Scanner;

public class Solution {

    // Function to calculate the Nth Fibonacci number recursively
    public static long fibonacci(int n) {
        if (n == 0) {
            return 0;
        } else if (n == 1) {
            return 1;
        } else {
            return fibonacci(n - 1) + fibonacci(n - 2);
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // Read input from stdin
        int n = scanner.nextInt();
        scanner.close();

        // Calculate and print the Nth Fibonacci number
        System.out.println(fibonacci(n));
    }
}","// Function to calculate the Nth Fibonacci number recursively
function fibonacci(n) {
    if (n === 0) {
        return 0;
    } else if (n === 1) {
        return 1;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

// Read input from stdin (Node.js environment)
let input = '';
process.stdin.on('data', chunk => {
    input += chunk;
});

process.stdin.on('end', () => {
    const n = parseInt(input.trim(), 10);
    // Calculate and print the Nth Fibonacci number
    console.log(fibonacci(n));
});","#include <iostream>

// Function to calculate the Nth Fibonacci number recursively
long long fibonacci(int n) {
    if (n == 0) {
        return 0;
    } else if (n == 1) {
        return 1;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

int main() {
    int n;
    // Read input from stdin
    std::cin >> n;

    // Calculate and print the Nth Fibonacci number
    std::cout << fibonacci(n) << std::endl;

    return 0;
}",4.1
Yellow-34,Kadane’s Algorithm,"- Kadane's Algorithm
- Dynamic Programming (implicitly greedy approach)
- Iteration
- Tracking maximum values","You are given an integer array `nums`. Your task is to find the contiguous subarray (containing at least one number) which has the largest sum and return its sum.

A contiguous subarray is a sequence of elements that are adjacent in the original array.","- `1 <= nums.length <= 10^5`
- `-10^4 <= nums[i] <= 10^4`","9
-2 1 -3 4 -1 2 1 -5 4",6,"Input: 5
1 2 3 -2 5
Output: 9
Input: 1
-100
Output: -100
Input: 7
-2 -3 -1 -5 -4 -6 -7
Output: -1
Input: 3
5 0 -3
Output: 5
Input: 8
1 2 -3 4 -1 2 1 -5
Output: 7","#include <stdio.h>
#include <limits.h>

// Function to find the maximum of two integers
int max(int a, int b) {
    return (a > b) ? a : b;
}

// Function to find the maximum subarray sum using Kadane's algorithm
int maxSubArray(int* nums, int numsSize) {
    if (numsSize == 0) {
        return 0; // Or handle as an error, depending on constraints. Constraints say numsSize >= 1.
    }

    int current_max = nums[0];
    int global_max = nums[0];

    for (int i = 1; i < numsSize; i++) {
        current_max = max(nums[i], current_max + nums[i]);
        global_max = max(global_max, current_max);
    }

    return global_max;
}

int main() {
    int numsSize;
    scanf(""%d"", &numsSize);

    int nums[numsSize]; // VLA for dynamic array, C99 standard
    for (int i = 0; i < numsSize; i++) {
        scanf(""%d"", &nums[i]);
    }

    int result = maxSubArray(nums, numsSize);
    printf(""%d\n"", result);

    return 0;
}","import sys

def max_sub_array(nums: list[int]) -> int:
    if not nums:
        return 0  # Constraints state nums.length >= 1, but good practice.

    current_max = nums[0]
    global_max = nums[0]

    for i in range(1, len(nums)):
        current_max = max(nums[i], current_max + nums[i])
        global_max = max(global_max, current_max)

    return global_max

if __name__ == '__main__':
    n = int(sys.stdin.readline())
    nums = list(map(int, sys.stdin.readline().split()))

    result = max_sub_array(nums)
    sys.stdout.write(str(result) + ""\n"")","import java.util.Scanner;

public class Solution {

    // Function to find the maximum subarray sum using Kadane's algorithm
    public int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0) {
            return 0; // Constraints state nums.length >= 1, but good practice.
        }

        int currentMax = nums[0];
        int globalMax = nums[0];

        for (int i = 1; i < nums.length; i++) {
            currentMax = Math.max(nums[i], currentMax + nums[i]);
            globalMax = Math.max(globalMax, currentMax);
        }

        return globalMax;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }
        scanner.close();

        Solution sol = new Solution();
        int result = sol.maxSubArray(nums);
        System.out.println(result);
    }
}","/**
 * @param {number[]} nums
 * @return {number}
 */
function maxSubArray(nums) {
    if (nums.length === 0) {
        return 0; // Constraints state nums.length >= 1, but good practice.
    }

    let currentMax = nums[0];
    let globalMax = nums[0];

    for (let i = 1; i < nums.length; i++) {
        currentMax = Math.max(nums[i], currentMax + nums[i]);
        globalMax = Math.max(globalMax, currentMax);
    }

    return globalMax;
}

// Handle input and output for competitive programming environment
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let inputLines = [];
rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    const n = parseInt(inputLines[0]);
    const nums = inputLines[1].split(' ').map(Number);
    
    const result = maxSubArray(nums);
    console.log(result);
});","#include <iostream>
#include <vector>
#include <algorithm> // For std::max

// Function to find the maximum subarray sum using Kadane's algorithm
int maxSubArray(const std::vector<int>& nums) {
    if (nums.empty()) {
        return 0; // Constraints state nums.length >= 1, but good practice.
    }

    int current_max = nums[0];
    int global_max = nums[0];

    for (size_t i = 1; i < nums.size(); ++i) {
        current_max = std::max(nums[i], current_max + nums[i]);
        global_max = std::max(global_max, current_max);
    }

    return global_max;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    std::vector<int> nums(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> nums[i];
    }

    int result = maxSubArray(nums);
    std::cout << result << std::endl;

    return 0;
}",4.2
Yellow-35,Infix to Postfix Conversion,"*   Stacks
*   Operator Precedence
*   Associativity Rules
*   String Manipulation
*   Algorithm Design","In mathematics and computer science, expressions can be written in different notations. The most common is **infix notation**, where operators are placed between their operands (e.g., `A + B`). However, for easier parsing and evaluation by computers, **postfix notation** (also known as Reverse Polish Notation or RPN) is often preferred, where operators follow their operands (e.g., `AB+`).

Your task is to convert a given infix expression into its equivalent postfix expression. This involves understanding operator precedence (which operations are performed first) and associativity (how operators of the same precedence are grouped).","*   The input string `infix_expr` will contain only:
    *   Uppercase English letters (`A-Z`) and digits (`0-9`) as operands.
    *   Operators: `+`, `-`, `*`, `/`, `^`.
    *   Parentheses: `(`, `)`.
*   The input string will be a valid infix expression.
*   There will be no spaces in the input string.
*   The length of the `infix_expr` will be between 1 and 100 characters, inclusive.
*   Operator Precedence (from highest to lowest):
    1.  `^` (Exponentiation)
    2.  `*`, `/` (Multiplication, Division)
    3.  `+`, `-` (Addition, Subtraction)
*   Associativity:
    *   `^` is right-associative (e.g., `A^B^C` is `A^(B^C)`).
    *   `+`, `-`, `*`, `/` are left-associative.","** `A+B*C`
**",** `ABC*+`,"Input: (A+B)*C
Output: AB+C*
Input: A*(B-C)/D
Output: ABC-*D/
Input: P+Q-R*S/T
Output: PQ+RS*T/-
Input: X^Y^Z
Output: XYZ^^
Input: (A+B*C)/(D-E)
Output: ABC*+DE-/","#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>

// Simple Stack implementation for characters
#define MAX_STACK_SIZE 101
char operatorStack[MAX_STACK_SIZE];
int stackTop = -1;

void push(char c) {
    if (stackTop < MAX_STACK_SIZE - 1) {
        operatorStack[++stackTop] = c;
    }
}

char pop() {
    if (stackTop != -1) {
        return operatorStack[stackTop--];
    }
    return '\0'; // Indicates stack underflow or empty
}

char peek() {
    if (stackTop != -1) {
        return operatorStack[stackTop];
    }
    return '\0'; // Indicates stack empty
}

int isEmpty() {
    return stackTop == -1;
}

// Function to check if a character is an operand (letter or digit)
int isOperand(char c) {
    return isalnum(c); // isalnum checks for alphabetic or numeric
}

// Function to check if a character is an operator
int isOperator(char c) {
    return (c == '+' || c == '-' || c == '*' || c == '/' || c == '^');
}

// Function to get the precedence of an operator
int getPrecedence(char op) {
    switch (op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        case '^':
            return 3;
        default:
            return 0; // For '(' or other non-operators/invalid chars
    }
}

// Function to check associativity of an operator
// Returns 1 for left-associative, 0 for right-associative
int isLeftAssociative(char op) {
    return (op == '+' || op == '-' || op == '*' || op == '/');
}

// Main function to convert infix to postfix
char* infixToPostfix(const char* infix) {
    int len = strlen(infix);
    char* postfix = (char*)malloc(sizeof(char) * (len + 1));
    if (postfix == NULL) {
        perror(""Failed to allocate memory for postfix expression"");
        exit(EXIT_FAILURE);
    }
    int j = 0; // Index for postfix expression
    
    // Reset stack for each conversion
    stackTop = -1; 

    for (int i = 0; i < len; i++) {
        char currentChar = infix[i];

        if (isOperand(currentChar)) {
            postfix[j++] = currentChar;
        } else if (currentChar == '(') {
            push(currentChar);
        } else if (currentChar == ')') {
            while (!isEmpty() && peek() != '(') {
                postfix[j++] = pop();
            }
            if (!isEmpty() && peek() == '(') { // Discard '('
                pop();
            } else {
                // Mismatched parentheses, handle error or assume valid input
                // For this problem, we assume valid input
            }
        } else if (isOperator(currentChar)) {
            while (!isEmpty() && peek() != '(' && 
                   (getPrecedence(peek()) > getPrecedence(currentChar) || 
                    (getPrecedence(peek()) == getPrecedence(currentChar) && isLeftAssociative(currentChar)))) {
                postfix[j++] = pop();
            }
            push(currentChar);
        }
    }

    // Pop any remaining operators from the stack
    while (!isEmpty()) {
        postfix[j++] = pop();
    }
    postfix[j] = '\0'; // Null-terminate the postfix string

    return postfix;
}

int main() {
    char infixExpr[101];
    if (scanf(""%s"", infixExpr) != 1) {
        fprintf(stderr, ""Failed to read input.\n"");
        return 1;
    }

    char* postfixExpr = infixToPostfix(infixExpr);
    printf(""%s\n"", postfixExpr);
    
    free(postfixExpr); // Free dynamically allocated memory
    
    return 0;
}","import sys

def is_operand(char):
    return '0' <= char <= '9' or 'A' <= char <= 'Z' or 'a' <= char <= 'z'

def get_precedence(op):
    if op == '+' or op == '-':
        return 1
    elif op == '*' or op == '/':
        return 2
    elif op == '^':
        return 3
    return 0 # For '(' or other non-operators

def is_left_associative(op):
    return op in {'+', '-', '*', '/'}

def infix_to_postfix(infix_expr):
    postfix_expr = []
    operator_stack = []

    for char in infix_expr:
        if is_operand(char):
            postfix_expr.append(char)
        elif char == '(':
            operator_stack.append(char)
        elif char == ')':
            while operator_stack and operator_stack[-1] != '(':
                postfix_expr.append(operator_stack.pop())
            if operator_stack and operator_stack[-1] == '(':
                operator_stack.pop() # Discard '('
            # else: Mismatched parentheses error, assuming valid input
        elif char in {'+', '-', '*', '/', '^'}: # It's an operator
            while (operator_stack and operator_stack[-1] != '(' and
                   (get_precedence(operator_stack[-1]) > get_precedence(char) or
                    (get_precedence(operator_stack[-1]) == get_precedence(char) and is_left_associative(char)))):
                postfix_expr.append(operator_stack.pop())
            operator_stack.append(char)
    
    # Pop any remaining operators from the stack
    while operator_stack:
        postfix_expr.append(operator_stack.pop())
            
    return """".join(postfix_expr)

def main():
    infix_expr = sys.stdin.readline().strip()
    postfix_expr = infix_to_postfix(infix_expr)
    sys.stdout.write(postfix_expr + ""\n"")

if __name__ == '__main__':
    main()","import java.util.Scanner;
import java.util.Stack;

public class Solution {

    // Function to check if a character is an operand (letter or digit)
    private static boolean isOperand(char c) {
        return Character.isLetterOrDigit(c);
    }

    // Function to get the precedence of an operator
    private static int getPrecedence(char op) {
        switch (op) {
            case '+':
            case '-':
                return 1;
            case '*':
            case '/':
                return 2;
            case '^':
                return 3;
            default:
                return 0; // For '(' or other non-operators/invalid chars
        }
    }

    // Function to check associativity of an operator
    // Returns true for left-associative, false for right-associative
    private static boolean isLeftAssociative(char op) {
        return (op == '+' || op == '-' || op == '*' || op == '/');
    }

    // Main function to convert infix to postfix
    public static String infixToPostfix(String infix) {
        StringBuilder postfix = new StringBuilder();
        Stack<Character> operatorStack = new Stack<>();

        for (int i = 0; i < infix.length(); i++) {
            char currentChar = infix.charAt(i);

            if (isOperand(currentChar)) {
                postfix.append(currentChar);
            } else if (currentChar == '(') {
                operatorStack.push(currentChar);
            } else if (currentChar == ')') {
                while (!operatorStack.isEmpty() && operatorStack.peek() != '(') {
                    postfix.append(operatorStack.pop());
                }
                if (!operatorStack.isEmpty() && operatorStack.peek() == '(') {
                    operatorStack.pop(); // Discard '('
                }
            } else { // It's an operator
                while (!operatorStack.isEmpty() && operatorStack.peek() != '(' &&
                       (getPrecedence(operatorStack.peek()) > getPrecedence(currentChar) ||
                        (getPrecedence(operatorStack.peek()) == getPrecedence(currentChar) && isLeftAssociative(currentChar)))) {
                    postfix.append(operatorStack.pop());
                }
                operatorStack.push(currentChar);
            }
        }

        // Pop any remaining operators from the stack
        while (!operatorStack.isEmpty()) {
            postfix.append(operatorStack.pop());
        }

        return postfix.toString();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String infixExpr = scanner.next(); // Reads a single token (no spaces)
        scanner.close();
        
        String postfixExpr = infixToPostfix(infixExpr);
        System.out.println(postfixExpr);
    }
}","function isOperand(char) {
    return (char >= '0' && char <= '9') || (char >= 'A' && char <= 'Z') || (char >= 'a' && char <= 'z');
}

function getPrecedence(op) {
    switch (op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        case '^':
            return 3;
        default:
            return 0; // For '(' or other non-operators
    }
}

function isLeftAssociative(op) {
    return ['+', '-', '*', '/'].includes(op);
}

function infixToPostfix(infixExpr) {
    let postfixExpr = [];
    let operatorStack = [];

    for (let i = 0; i < infixExpr.length; i++) {
        let currentChar = infixExpr[i];

        if (isOperand(currentChar)) {
            postfixExpr.push(currentChar);
        } else if (currentChar === '(') {
            operatorStack.push(currentChar);
        } else if (currentChar === ')') {
            while (operatorStack.length > 0 && operatorStack[operatorStack.length - 1] !== '(') {
                postfixExpr.push(operatorStack.pop());
            }
            if (operatorStack.length > 0 && operatorStack[operatorStack.length - 1] === '(') {
                operatorStack.pop(); // Discard '('
            }
            // else: Mismatched parentheses error, assuming valid input
        } else { // It's an operator
            while (operatorStack.length > 0 && operatorStack[operatorStack.length - 1] !== '(' &&
                   (getPrecedence(operatorStack[operatorStack.length - 1]) > getPrecedence(currentChar) ||
                    (getPrecedence(operatorStack[operatorStack.length - 1]) === getPrecedence(currentChar) && isLeftAssociative(currentChar)))) {
                postfixExpr.push(operatorStack.pop());
            }
            operatorStack.push(currentChar);
        }
    }

    // Pop any remaining operators from the stack
    while (operatorStack.length > 0) {
        postfixExpr.push(operatorStack.pop());
    }

    return postfixExpr.join('');
}

// Node.js specific input/output handling
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

rl.on('line', (line) => {
  const infixExpr = line.trim();
  const postfixExpr = infixToPostfix(infixExpr);
  console.log(postfixExpr);
  rl.close();
});","#include <iostream>
#include <string>
#include <stack>
#include <cctype> // For isalnum

// Function to check if a character is an operand (letter or digit)
bool isOperand(char c) {
    return isalnum(c);
}

// Function to get the precedence of an operator
int getPrecedence(char op) {
    switch (op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        case '^':
            return 3;
        default:
            return 0; // For '(' or other non-operators/invalid chars
    }
}

// Function to check associativity of an operator
// Returns true for left-associative, false for right-associative
bool isLeftAssociative(char op) {
    return (op == '+' || op == '-' || op == '*' || op == '/');
}

// Main function to convert infix to postfix
std::string infixToPostfix(const std::string& infix) {
    std::string postfix = """";
    std::stack<char> operatorStack;

    for (char currentChar : infix) {
        if (isOperand(currentChar)) {
            postfix += currentChar;
        } else if (currentChar == '(') {
            operatorStack.push(currentChar);
        } else if (currentChar == ')') {
            while (!operatorStack.empty() && operatorStack.top() != '(') {
                postfix += operatorStack.top();
                operatorStack.pop();
            }
            if (!operatorStack.empty() && operatorStack.top() == '(') {
                operatorStack.pop(); // Discard '('
            }
            // For invalid input (mismatched parentheses), this might leave '(' on stack
            // or try to pop from empty stack. Assuming valid infix for this problem.
        } else { // It's an operator
            while (!operatorStack.empty() && operatorStack.top() != '(' &&
                   (getPrecedence(operatorStack.top()) > getPrecedence(currentChar) ||
                    (getPrecedence(operatorStack.top()) == getPrecedence(currentChar) && isLeftAssociative(currentChar)))) {
                postfix += operatorStack.top();
                operatorStack.pop();
            }
            operatorStack.push(currentChar);
        }
    }

    // Pop any remaining operators from the stack
    while (!operatorStack.empty()) {
        postfix += operatorStack.top();
        operatorStack.pop();
    }

    return postfix;
}

int main() {
    std::string infixExpr;
    std::cin >> infixExpr;
    
    std::string postfixExpr = infixToPostfix(infixExpr);
    std::cout << postfixExpr << std::endl;
    
    return 0;
}",4.3
Yellow-36,"Singly Linked List (creation, traversal, insertion, deletion)","- Singly Linked List Structure
- Linked List Traversal
- Node Deletion (handling head, middle, and tail scenarios)
- Pointer Manipulation","You are given the head of a singly linked list and an integer `val`. Your task is to delete all the nodes of the linked list that have `Node.val == val` and return the new head of the modified linked list.

This problem tests your understanding of linked list traversal, manipulation, and the crucial aspects of node deletion, including handling edge cases such as deleting the head, nodes in the middle, and the tail of the list, as well as an empty list.","- The number of nodes in the list is in the range `[0, 1000]`.
- Node values are integers in the range `[-1000, 1000]`.
- The target value `val` is an integer in the range `[-1000, 1000]`.","**

1 2 6 3 4 5 6
6

**","**

1 2 3 4 5


**","Input: 7 7 7 7
7
Output: 
Input: 1 2 3 4 5
6
Output: 1 2 3 4 5
Input: 8 1 8 2 8 3 8
8
Output: 1 2 3
Input: 
5
Output: 
Input: 42
100
Output: 42","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Definition for singly-linked list.
struct ListNode {
    int val;
    struct ListNode *next;
};

// Function to delete nodes with a specific value
struct ListNode* deleteNodesWithValue(struct ListNode* head, int val) {
    // Handle deletions at the head
    while (head != NULL && head->val == val) {
        struct ListNode* temp = head;
        head = head->next;
        free(temp); // Free memory
    }
    
    struct ListNode* current = head;
    struct ListNode* prev = NULL;

    while (current != NULL) {
        if (current->val == val) {
            // Bypass current node
            if (prev != NULL) {
                prev->next = current->next;
            }
            // Free memory for the deleted node
            struct ListNode* temp = current;
            current = current->next; // Move current before deleting temp
            free(temp);
        } else {
            prev = current;
            current = current->next;
        }
    }
    
    return head;
}

// Function to create a linked list from an array of integers
struct ListNode* createLinkedList(int* arr, int size) {
    if (size == 0) {
        return NULL;
    }
    struct ListNode* head = (struct ListNode*)malloc(sizeof(struct ListNode));
    head->val = arr[0];
    head->next = NULL;
    struct ListNode* current = head;
    for (int i = 1; i < size; ++i) {
        current->next = (struct ListNode*)malloc(sizeof(struct ListNode));
        current = current->next;
        current->val = arr[i];
        current->next = NULL;
    }
    return head;
}

// Function to print a linked list and free memory
void printAndFreeLinkedList(struct ListNode* head) {
    struct ListNode* current = head;
    while (current != NULL) {
        printf(""%d"", current->val);
        if (current->next != NULL) {
            printf("" "");
        }
        struct ListNode* temp = current;
        current = current->next;
        free(temp); // Free memory
    }
    printf(""\n"");
}

int main() {
    char line[4000]; // Assuming max chars for input line (e.g., 1000 nodes * 5 digits + spaces)
    if (fgets(line, sizeof(line), stdin) == NULL) {
        // Handle empty input or error
        printAndFreeLinkedList(NULL); 
        return 0;
    }

    int nodeValues[1000]; // Assuming max 1000 nodes
    int count = 0;
    
    // Remove trailing newline character if present
    line[strcspn(line, ""\n"")] = 0; 

    if (strlen(line) > 0) {
        char *token = strtok(line, "" "");
        while (token != NULL) {
            nodeValues[count++] = atoi(token);
            token = strtok(NULL, "" "");
        }
    }

    int targetVal;
    // Check if scanf reads an integer successfully
    if (scanf(""%d"", &targetVal) != 1) {
        // If target value is not provided (e.g. only empty list line), handle it.
        // For this problem, it's assumed targetVal will always be provided.
        printAndFreeLinkedList(NULL);
        return 0;
    }

    struct ListNode* head = createLinkedList(nodeValues, count);
    struct ListNode* resultHead = deleteNodesWithValue(head, targetVal);
    printAndFreeLinkedList(resultHead);

    return 0;
}","class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

def deleteNodesWithValue(head: ListNode, val: int) -> ListNode:
    # Handle deletions at the head
    while head and head.val == val:
        head = head.next
    
    current = head
    prev = None

    while current:
        if current.val == val:
            # Bypass current node
            if prev:
                prev.next = current.next
            # No else needed, if current is head and has target value, it's handled by first while loop.
        else:
            prev = current
        current = current.next
    
    return head

def create_linked_list(arr):
    if not arr:
        return None
    head = ListNode(arr[0])
    current = head
    for i in range(1, len(arr)):
        current.next = ListNode(arr[i])
        current = current.next
    return head

def print_linked_list(head):
    nodes = []
    current = head
    while current:
        nodes.append(str(current.val))
        current = current.next
    print("" "".join(nodes))

if __name__ == ""__main__"":
    try:
        input_line = input()
        if input_line.strip() == """":
            arr_str = []
        else:
            arr_str = input_line.split()
        
        node_values = [int(x) for x in arr_str]
        
        target_val = int(input())

        head = create_linked_list(node_values)
        result_head = deleteNodesWithValue(head, target_val)
        print_linked_list(result_head)
    except EOFError:
        # For empty list, input_line will be empty, correctly handled. 
        # If target_val input also missing due to specific test case setup, this catches it.
        # Generally, target_val is expected after list input.
        print_linked_list(None) # Print empty line for empty list (e.g. all nodes deleted)","import java.util.Scanner;
import java.util.ArrayList;
import java.util.List;

// Definition for singly-linked list.
class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

public class Solution {
    public ListNode deleteNodesWithValue(ListNode head, int val) {
        // Handle deletions at the head
        while (head != null && head.val == val) {
            head = head.next;
        }
        
        ListNode current = head;
        ListNode prev = null;

        while (current != null) {
            if (current.val == val) {
                // Bypass current node
                if (prev != null) {
                    prev.next = current.next;
                }
                // No else needed, if current is head and has target value, it's handled by first while loop.
            } else {
                prev = current;
            }
            current = current.next;
        }
        
        return head;
    }

    // Function to create a linked list from a list of integers
    public ListNode createLinkedList(List<Integer> arr) {
        if (arr == null || arr.isEmpty()) {
            return null;
        }
        ListNode head = new ListNode(arr.get(0));
        ListNode current = head;
        for (int i = 1; i < arr.size(); ++i) {
            current.next = new ListNode(arr.get(i));
            current = current.next;
        }
        return head;
    }

    // Function to print a linked list
    public void printLinkedList(ListNode head) {
        StringBuilder sb = new StringBuilder();
        ListNode current = head;
        while (current != null) {
            sb.append(current.val);
            if (current.next != null) {
                sb.append("" "");
            }
            current = current.next;
        }
        System.out.println(sb.toString());
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Solution sol = new Solution();

        String line = scanner.nextLine();
        List<Integer> nodeValues = new ArrayList<>();
        if (!line.trim().isEmpty()) {
            String[] arrStr = line.split("" "");
            for (String s : arrStr) {
                nodeValues.add(Integer.parseInt(s));
            }
        }
        
        int targetVal = scanner.nextInt();

        ListNode head = sol.createLinkedList(nodeValues);
        ListNode resultHead = sol.deleteNodesWithValue(head, targetVal);
        sol.printLinkedList(resultHead);

        scanner.close();
    }
}","// Definition for singly-linked list.
function ListNode(val, next) {
    this.val = (val===undefined ? 0 : val)
    this.next = (next===undefined ? null : next)
}

/**
 * @param {ListNode} head
 * @param {number} val
 * @return {ListNode}
 */
function deleteNodesWithValue(head, val) {
    // Handle deletions at the head
    while (head !== null && head.val === val) {
        head = head.next;
    }
    
    let current = head;
    let prev = null;

    while (current !== null) {
        if (current.val === val) {
            // Bypass current node
            if (prev !== null) {
                prev.next = current.next;
            }
            // No explicit memory management like C++/C in JS
        } else {
            prev = current;
        }
        current = current.next;
    }
    
    return head;
}

// Function to create a linked list from an array
function createLinkedList(arr) {
    if (!arr || arr.length === 0) {
        return null;
    }
    let head = new ListNode(arr[0]);
    let current = head;
    for (let i = 1; i < arr.length; ++i) {
        current.next = new ListNode(arr[i]);
        current = current.next;
    }
    return head;
}

// Function to print a linked list
function printLinkedList(head) {
    let nodes = [];
    let current = head;
    while (current !== null) {
        nodes.push(current.val);
        current = current.next;
    }
    console.log(nodes.join("" ""));
}

// Main execution for handling input/output
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let lines = [];
    rl.on('line', (line) => {
        lines.push(line);
    }).on('close', () => {
        let nodeValuesStr = lines[0].trim();
        let nodeValues = [];
        if (nodeValuesStr !== """") {
            nodeValues = nodeValuesStr.split(' ').map(Number);
        }
        
        let targetVal = parseInt(lines[1]);

        let head = createLinkedList(nodeValues);
        let resultHead = deleteNodesWithValue(head, targetVal);
        printLinkedList(resultHead);
    });
}

main();","#include <iostream>
#include <vector>
#include <string>
#include <sstream>

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* deleteNodesWithValue(ListNode* head, int val) {
    // Handle deletions at the head
    while (head != nullptr && head->val == val) {
        ListNode* temp = head;
        head = head->next;
        delete temp; // Free memory
    }
    
    ListNode* current = head;
    ListNode* prev = nullptr;

    while (current != nullptr) {
        if (current->val == val) {
            // Bypass current node
            if (prev != nullptr) {
                prev->next = current->next;
            }
            // Free memory for the deleted node
            ListNode* temp = current;
            current = current->next; // Move current before deleting temp
            delete temp;
        } else {
            prev = current;
            current = current->next;
        }
    }
    
    return head;
}

// Function to create a linked list from a vector
ListNode* createLinkedList(const std::vector<int>& arr) {
    if (arr.empty()) {
        return nullptr;
    }
    ListNode* head = new ListNode(arr[0]);
    ListNode* current = head;
    for (size_t i = 1; i < arr.size(); ++i) {
        current->next = new ListNode(arr[i]);
        current = current->next;
    }
    return head;
}

// Function to print a linked list and free memory
void printAndFreeLinkedList(ListNode* head) {
    ListNode* current = head;
    while (current != nullptr) {
        std::cout << current->val;
        if (current->next != nullptr) {
            std::cout << "" "";
        }
        ListNode* temp = current;
        current = current->next;
        delete temp; // Free memory
    }
    std::cout << std::endl;
}

int main() {
    std::string line;
    std::getline(std::cin, line);
    std::vector<int> nodeValues;
    if (!line.empty()) {
        std::stringstream ss(line);
        std::string segment;
        while (std::getline(ss, segment, ' ')) {
            nodeValues.push_back(std::stoi(segment));
        }
    }

    int targetVal;
    std::cin >> targetVal;

    ListNode* head = createLinkedList(nodeValues);
    ListNode* resultHead = deleteNodesWithValue(head, targetVal);
    printAndFreeLinkedList(resultHead);

    return 0;
}",4.4
Yellow-37,Recursive Fibonacci,"- Recursion
- Base Cases
- Recursive Step
- Function Call Stack","The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. The sequence begins: 0, 1, 1, 2, 3, 5, 8, 13, 21, and so on.

Your task is to write a recursive function that calculates the Nth Fibonacci number. Given a non-negative integer `n`, return the `n`-th Fibonacci number.

For example:
- `fib(0) = 0`
- `fib(1) = 1`
- `fib(2) = fib(1) + fib(0) = 1 + 0 = 1`
- `fib(3) = fib(2) + fib(1) = 1 + 1 = 2`",- `0 <= n <= 20` (The recursion depth and computation time grow very quickly for larger `n` with a naive recursive approach),"**
`n = 5`

**","**
`5`

**","Input: 0
Output: 0
Input: 1
Output: 1
Input: 2
Output: 1
Input: 7
Output: 13
Input: 15
Output: 610","#include <stdio.h>

// Function to calculate the Nth Fibonacci number recursively
int fibonacci(int n) {
    // Base cases
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    // Recursive step
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    int n;

    // Read input from stdin
    if (scanf(""%d"", &n) != 1) {
        // Handle error if input is not a valid integer
        return 1;
    }

    // Calculate and print the Nth Fibonacci number
    int result = fibonacci(n);
    printf(""%d\n"", result);

    return 0;
}","def fibonacci(n: int) -> int:
    """"""
    Calculates the Nth Fibonacci number recursively.
    """"""
    # Base cases
    if n == 0:
        return 0
    if n == 1:
        return 1
    # Recursive step
    return fibonacci(n - 1) + fibonacci(n - 2)

if __name__ == ""__main__"":
    # Read input from stdin
    n = int(input())
    
    # Calculate and print the Nth Fibonacci number
    result = fibonacci(n)
    print(result)","import java.util.Scanner;

public class Solution {

    // Function to calculate the Nth Fibonacci number recursively
    public int fibonacci(int n) {
        // Base cases
        if (n == 0) {
            return 0;
        }
        if (n == 1) {
            return 1;
        }
        // Recursive step
        return fibonacci(n - 1) + fibonacci(n - 2);
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        
        // Read input from stdin
        int n = scanner.nextInt();
        
        // Create an instance of the Solution class to call the non-static method
        Solution sol = new Solution();
        
        // Calculate and print the Nth Fibonacci number
        int result = sol.fibonacci(n);
        System.out.println(result);
        
        scanner.close();
    }
}","// Function to calculate the Nth Fibonacci number recursively
function fibonacci(n) {
    // Base cases
    if (n === 0) {
        return 0;
    }
    if (n === 1) {
        return 1;
    }
    // Recursive step
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// Read input from stdin and print output to stdout
// This setup is common for competitive programming environments in Node.js
process.stdin.resume();
process.stdin.setEncoding('utf8');

let inputString = '';
let currentLine = 0;

process.stdin.on('data', chunk => {
    inputString += chunk;
});

process.stdin.on('end', _ => {
    inputString = inputString.trim().split('\n').map(str => str.trim());
    main();
});

function readLine() {
    return inputString[currentLine++];
}

function main() {
    const n = parseInt(readLine(), 10);
    
    const result = fibonacci(n);
    console.log(result);
}","#include <iostream>

// Function to calculate the Nth Fibonacci number recursively
int fibonacci(int n) {
    // Base cases
    if (n == 0) {
        return 0;
    }
    if (n == 1) {
        return 1;
    }
    // Recursive step
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    int n;

    // Read input from stdin
    std::cin >> n;

    // Calculate and print the Nth Fibonacci number
    int result = fibonacci(n);
    std::cout << result << std::endl;

    return 0;
}",3.9
Orange-2,Hash Tables & Hash Maps,"*   Hash Tables / Hash Maps
*   String Iteration
*   Frequency Counting","You are given a string `s` consisting of lowercase English letters. Your task is to count the frequency of each character in the string and return them. The output should be a list of character-frequency pairs, sorted alphabetically by character.","*   1 <= `s.length` <= 1000
*   The string `s` consists only of lowercase English letters ('a'-'z').","""apple""","a:1, e:1, l:1, p:2","Input: hello
Output: e:1, h:1, l:2, o:1
Input: zzzzaac
Output: a:2, c:1, z:4
Input: codingchallenge
Output: c:3, d:1, e:2, g:1, h:1, i:1, l:2, n:1, o:1
Input: programming
Output: a:1, g:2, i:1, m:2, n:1, o:1, p:1, r:2","#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// Function to count character frequencies
void countCharacterFrequencies(const char* s) {
    int frequencies[26] = {0}; // Initialize all counts to 0
    int len = strlen(s);

    // Populate frequencies array
    for (int i = 0; i < len; i++) {
        // The constraint guarantees 'a'-'z', so this check is technically not strictly needed
        // but good for robustness.
        if (s[i] >= 'a' && s[i] <= 'z') {
            frequencies[s[i] - 'a']++;
        }
    }

    // Print frequencies in alphabetical order
    int first_printed = 0;
    for (int i = 0; i < 26; i++) {
        if (frequencies[i] > 0) {
            if (first_printed) {
                printf("", "");
            }
            printf(""%c:%d"", (char)('a' + i), frequencies[i]);
            first_printed = 1;
        }
    }
    printf(""\n"");
}

int main() {
    char s[1001]; // Max length 1000 + null terminator

    // Read input string
    if (fgets(s, sizeof(s), stdin) != NULL) {
        // Remove trailing newline character if present
        s[strcspn(s, ""\n"")] = 0;
        countCharacterFrequencies(s);
    }

    return 0;
}","import sys

def count_character_frequencies(s):
    frequencies = {} # Python dictionary acts as a hash map

    # Populate frequencies dictionary
    for char_code in s:
        # The constraint guarantees 'a'-'z', so this check is technically not strictly needed
        # but good for robustness.
        if 'a' <= char_code <= 'z':
            frequencies[char_code] = frequencies.get(char_code, 0) + 1

    # Sort keys and print frequencies
    sorted_chars = sorted(frequencies.keys())
    
    result_parts = []
    for char_code in sorted_chars:
        result_parts.append(f""{char_code}:{frequencies[char_code]}"")
    
    print("", "".join(result_parts))

if __name__ == ""__main__"":
    s = sys.stdin.readline().strip() # Read input string
    count_character_frequencies(s)","import java.util.Scanner;
import java.util.Map;
import java.util.TreeMap; // TreeMap keeps keys sorted automatically

public class Solution {

    // Function to count character frequencies
    public void countCharacterFrequencies(String s) {
        Map<Character, Integer> frequencies = new TreeMap<>(); // TreeMap automatically sorts by key

        // Populate frequencies map
        for (char c : s.toCharArray()) {
            // The constraint guarantees 'a'-'z', so this check is technically not strictly needed
            // but good for robustness.
            if (c >= 'a' && c <= 'z') {
                frequencies.put(c, frequencies.getOrDefault(c, 0) + 1);
            }
        }

        // Print frequencies in alphabetical order
        StringBuilder result = new StringBuilder();
        boolean firstPrinted = false;
        for (Map.Entry<Character, Integer> entry : frequencies.entrySet()) {
            if (firstPrinted) {
                result.append("", "");
            }
            result.append(entry.getKey()).append("":"").append(entry.getValue());
            firstPrinted = true;
        }
        System.out.println(result.toString());
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.nextLine(); // Read input string
        scanner.close();

        Solution sol = new Solution();
        sol.countCharacterFrequencies(s);
    }
}","function countCharacterFrequencies(s) {
    const frequencies = new Map(); // JavaScript Map acts as a hash map

    // Populate frequencies map
    for (const char of s) {
        // The constraint guarantees 'a'-'z', so this check is technically not strictly needed
        // but good for robustness.
        if (char >= 'a' && char <= 'z') {
            frequencies.set(char, (frequencies.get(char) || 0) + 1);
        }
    }

    // Sort keys and print frequencies
    const sortedChars = Array.from(frequencies.keys()).sort();
    
    const resultParts = [];
    for (const char of sortedChars) {
        resultParts.push(`${char}:${frequencies.get(char)}`);
    }
    
    console.log(resultParts.join("", ""));
}

// Read input from stdin
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.on('line', (line) => {
    countCharacterFrequencies(line);
    rl.close();
});","#include <iostream>
#include <string>
#include <map>

// Function to count character frequencies
void countCharacterFrequencies(const std::string& s) {
    std::map<char, int> frequencies; // std::map keeps keys sorted automatically

    // Populate frequencies map
    for (char c : s) {
        // The constraint guarantees 'a'-'z', so this check is technically not strictly needed
        // but good for robustness.
        if (c >= 'a' && c <= 'z') {
            frequencies[c]++;
        }
    }

    // Print frequencies in alphabetical order
    bool firstPrinted = false;
    for (const auto& pair : frequencies) {
        if (firstPrinted) {
            std::cout << "", "";
        }
        std::cout << pair.first << "":"" << pair.second;
        firstPrinted = true;
    }
    std::cout << std::endl;
}

int main() {
    std::string s;
    // Read input string
    std::getline(std::cin, s);

    countCharacterFrequencies(s);

    return 0;
}",4.0
Yellow-38,Circular Queue basics,"- Array/Vector Data Structure
- Queue Data Structure Principles (FIFO)
- Modulo Arithmetic
- Pointer Management (front, rear indices)
- Fixed-Size Buffer","A circular queue is a linear data structure that operates in a First-In, First-Out (FIFO) manner, similar to a regular queue. However, it handles the `rear` and `front` pointers in a way that allows it to reuse empty spaces from the front of the queue, effectively treating the buffer as a circle. This prevents wasted memory if elements are frequently enqueued and dequeued.

Your task is to implement the `MyCircularQueue` class, which supports the following operations:

- `MyCircularQueue(k)`: Initializes the object with the size of the queue to be `k`. All values will be in the range `[0, 1000]`.
- `enqueue(value)`: Inserts an element into the circular queue. Returns `true` if the operation is successful, `false` otherwise (if the queue is full).
- `dequeue()`: Deletes an element from the circular queue. Returns `true` if the operation is successful, `false` otherwise (if the queue is empty).
- `Front()`: Gets the front element from the queue. Returns the element value, or `-1` if the queue is empty.
- `Rear()`: Gets the last element from the queue. Returns the element value, or `-1` if the queue is empty.
- `isEmpty()`: Checks whether the circular queue is empty. Returns `true` if empty, `false` otherwise.
- `isFull()`: Checks whether the circular queue is full. Returns `true` if full, `false` otherwise.

You should implement your circular queue using an array (or equivalent data structure) and manage the `front` and `rear` pointers using modulo arithmetic.","- `1 <= k <= 1000` (Capacity of the queue)
- `0 <= value <= 1000` (Values to enqueue)
- At most `3000` calls will be made to `enqueue`, `dequeue`, `Front`, `Rear`, `isEmpty`, and `isFull`.
- All operations run in O(1) time.","3
10
enqueue 1
enqueue 2
enqueue 3
enqueue 4
Rear
isFull
dequeue
enqueue 4
Rear
Front","true
true
true
false
3
true
true
true
4
2","Input:
2
8
enqueue 1
enqueue 2
enqueue 3
Front
Rear
dequeue
enqueue 3
Front
Output:
true
true
false
1
2
true
true
2
Input:
5
12
enqueue 10
enqueue 20
enqueue 30
enqueue 40
Front
Rear
isEmpty
isFull
dequeue
dequeue
enqueue 50
Front
Output:
true
true
true
true
10
40
false
true
true
true
true
30
Input:
1
7
enqueue 5
isFull
Front
Rear
dequeue
isEmpty
dequeue
Output:
true
true
5
5
true
true
false","#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

typedef struct {
    int* data;
    int front;
    int rear;
    int size;
    int capacity;
} MyCircularQueue;

MyCircularQueue* myCircularQueueCreate(int k) {
    MyCircularQueue* obj = (MyCircularQueue*)malloc(sizeof(MyCircularQueue));
    obj->data = (int*)malloc(sizeof(int) * k);
    obj->front = -1;
    obj->rear = -1;
    obj->size = 0;
    obj->capacity = k;
    return obj;
}

bool myCircularQueueIsEmpty(MyCircularQueue* obj) {
    return obj->size == 0;
}

bool myCircularQueueIsFull(MyCircularQueue* obj) {
    return obj->size == obj->capacity;
}

bool myCircularQueueEnQueue(MyCircularQueue* obj, int value) {
    if (myCircularQueueIsFull(obj)) {
        return false;
    }
    obj->rear = (obj->rear + 1) % obj->capacity;
    obj->data[obj->rear] = value;
    if (obj->front == -1) { // First element being added
        obj->front = 0;
    }
    obj->size++;
    return true;
}

bool myCircularQueueDeQueue(MyCircularQueue* obj) {
    if (myCircularQueueIsEmpty(obj)) {
        return false;
    }
    obj->front = (obj->front + 1) % obj->capacity;
    obj->size--;
    if (obj->size == 0) { // Queue became empty, reset pointers
        obj->front = -1;
        obj->rear = -1;
    }
    return true;
}

int myCircularQueueFront(MyCircularQueue* obj) {
    if (myCircularQueueIsEmpty(obj)) {
        return -1;
    }
    return obj->data[obj->front];
}

int myCircularQueueRear(MyCircularQueue* obj) {
    if (myCircularQueueIsEmpty(obj)) {
        return -1;
    }
    return obj->data[obj->rear];
}

void myCircularQueueFree(MyCircularQueue* obj) {
    free(obj->data);
    free(obj);
}

int main() {
    int k, n;
    scanf(""%d"", &k);
    scanf(""%d"", &n);

    MyCircularQueue* obj = myCircularQueueCreate(k);
    char command[20];
    int value;

    for (int i = 0; i < n; i++) {
        scanf(""%s"", command);
        if (strcmp(command, ""enqueue"") == 0) {
            scanf(""%d"", &value);
            printf(""%s\n"", myCircularQueueEnQueue(obj, value) ? ""true"" : ""false"");
        } else if (strcmp(command, ""dequeue"") == 0) {
            printf(""%s\n"", myCircularQueueDeQueue(obj) ? ""true"" : ""false"");
        } else if (strcmp(command, ""Front"") == 0) {
            printf(""%d\n"", myCircularQueueFront(obj));
        } else if (strcmp(command, ""Rear"") == 0) {
            printf(""%d\n"", myCircularQueueRear(obj));
        } else if (strcmp(command, ""isEmpty"") == 0) {
            printf(""%s\n"", myCircularQueueIsEmpty(obj) ? ""true"" : ""false"");
        } else if (strcmp(command, ""isFull"") == 0) {
            printf(""%s\n"", myCircularQueueIsFull(obj) ? ""true"" : ""false"");
        }
    }

    myCircularQueueFree(obj);

    return 0;
}","class MyCircularQueue:

    def __init__(self, k: int):
        self.data = [0] * k
        self.front = -1
        self.rear = -1
        self.size = 0
        self.capacity = k

    def enQueue(self, value: int) -> bool:
        if self.isFull():
            return False
        self.rear = (self.rear + 1) % self.capacity
        self.data[self.rear] = value
        if self.front == -1: # First element being added
            self.front = 0
        self.size += 1
        return True

    def deQueue(self) -> bool:
        if self.isEmpty():
            return False
        self.front = (self.front + 1) % self.capacity
        self.size -= 1
        if self.size == 0: # Queue became empty, reset pointers
            self.front = -1
            self.rear = -1
        return True

    def Front(self) -> int:
        if self.isEmpty():
            return -1
        return self.data[self.front]

    def Rear(self) -> int:
        if self.isEmpty():
            return -1
        return self.data[self.rear]

    def isEmpty(self) -> bool:
        return self.size == 0

    def isFull(self) -> bool:
        return self.size == self.capacity

if __name__ == ""__main__"":
    k = int(input())
    n = int(input())

    obj = MyCircularQueue(k)

    for _ in range(n):
        command_line = input().split()
        command = command_line[0]
        
        if command == ""enqueue"":
            value = int(command_line[1])
            print(obj.enQueue(value))
        elif command == ""dequeue"":
            print(obj.deQueue())
        elif command == ""Front"":
            print(obj.Front())
        elif command == ""Rear"":
            print(obj.Rear())
        elif command == ""isEmpty"":
            print(obj.isEmpty())
        elif command == ""isFull"":
            print(obj.isFull())","import java.util.Scanner;

class MyCircularQueue {
    private int[] data;
    private int front;
    private int rear;
    private int size;
    private int capacity;

    public MyCircularQueue(int k) {
        capacity = k;
        data = new int[k];
        front = -1;
        rear = -1;
        size = 0;
    }

    public boolean enQueue(int value) {
        if (isFull()) {
            return false;
        }
        rear = (rear + 1) % capacity;
        data[rear] = value;
        if (front == -1) { // First element being added
            front = 0;
        }
        size++;
        return true;
    }

    public boolean deQueue() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        size--;
        if (size == 0) { // Queue became empty, reset pointers
            front = -1;
            rear = -1;
        }
        return true;
    }

    public int Front() {
        if (isEmpty()) {
            return -1;
        }
        return data[front];
    }

    public int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return data[rear];
    }

    public boolean isEmpty() {
        return size == 0;
    }

    public boolean isFull() {
        return size == capacity;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int k = scanner.nextInt();
        int n = scanner.nextInt();

        MyCircularQueue obj = new MyCircularQueue(k);
        
        for (int i = 0; i < n; i++) {
            String command = scanner.next();
            if (command.equals(""enqueue"")) {
                int value = scanner.nextInt();
                System.out.println(obj.enQueue(value));
            } else if (command.equals(""dequeue"")) {
                System.out.println(obj.deQueue());
            } else if (command.equals(""Front"")) {
                System.out.println(obj.Front());
            } else if (command.equals(""Rear"")) {
                System.out.println(obj.Rear());
            } else if (command.equals(""isEmpty"")) {
                System.out.println(obj.isEmpty());
            } else if (command.equals(""isFull"")) {
                System.out.println(obj.isFull());
            }
        }

        scanner.close();
    }
}","const readline = require('readline');

class MyCircularQueue {
    constructor(k) {
        this.data = new Array(k);
        this.front = -1;
        this.rear = -1;
        this.size = 0;
        this.capacity = k;
    }

    enQueue(value) {
        if (this.isFull()) {
            return false;
        }
        this.rear = (this.rear + 1) % this.capacity;
        this.data[this.rear] = value;
        if (this.front === -1) { // First element being added
            this.front = 0;
        }
        this.size++;
        return true;
    }

    deQueue() {
        if (this.isEmpty()) {
            return false;
        }
        this.front = (this.front + 1) % this.capacity;
        this.size--;
        if (this.size === 0) { // Queue became empty, reset pointers
            this.front = -1;
            this.rear = -1;
        }
        return true;
    }

    Front() {
        if (this.isEmpty()) {
            return -1;
        }
        return this.data[this.front];
    }

    Rear() {
        if (this.isEmpty()) {
            return -1;
        }
        return this.data[this.rear];
    }

    isEmpty() {
        return this.size === 0;
    }

    isFull() {
        return this.size === this.capacity;
    }
}

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let lines = [];
rl.on('line', (line) => {
    lines.push(line);
});

rl.on('close', () => {
    const k = parseInt(lines[0]);
    const n = parseInt(lines[1]);
    let lineIndex = 2;

    const obj = new MyCircularQueue(k);

    for (let i = 0; i < n; i++) {
        const commandLine = lines[lineIndex++].split(' ');
        const command = commandLine[0];
        
        if (command === ""enqueue"") {
            const value = parseInt(commandLine[1]);
            console.log(obj.enQueue(value));
        } else if (command === ""dequeue"") {
            console.log(obj.deQueue());
        } else if (command === ""Front"") {
            console.log(obj.Front());
        } else if (command === ""Rear"") {
            console.log(obj.Rear());
        } else if (command === ""isEmpty"") {
            console.log(obj.isEmpty());
        } else if (command === ""isFull"") {
            console.log(obj.isFull());
        }
    }
});","#include <iostream>
#include <vector>
#include <string>

class MyCircularQueue {
private:
    std::vector<int> data;
    int front;
    int rear;
    int size;
    int capacity;

public:
    MyCircularQueue(int k) {
        capacity = k;
        data.resize(k);
        front = -1;
        rear = -1;
        size = 0;
    }

    bool enQueue(int value) {
        if (isFull()) {
            return false;
        }
        rear = (rear + 1) % capacity;
        data[rear] = value;
        if (front == -1) { // First element being added
            front = 0;
        }
        size++;
        return true;
    }

    bool deQueue() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        size--;
        if (size == 0) { // Queue became empty, reset pointers
            front = -1;
            rear = -1;
        }
        return true;
    }

    int Front() {
        if (isEmpty()) {
            return -1;
        }
        return data[front];
    }

    int Rear() {
        if (isEmpty()) {
            return -1;
        }
        return data[rear];
    }

    bool isEmpty() {
        return size == 0;
    }

    bool isFull() {
        return size == capacity;
    }
};

int main() {
    int k, n;
    std::cin >> k;
    std::cin >> n;

    MyCircularQueue* obj = new MyCircularQueue(k);
    std::string command;
    int value;

    for (int i = 0; i < n; ++i) {
        std::cin >> command;
        if (command == ""enqueue"") {
            std::cin >> value;
            std::cout << (obj->enQueue(value) ? ""true"" : ""false"") << std::endl;
        } else if (command == ""dequeue"") {
            std::cout << (obj->deQueue() ? ""true"" : ""false"") << std::endl;
        } else if (command == ""Front"") {
            std::cout << obj->Front() << std::endl;
        } else if (command == ""Rear"") {
            std::cout << obj->Rear() << std::endl;
        } else if (command == ""isEmpty"") {
            std::cout << (obj->isEmpty() ? ""true"" : ""false"") << std::endl;
        } else if (command == ""isFull"") {
            std::cout << (obj->isFull() ? ""true"" : ""false"") << std::endl;
        }
    }

    delete obj;
    return 0;
}",4.1
Yellow-39,Intro to Backtracking,"*   Backtracking
*   Recursion
*   Depth-First Search (implicitly)
*   State Management",You are given an array `nums` of distinct integers. Your task is to return all possible permutations of the numbers in `nums`. A permutation is an arrangement of all elements in a specific order. You can return the answer in any order.,"* `1 <= nums.length <= 6`
* `-10 <= nums[i] <= 10`
* All the integers in `nums` are unique.","**

3
1 2 3


**","**

[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

*(The order of permutations in the output list may vary, but all must be present.)*","Input: 2
0 1
Output: [[0,1],[1,0]]
Input: 1
5
Output: [[5]]
Input: 4
1 2 3 4
Output: [[1,2,3,4],[1,2,4,3],[1,3,2,4],[1,3,4,2],[1,4,2,3],[1,4,3,2],[2,1,3,4],[2,1,4,3],[2,3,1,4],[2,3,4,1],[2,4,1,3],[2,4,3,1],[3,1,2,4],[3,1,4,2],[3,2,1,4],[3,2,4,1],[3,4,1,2],[3,4,2,1],[4,1,2,3],[4,1,3,2],[4,2,1,3],[4,2,3,1],[4,3,1,2],[4,3,2,1]]
Input: 3
-1 0 1
Output: [[-1,0,1],[-1,1,0],[0,-1,1],[0,1,-1],[1,-1,0],[1,0,-1]]","#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

// Helper function to print a single permutation in the format [x,y,z]
void printPermutation(int* arr, int size) {
    printf(""["");
    for (int i = 0; i < size; i++) {
        printf(""%d"", arr[i]);
        if (i < size - 1) {
            printf("","");
        }
    }
    printf(""]"");
}

// Recursive backtracking function
// count_ptr is used to correctly format the output with commas between permutations
void backtrack(int* nums, int numsSize, int* currentPermutation, bool* visited, int k, int* count_ptr) {
    // Base case: if k equals numsSize, a complete permutation is formed
    if (k == numsSize) {
        if (*count_ptr > 0) {
            printf("","");
        }
        printPermutation(currentPermutation, numsSize);
        (*count_ptr)++;
        return;
    }

    // Recursive step: iterate through nums
    for (int i = 0; i < numsSize; i++) {
        if (!visited[i]) {
            // Choose: add nums[i] to currentPermutation
            currentPermutation[k] = nums[i];
            visited[i] = true;

            // Explore: recursively call for next element
            backtrack(nums, numsSize, currentPermutation, visited, k + 1, count_ptr);

            // Unchoose (Backtrack): remove nums[i] from currentPermutation and mark as unvisited
            visited[i] = false;
        }
    }
}

// Main logic function to initiate finding permutations
void solvePermutations(int* nums, int numsSize) {
    if (numsSize == 0) {
        printf(""[]\n"");
        return;
    }

    int* currentPermutation = (int*)malloc(sizeof(int) * numsSize);
    bool* visited = (bool*)calloc(numsSize, sizeof(bool)); // calloc initializes to false
    int permutationCount = 0; // Counter for correct comma separation

    printf(""[""); // Start outer list
    backtrack(nums, numsSize, currentPermutation, visited, 0, &permutationCount);
    printf(""]\n""); // End outer list

    free(currentPermutation);
    free(visited);
}

int main() {
    int n;
    scanf(""%d"", &n);

    int* nums = NULL;
    if (n > 0) {
        nums = (int*)malloc(sizeof(int) * n);
        for (int i = 0; i < n; i++) {
            scanf(""%d"", &nums[i]);
        }
    }
    
    solvePermutations(nums, n); // Call the main logic function

    if (nums != NULL) {
        free(nums);
    }

    return 0;
}","import json

class Solution:
    def _backtrack(self, nums, current_permutation, visited, results):
        # Base case: if current_permutation is complete
        if len(current_permutation) == len(nums):
            results.append(list(current_permutation)) # Add a copy
            return

        # Recursive step: iterate through nums
        for i in range(len(nums)):
            if not visited[i]:
                # Choose
                current_permutation.append(nums[i])
                visited[i] = True

                # Explore
                self._backtrack(nums, current_permutation, visited, results)

                # Unchoose (Backtrack)
                visited[i] = False
                current_permutation.pop()

    def permute(self, nums):
        results = []
        if not nums:
            return results

        current_permutation = []
        visited = [False] * len(nums) # Initialize all to False

        self._backtrack(nums, current_permutation, visited, results)
        return results

def main():
    n = int(input())
    # Read space-separated integers
    nums = list(map(int, input().split()))

    sol = Solution()
    all_permutations = sol.permute(nums)

    # Print the results in the required JSON-like format, no spaces.
    print(json.dumps(all_permutations).replace("" "", """"))

if __name__ == ""__main__"":
    main()","import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Solution {

    // Helper function for backtracking
    private void backtrack(int[] nums, List<Integer> currentPermutation, 
                           boolean[] visited, List<List<Integer>> results) {
        // Base case: if currentPermutation is complete
        if (currentPermutation.size() == nums.length) {
            results.add(new ArrayList<>(currentPermutation)); // Add a copy
            return;
        }

        // Recursive step: iterate through nums
        for (int i = 0; i < nums.length; i++) {
            if (!visited[i]) {
                // Choose
                currentPermutation.add(nums[i]);
                visited[i] = true;

                // Explore
                backtrack(nums, currentPermutation, visited, results);

                // Unchoose (Backtrack)
                visited[i] = false;
                currentPermutation.remove(currentPermutation.size() - 1);
            }
        }
    }

    // Main logic function
    public List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> results = new ArrayList<>();
        if (nums == null || nums.length == 0) {
            return results;
        }

        List<Integer> currentPermutation = new ArrayList<>();
        boolean[] visited = new boolean[nums.length]; // All initialized to false

        backtrack(nums, currentPermutation, visited, results);
        return results;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }
        scanner.close();

        Solution sol = new Solution();
        List<List<Integer>> allPermutations = sol.permute(nums);

        // Print the results in the required format
        System.out.print(""["");
        for (int i = 0; i < allPermutations.size(); i++) {
            List<Integer> perm = allPermutations.get(i);
            System.out.print(""["");
            for (int j = 0; j < perm.size(); j++) {
                System.out.print(perm.get(j));
                if (j < perm.size() - 1) {
                    System.out.print("","");
                }
            }
            System.out.print(""]"");
            if (i < allPermutations.size() - 1) {
                System.out.print("","");
            }
        }
        System.out.println(""]"");
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

class Solution {
    _backtrack(nums, currentPermutation, visited, results) {
        // Base case: if currentPermutation is complete
        if (currentPermutation.length === nums.length) {
            results.push([...currentPermutation]); // Add a copy
            return;
        }

        // Recursive step: iterate through nums
        for (let i = 0; i < nums.length; i++) {
            if (!visited[i]) {
                // Choose
                currentPermutation.push(nums[i]);
                visited[i] = true;

                // Explore
                this._backtrack(nums, currentPermutation, visited, results);

                // Unchoose (Backtrack)
                visited[i] = false;
                currentPermutation.pop();
            }
        }
    }

    permute(nums) {
        const results = [];
        if (!nums || nums.length === 0) {
            return results;
        }

        const currentPermutation = [];
        const visited = new Array(nums.length).fill(false); // Initialize all to false

        this._backtrack(nums, currentPermutation, visited, results);
        return results;
    }
}

let inputLines = [];
rl.on('line', (line) => {
    inputLines.push(line);
}).on('close', () => {
    const n = parseInt(inputLines[0]);
    const nums = inputLines[1].split(' ').map(Number);

    const sol = new Solution();
    const allPermutations = sol.permute(nums);

    // Print the results in the required JSON-like format, no spaces.
    console.log(JSON.stringify(allPermutations).replace(/\s/g, ''));
});","#include <iostream>
#include <vector>
#include <algorithm> 

// Helper function for backtracking
void backtrack(std::vector<int>& nums, std::vector<int>& currentPermutation, 
               std::vector<bool>& visited, std::vector<std::vector<int>>& results) {
    // Base case: if currentPermutation is complete
    if (currentPermutation.size() == nums.size()) {
        results.push_back(currentPermutation); // Add a copy
        return;
    }

    // Recursive step: iterate through nums
    for (int i = 0; i < nums.size(); ++i) {
        if (!visited[i]) {
            // Choose
            currentPermutation.push_back(nums[i]);
            visited[i] = true;

            // Explore
            backtrack(nums, currentPermutation, visited, results);

            // Unchoose (Backtrack)
            visited[i] = false;
            currentPermutation.pop_back();
        }
    }
}

// Main logic function
std::vector<std::vector<int>> permute(std::vector<int>& nums) {
    std::vector<std::vector<int>> results;
    if (nums.empty()) {
        return results;
    }

    std::vector<int> currentPermutation;
    std::vector<bool> visited(nums.size(), false); // Initialize all to false

    backtrack(nums, currentPermutation, visited, results);
    return results;
}

// Helper function to print the vector of vectors in the required format
void printResults(const std::vector<std::vector<int>>& results) {
    std::cout << ""["";
    for (size_t i = 0; i < results.size(); ++i) {
        std::cout << ""["";
        for (size_t j = 0; j < results[i].size(); ++j) {
            std::cout << results[i][j];
            if (j < results[i].size() - 1) {
                std::cout << "","";
            }
        }
        std::cout << ""]"";
        if (i < results.size() - 1) {
            std::cout << "","";
        }
    }
    std::cout << ""]"" << std::endl;
}

int main() {
    int n;
    std::cin >> n;

    std::vector<int> nums(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> nums[i];
    }

    // Call the main logic function
    std::vector<std::vector<int>> allPermutations = permute(nums);

    // Print the results
    printResults(allPermutations);

    return 0;
}",4.4
Yellow-40,LeetCode,"- **Linked Lists:** Understanding what a node is, how pointers/references connect nodes, and the concept of a `head` and `NULL`/`None` (end of list).
- **Iteration/Traversal:** Moving through a linked list, node by node, using a loop.
- **Pointer Manipulation:** The core of this problem involves carefully changing which node each `next` pointer refers to, effectively 'flipping' the direction of the links.
- **Edge Cases:** Handling special scenarios like an empty list (no nodes) or a list with only one node.","Given the `head` of a singly linked list, reverse the list, and return the reversed list.

A singly linked list is a linear data structure where each element (called a node) points to the next element in the sequence. Reversing it means that the last node becomes the first, the second-to-last becomes the second, and so on, with all the pointers flipped to point in the opposite direction.

For example, if your list is `1 -> 2 -> 3 -> NULL`, after reversing, it should become `3 -> 2 -> 1 -> NULL`.","- The number of nodes in the list is in the range `[0, 5000]`.
- `-5000 <= Node.val <= 5000`.",1 2 3 4 5,"5 4 3 2 1

(","Input: 1 2 3 4 5
Output: 5 4 3 2 1,Input:
Output:,Input: 7
Output: 7,Input: 10 20
Output: 20 10,Input: 1 2 2 1
Output: 1 2 2 1","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Definition for singly-linked list.
struct ListNode {
    int val;
    struct ListNode *next;
};

struct ListNode* reverseList(struct ListNode* head) {
    struct ListNode* prev = NULL;
    struct ListNode* curr = head;
    struct ListNode* next_node = NULL;

    while (curr != NULL) {
        next_node = curr->next; // Store next node
        curr->next = prev;      // Reverse current node's pointer
        prev = curr;            // Move prev one step forward
        curr = next_node;       // Move curr one step forward
    }
    return prev; // prev will be the new head
}

// Helper function to create a new node
struct ListNode* createNode(int val) {
    struct ListNode* newNode = (struct ListNode*)malloc(sizeof(struct ListNode));
    if (newNode == NULL) {
        perror(""Failed to allocate memory for ListNode"");
        exit(EXIT_FAILURE);
    }
    newNode->val = val;
    newNode->next = NULL;
    return newNode;
}

// Helper function to print the list
void printList(struct ListNode* head) {
    struct ListNode* current = head;
    if (current == NULL) {
        printf(""\n"");
        return;
    }
    while (current != NULL) {
        printf(""%d"", current->val);
        if (current->next != NULL) {
            printf("" "");
        }
        current = current->next;
    }
    printf(""\n"");
}

// Helper function to free the list memory
void freeList(struct ListNode* head) {
    struct ListNode* current = head;
    while (current != NULL) {
        struct ListNode* temp = current;
        current = current->next;
        free(temp);
    }
}

int main() {
    struct ListNode* head = NULL;
    struct ListNode* tail = NULL;
    int val;

    char line[1000];
    if (fgets(line, sizeof(line), stdin) == NULL) {
        // Error reading or EOF immediately, treat as empty list
        printList(reverseList(head));
        return 0;
    }

    // Remove trailing newline character if present
    line[strcspn(line, ""\n"")] = 0;

    // If line is empty after stripping newline, it's an empty list
    if (strlen(line) == 0) {
        printList(reverseList(head));
        return 0;
    }

    char *token = strtok(line, "" "");
    while (token != NULL) {
        val = atoi(token);
        struct ListNode* newNode = createNode(val);
        if (head == NULL) {
            head = newNode;
            tail = newNode;
        } else {
            tail->next = newNode;
            tail = newNode;
        }
        token = strtok(NULL, "" "");
    }

    struct ListNode* reversedHead = reverseList(head);
    printList(reversedHead);

    freeList(reversedHead); // Free memory of the reversed list

    return 0;
}","# Definition for singly-linked list.
class ListNode:
    def __init__(self, val=0, next=None):
        self.val = val
        self.next = next

class Solution:
    def reverseList(self, head: ListNode) -> ListNode:
        prev = None
        curr = head

        while curr:
            next_node = curr.next  # Store next node
            curr.next = prev       # Reverse current node's pointer
            prev = curr            # Move prev one step forward
            curr = next_node       # Move curr one step forward
        return prev # prev will be the new head

# Helper function to print the list
def print_list(head: ListNode):
    current = head
    values = []
    while current:
        values.append(str(current.val))
        current = current.next
    print("" "".join(values))

# Main function for I/O
if __name__ == ""__main__"":
    line = input().strip()

    head = None
    tail = None

    if line:
        values = list(map(int, line.split()))
        for val in values:
            new_node = ListNode(val)
            if head is None:
                head = new_node
                tail = new_node
            else:
                tail.next = new_node
                tail = new_node

    sol = Solution()
    reversed_head = sol.reverseList(head)
    print_list(reversed_head)","import java.util.Scanner;

// Definition for singly-linked list.
class ListNode {
    int val;
    ListNode next;
    ListNode() {}
    ListNode(int val) { this.val = val; }
    ListNode(int val, ListNode next) { this.val = val; this.next = next; }
}

class Solution {
    public ListNode reverseList(ListNode head) {
        ListNode prev = null;
        ListNode curr = head;
        ListNode nextNode = null;

        while (curr != null) {
            nextNode = curr.next; // Store next node
            curr.next = prev;     // Reverse current node's pointer
            prev = curr;          // Move prev one step forward
            curr = nextNode;      // Move curr one step forward
        }
        return prev; // prev will be the new head
    }
}

public class Main {
    // Helper function to print the list
    public static void printList(ListNode head) {
        ListNode current = head;
        if (current == null) {
            System.out.println();
            return;
        }
        while (current != null) {
            System.out.print(current.val);
            if (current.next != null) {
                System.out.print("" "");
            }
            current = current.next;
        }
        System.out.println();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String line = scanner.nextLine();
        scanner.close();

        ListNode head = null;
        ListNode tail = null;

        if (!line.trim().isEmpty()) {
            String[] parts = line.trim().split("" "");
            for (String part : parts) {
                int val = Integer.parseInt(part);
                ListNode newNode = new ListNode(val);
                if (head == null) {
                    head = newNode;
                    tail = newNode;
                } else {
                    tail.next = newNode;
                    tail = newNode;
                }
            }
        }

        Solution sol = new Solution();
        ListNode reversedHead = sol.reverseList(head);
        printList(reversedHead);
    }
}","// Definition for singly-linked list.
function ListNode(val, next) {
    this.val = (val===undefined ? 0 : val)
    this.next = (next===undefined ? null : next)
}

/**
 * @param {ListNode} head
 * @return {ListNode}
 */
var reverseList = function(head) {
    let prev = null;
    let curr = head;
    let nextNode = null;

    while (curr !== null) {
        nextNode = curr.next; // Store next node
        curr.next = prev;     // Reverse current node's pointer
        prev = curr;          // Move prev one step forward
        curr = nextNode;      // Move curr one step forward
    }
    return prev; // prev will be the new head
};

// Helper function to print the list
function printList(head) {
    let current = head;
    const values = [];
    while (current !== null) {
        values.push(current.val);
        current = current.next;
    }
    console.log(values.join(' '));
}

// Main function for I/O
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.on('line', (line) => {
    let head = null;
    let tail = null;

    if (line.trim() !== '') {
        const values = line.split(' ').map(Number);
        for (const val of values) {
            const newNode = new ListNode(val);
            if (head === null) {
                head = newNode;
                tail = newNode;
            } else {
                tail.next = newNode;
                tail = newNode;
            }
        }
    }

    const reversedHead = reverseList(head);
    printList(reversedHead);
    rl.close();
});","#include <iostream>
#include <vector>
#include <string>
#include <sstream>

// Definition for singly-linked list.
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

class Solution {
public:
    ListNode* reverseList(ListNode* head) {
        ListNode* prev = nullptr;
        ListNode* curr = head;
        ListNode* next_node = nullptr;

        while (curr != nullptr) {
            next_node = curr->next; // Store next node
            curr->next = prev;      // Reverse current node's pointer
            prev = curr;            // Move prev one step forward
            curr = next_node;       // Move curr one step forward
        }
        return prev; // prev will be the new head
    }
};

// Helper function to print the list
void printList(ListNode* head) {
    ListNode* current = head;
    if (current == nullptr) {
        std::cout << std::endl;
        return;
    }
    while (current != nullptr) {
        std::cout << current->val;
        if (current->next != nullptr) {
            std::cout << "" "";
        }
        current = current->next;
    }
    std::cout << std::endl;
}

// Helper function to free the list memory
void freeList(ListNode* head) {
    ListNode* current = head;
    while (current != nullptr) {
        ListNode* temp = current;
        current = current->next;
        delete temp;
    }
}

int main() {
    std::string line;
    std::getline(std::cin, line);

    ListNode* head = nullptr;
    ListNode* tail = nullptr;

    if (!line.empty()) {
        std::stringstream ss(line);
        int val;
        while (ss >> val) {
            ListNode* newNode = new ListNode(val);
            if (head == nullptr) {
                head = newNode;
                tail = newNode;
            } else {
                tail->next = newNode;
                tail = newNode;
            }
        }
    }

    Solution sol;
    ListNode* reversedHead = sol.reverseList(head);
    printList(reversedHead);

    freeList(reversedHead); // Free memory of the reversed list

    return 0;
}",3.7
Yellow-41,Recursive Fibonacci,"*   **Recursion**: A function calling itself to solve smaller subproblems.
*   **Base Cases**: Conditions that stop the recursion and provide a direct result.
*   **Recursive Step**: The part of the function that breaks down the problem and calls itself with modified arguments.","Welcome, aspiring coder! In this problem, you'll explore the classic Fibonacci sequence using the power of recursion. The Fibonacci sequence is a series of numbers where each number is the sum of the two preceding ones, usually starting with 0 and 1. 

Your task is to write a function that calculates the `n`-th Fibonacci number. The sequence typically starts as: 0, 1, 1, 2, 3, 5, 8, 13, ...

For example:
- `fib(0)` should return 0
- `fib(1)` should return 1
- `fib(2)` should return `fib(1) + fib(0) = 1 + 0 = 1`
- `fib(3)` should return `fib(2) + fib(1) = 1 + 1 = 2`

You must implement this using a recursive approach.","*   `n` is a non-negative integer.
*   `0 <= n <= 20` (The value of `n` is kept small to allow for the direct recursive solution without performance issues for a Yellow Belt level.)","**

5


**","**

5


**","Input: 0
Output: 0
Input: 1
Output: 1
Input: 2
Output: 1
Input: 10
Output: 55
Input: 15
Output: 610","#include <stdio.h>

// Function to calculate the nth Fibonacci number recursively
int fibonacci(int n) {
    // Base cases
    if (n <= 1) {
        return n;
    }
    // Recursive step
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    int n;
    // Read input from stdin
    scanf(""%d"", &n);
    
    // Call the fibonacci function and print the result
    printf(""%d\n"", fibonacci(n));
    
    return 0;
}","def fibonacci(n: int) -> int:
    """"""
    Calculates the nth Fibonacci number recursively.
    """"""
    # Base cases
    if n <= 1:
        return n
    # Recursive step
    return fibonacci(n - 1) + fibonacci(n - 2)

if __name__ == ""__main__"":
    # Read input from stdin
    n = int(input())
    
    # Call the fibonacci function and print the result
    print(fibonacci(n))","import java.util.Scanner;

public class Main {

    // Function to calculate the nth Fibonacci number recursively
    public int fibonacci(int n) {
        // Base cases
        if (n <= 1) {
            return n;
        }
        // Recursive step
        return fibonacci(n - 1) + fibonacci(n - 2);
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // Read input from stdin
        int n = scanner.nextInt();
        
        Main sol = new Main();
        // Call the fibonacci function and print the result
        System.out.println(sol.fibonacci(n));
        
        scanner.close();
    }
}","function fibonacci(n) {
    // Base cases
    if (n <= 1) {
        return n;
    }
    // Recursive step
    return fibonacci(n - 1) + fibonacci(n - 2);
}

// Read input from stdin using readline module
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.on('line', (line) => {
    const n = parseInt(line.trim(), 10);
    // Call the fibonacci function and print the result
    console.log(fibonacci(n));
    rl.close(); // Close the interface after processing the line
});","#include <iostream>

// Function to calculate the nth Fibonacci number recursively
int fibonacci(int n) {
    // Base cases
    if (n <= 1) {
        return n;
    }
    // Recursive step
    return fibonacci(n - 1) + fibonacci(n - 2);
}

int main() {
    int n;
    // Read input from stdin
    std::cin >> n;
    
    // Call the fibonacci function and print the result
    std::cout << fibonacci(n) << std::endl;
    
    return 0;
}",4.4
Yellow-42,Frequency Count / Anagrams,"*   Frequency Counting
*   Character Arrays / Hash Maps
*   String Manipulation","You are given two strings, `s` and `t`. Your task is to determine if `t` is an anagram of `s`. An anagram is formed by rearranging the letters of another word or phrase, using all the original letters exactly once. For this problem, assume the strings contain only lowercase English letters.","*   `1 <= s.length, t.length <= 5 * 10^4`
*   `s` and `t` consist of lowercase English letters.","s = ""anagram"", t = ""nagaram""",true,"Input: s = ""listen"", t = ""silent""
Output: true
Input: s = ""abc"", t = ""bca""
Output: true
Input: s = ""hello"", t = ""holle""
Output: true
Input: s = ""apple"", t = ""aple""
Output: false
Input: s = ""zzzaac"", t = ""aazzcz""
Output: true","#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_STR_LEN 50000

bool isAnagram(char *s, char *t) {
    int len_s = strlen(s);
    int len_t = strlen(t);

    if (len_s != len_t) {
        return false;
    }

    int freq[26];
    memset(freq, 0, sizeof(freq));

    for (int i = 0; i < len_s; i++) {
        freq[s[i] - 'a']++;
    }

    for (int i = 0; i < len_t; i++) {
        freq[t[i] - 'a']--;
        if (freq[t[i] - 'a'] < 0) {
            return false;
        }
    }

    return true;
}

int main() {
    char *s = (char *)malloc(sizeof(char) * (MAX_STR_LEN + 1));
    char *t = (char *)malloc(sizeof(char) * (MAX_STR_LEN + 1));

    if (s == NULL || t == NULL) {
        fprintf(stderr, ""Memory allocation failed.\n"");
        return 1;
    }

    // Read input strings, limit characters to prevent buffer overflow
    if (scanf(""%50000s"", s) != 1) {
        fprintf(stderr, ""Error reading string s.\n"");
        free(s);
        free(t);
        return 1;
    }
    if (scanf(""%50000s"", t) != 1) {
        fprintf(stderr, ""Error reading string t.\n"");
        free(s);
        free(t);
        return 1;
    }

    if (isAnagram(s, t)) {
        printf(""true\n"");
    } else {
        printf(""false\n"");
    }

    free(s);
    free(t);

    return 0;
}","import sys

class Solution:
    def isAnagram(self, s: str, t: str) -> bool:
        if len(s) != len(t):
            return False

        freq = [0] * 26

        for char_s in s:
            freq[ord(char_s) - ord('a')] += 1

        for char_t in t:
            freq[ord(char_t) - ord('a')] -= 1
            if freq[ord(char_t) - ord('a')] < 0:
                return False
        
        return True

if __name__ == '__main__':
    input_lines = sys.stdin.readlines()
    s = input_lines[0].strip()
    t = input_lines[1].strip()

    sol = Solution()
    if sol.isAnagram(s, t):
        print(""true"")
    else:
        print(""false"")","import java.util.Scanner;

class Solution {
    public boolean isAnagram(String s, String t) {
        if (s.length() != t.length()) {
            return false;
        }

        int[] freq = new int[26];

        for (char c : s.toCharArray()) {
            freq[c - 'a']++;
        }

        for (char c : t.toCharArray()) {
            freq[c - 'a']--;
            if (freq[c - 'a'] < 0) {
                return false;
            }
        }

        return true;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.next();
        String t = scanner.next();
        scanner.close();

        Solution sol = new Solution();
        if (sol.isAnagram(s, t)) {
            System.out.println(""true"");
        } else {
            System.out.println(""false"");
        }
    }
}","/**
 * @param {string} s
 * @param {string} t
 * @return {boolean}
 */
var isAnagram = function(s, t) {
    if (s.length !== t.length) {
        return false;
    }

    let freq = new Array(26).fill(0);

    for (let i = 0; i < s.length; i++) {
        freq[s.charCodeAt(i) - 'a'.charCodeAt(0)]++;
    }

    for (let i = 0; i < t.length; i++) {
        freq[t.charCodeAt(i) - 'a'.charCodeAt(0)]--;
        if (freq[t.charCodeAt(i) - 'a'.charCodeAt(0)] < 0) {
            return false;
        }
    }

    return true;
};

// Main function for handling input/output in a Node.js-like environment
const readline = require('readline');

const rl = readline.createInterface({
  input: process.stdin,
  output: process.stdout
});

let lines = [];
rl.on('line', (line) => {
  lines.push(line);
});

rl.on('close', () => {
  const s = lines[0];
  const t = lines[1];

  if (isAnagram(s, t)) {
    console.log(""true"");
  } else {
    console.log(""false"");
  }
});","#include <iostream>
#include <string>
#include <vector>
#include <numeric>

class Solution {
public:
    bool isAnagram(std::string s, std::string t) {
        if (s.length() != t.length()) {
            return false;
        }

        std::vector<int> freq(26, 0);

        for (char c : s) {
            freq[c - 'a']++;
        }

        for (char c : t) {
            freq[c - 'a']--;
            if (freq[c - 'a'] < 0) {
                return false;
            }
        }

        return true;
    }
};

int main() {
    std::string s, t;
    std::cin >> s >> t;

    Solution sol;
    if (sol.isAnagram(s, t)) {
        std::cout << ""true"" << std::endl;
    } else {
        std::cout << ""false"" << std::endl;
    }

    return 0;
}",4.0
Yellow-43,Linear Search,"*   Arrays
*   Iteration (Loops)
*   Conditional Statements
*   Return Values
*   Linear Search","You are given an array of integers `arr` and a target integer `target`. Your task is to implement a linear search algorithm to find the first index of the `target` in the `arr`. If the `target` is not found in the array, you should return `-1`.","*   `1 <= arr.length <= 1000`
*   `-1000 <= arr[i] <= 1000`
*   `-1000 <= target <= 1000`","arr = [4, 2, 7, 1, 9]
target = 7",2,"Input: 5
1 2 3 4 5
3
Output: 2
Input: 1
99
99
Output: 0
Input: 7
10 20 30 40 50 60 70
70
Output: 6
Input: 5
-5 -2 0 2 5
-1
Output: -1
Input: 6
1 5 3 5 8 9
5
Output: 1","#include <stdio.h>

// Function to perform linear search
int linearSearch(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}

int main() {
    int n;
    // Read the size of the array
    scanf(""%d"", &n);

    int arr[n]; // Declare array of size n (VLA - C99 feature)
    // Read array elements
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]);
    }

    int target;
    // Read the target element
    scanf(""%d"", &target);

    // Call the linear search function
    int result = linearSearch(arr, n, target);

    // Print the result
    printf(""%d\n"", result);

    return 0;
}","def linear_search(arr, target):
    """"""
    Function to perform linear search.
    :param arr: List of integers to search within.
    :param target: The integer to search for.
    :return: The index of the first occurrence of the target, or -1 if not found.
    """"""
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # Target found, return its index
    return -1  # Target not found

if __name__ == ""__main__"":
    # Read the size of the array
    n = int(input())

    # Read array elements
    arr = list(map(int, input().split()))

    # Read the target element
    target = int(input())

    # Call the linear search function
    result = linear_search(arr, target)

    # Print the result
    print(result)","import java.util.Scanner;

public class Solution {

    // Function to perform linear search
    public static int linearSearch(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i; // Target found, return its index
            }
        }
        return -1; // Target not found
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the size of the array
        int n = scanner.nextInt();

        int[] arr = new int[n];
        // Read array elements
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        // Read the target element
        int target = scanner.nextInt();

        // Call the linear search function
        int result = linearSearch(arr, target);

        // Print the result
        System.out.println(result);

        scanner.close();
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let inputLines = [];

rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    // Function to perform linear search
    function linearSearch(arr, target) {
        for (let i = 0; i < arr.length; i++) {
            if (arr[i] === target) {
                return i; // Target found, return its index
            }
        }
        return -1; // Target not found
    }

    // Parse input
    const n = parseInt(inputLines[0]);
    const arr = inputLines[1].split(' ').map(Number);
    const target = parseInt(inputLines[2]);

    // Call the linear search function
    const result = linearSearch(arr, target);

    // Print the result
    console.log(result);
});","#include <iostream>
#include <vector>

// Function to perform linear search
int linearSearch(const std::vector<int>& arr, int target) {
    for (int i = 0; i < arr.size(); ++i) {
        if (arr[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found
}

int main() {
    int n;
    // Read the size of the array
    std::cin >> n;

    std::vector<int> arr(n);
    // Read array elements
    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i];
    }

    int target;
    // Read the target element
    std::cin >> target;

    // Call the linear search function
    int result = linearSearch(arr, target);

    // Print the result
    std::cout << result << std::endl;

    return 0;
}",4.2
Yellow-44,Circular Queue basics,"*   Array-based queue implementation
*   Circular array concept using the modulo operator (`%`)
*   Managing `front` and `rear` pointers (or indices)
*   Handling queue empty and full conditions
*   First-In, First-Out (FIFO) principle","A circular queue is a linear data structure that operates in a First-In, First-Out (FIFO) manner, similar to a regular queue. The key difference is that the last position is connected back to the first position, forming a circle. This allows for efficient reuse of array space once elements are dequeued from the front.

Your task is to implement a `CircularQueue` class (or equivalent structure) that supports the following operations:

*   `CircularQueue(k)`: Initializes the queue with a maximum capacity of `k` elements.
*   `enqueue(value)`: Adds an element `value` to the rear of the queue. Returns `true` if the operation was successful, `false` otherwise (if the queue is full).
*   `dequeue()`: Removes an element from the front of the queue. Returns `true` if the operation was successful, `false` otherwise (if the queue is empty).
*   `front()`: Gets the front element of the queue. Returns the element if the queue is not empty, ` -1` otherwise.
*   `rear()`: Gets the last element of the queue. Returns the element if the queue is not empty, `-1` otherwise.
*   `isEmpty()`: Checks whether the circular queue is empty. Returns `true` if empty, `false` otherwise.
*   `isFull()`: Checks whether the circular queue is full. Returns `true` if full, `false` otherwise.

All values will be integers.","*   `1 <= k <= 1000` (capacity)
*   `0 <= value <= 1000` (values to enqueue)
*   At most `1000` calls will be made to `enqueue`, `dequeue`, `front`, `rear`, `isEmpty`, and `isFull`.","**

init 3
enqueue 1
enqueue 2
enqueue 3
enqueue 4
rear
isFull
dequeue
enqueue 4
front


**","**

true
true
true
false
3
true
true
4


**","Input:
init 2
isEmpty
enqueue 10
enqueue 20
isFull
enqueue 30
front
rear
dequeue
dequeue
isEmpty
dequeue
Output:
true
true
true
false
10
20
true
true
true
false
Input:
init 1
enqueue 5
front
rear
enqueue 6
dequeue
front
isEmpty
enqueue 7
isFull
Output:
true
5
5
false
true
-1
true
true
true
Input:
init 1
enqueue 100
front
rear
dequeue
front
isEmpty
enqueue 200
rear
dequeue
isEmpty
Output:
true
100
100
true
-1
true
true
200
true
true","#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>
#include <string.h>

typedef struct {
    int* queue_arr;
    int front;
    int rear; // points to the next available slot
    int count;
    int capacity;
} CircularQueue;

CircularQueue* circularQueueCreate(int k) {
    CircularQueue* obj = (CircularQueue*)malloc(sizeof(CircularQueue));
    if (obj == NULL) return NULL; // Handle allocation failure
    obj->queue_arr = (int*)malloc(sizeof(int) * k);
    if (obj->queue_arr == NULL) { // Handle allocation failure
        free(obj);
        return NULL;
    }
    obj->front = 0;
    obj->rear = 0;
    obj->count = 0;
    obj->capacity = k;
    return obj;
}

bool circularQueueIsEmpty(CircularQueue* obj) {
    return obj->count == 0;
}

bool circularQueueIsFull(CircularQueue* obj) {
    return obj->count == obj->capacity;
}

bool circularQueueEnqueue(CircularQueue* obj, int value) {
    if (circularQueueIsFull(obj)) {
        return false;
    }
    obj->queue_arr[obj->rear] = value;
    obj->rear = (obj->rear + 1) % obj->capacity;
    obj->count++;
    return true;
}

bool circularQueueDequeue(CircularQueue* obj) {
    if (circularQueueIsEmpty(obj)) {
        return false;
    }
    obj->front = (obj->front + 1) % obj->capacity;
    obj->count--;
    return true;
}

int circularQueueFront(CircularQueue* obj) {
    if (circularQueueIsEmpty(obj)) {
        return -1;
    }
    return obj->queue_arr[obj->front];
}

int circularQueueRear(CircularQueue* obj) {
    if (circularQueueIsEmpty(obj)) {
        return -1;
    }
    // The actual rear element is at (rear - 1 + capacity) % capacity
    // Adding capacity before modulo handles cases where (rear - 1) might be negative (e.g., rear=0)
    return obj->queue_arr[(obj->rear - 1 + obj->capacity) % obj->capacity];
}

void circularQueueFree(CircularQueue* obj) {
    if (obj == NULL) return;
    free(obj->queue_arr);
    free(obj);
}

int main() {
    CircularQueue* cq = NULL;
    char command[20];
    int k_val, value_val;

    while (scanf(""%s"", command) != EOF) {
        if (strcmp(command, ""init"") == 0) {
            scanf(""%d"", &k_val);
            if (cq != NULL) {
                circularQueueFree(cq); // Free previous queue if exists
            }
            cq = circularQueueCreate(k_val);
        } else if (strcmp(command, ""enqueue"") == 0) {
            scanf(""%d"", &value_val);
            printf(""%s\n"", circularQueueEnqueue(cq, value_val) ? ""true"" : ""false"");
        } else if (strcmp(command, ""dequeue"") == 0) {
            printf(""%s\n"", circularQueueDequeue(cq) ? ""true"" : ""false"");
        } else if (strcmp(command, ""front"") == 0) {
            printf(""%d\n"", circularQueueFront(cq));
        } else if (strcmp(command, ""rear"") == 0) {
            printf(""%d\n"", circularQueueRear(cq));
        } else if (strcmp(command, ""isEmpty"") == 0) {
            printf(""%s\n"", circularQueueIsEmpty(cq) ? ""true"" : ""false"");
        } else if (strcmp(command, ""isFull"") == 0) {
            printf(""%s\n"", circularQueueIsFull(cq) ? ""true"" : ""false"");
        }
    }
    circularQueueFree(cq); // Free final queue

    return 0;
}","import sys

class CircularQueue:
    def __init__(self, k: int):
        self.queue = [0] * k
        self.front = 0
        self.rear = 0 # points to the next available slot
        self.count = 0
        self.capacity = k

    def enqueue(self, value: int) -> bool:
        if self.isFull():
            return False
        self.queue[self.rear] = value
        self.rear = (self.rear + 1) % self.capacity
        self.count += 1
        return True

    def dequeue(self) -> bool:
        if self.isEmpty():
            return False
        self.front = (self.front + 1) % self.capacity
        self.count -= 1
        return True

    def front(self) -> int:
        if self.isEmpty():
            return -1
        return self.queue[self.front]

    def rear(self) -> int:
        if self.isEmpty():
            return -1
        # The actual rear element is at (rear - 1 + capacity) % capacity
        # Adding capacity before modulo handles cases where (rear - 1) might be negative (e.g., rear=0)
        return self.queue[(self.rear - 1 + self.capacity) % self.capacity]

    def isEmpty(self) -> bool:
        return self.count == 0

    def isFull(self) -> bool:
        return self.count == self.capacity

# Main function to handle I/O
def solve():
    circular_queue = None
    results = []

    for line in sys.stdin:
        parts = line.strip().split()
        command = parts[0]

        if command == ""init"":
            k = int(parts[1])
            circular_queue = CircularQueue(k)
        elif command == ""enqueue"":
            value = int(parts[1])
            results.append(str(circular_queue.enqueue(value)).lower())
        elif command == ""dequeue"":
            results.append(str(circular_queue.dequeue()).lower())
        elif command == ""front"":
            results.append(str(circular_queue.front()))
        elif command == ""rear"":
            results.append(str(circular_queue.rear()))
        elif command == ""isEmpty"":
            results.append(str(circular_queue.isEmpty()).lower())
        elif command == ""isFull"":
            results.append(str(circular_queue.isFull()).lower())
    
    for res in results:
        print(res)

solve()","import java.util.Scanner;

class CircularQueue {
    private int[] queue;
    private int front;
    private int rear; // points to the next available slot
    private int count;
    private int capacity;

    public CircularQueue(int k) {
        queue = new int[k];
        front = 0;
        rear = 0;
        count = 0;
        capacity = k;
    }

    public boolean enqueue(int value) {
        if (isFull()) {
            return false;
        }
        queue[rear] = value;
        rear = (rear + 1) % capacity;
        count++;
        return true;
    }

    public boolean dequeue() {
        if (isEmpty()) {
            return false;
        }
        front = (front + 1) % capacity;
        count--;
        return true;
    }

    public int front() {
        if (isEmpty()) {
            return -1;
        }
        return queue[front];
    }

    public int rear() {
        if (isEmpty()) {
            return -1;
        }
        // The actual rear element is at (rear - 1 + capacity) % capacity
        // Adding capacity before modulo handles cases where (rear - 1) might be negative (e.g., rear=0)
        return queue[(rear - 1 + capacity) % capacity];
    }

    public boolean isEmpty() {
        return count == 0;
    }

    public boolean isFull() {
        return count == capacity;
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        CircularQueue circularQueue = null;

        while (scanner.hasNextLine()) {
            String line = scanner.nextLine();
            String[] parts = line.trim().split("" "");
            String command = parts[0];

            switch (command) {
                case ""init"":
                    int k = Integer.parseInt(parts[1]);
                    circularQueue = new CircularQueue(k);
                    break;
                case ""enqueue"":
                    int value = Integer.parseInt(parts[1]);
                    System.out.println(circularQueue.enqueue(value));
                    break;
                case ""dequeue"":
                    System.out.println(circularQueue.dequeue());
                    break;
                case ""front"":
                    System.out.println(circularQueue.front());
                    break;
                case ""rear"":
                    System.out.println(circularQueue.rear());
                    break;
                case ""isEmpty"":
                    System.out.println(circularQueue.isEmpty());
                    break;
                case ""isFull"":
                    System.out.println(circularQueue.isFull());
                    break;
            }
        }
        scanner.close();
    }
}","class CircularQueue {
    constructor(k) {
        this.queue = new Array(k);
        this.front = 0;
        this.rear = 0; // points to the next available slot
        this.count = 0;
        this.capacity = k;
    }

    enqueue(value) {
        if (this.isFull()) {
            return false;
        }
        this.queue[this.rear] = value;
        this.rear = (this.rear + 1) % this.capacity;
        this.count++;
        return true;
    }

    dequeue() {
        if (this.isEmpty()) {
            return false;
        }
        this.front = (this.front + 1) % this.capacity;
        this.count--;
        return true;
    }

    front() {
        if (this.isEmpty()) {
            return -1;
        }
        return this.queue[this.front];
    }

    rear() {
        if (this.isEmpty()) {
            return -1;
        }
        // The actual rear element is at (rear - 1 + capacity) % capacity
        // Adding capacity before modulo handles cases where (rear - 1) might be negative (e.g., rear=0)
        return this.queue[(this.rear - 1 + this.capacity) % this.capacity];
    }

    isEmpty() {
        return this.count === 0;
    }

    isFull() {
        return this.count === this.capacity;
    }
}

// Main function to handle I/O
function solve() {
    let circularQueue = null;
    const results = [];
    // Read input from stdin for Node.js environment
    // In a browser environment, this part would be different (e.g., prompt, event listeners)
    const inputLines = require('fs').readFileSync(0, 'utf-8').trim().split('\n');
    
    for (const line of inputLines) {
        const parts = line.trim().split(' ');
        const command = parts[0];

        switch (command) {
            case ""init"":
                const k = parseInt(parts[1]);
                circularQueue = new CircularQueue(k);
                break;
            case ""enqueue"":
                const value = parseInt(parts[1]);
                results.push(circularQueue.enqueue(value).toString());
                break;
            case ""dequeue"":
                results.push(circularQueue.dequeue().toString());
                break;
            case ""front"":
                results.push(circularQueue.front().toString());
                break;
            case ""rear"":
                results.push(circularQueue.rear().toString());
                break;
            case ""isEmpty"":
                results.push(circularQueue.isEmpty().toString());
                break;
            case ""isFull"":
                results.push(circularQueue.isFull().toString());
                break;
        }
    }
    
    console.log(results.join('\n'));
}

solve();","#include <iostream>
#include <vector>
#include <string>
#include <sstream>

class CircularQueue {
private:
    std::vector<int> queue;
    int front_ptr;
    int rear_ptr; // points to the next available slot
    int current_count;
    int capacity;

public:
    CircularQueue(int k) {
        queue.resize(k);
        front_ptr = 0;
        rear_ptr = 0;
        current_count = 0;
        capacity = k;
    }

    bool enqueue(int value) {
        if (isFull()) {
            return false;
        }
        queue[rear_ptr] = value;
        rear_ptr = (rear_ptr + 1) % capacity;
        current_count++;
        return true;
    }

    bool dequeue() {
        if (isEmpty()) {
            return false;
        }
        front_ptr = (front_ptr + 1) % capacity;
        current_count--;
        return true;
    }

    int front() {
        if (isEmpty()) {
            return -1;
        }
        return queue[front_ptr];
    }

    int rear() {
        if (isEmpty()) {
            return -1;
        }
        // The actual rear element is at (rear_ptr - 1 + capacity) % capacity
        // Adding capacity before modulo handles cases where (rear_ptr - 1) might be negative (e.g., rear_ptr=0)
        return queue[(rear_ptr - 1 + capacity) % capacity];
    }

    bool isEmpty() {
        return current_count == 0;
    }

    bool isFull() {
        return current_count == capacity;
    }
};

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    CircularQueue* circularQueue = nullptr;
    std::string line;

    while (std::getline(std::cin, line)) {
        std::stringstream ss(line);
        std::string command;
        ss >> command;

        if (command == ""init"") {
            int k;
            ss >> k;
            if (circularQueue != nullptr) {
                delete circularQueue; // Clean up previous queue if any
            }
            circularQueue = new CircularQueue(k);
        } else if (command == ""enqueue"") {
            int value;
            ss >> value;
            std::cout << (circularQueue->enqueue(value) ? ""true"" : ""false"") << std::endl;
        } else if (command == ""dequeue"") {
            std::cout << (circularQueue->dequeue() ? ""true"" : ""false"") << std::endl;
        } else if (command == ""front"") {
            std::cout << circularQueue->front() << std::endl;
        } else if (command == ""rear"") {
            std::cout << circularQueue->rear() << std::endl;
        } else if (command == ""isEmpty"") {
            std::cout << (circularQueue->isEmpty() ? ""true"" : ""false"") << std::endl;
        } else if (command == ""isFull"") {
            std::cout << (circularQueue->isFull() ? ""true"" : ""false"") << std::endl;
        }
    }

    if (circularQueue != nullptr) {
        delete circularQueue; // Clean up allocated memory
    }

    return 0;
}",4.4
Yellow-45,Prefix & Suffix Sums,"*   Prefix Sums (also known as Cumulative Sums)
*   Array Manipulation
*   Range Queries
*   Time and Space Complexity Analysis","YouYou are given an array of integers and a list of queries. Each query consists of two indices, `L` and `R`, representing a range `[L, R]` (inclusive) within the array. Your task is to find the sum of all elements in the array for each given range query.

This problem tests your ability to efficiently process multiple range sum queries on a static array. A naive approach of summing elements for each query would be too slow for large inputs.","*   `1 <= N <= 10^5` (where `N` is the number of elements in the array)
*   `-1000 <= arr[i] <= 1000` (value of each element in the array)
*   `1 <= Q <= 10^5` (where `Q` is the number of queries)
*   `0 <= L <= R < N` (indices for each query)","**

5
1 2 3 4 5
3
0 2
1 3
2 4


**","**

6
9
12


**","Input:
4
-1 2 -3 4
3
0 0
1 2
0 3
Output:
-1
-1
2
Input:
1
100
1
0 0
Output:
100
Input:
5
10 20 30 40 50
3
0 0
2 2
0 4
Output:
10
30
150
Input:
4
0 0 0 0
2
0 1
2 3
Output:
0
0","#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int left;
    int right;
} Query;

// Function to solve the range sum queries using prefix sums
// Note: For very large sums, prefixSum should be long long. Given constraints, int is acceptable.
int* solve(int* arr, int n, Query* queries, int numQueries) {
    int* prefixSum = (int*) malloc(sizeof(int) * (n + 1));
    if (prefixSum == NULL) {
        return NULL; // Handle allocation failure
    }
    prefixSum[0] = 0;
    for (int i = 0; i < n; i++) {
        prefixSum[i + 1] = prefixSum[i] + arr[i];
    }

    int* results = (int*) malloc(sizeof(int) * numQueries);
    if (results == NULL) {
        free(prefixSum);
        return NULL; // Handle allocation failure
    }

    for (int i = 0; i < numQueries; i++) {
        int L = queries[i].left;
        int R = queries[i].right;
        // Sum from index L to R (inclusive) is prefixSum[R+1] - prefixSum[L]
        results[i] = prefixSum[R + 1] - prefixSum[L];
    }

    free(prefixSum); // Free allocated prefixSum array
    return results;
}

int main() {
    int n;
    scanf(""%d"", &n);

    int* arr = (int*) malloc(sizeof(int) * n);
    if (arr == NULL) {
        return 1; // Indicate error
    }
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]);
    }

    int numQueries;
    scanf(""%d"", &numQueries);

    Query* queries = (Query*) malloc(sizeof(Query) * numQueries);
    if (queries == NULL) {
        free(arr);
        return 1; // Indicate error
    }
    for (int i = 0; i < numQueries; i++) {
        scanf(""%d %d"", &queries[i].left, &queries[i].right);
    }

    int* results = solve(arr, n, queries, numQueries);

    if (results == NULL) {
        free(arr);
        free(queries);
        return 1;
    }

    for (int i = 0; i < numQueries; i++) {
        printf(""%d\n"", results[i]);
    }

    free(arr);
    free(queries);
    free(results);
    return 0;
}","import sys

# Function to solve the range sum queries using prefix sums
def solve(arr, queries):
    n = len(arr)
    prefix_sum = [0] * (n + 1)
    for i in range(n):
        prefix_sum[i + 1] = prefix_sum[i] + arr[i]

    results = []
    for L, R in queries:
        # Sum from index L to R (inclusive) is prefix_sum[R+1] - prefix_sum[L]
        results.append(prefix_sum[R + 1] - prefix_sum[L])
    return results

def main():
    # Read N
    n = int(sys.stdin.readline())

    # Read array elements
    arr = list(map(int, sys.stdin.readline().split()))

    # Read number of queries
    num_queries = int(sys.stdin.readline())

    # Read queries (L, R tuples)
    queries = []
    for _ in range(num_queries):
        L, R = map(int, sys.stdin.readline().split())
        queries.append((L, R)) 

    # Solve and print results
    results = solve(arr, queries)
    for result in results:
        sys.stdout.write(str(result) + ""\n"")

if __name__ == ""__main__"":
    main()","import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

class Query {
    int left;
    int right;

    public Query(int left, int right) {
        this.left = left;
        this.right = right;
    }
}

public class Solution {

    // Function to solve the range sum queries using prefix sums
    public static List<Integer> solve(int[] arr, List<Query> queries) {
        int n = arr.length;
        // Use long for prefixSum to prevent potential overflow, especially if constraints were larger.
        // For current constraints (N=10^5, val=1000), int (max 2*10^9) would technically suffice (max sum 10^8).
        long[] prefixSum = new long[n + 1];
        prefixSum[0] = 0;
        for (int i = 0; i < n; i++) {
            prefixSum[i + 1] = prefixSum[i] + arr[i];
        }

        List<Integer> results = new ArrayList<>();
        for (Query q : queries) {
            int L = q.left;
            int R = q.right;
            // Sum from index L to R (inclusive) is prefixSum[R+1] - prefixSum[L]
            results.add((int)(prefixSum[R + 1] - prefixSum[L]));
        }
        return results;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        int numQueries = scanner.nextInt();
        List<Query> queries = new ArrayList<>();
        for (int i = 0; i < numQueries; i++) {
            int L = scanner.nextInt();
            int R = scanner.nextInt();
            queries.add(new Query(L, R));
        }

        List<Integer> results = solve(arr, queries);

        for (int result : results) {
            System.out.println(result);
        }

        scanner.close();
    }
}","// Function to solve the range sum queries using prefix sums
function solve(arr, queries) {
    const n = arr.length;
    const prefixSum = new Array(n + 1).fill(0);
    for (let i = 0; i < n; i++) {
        prefixSum[i + 1] = prefixSum[i] + arr[i];
    }

    const results = [];
    for (const query of queries) {
        const L = query[0]; // Assuming query is [L, R]
        const R = query[1];
        // Sum from index L to R (inclusive) is prefixSum[R+1] - prefixSum[L]
        results.push(prefixSum[R + 1] - prefixSum[L]);
    }
    return results;
}

function main() {
    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\n');
    let lineIndex = 0;

    const n = parseInt(input[lineIndex++]);
    const arr = input[lineIndex++].split(' ').map(Number);

    const numQueries = parseInt(input[lineIndex++]);
    const queries = [];
    for (let i = 0; i < numQueries; i++) {
        queries.push(input[lineIndex++].split(' ').map(Number));
    }

    const results = solve(arr, queries);

    for (const result of results) {
        console.log(result);
    }
}

main();","#include <iostream>
#include <vector>
#include <numeric>

struct Query {
    int left;
    int right;
};

// Function to solve the range sum queries using prefix sums
std::vector<int> solve(const std::vector<int>& arr, const std::vector<Query>& queries) {
    int n = arr.size();
    // Use long long for prefixSum to prevent potential overflow, especially if constraints were larger.
    // For current constraints (N=10^5, val=1000), int (max 2*10^9) would technically suffice (max sum 10^8).
    std::vector<long long> prefixSum(n + 1, 0);
    for (int i = 0; i < n; ++i) {
        prefixSum[i + 1] = prefixSum[i] + arr[i];
    }

    std::vector<int> results;
    results.reserve(queries.size()); // Pre-allocate memory for efficiency

    for (const auto& q : queries) {
        int L = q.left;
        int R = q.right;
        // Sum from index L to R (inclusive) is prefixSum[R+1] - prefixSum[L]
        results.push_back(static_cast<int>(prefixSum[R + 1] - prefixSum[L]));
    }
    return results;
}

int main() {
    // Optimize C++ standard streams for competitive programming
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    std::vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i];
    }

    int numQueries;
    std::cin >> numQueries;

    std::vector<Query> queries(numQueries);
    for (int i = 0; i < numQueries; ++i) {
        std::cin >> queries[i].left >> queries[i].right;
    }

    std::vector<int> results = solve(arr, queries);

    for (int result : results) {
        std::cout << result << ""\n"";
    }

    return 0;
}",4.2
Yellow-46,Intro to Backtracking,"*   Backtracking
*   Recursion
*   Decision Tree
*   Time and Space Complexity Analysis",You are given an array of unique integers `nums`. Your task is to return all possible subsets (the power set) of this array. The order of the subsets and the order of elements within each subset do not matter. Duplicate subsets should not be included.,"*   `1 <= nums.length <= 10`
*   `0 <= nums[i] <= 100`
*   All the integers in `nums` are unique.","`[1, 2, 3]`","`[[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]`","Input: 5
Output: []
[5]
Input: 10 20
Output: []
[10]
[20]
[10 20]
Input: 4 5 6 7
Output: []
[4]
[5]
[6]
[7]
[4 5]
[4 6]
[4 7]
[5 6]
[5 7]
[6 7]
[4 5 6]
[4 5 7]
[4 6 7]
[5 6 7]
[4 5 6 7]
Input: 0 1
Output: []
[0]
[1]
[0 1]
Input: 80 90 100
Output: []
[80]
[90]
[100]
[80 90]
[80 100]
[90 100]
[80 90 100]","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// A helper function to print an integer array (subset)
void printSubset(int* subset, int size) {
    printf(""["");
    for (int i = 0; i < size; i++) {
        printf(""%d"", subset[i]);
        if (i < size - 1) {
            printf("" "");
        }
    }
    printf(""]\n"");
}

// Backtracking helper function to generate subsets
// For C, we'll print subsets directly to avoid complex memory management for a list of lists,
// as is common in competitive programming when the goal is to find and print all solutions.
void backtrack(int* nums, int numsSize, int* currentSubset, int currentSubsetSize, int startIdx) {
    // Base case: currentSubset is a valid subset, print it.
    printSubset(currentSubset, currentSubsetSize);

    // Recursive step: Explore choices
    for (int i = startIdx; i < numsSize; i++) {
        // Choose: Add nums[i] to currentSubset
        currentSubset[currentSubsetSize] = nums[i];

        // Explore: Recurse with the next element
        backtrack(nums, numsSize, currentSubset, currentSubsetSize + 1, i + 1);

        // Unchoose (Backtrack): Conceptually remove the last element.
        // In C with a fixed-size `currentSubset` passed by value or managing size, 
        // simply returning from the function means `currentSubsetSize` will revert for the caller.
        // No explicit `pop_back` is needed on the array itself, as we pass `currentSubsetSize + 1` 
        // to the next call, and currentSubsetSize will implicitly be its old value for the next iteration.
    }
}

// Main function to find all subsets
void findSubsets(int* nums, int numsSize) {
    // currentSubset will hold the elements for the current subset being built.
    // Max size of currentSubset is numsSize (when all elements are included).
    int* currentSubset = (int*)malloc(numsSize * sizeof(int));
    if (currentSubset == NULL) {
        fprintf(stderr, ""Memory allocation failed\n"");
        return;
    }

    // Start the backtracking process
    backtrack(nums, numsSize, currentSubset, 0, 0);

    free(currentSubset);
}

int main() {
    int nums[10]; // Max constraint 10 elements
    int numsSize = 0;
    int num;

    // Read input from stdin: space-separated integers on a single line
    char buffer[100]; // Buffer to read the line
    if (fgets(buffer, sizeof(buffer), stdin) == NULL) {
        // Handle error or empty input
        return 1;
    }

    char* token = strtok(buffer, "" \n"");
    while (token != NULL && numsSize < 10) {
        nums[numsSize++] = atoi(token);
        token = strtok(NULL, "" \n"");
    }
    
    // As per constraints, nums.length >= 1, so no empty array input for main logic
    // If it were allowed and empty, just [] would be the output.

    findSubsets(nums, numsSize);

    return 0;
}","import sys

class Solution:
    def _backtrack(self, nums, start_idx, current_subset, result):
        # Add the current subset to the result list
        result.append(list(current_subset)) # Append a copy to prevent modification issues

        # Explore choices
        for i in range(start_idx, len(nums)):
            # Choose: Add nums[i] to current_subset
            current_subset.append(nums[i])

            # Explore: Recurse with the next element
            self._backtrack(nums, i + 1, current_subset, result)

            # Unchoose (Backtrack): Remove the last element to explore other paths
            current_subset.pop()

    def find_subsets(self, nums):
        result = []
        current_subset = []
        self._backtrack(nums, 0, current_subset, result)
        return result

def main():
    line = sys.stdin.readline().strip()

    # Constraints say nums.length >= 1, but handling empty input defensively.
    if not line:
        print(""[]"")
        return

    nums = list(map(int, line.split()))

    sol = Solution()
    result = sol.find_subsets(nums)

    # Print the results
    for subset in result:
        print(""["" + "" "".join(map(str, subset)) + ""]"")

if __name__ == ""__main__"":
    main()","import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;

public class Solution {

    // Helper function for backtracking
    private void backtrack(int[] nums,
                           int startIdx,
                           List<Integer> currentSubset,
                           List<List<Integer>> result) {

        // Add the current subset to the result list
        result.add(new ArrayList<>(currentSubset)); // Add a copy to prevent modification issues

        // Explore choices
        for (int i = startIdx; i < nums.length; i++) {
            // Choose: Add nums[i] to currentSubset
            currentSubset.add(nums[i]);

            // Explore: Recurse with the next element
            backtrack(nums, i + 1, currentSubset, result);

            // Unchoose (Backtrack): Remove the last element to explore other paths
            currentSubset.remove(currentSubset.size() - 1);
        }
    }

    // Main function to find all subsets
    public List<List<Integer>> findSubsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();
        backtrack(nums, 0, currentSubset, result);
        return result;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String line = scanner.nextLine();
        scanner.close();

        // Constraints say nums.length >= 1, but handling empty input defensively.
        if (line.trim().isEmpty()) {
            System.out.println(""[]""); 
            return;
        }

        String[] numStrings = line.trim().split(""\\s+"");
        int[] nums = new int[numStrings.length];
        for (int i = 0; i < numStrings.length; i++) {
            nums[i] = Integer.parseInt(numStrings[i]);
        }

        Solution sol = new Solution();
        List<List<Integer>> result = sol.findSubsets(nums);

        // Print the results
        for (List<Integer> subset : result) {
            System.out.print(""["");
            for (int i = 0; i < subset.size(); i++) {
                System.out.print(subset.get(i));
                if (i < subset.size() - 1) {
                    System.out.print("" "");
                }
            }
            System.out.println(""]"");
        }
    }
}","const readline = require('readline');

class Solution {
    _backtrack(nums, startIdx, currentSubset, result) {
        // Add the current subset to the result list
        result.push([...currentSubset]); // Push a shallow copy to prevent modification issues

        // Explore choices
        for (let i = startIdx; i < nums.length; i++) {
            // Choose: Add nums[i] to currentSubset
            currentSubset.push(nums[i]);

            // Explore: Recurse with the next element
            this._backtrack(nums, i + 1, currentSubset, result);

            // Unchoose (Backtrack): Remove the last element to explore other paths
            currentSubset.pop();
        }
    }

    // Main function to find all subsets
    findSubsets(nums) {
        const result = [];
        const currentSubset = [];
        this._backtrack(nums, 0, currentSubset, result);
        return result;
    }
}

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.on('line', (line) => {
    // Constraints say nums.length >= 1, but handling empty input defensively.
    if (line.trim() === '') {
        console.log(""[]"");
        rl.close();
        return;
    }

    const nums = line.split(' ').map(Number);

    const sol = new Solution();
    const result = sol.findSubsets(nums);

    // Print the results
    for (const subset of result) {
        console.log(`[${subset.join(' ')}]`);
    }

    rl.close();
});","#include <iostream>
#include <vector>
#include <algorithm>
#include <string>
#include <sstream>

// Helper function for backtracking
void backtrack(const std::vector<int>& nums,
               int startIdx,
               std::vector<int>& currentSubset,
               std::vector<std::vector<int>>& result) {
    
    // Add the current subset to the result list
    result.push_back(currentSubset);

    // Explore choices
    for (int i = startIdx; i < nums.size(); ++i) {
        // Choose: Add nums[i] to currentSubset
        currentSubset.push_back(nums[i]);

        // Explore: Recurse with the next element
        backtrack(nums, i + 1, currentSubset, result);

        // Unchoose (Backtrack): Remove the last element to explore other paths
        currentSubset.pop_back();
    }
}

// Main function to find all subsets
std::vector<std::vector<int>> findSubsets(const std::vector<int>& nums) {
    std::vector<std::vector<int>> result;
    std::vector<int> currentSubset;
    backtrack(nums, 0, currentSubset, result);
    return result;
}

int main() {
    std::vector<int> nums;
    int num;
    std::string line;

    // Read a line of space-separated integers from stdin
    std::getline(std::cin, line);
    std::stringstream ss(line);
    while (ss >> num) {
        nums.push_back(num);
    }

    // Constraints say nums.length >= 1, so no empty array input for main logic
    // If it were allowed and empty, just {{}} (a list containing one empty list) would be the output.

    std::vector<std::vector<int>> result = findSubsets(nums);

    // Print the results
    for (const auto& subset : result) {
        std::cout << ""["";
        for (size_t i = 0; i < subset.size(); ++i) {
            std::cout << subset[i];
            if (i < subset.size() - 1) {
                std::cout << "" "";
            }
        }
        std::cout << ""]\n"";
    }

    return 0;
}",4.4
Yellow-47,Intro to Backtracking,"*   **Backtracking:** A general algorithmic technique for finding all (or some) solutions to a computational problem, particularly constraint satisfaction problems, by systematically trying to build a solution incrementally. If a partial solution cannot be completed to a valid solution, it ""backtracks"" to an earlier state and tries another option.
*   **Recursion:** A function calling itself to solve a smaller instance of the same problem. Backtracking problems are often naturally solved using recursion.
*   **Base Cases:** The condition under which a recursive function stops calling itself and returns a result.
*   **State Management:** Keeping track of the current state of the solution (e.g., characters chosen so far, characters remaining to be chosen) during the recursive calls.",You are given a string `s` consisting of unique lowercase English letters. Your task is to generate and print all possible permutations of this string. A permutation is an arrangement of all its characters in a different order.,"*   `1 <= s.length <= 7` (To keep the number of permutations manageable for a Yellow Belt)
*   `s` consists only of unique lowercase English letters.","**

abc


**","**

abc
acb
bac
bca
cab
cba","Input: a
Output:
a
Input: ab
Output:
ab
ba
Input: abcd
Output:
abcd
abdc
acbd
acdb
adbc
adcb
bacd
badc
bcad
bcda
bdac
bdca
cabd
cadb
cbad
cbda
cdab
cdba
dabc
dacb
dbac
dbca
dcab
dcba
Input: xyz
Output:
xyz
xzy
yxz
yzx
zxy
zyx","#include <stdio.h>
#include <string.h>
#include <stdbool.h>

// Function to print all permutations
void findPermutations(char* str_arr, int n, char* current_perm, bool* visited, int level) {
    // Base case: If the current permutation length equals string length, print it
    if (level == n) {
        current_perm[level] = '\0'; // Null-terminate the string
        printf(""%s\n"", current_perm);
        return;
    }

    // Recursive step: Try each character from the original string
    for (int i = 0; i < n; i++) {
        // If character at index i has not been visited
        if (!visited[i]) {
            // Choose: Add character to current permutation and mark as visited
            current_perm[level] = str_arr[i];
            visited[i] = true;

            // Explore: Recurse for the next level
            findPermutations(str_arr, n, current_perm, visited, level + 1);

            // Unchoose (Backtrack): Remove character from current permutation and unmark as visited
            visited[i] = false;
        }
    }
}

int main() {
    char s[10]; // Assuming max string length as per constraints + null terminator
    if (scanf(""%s"", s) != 1) {
        return 1; // Error reading input
    }

    int n = strlen(s);

    char current_perm[10]; // Buffer for current permutation
    bool visited[10];      // Visited array

    // Initialize visited array to all false
    for (int i = 0; i < n; i++) {
        visited[i] = false;
    }

    findPermutations(s, n, current_perm, visited, 0);

    return 0;
}","def find_permutations_util(s_chars, current_perm, visited, results):
    # Base case: If the current permutation length equals string length, add it to results
    if len(current_perm) == len(s_chars):
        results.append("""".join(current_perm))
        return

    # Recursive step: Try each character from the original string
    for i in range(len(s_chars)):
        # If character at index i has not been visited
        if not visited[i]:
            # Choose: Add character to current permutation and mark as visited
            current_perm.append(s_chars[i])
            visited[i] = True

            # Explore: Recurse
            find_permutations_util(s_chars, current_perm, visited, results)

            # Unchoose (Backtrack): Remove character from current permutation and unmark as visited
            visited[i] = False
            current_perm.pop()

def get_all_permutations(s):
    s_chars = list(s)
    current_perm = []
    visited = [False] * len(s_chars)
    results = []

    find_permutations_util(s_chars, current_perm, visited, results)
    return results

if __name__ == ""__main__"":
    s = input()
    permutations = get_all_permutations(s)
    for p in permutations:
        print(p)","import java.util.Scanner;

public class Permutations {

    // Function to print all permutations
    public static void findPermutations(char[] s_chars, StringBuilder currentPerm, boolean[] visited) {
        // Base case: If the current permutation length equals string length, print it
        if (currentPerm.length() == s_chars.length) {
            System.out.println(currentPerm.toString());
            return;
        }

        // Recursive step: Try each character from the original string
        for (int i = 0; i < s_chars.length; i++) {
            // If character at index i has not been visited
            if (!visited[i]) {
                // Choose: Add character to current permutation and mark as visited
                currentPerm.append(s_chars[i]);
                visited[i] = true;

                // Explore: Recurse
                findPermutations(s_chars, currentPerm, visited);

                // Unchoose (Backtrack): Remove character from current permutation and unmark as visited
                currentPerm.deleteCharAt(currentPerm.length() - 1);
                visited[i] = false;
            }
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String s = scanner.next();
        scanner.close();

        char[] s_chars = s.toCharArray();
        StringBuilder currentPerm = new StringBuilder();
        boolean[] visited = new boolean[s_chars.length];

        findPermutations(s_chars, currentPerm, visited);
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

// Function to print all permutations
function findPermutations(s_chars, currentPerm, visited) {
    // Base case: If the current permutation length equals string length, print it
    if (currentPerm.length === s_chars.length) {
        console.log(currentPerm.join(''));
        return;
    }

    // Recursive step: Try each character from the original string
    for (let i = 0; i < s_chars.length; i++) {
        // If character at index i has not been visited
        if (!visited[i]) {
            // Choose: Add character to current permutation and mark as visited
            currentPerm.push(s_chars[i]);
            visited[i] = true;

            // Explore: Recurse
            findPermutations(s_chars, currentPerm, visited);

            // Unchoose (Backtrack): Remove character from current permutation and unmark as visited
            visited[i] = false;
            currentPerm.pop();
        }
    }
}

rl.on('line', (s) => {
    const s_chars = s.split('');
    const currentPerm = [];
    const visited = new Array(s_chars.length).fill(false);

    findPermutations(s_chars, currentPerm, visited);
    rl.close();
});","#include <iostream>
#include <string>
#include <vector>
#include <algorithm>

// Function to print all permutations
void findPermutations(const std::string& s, std::string& current_perm, std::vector<bool>& visited) {
    // Base case: If the current permutation length equals string length, print it
    if (current_perm.length() == s.length()) {
        std::cout << current_perm << std::endl;
        return;
    }

    // Recursive step: Try each character from the original string
    for (int i = 0; i < s.length(); ++i) {
        // If character at index i has not been visited
        if (!visited[i]) {
            // Choose: Add character to current permutation and mark as visited
            current_perm.push_back(s[i]);
            visited[i] = true;

            // Explore: Recurse
            findPermutations(s, current_perm, visited);

            // Unchoose (Backtrack): Remove character from current permutation and unmark as visited
            visited[i] = false;
            current_perm.pop_back();
        }
    }
}

int main() {
    std::string s;
    std::cin >> s;

    std::string current_perm;
    std::vector<bool> visited(s.length(), false);

    findPermutations(s, current_perm, visited);

    return 0;
}",4.4
Yellow-48,Intro to Backtracking,"- Backtracking
- Recursion
- Decision Tree
- Subset Generation
- State Management in Recursive Calls","Given an array of unique integers `nums`, the task is to return all possible subsets (the power set). The solution set must not contain duplicate subsets.

The order of the subsets and the order of elements within each subset does not matter, but your output should be consistent.","- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`
- All the integers in `nums` are unique.","`1 2 3`

####","[]
[1]
[1 2]
[1 2 3]
[1 3]
[2]
[2 3]
[3]

(Note: The order of subsets shown here is one possible valid output. Your output might have a different order, which is acceptable as long as all subsets are present and unique.)","Input: 1 2
Output: []
[1]
[1 2]
[2]
Input: 5
Output: []
[5]
Input: 
Output: []
Input: -1 0 1
Output: []
[-1]
[-1 0]
[-1 0 1]
[-1 1]
[0]
[0 1]
[1]
Input: 10 20
Output: []
[10]
[10 20]
[20]","#include <stdio.n>
#include <stdlib.h>

// Dynamic array for a single subset
typedef struct {
    int* data;
    int size;
    int capacity;
} Subset;

// Dynamic array for all subsets
typedef struct {
    Subset* subsets;
    int size;
    int capacity;
} SubsetsList;

// Function to initialize a Subset
void initSubset(Subset* s) {
    s->data = NULL;
    s->size = 0;
    s->capacity = 0;
}

// Function to add an element to a Subset
void addToSubset(Subset* s, int val) {
    if (s->size == s->capacity) {
        s->capacity = (s->capacity == 0) ? 1 : s->capacity * 2;
        s->data = (int*)realloc(s->data, s->capacity * sizeof(int));
        if (s->data == NULL) {
            fprintf(stderr, ""Memory allocation failed for subset data.\n"");
            exit(EXIT_FAILURE);
        }
    }
    s->data[s->size++] = val;
}

// Function to remove the last element from a Subset
void removeFromSubset(Subset* s) {
    if (s->size > 0) {
        s->size--;
    }
}

// Function to initialize SubsetsList
void initSubsetsList(SubsetsList* sl) {
    sl->subsets = NULL;
    sl->size = 0;
    sl->capacity = 0;
}

// Function to add a copy of a Subset to SubsetsList
void addSubsetToList(SubsetsList* sl, const Subset* s) {
    if (sl->size == sl->capacity) {
        sl->capacity = (sl->capacity == 0) ? 1 : sl->capacity * 2;
        sl->subsets = (Subset*)realloc(sl->subsets, sl->capacity * sizeof(Subset));
        if (sl->subsets == NULL) {
            fprintf(stderr, ""Memory allocation failed for subsets list.\n"");
            exit(EXIT_FAILURE);
        }
    }
    
    Subset new_s;
    initSubset(&new_s);
    for (int i = 0; i < s->size; ++i) {
        addToSubset(&new_s, s->data[i]);
    }
    sl->subsets[sl->size++] = new_s;
}

// Function to free memory of a Subset
void freeSubset(Subset* s) {
    free(s->data);
    s->data = NULL;
    s->size = 0;
    s->capacity = 0;
}

// Function to free memory of SubsetsList
void freeSubsetsList(SubsetsList* sl) {
    for (int i = 0; i < sl->size; ++i) {
        freeSubset(&sl->subsets[i]);
    }
    free(sl->subsets);
    sl->subsets = NULL;
    sl->size = 0;
    sl->capacity = 0;
}

// Backtracking helper function
void backtrack(int index, int* nums, int nums_size, Subset* current_subset, SubsetsList* result_list) {
    addSubsetToList(result_list, current_subset);

    for (int i = index; i < nums_size; ++i) {
        addToSubset(current_subset, nums[i]);
        backtrack(i + 1, nums, nums_size, current_subset, result_list);
        removeFromSubset(current_subset); // Backtrack
    }
}

// Main logic function to find all subsets
SubsetsList generateSubsets(int* nums, int nums_size) {
    SubsetsList result_list;
    initSubsetsList(&result_list);

    Subset current_subset;
    initSubset(&current_subset);

    backtrack(0, nums, nums_size, &current_subset, &result_list);
    
    freeSubset(&current_subset); // Free the temp subset used in recursion
    
    return result_list;
}

int main() {
    int nums[10]; // Max 10 elements as per constraints
    int nums_size = 0;
    int val;

    // Read input numbers until newline or EOF
    // Using a loop with getchar() to correctly handle space-separated integers
    // and stop on newline, assuming single line input.
    char buffer[100]; // Small buffer for input line
    if (fgets(buffer, sizeof(buffer), stdin) != NULL) {
        char* ptr = buffer;
        while (sscanf(ptr, ""%d"", &val) == 1) {
            nums[nums_size++] = val;
            // Move pointer past the number and any spaces
            while (*ptr != '\0' && *ptr != ' ' && *ptr != '\n') {
                ptr++;
            }
            while (*ptr != '\0' && *ptr == ' ') {
                ptr++;
            }
            if (*ptr == '\n' || *ptr == '\0') break;
        }
    }

    SubsetsList result = generateSubsets(nums, nums_size);

    // Print the result
    for (int i = 0; i < result.size; ++i) {
        printf(""["");
        for (int j = 0; j < result.subsets[i].size; ++j) {
            printf(""%d"", result.subsets[i].data[j]);
            if (j < result.subsets[i].size - 1) {
                printf("" "");
            }
        }
        printf(""]\n"");
    }

    freeSubsetsList(&result);

    return 0;
}","import sys

class Solution:
    def subsets(self, nums: list[int]) -> list[list[int]]:
        result = []
        current_subset = []
        
        def backtrack(index):
            result.append(list(current_subset)) # Add a copy of the current subset
            
            for i in range(index, len(nums)):
                current_subset.append(nums[i]) # Include nums[i]
                backtrack(i + 1) # Recurse with the next index
                current_subset.pop() # Backtrack: remove nums[i]
        
        backtrack(0)
        return result

def main():
    line = sys.stdin.readline().strip()
    
    if line:
        nums = list(map(int, line.split()))
    else:
        nums = []

    sol = Solution()
    result = sol.subsets(nums)

    # Print the result
    for subset in result:
        sys.stdout.write(""["")
        sys.stdout.write("" "".join(map(str, subset)))
        sys.stdout.write(""]\n"")

if __name__ == ""__main__"":
    main()","import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;

public class Solution {

    public List<List<Integer>> generateSubsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();
        backtrack(0, nums, currentSubset, result);
        return result;
    }

    private void backtrack(int index, int[] nums, List<Integer> currentSubset, List<List<Integer>> result) {
        result.add(new ArrayList<>(currentSubset)); // Add a copy of the current subset

        for (int i = index; i < nums.length; i++) {
            currentSubset.add(nums[i]); // Include nums[i]
            backtrack(i + 1, nums, currentSubset, result); // Recurse with the next index
            currentSubset.remove(currentSubset.size() - 1); // Backtrack: remove nums[i]
        }
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String line = scanner.nextLine();
        scanner.close();

        // Parse the input line into an array of integers
        String[] numStrings = line.trim().split("" "");
        
        int[] nums;
        if (line.trim().isEmpty()) { // Handle empty input case
            nums = new int[0];
        } else {
            nums = new int[numStrings.length];
            for (int i = 0; i < numStrings.length; i++) {
                nums[i] = Integer.parseInt(numStrings[i]);
            }
        }

        Solution sol = new Solution();
        List<List<Integer>> result = sol.generateSubsets(nums);

        // Print the result
        for (List<Integer> subset : result) {
            System.out.print(""["");
            for (int i = 0; i < subset.size(); i++) {
                System.out.print(subset.get(i));
                if (i < subset.size() - 1) {
                    System.out.print("" "");
                }
            }
            System.out.println(""]"");
        }
    }
}","class Solution {
    subsets(nums) {
        const result = [];
        const currentSubset = [];

        function backtrack(index) {
            result.push([...currentSubset]); // Add a copy of the current subset

            for (let i = index; i < nums.length; i++) {
                currentSubset.push(nums[i]); // Include nums[i]
                backtrack(i + 1); // Recurse with the next index
                currentSubset.pop(); // Backtrack: remove nums[i]
            }
        }

        backtrack(0);
        return result;
    }
}

// Function to handle input and output for the platform
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    rl.on('line', (line) => {
        let nums;
        if (line.trim() === """") {
            nums = [];
        } else {
            nums = line.split(' ').map(Number);
        }

        const sol = new Solution();
        const result = sol.subsets(nums);

        // Print the result
        for (const subset of result) {
            process.stdout.write(""["");
            process.stdout.write(subset.join("" ""));
            process.stdout.write(""]\n"");
        }
        rl.close(); // Close the readline interface after processing input
    });
}

// Ensure main is called if script is executed directly
if (require.main === module) {
    main();
}","#include <iostream>
#include <vector>
#include <string>
#include <sstream>

void backtrack(int index, const std::vector<int>& nums, std::vector<int>& current_subset, std::vector<std::vector<int>>& result) {
    result.push_back(current_subset); // Add the current subset to the result

    for (int i = index; i < nums.size(); ++i) {
        current_subset.push_back(nums[i]); // Include nums[i]
        backtrack(i + 1, nums, current_subset, result); // Recurse with the next index
        current_subset.pop_back(); // Backtrack: remove nums[i]
    }
}

std::vector<std::vector<int>> generateSubsets(const std::vector<int>& nums) {
    std::vector<std::vector<int>> result;
    std::vector<int> current_subset;
    backtrack(0, nums, current_subset, result);
    return result;
}

int main() {
    std::string line;
    std::getline(std::cin, line);
    std::stringstream ss(line);
    
    std::vector<int> nums;
    int num;
    while (ss >> num) {
        nums.push_back(num);
    }

    std::vector<std::vector<int>> result = generateSubsets(nums);

    // Print the result
    for (const auto& subset : result) {
        std::cout << ""["";
        for (size_t i = 0; i < subset.size(); ++i) {
            std::cout << subset[i];
            if (i < subset.size() - 1) {
                std::cout << "" "";
            }
        }
        std::cout << ""]"" << std::endl;
    }

    return 0;
}",4.2
Yellow-49,Linear Search,"*   Linear Search
*   Array Traversal
*   Iteration (Loops)
*   Conditional Statements","You are given an array of integers `arr` and a target integer `target`. Your task is to implement a linear search algorithm to find the first occurrence of the `target` in the `arr`. If the `target` is found, return its 0-based index. If the `target` is not present in the array, return `-1`.","* `1 <= n <= 1000` (where `n` is the size of the array `arr`)
* `-1000 <= arr[i] <= 1000`
* `-1000 <= target <= 1000`","**

5
10 20 30 40 50
30

**","**

2

**","Input: 5
10 20 30 40 50
10
Output: 0
Input: 5
10 20 30 40 50
50
Output: 4
Input: 7
1 5 3 8 5 9 2
5
Output: 1
Input: 3
-5 -10 -15
-10
Output: 1
Input: 4
1 2 3 4
0
Output: -1","#include <stdio.h>
#include <stdlib.h> // For malloc, free

// Function to perform linear search
// Returns the 0-based index of the first occurrence of target, or -1 if not found.
int linearSearch(int arr[], int n, int target) {
    for (int i = 0; i < n; i++) {
        if (arr[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found in the array
}

int main() {
    int n;
    // Read the size of the array
    if (scanf(""%d"", &n) != 1 || n < 1 || n > 1000) {
        fprintf(stderr, ""Invalid array size.\n"");
        return 1;
    }

    // Allocate memory for the array
    int* arr = (int*)malloc(n * sizeof(int));
    if (arr == NULL) {
        fprintf(stderr, ""Memory allocation failed.\n"");
        return 1;
    }

    // Read array elements
    for (int i = 0; i < n; i++) {
        if (scanf(""%d"", &arr[i]) != 1) {
            fprintf(stderr, ""Failed to read array element.\n"");
            free(arr);
            return 1;
        }
    }

    int target;
    // Read the target value
    if (scanf(""%d"", &target) != 1) {
        fprintf(stderr, ""Failed to read target value.\n"");
        free(arr);
        return 1;
    }

    // Call the linear search function
    int result = linearSearch(arr, n, target);

    // Print the result
    printf(""%d\n"", result);

    // Free the allocated memory
    free(arr);

    return 0;
}","import sys

def linear_search(arr, target):
    """"""
    Performs linear search to find the first occurrence of target in arr.
    Returns the 0-based index of the first occurrence, or -1 if not found.
    """"""
    for i in range(len(arr)):
        if arr[i] == target:
            return i  # Target found, return its index
    return -1  # Target not found in the array

def main():
    # Read the size of the array
    n = int(input())
    if not (1 <= n <= 1000):
        print(""Invalid array size."", file=sys.stderr)
        sys.exit(1)

    # Read array elements
    arr = list(map(int, input().split()))
    if len(arr) != n:
        print(""Number of array elements does not match declared size."", file=sys.stderr)
        sys.exit(1)

    # Read the target value
    target = int(input())

    # Call the linear search function
    result = linear_search(arr, target)

    # Print the result
    print(result)

if __name__ == ""__main__"":
    main()","import java.util.Scanner;

public class Main {

    // Function to perform linear search
    // Returns the 0-based index of the first occurrence of target, or -1 if not found.
    public static int linearSearch(int[] arr, int target) {
        for (int i = 0; i < arr.length; i++) {
            if (arr[i] == target) {
                return i; // Target found, return its index
            }
        }
        return -1; // Target not found in the array
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the size of the array
        int n = scanner.nextInt();
        if (n < 1 || n > 1000) {
            System.err.println(""Invalid array size."");
            scanner.close();
            return;
        }

        // Read array elements
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        // Read the target value
        int target = scanner.nextInt();

        // Call the linear search function
        int result = linearSearch(arr, target);

        // Print the result
        System.out.println(result);

        scanner.close();
    }
}","// Function to perform linear search
// Returns the 0-based index of the first occurrence of target, or -1 if not found.
function linearSearch(arr, target) {
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found in the array
}

// Main execution logic for handling input/output
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let inputLines = [];
    rl.on('line', (line) => {
        inputLines.push(line);
    });

    rl.on('close', () => {
        let lineIndex = 0;

        // Read the size of the array
        const n = parseInt(inputLines[lineIndex++]);
        if (isNaN(n) || n < 1 || n > 1000) {
            console.error(""Invalid array size."");
            process.exit(1);
        }

        // Read array elements
        const arr = inputLines[lineIndex++].split(' ').map(Number);
        if (arr.length !== n) {
            console.error(""Number of array elements does not match declared size."");
            process.exit(1);
        }

        // Read the target value
        const target = parseInt(inputLines[lineIndex++]);
        if (isNaN(target)) {
            console.error(""Invalid target value."");
            process.exit(1);
        }

        // Call the linear search function
        const result = linearSearch(arr, target);

        // Print the result
        console.log(result);
    });
}

main();","#include <iostream>
#include <vector> // For std::vector

// Function to perform linear search
// Returns the 0-based index of the first occurrence of target, or -1 if not found.
int linearSearch(const std::vector<int>& arr, int target) {
    for (int i = 0; i < arr.size(); ++i) {
        if (arr[i] == target) {
            return i; // Target found, return its index
        }
    }
    return -1; // Target not found in the array
}

int main() {
    std::ios_base::sync_with_stdio(false); // Optimize C++ standard streams
    std::cin.tie(NULL); // Untie cin from cout

    int n;
    // Read the size of the array
    if (!(std::cin >> n) || n < 1 || n > 1000) {
        std::cerr << ""Invalid array size."" << std::endl;
        return 1;
    }

    // Read array elements into a std::vector
    std::vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        if (!(std::cin >> arr[i])) {
            std::cerr << ""Failed to read array element."" << std::endl;
            return 1;
        }
    }

    int target;
    // Read the target value
    if (!(std::cin >> target)) {
        std::cerr << ""Failed to read target value."" << std::endl;
        return 1;
    }

    // Call the linear search function
    int result = linearSearch(arr, target);

    // Print the result
    std::cout << result << std::endl;

    return 0;
}",4.2
Yellow-50,Prefix & Suffix Sums,"- Prefix Sums
- Array Manipulation
- Time and Space Complexity Analysis","You are given an array of integers, `arr`, and a list of queries. Each query consists of two indices, `start` and `end`, representing a range within the array (inclusive). Your task is to calculate the sum of all elements within each specified range for every query.

For example, if `arr = [1, 2, 3, 4, 5]` and a query is `[0, 2]`, the sum would be `arr[0] + arr[1] + arr[2] = 1 + 2 + 3 = 6`. You need to process all queries efficiently.","- `1 <= N <= 10^5` (where `N` is the length of `arr`)
- `-1000 <= arr[i] <= 1000`
- `1 <= Q <= 10^5` (where `Q` is the number of queries)
- `0 <= start <= end < N` for each query","Array: `[1, 2, 3, 4, 5]`
Queries: `[[0, 2], [1, 3]]`","`[6, 9]`","Input: 1
10
1
0 0
Output: 10
Input: 5
5 -2 8 -1 3
2
0 4
1 2
Output: 13
6
Input: 5
1 1 1 1 1
3
0 0
0 4
2 2
Output: 1
5
1
Input: 5
-1 -2 -3 -4 -5
2
0 1
3 4
Output: -3
-9","#include <stdio.h>
#include <stdlib.h> // For malloc, free

// Function to calculate range sums using prefix sums
// arr: input array
// N: size of arr
// queries: 2D array of queries, each query is {start, end}
// Q: number of queries
// resultSize: pointer to store the size of the result array
// Returns a dynamically allocated array of long long sums
long long* calculateRangeSums(int* arr, int N, int (*queries)[2], int Q, int* resultSize) {
    if (N == 0 || Q == 0) {
        *resultSize = 0;
        return NULL;
    }

    // Allocate memory for prefix sum array
    // prefixSum[i] stores sum from arr[0] to arr[i]
    long long* prefixSum = (long long*)malloc(N * sizeof(long long));
    if (prefixSum == NULL) {
        // Handle allocation failure
        *resultSize = 0;
        return NULL;
    }

    prefixSum[0] = arr[0];
    for (int i = 1; i < N; i++) {
        prefixSum[i] = prefixSum[i - 1] + arr[i];
    }

    // Allocate memory for results
    long long* results = (long long*)malloc(Q * sizeof(long long));
    if (results == NULL) {
        // Handle allocation failure, free prefixSum array
        free(prefixSum);
        *resultSize = 0;
        return NULL;
    }

    for (int i = 0; i < Q; i++) {
        int start = queries[i][0];
        int end = queries[i][1];

        if (start == 0) {
            results[i] = prefixSum[end];
        } else {
            results[i] = prefixSum[end] - prefixSum[start - 1];
        }
    }

    free(prefixSum); // Free prefix sum array as it's no longer needed
    *resultSize = Q;
    return results;
}

int main() {
    int N;
    scanf(""%d"", &N);

    int* arr = (int*)malloc(N * sizeof(int));
    if (arr == NULL) {
        return 1; // Allocation failed
    }
    for (int i = 0; i < N; i++) {
        scanf(""%d"", &arr[i]);
    }

    int Q;
    scanf(""%d"", &Q);

    int (*queries)[2] = (int(*)[2])malloc(Q * sizeof(int[2]));
    if (queries == NULL) {
        free(arr);
        return 1; // Allocation failed
    }
    for (int i = 0; i < Q; i++) {
        scanf(""%d %d"", &queries[i][0], &queries[i][1]);
    }

    int resultSize;
    long long* results = calculateRangeSums(arr, N, queries, Q, &resultSize);

    for (int i = 0; i < resultSize; i++) {
        printf(""%lld\n"", results[i]);
    }

    free(arr);
    free(queries);
    free(results); // Free the results array returned by the function

    return 0;
}","def calculate_range_sums(arr, queries):
    if not arr or not queries:
        return []

    # Build prefix sum array
    # prefix_sum[i] stores sum from arr[0] to arr[i]
    prefix_sum = [0] * len(arr)
    prefix_sum[0] = arr[0]
    for i in range(1, len(arr)):
        prefix_sum[i] = prefix_sum[i - 1] + arr[i]

    results = []
    for start, end in queries:
        if start == 0:
            results.append(prefix_sum[end])
        else:
            results.append(prefix_sum[end] - prefix_sum[start - 1])
            
    return results

def main():
    N = int(input())
    arr = list(map(int, input().split()))

    Q = int(input())
    queries = []
    for _ in range(Q):
        start, end = map(int, input().split())
        queries.append((start, end))

    results = calculate_range_sums(arr, queries)

    for s in results:
        print(s)

if __name__ == ""__main__"":
    main()","import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class Main {

    // Function to calculate range sums using prefix sums
    public List<Long> calculateRangeSums(int[] arr, int[][] queries) {
        if (arr == null || arr.length == 0 || queries == null || queries.length == 0) {
            return new ArrayList<>();
        }

        // Build prefix sum array
        // prefixSum[i] stores sum from arr[0] to arr[i]
        long[] prefixSum = new long[arr.length];
        prefixSum[0] = arr[0];
        for (int i = 1; i < arr.length; i++) {
            prefixSum[i] = prefixSum[i - 1] + arr[i];
        }

        List<Long> results = new ArrayList<>();
        for (int[] query : queries) {
            int start = query[0];
            int end = query[1];

            if (start == 0) {
                results.add(prefixSum[end]);
            } else {
                results.add(prefixSum[end] - prefixSum[start - 1]);
            }
        }

        return results;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Main solution = new Main(); // Create an instance to call the non-static method

        int N = scanner.nextInt();
        int[] arr = new int[N];
        for (int i = 0; i < N; i++) {
            arr[i] = scanner.nextInt();
        }

        int Q = scanner.nextInt();
        int[][] queries = new int[Q][2];
        for (int i = 0; i < Q; i++) {
            queries[i][0] = scanner.nextInt();
            queries[i][1] = scanner.nextInt();
        }

        List<Long> results = solution.calculateRangeSums(arr, queries);

        for (long sum : results) {
            System.out.println(sum);
        }

        scanner.close();
    }
}","function calculateRangeSums(arr, queries) {
    if (!arr || arr.length === 0 || !queries || queries.length === 0) {
        return [];
    }

    // Build prefix sum array
    // prefixSum[i] stores sum from arr[0] to arr[i]
    const prefixSum = new Array(arr.length);
    prefixSum[0] = arr[0];
    for (let i = 1; i < arr.length; i++) {
        prefixSum[i] = prefixSum[i - 1] + arr[i];
    }

    const results = [];
    for (const query of queries) {
        const start = query[0];
        const end = query[1];

        if (start === 0) {
            results.push(prefixSum[end]);
        } else {
            results.push(prefixSum[end] - prefixSum[start - 1]);
        }
    }

    return results;
}

function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let lines = [];
    rl.on('line', (line) => {
        lines.push(line);
    }).on('close', () => {
        let lineIndex = 0;

        const N = parseInt(lines[lineIndex++]);
        const arr = lines[lineIndex++].split(' ').map(Number);

        const Q = parseInt(lines[lineIndex++]);
        const queries = [];
        for (let i = 0; i < Q; i++) {
            queries.push(lines[lineIndex++].split(' ').map(Number));
        }

        const results = calculateRangeSums(arr, queries);

        for (const sum of results) {
            console.log(sum);
        }
    });
}

main();","#include <iostream>
#include <vector>
#include <numeric> // For std::partial_sum, though manual implementation is fine

// Function to calculate range sums using prefix sums
std::vector<long long> calculateRangeSums(const std::vector<int>& arr, const std::vector<std::pair<int, int>>& queries) {
    if (arr.empty() || queries.empty()) {
        return {};
    }

    // Build prefix sum array
    // prefixSum[i] stores sum from arr[0] to arr[i]
    std::vector<long long> prefixSum(arr.size());
    prefixSum[0] = arr[0];
    for (size_t i = 1; i < arr.size(); ++i) {
        prefixSum[i] = prefixSum[i - 1] + arr[i];
    }

    std::vector<long long> results;
    results.reserve(queries.size()); // Pre-allocate memory for results

    for (const auto& query : queries) {
        int start = query.first;
        int end = query.second;

        if (start == 0) {
            results.push_back(prefixSum[end]);
        } else {
            results.push_back(prefixSum[end] - prefixSum[start - 1]);
        }
    }

    return results;
}

int main() {
    std::ios_base::sync_with_stdio(false); // Optimize C++ standard streams for faster I/O
    std::cin.tie(NULL);

    int N;
    std::cin >> N;

    std::vector<int> arr(N);
    for (int i = 0; i < N; ++i) {
        std::cin >> arr[i];
    }

    int Q;
    std::cin >> Q;

    std::vector<std::pair<int, int>> queries(Q);
    for (int i = 0; i < Q; ++i) {
        std::cin >> queries[i].first >> queries[i].second;
    }

    std::vector<long long> results = calculateRangeSums(arr, queries);

    for (long long sum : results) {
        std::cout << sum << ""\n"";
    }

    return 0;
}",4.2
Yellow-51,Prefix & Suffix Sums,"*   Array Traversal
*   Prefix Sums (implicit calculation)
*   Summation","Given an array `arr` of `n` integers, your task is to find the *first* equilibrium point in the array. An equilibrium point is an index `i` such that the sum of elements strictly to its left (indices `0` to `i-1`) is equal to the sum of elements strictly to its right (indices `i+1` to `n-1`). If no such index exists, return -1.","*   `1 <= n <= 1000`
*   `-100 <= arr[i] <= 100`","**

7
-7 1 5 2 -4 3 0

**","**

3

**","Input: 1
0
Output: 0
Input: 5
1 2 3 4 5
Output: -1
Input: 6
1 2 3 -3 2 1
Output: 2
Input: 3
-1 0 1
Output: 1
Input: 4
2 3 5 10
Output: -1","#include <stdio.h>
#include <stdlib.h>

// Function to find the first equilibrium point
int findEquilibriumPoint(int arr[], int n) {
    if (n == 0) {
        return -1;
    }

    long long totalSum = 0;
    for (int i = 0; i < n; i++) {
        totalSum += arr[i];
    }

    long long leftSum = 0;
    for (int i = 0; i < n; i++) {
        // rightSum = totalSum - leftSum - arr[i]
        // Note: For a single element array, leftSum is 0, rightSum is 0. So index 0 is an equilibrium point.
        if (leftSum == (totalSum - leftSum - arr[i])) {
            return i;
        }
        leftSum += arr[i];
    }

    return -1;
}

int main() {
    int n;
    scanf(""%d"", &n);

    int *arr = (int *)malloc(n * sizeof(int));
    if (arr == NULL) {
        return 1; // Memory allocation failed
    }

    for (int i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]);
    }

    int result = findEquilibriumPoint(arr, n);
    printf(""%d\n"", result);

    free(arr);
    return 0;
}","import sys

def find_equilibrium_point(arr):
    n = len(arr)
    if n == 0:
        return -1

    total_sum = sum(arr)
    left_sum = 0

    for i in range(n):
        # right_sum = total_sum - left_sum - arr[i]
        # Note: For a single element array, left_sum is 0, right_sum is 0. So index 0 is an equilibrium point.
        if left_sum == (total_sum - left_sum - arr[i]):
            return i
        left_sum += arr[i]

    return -1

def main():
    n = int(sys.stdin.readline())
    arr = list(map(int, sys.stdin.readline().split()))

    result = find_equilibrium_point(arr)
    sys.stdout.write(str(result) + '\n')

if __name__ == '__main__':
    main()","import java.util.Scanner;

public class Solution {

    // Function to find the first equilibrium point
    public static int findEquilibriumPoint(int[] arr) {
        int n = arr.length;
        if (n == 0) {
            return -1;
        }

        long totalSum = 0;
        for (int x : arr) {
            totalSum += x;
        }

        long leftSum = 0;
        for (int i = 0; i < n; i++) {
            // rightSum = totalSum - leftSum - arr[i]
            // Note: For a single element array, leftSum is 0, rightSum is 0. So index 0 is an equilibrium point.
            if (leftSum == (totalSum - leftSum - arr[i])) {
                return i;
            }
            leftSum += arr[i];
        }

        return -1;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }
        scanner.close();

        int result = findEquilibriumPoint(arr);
        System.out.println(result);
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

// Function to find the first equilibrium point
function findEquilibriumPoint(arr) {
    const n = arr.length;
    if (n === 0) {
        return -1;
    }

    let totalSum = 0;
    for (let i = 0; i < n; i++) {
        totalSum += arr[i];
    }

    let leftSum = 0;
    for (let i = 0; i < n; i++) {
        // rightSum = totalSum - leftSum - arr[i]
        // Note: For a single element array, leftSum is 0, rightSum is 0. So index 0 is an equilibrium point.
        if (leftSum === (totalSum - leftSum - arr[i])) {
            return i;
        }
        leftSum += arr[i];
    }

    return -1;
}

let input = [];
rl.on('line', (line) => {
    input.push(line);
}).on('close', () => {
    const n = parseInt(input[0]);
    const arr = input[1].split(' ').map(Number);

    const result = findEquilibriumPoint(arr);
    console.log(result);
});","#include <iostream>
#include <vector>
#include <numeric>

// Function to find the first equilibrium point
int findEquilibriumPoint(const std::vector<int>& arr) {
    int n = arr.size();
    if (n == 0) {
        return -1;
    }

    long long totalSum = 0;
    for (int x : arr) {
        totalSum += x;
    }

    long long leftSum = 0;
    for (int i = 0; i < n; ++i) {
        // rightSum = totalSum - leftSum - arr[i]
        // Note: For a single element array, leftSum is 0, rightSum is 0. So index 0 is an equilibrium point.
        if (leftSum == (totalSum - leftSum - arr[i])) {
            return i;
        }
        leftSum += arr[i];
    }

    return -1;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    std::vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i];
    }

    int result = findEquilibriumPoint(arr);
    std::cout << result << std::endl;

    return 0;
}",4.4
White-103,LeetCode,"- **2D Arrays (Matrices)**: Understanding how to work with grid-like data structures.
- **In-place Modification**: Modifying data directly in its original memory location without using extra space.
- **Matrix Transposition**: Swapping elements across the main diagonal (e.g., `matrix[i][j]` becomes `matrix[j][i]`).
- **Array Reversal**: Flipping the order of elements within a 1D array or a row of a 2D array.
- **Nested Loops**: Using loops within loops to iterate through all elements of a 2D array.","You are given an `n x n` 2D matrix, which represents an image. Your task is to rotate the image by 90 degrees clockwise.

You must do this **in-place**, meaning you have to modify the input 2D matrix directly. You should not allocate another 2D matrix to perform the rotation. Think of it like rotating a physical photo frame without replacing the photo inside.

For example, if you have a 3x3 matrix:

1 2 3
4 5 6
7 8 9

After rotating it 90 degrees clockwise, it should become:

7 4 1
8 5 2
9 6 3","- `n == matrix.length == matrix[i].length` (The matrix is always square)
- `1 <= n <= 20` (The size of the matrix will be between 1x1 and 20x20)
- `-1000 <= matrix[i][j] <= 1000` (The values inside the matrix are integers)","`matrix = [[1,2,3],[4,5,6],[7,8,9]]`","`[[7,4,1],[8,5,2],[9,6,3]]`","Input: 
3
1 2 3
4 5 6
7 8 9
Output: 
7 4 1
8 5 2
9 6 3,Input: 
4
5 1 9 11
2 4 8 10
13 3 6 7
15 14 12 16
Output: 
15 13 2 5
14 3 4 1
12 6 8 9
16 7 10 11,Input: 
2
1 2
3 4
Output: 
3 1
4 2,Input: 
1
7
Output: 
7","#include <stdio.h>
#include <stdlib.h>

// Function to rotate the matrix in-place
void rotate(int** matrix, int matrixSize, int* matrixColSize) {
    // 1. Transpose the matrix
    for (int i = 0; i < matrixSize; i++) {
        for (int j = i + 1; j < matrixSize; j++) {
            // Swap matrix[i][j] with matrix[j][i]
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }

    // 2. Reverse each row
    for (int i = 0; i < matrixSize; i++) {
        int left = 0;
        int right = matrixSize - 1;
        while (left < right) {
            // Swap matrix[i][left] with matrix[i][right]
            int temp = matrix[i][left];
            matrix[i][left] = matrix[i][right];
            matrix[i][right] = temp;
            left++;
            right--;
        }
    }
}

int main() {
    int n;
    scanf(""%d"", &n);

    // Dynamically allocate matrix
    int** matrix = (int**)malloc(n * sizeof(int*));
    // For LeetCode compatibility, matrixColSize array is usually passed, 
    // but for square matrices all elements are 'n'.
    int* colSizes = (int*)malloc(n * sizeof(int)); 

    for (int i = 0; i < n; i++) {
        matrix[i] = (int*)malloc(n * sizeof(int));
        colSizes[i] = n; // Each row has n columns
        for (int j = 0; j < n; j++) {
            scanf(""%d"", &matrix[i][j]);
        }
    }

    rotate(matrix, n, colSizes); // Pass n as matrixSize and colSizes (though not strictly needed for square)

    // Print the rotated matrix
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            printf(""%d%s"", matrix[i][j], (j == n - 1) ? """" : "" "");
        }
        printf(""\n"");
    }

    // Free dynamically allocated memory
    for (int i = 0; i < n; i++) {
        free(matrix[i]);
    }
    free(matrix);
    free(colSizes);

    return 0;
}","import sys

class Solution:
    def rotate(self, matrix: list[list[int]]) -> None:
        """"""
        Do not return anything, modify matrix in-place instead.
        """"""
        n = len(matrix)

        # 1. Transpose the matrix
        for i in range(n):
            for j in range(i + 1, n):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]

        # 2. Reverse each row
        for i in range(n):
            matrix[i].reverse() # Python's list.reverse() works in-place

def main():
    lines = sys.stdin.readlines()
    n = int(lines[0].strip())
    matrix = []
    for i in range(1, n + 1):
        row = list(map(int, lines[i].strip().split()))
        matrix.append(row)

    sol = Solution()
    sol.rotate(matrix)

    # Print the rotated matrix
    for row in matrix:
        print(*(row)) # Python's print(*list) prints space-separated elements

if __name__ == ""__main__"":
    main()","import java.util.Scanner;

class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;

        // 1. Transpose the matrix
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }

        // 2. Reverse each row
        for (int i = 0; i < n; i++) {
            int left = 0;
            int right = n - 1;
            while (left < right) {
                int temp = matrix[i][left];
                matrix[i][left] = matrix[i][right];
                matrix[i][right] = temp;
                left++;
                right--;
            }
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();

        int[][] matrix = new int[n][n];

        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = scanner.nextInt();
            }
        }

        Solution sol = new Solution();
        sol.rotate(matrix);

        // Print the rotated matrix
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(matrix[i][j] + (j == n - 1 ? """" : "" ""));
            }
            System.out.println();
        }

        scanner.close();
    }
}","// Function to rotate the matrix in-place
function rotate(matrix) {
    const n = matrix.length;

    // 1. Transpose the matrix
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]]; // ES6 destructuring for swap
        }
    }

    // 2. Reverse each row
    for (let i = 0; i < n; i++) {
        matrix[i].reverse(); // Array.prototype.reverse() works in-place
    }
}

// Handle I/O
// Node.js specific for stdin/stdout
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let n;
let matrix = [];
let lineCount = 0;

rl.on('line', (line) => {
    if (lineCount === 0) {
        n = parseInt(line);
    } else {
        matrix.push(line.split(' ').map(Number));
    }
    lineCount++;

    if (lineCount > n) { // All lines including n have been read
        rotate(matrix);

        // Print the rotated matrix
        for (let i = 0; i < n; i++) {
            console.log(matrix[i].join(' '));
        }
        rl.close();
    }
});","#include <iostream>
#include <vector>
#include <algorithm> // For std::reverse

// Function to rotate the matrix in-place
void rotate(std::vector<std::vector<int>>& matrix) {
    int n = matrix.size();

    // 1. Transpose the matrix
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            std::swap(matrix[i][j], matrix[j][i]);
        }
    }

    // 2. Reverse each row
    for (int i = 0; i < n; i++) {
        std::reverse(matrix[i].begin(), matrix[i].end());
    }
}

int main() {
    int n;
    std::cin >> n;

    std::vector<std::vector<int>> matrix(n, std::vector<int>(n));

    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            std::cin >> matrix[i][j];
        }
    }

    rotate(matrix);

    // Print the rotated matrix
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            std::cout << matrix[i][j] << (j == n - 1 ? """" : "" "");
        }
        std::cout << std::endl;
    }

    return 0;
}",4.2
DELETE-103-rotate-image,Deletion,N/A,Deleted folder: 103-rotate-image,N/A,N/A,N/A,N/A,,,,,,N/A
Yellow-52,LeetCode,"*   **2D Arrays (Matrices)**: Understanding how to store and access data in a grid-like structure.
*   **In-place Operations**: Modifying the existing data structure directly without creating a new one, which is important for memory efficiency.
*   **Nested Loops**: Using loops within loops to iterate through all elements of a 2D array.
*   **Swapping Elements**: Exchanging the values of two variables, a fundamental operation in many algorithms.
*   **Algorithmic Thinking**: Breaking down a complex transformation (like rotation) into simpler, manageable steps.","You are given an `n x n` 2D `matrix` representing an image. You need to rotate the image by 90 degrees clockwise.

You must do this in-place, which means you modify the input 2D matrix directly. Do NOT allocate another 2D matrix to perform the rotation.

For example, if you have:

1 2 3
4 5 6
7 8 9

After rotating 90 degrees clockwise, it becomes:

7 4 1
8 5 2
9 6 3","*   `n == matrix.length == matrix[i].length`
*   `1 <= n <= 20`
*   `-1000 <= matrix[i][j] <= 1000`","** `matrix = [[1,2,3],[4,5,6],[7,8,9]]`
**","** `[[7,4,1],[8,5,2],[9,6,3]]`

**","Input: 3
1 2 3
4 5 6
7 8 9
Output: 7 4 1
8 5 2
9 6 3,Input: 4
5 1 9 11
2 4 8 10
13 3 6 7
15 14 12 16
Output: 15 13 2 5
14 3 4 1
12 6 8 9
16 7 10 11,Input: 1
1
Output: 1,Input: 2
1 2
3 4
Output: 3 1
4 2","#include <stdio.h>
#include <stdlib.h>

// Function to rotate the matrix
void rotate(int** matrix, int n) {
    // 1. Transpose the matrix
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            int temp = matrix[i][j];
            matrix[i][j] = matrix[j][i];
            matrix[j][i] = temp;
        }
    }

    // 2. Reverse each row
    for (int i = 0; i < n; i++) {
        int left = 0;
        int right = n - 1;
        while (left < right) {
            int temp = matrix[i][left];
            matrix[i][left] = matrix[i][right];
            matrix[i][right] = temp;
            left++;
            right--;
        }
    }
}

int main() {
    int n;
    // Input format: first line is N, then N lines of N space-separated integers
    // Example:
    // 3
    // 1 2 3
    // 4 5 6
    // 7 8 9
    scanf(""%d"", &n);

    // Allocate memory for the matrix
    int** matrix = (int**)malloc(n * sizeof(int*));
    for (int i = 0; i < n; i++) {
        matrix[i] = (int*)malloc(n * sizeof(int));
        for (int j = 0; j < n; j++) {
            scanf(""%d"", &matrix[i][j]);
        }
    }

    // Rotate the matrix
    rotate(matrix, n);

    // Print the rotated matrix
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            printf(""%d%s"", matrix[i][j], (j == n - 1) ? """" : "" "");
        }
        printf(""\n"");
    }

    // Free allocated memory
    for (int i = 0; i < n; i++) {
        free(matrix[i]);
    }
    free(matrix);

    return 0;
}","class Solution:
    def rotate(self, matrix: list[list[int]]) -> None:
        """"""
        Do not return anything, modify matrix in-place instead.
        """"""
        n = len(matrix)

        # 1. Transpose the matrix
        for i in range(n):
            for j in range(i + 1, n):
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]

        # 2. Reverse each row
        for i in range(n):
            matrix[i].reverse() # Python's list.reverse() is convenient

def main():
    # Input format: first line is N, then N lines of N space-separated integers
    # Example:
    # 3
    # 1 2 3
    # 4 5 6
    # 7 8 9
    n = int(input())
    matrix = []
    for _ in range(n):
        matrix.append(list(map(int, input().split())))

    sol = Solution()
    sol.rotate(matrix)

    # Print the rotated matrix
    for row in matrix:
        print(*(row)) # Python's print(*row) will print elements separated by space

if __name__ == ""__main__"":
    main()","import java.util.Scanner;

class Solution {
    public void rotate(int[][] matrix) {
        int n = matrix.length;

        // 1. Transpose the matrix
        for (int i = 0; i < n; i++) {
            for (int j = i + 1; j < n; j++) {
                int temp = matrix[i][j];
                matrix[i][j] = matrix[j][i];
                matrix[j][i] = temp;
            }
        }

        // 2. Reverse each row
        for (int i = 0; i < n; i++) {
            int left = 0;
            int right = n - 1;
            while (left < right) {
                int temp = matrix[i][left];
                matrix[i][left] = matrix[i][right];
                matrix[i][right] = temp;
                left++;
                right--;
            }
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // Input format: first line is N, then N lines of N space-separated integers
        // Example:
        // 3
        // 1 2 3
        // 4 5 6
        // 7 8 9
        int n = scanner.nextInt();

        int[][] matrix = new int[n][n];
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                matrix[i][j] = scanner.nextInt();
            }
        }

        Solution sol = new Solution();
        sol.rotate(matrix);

        // Print the rotated matrix
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                System.out.print(matrix[i][j] + (j == n - 1 ? """" : "" ""));
            }
            System.out.println();
        }

        scanner.close();
    }
}","/**
 * @param {number[][]} matrix
 * @return {void} Do not return anything, modify matrix in-place instead.
 */
function rotate(matrix) {
    const n = matrix.length;

    // 1. Transpose the matrix
    for (let i = 0; i < n; i++) {
        for (let j = i + 1; j < n; j++) {
            [matrix[i][j], matrix[j][i]] = [matrix[j][i], matrix[i][j]]; // ES6 destructuring for swap
        }
    }

    // 2. Reverse each row
    for (let i = 0; i < n; i++) {
        matrix[i].reverse(); // Array.prototype.reverse() is convenient
    }
}

// Function to handle input and output for testing
function main() {
    // Input format: first line is N, then N lines of N space-separated integers
    // Example:
    // 3
    // 1 2 3
    // 4 5 6
    // 7 8 9
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let n = 0;
    let matrix = [];
    let lineNum = 0;

    rl.on('line', (line) => {
        if (lineNum === 0) {
            n = parseInt(line);
        } else {
            matrix.push(line.split(' ').map(Number));
        }
        lineNum++;

        if (lineNum > n) { // All lines of matrix data read
            rotate(matrix);

            // Print the rotated matrix
            for (let i = 0; i < n; i++) {
                console.log(matrix[i].join(' '));
            }
            rl.close();
        }
    });
}

if (require.main === module) {
    main();
}","#include <iostream>
#include <vector>
#include <algorithm> // For std::swap and std::reverse

// Function to rotate the matrix
void rotate(std::vector<std::vector<int>>& matrix) {
    int n = matrix.size();

    // 1. Transpose the matrix
    for (int i = 0; i < n; i++) {
        for (int j = i + 1; j < n; j++) {
            std::swap(matrix[i][j], matrix[j][i]);
        }
    }

    // 2. Reverse each row
    for (int i = 0; i < n; i++) {
        std::reverse(matrix[i].begin(), matrix[i].end());
    }
}

int main() {
    int n;
    // Input format: first line is N, then N lines of N space-separated integers
    // Example:
    // 3
    // 1 2 3
    // 4 5 6
    // 7 8 9
    std::cin >> n;

    std::vector<std::vector<int>> matrix(n, std::vector<int>(n));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            std::cin >> matrix[i][j];
        }
    }

    // Rotate the matrix
    rotate(matrix);

    // Print the rotated matrix
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            std::cout << matrix[i][j] << (j == n - 1 ? """" : "" "");
        }
        std::cout << std::endl;
    }

    return 0;
}",4.2
Yellow-53,Kadane’s Algorithm,"*   Dynamic Programming
*   Array Traversal
*   Optimization",You are given an array of integers. Your task is to find the contiguous subarray (a subarray containing at least one number) which has the largest sum and return its sum.,"*   1 <= `nums.length` <= 10^5
*   -10^4 <= `nums[i]` <= 10^4","nums = [-2, 1, -3, 4, -1, 2, 1, -5, 4]",6,"Input: 5
1 2 3 4 5
Output: 15
Input: 4
-1 -2 -3 -4
Output: -1
Input: 6
-2 1 -3 5 -1 2
Output: 6
Input: 1
7
Output: 7","#include <stdio.h>
#include <stdlib.h> // For malloc, free

int max(int a, int b) {
    return (a > b) ? a : b;
}

int maxSubArray(int* nums, int numsSize) {
    if (numsSize == 0) {
        // According to constraints, numsSize will be at least 1.
        // If allowed, returning 0 or handling as error would be appropriate.
        return 0; 
    }

    int max_so_far = nums[0];
    int current_max = nums[0];

    for (int i = 1; i < numsSize; i++) {
        current_max = max(nums[i], current_max + nums[i]);
        max_so_far = max(max_so_far, current_max);
    }

    return max_so_far;
}

int main() {
    int numsSize;
    scanf(""%d"", &numsSize);

    int* nums = (int*)malloc(numsSize * sizeof(int));
    if (nums == NULL) {
        fprintf(stderr, ""Memory allocation failed\n"");
        return 1; 
    }

    for (int i = 0; i < numsSize; i++) {
        scanf(""%d"", &nums[i]);
    }

    int result = maxSubArray(nums, numsSize);
    printf(""%d\n"", result);

    free(nums);
    return 0;
}","def max_sub_array(nums):
    if not nums:
        # According to constraints, nums will have at least 1 element.
        # If allowed, returning 0 or raising a ValueError would be appropriate.
        return 0 

    max_so_far = nums[0]
    current_max = nums[0]

    for i in range(1, len(nums)):
        current_max = max(nums[i], current_max + nums[i])
        max_so_far = max(max_so_far, current_max)

    return max_so_far

if __name__ == ""__main__"":
    nums_size = int(input())
    nums = list(map(int, input().split()))

    result = max_sub_array(nums)
    print(result)","import java.util.Scanner;

public class Solution {

    public int maxSubArray(int[] nums) {
        if (nums == null || nums.length == 0) {
            // According to constraints, nums will have at least 1 element.
            // If allowed, returning 0 or throwing an IllegalArgumentException would be appropriate.
            return 0; 
        }

        int maxSoFar = nums[0];
        int currentMax = nums[0];

        for (int i = 1; i < nums.length; i++) {
            currentMax = Math.max(nums[i], currentMax + nums[i]);
            maxSoFar = Math.max(maxSoFar, currentMax);
        }

        return maxSoFar;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int numsSize = scanner.nextInt();
        int[] nums = new int[numsSize];
        for (int i = 0; i < numsSize; i++) {
            nums[i] = scanner.nextInt();
        }
        scanner.close();

        Solution sol = new Solution();
        int result = sol.maxSubArray(nums);
        System.out.println(result);
    }
}","function maxSubArray(nums) {
    if (!nums || nums.length === 0) {
        // According to constraints, nums will have at least 1 element.
        // If allowed, returning 0 or throwing an error would be appropriate.
        return 0; 
    }

    let maxSoFar = nums[0];
    let currentMax = nums[0];

    for (let i = 1; i < nums.length; i++) {
        currentMax = Math.max(nums[i], currentMax + nums[i]);
        maxSoFar = Math.max(maxSoFar, currentMax);
    }

    return maxSoFar;
}

// Handle input/output for competitive programming environment
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let inputLines = [];
    rl.on('line', (line) => {
        inputLines.push(line);
    }).on('close', () => {
        const numsSize = parseInt(inputLines[0], 10);
        const nums = inputLines[1].split(' ').map(Number);

        const result = maxSubArray(nums);
        console.log(result);
    });
}

main();","#include <iostream>
#include <vector>
#include <algorithm> // For std::max

int maxSubArray(const std::vector<int>& nums) {
    if (nums.empty()) {
        // According to constraints, nums will have at least 1 element.
        // If allowed, returning 0 or throwing an exception would be appropriate.
        return 0; 
    }

    int max_so_far = nums[0];
    int current_max = nums[0];

    for (size_t i = 1; i < nums.size(); ++i) {
        current_max = std::max(nums[i], current_max + nums[i]);
        max_so_far = std::max(max_so_far, current_max);
    }

    return max_so_far;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int numsSize;
    std::cin >> numsSize;

    std::vector<int> nums(numsSize);
    for (int i = 0; i < numsSize; ++i) {
        std::cin >> nums[i];
    }

    int result = maxSubArray(nums);
    std::cout << result << std::endl;

    return 0;
}",4.4
Yellow-54,Infix to Postfix Conversion,"*   **Stacks**: LIFO (Last-In, First-Out) data structure.
*   **Operator Precedence**: The rules that define the order in which operations are performed (e.g., multiplication before addition).
*   **Associativity**: The rule for operators with the same precedence (e.g., `a - b - c` is `(a - b) - c`).
*   **Algorithm Design**: Developing a step-by-step procedure to solve a problem.
*   **String Manipulation**: Processing and building strings.","In computer science, expressions can be written in various notations. Two common ones are **Infix** and **Postfix** (also known as Reverse Polish Notation or RPN). Infix notation is what we commonly use in mathematics, where operators are placed *between* their operands (e.g., `A + B`). Postfix notation places operators *after* their operands (e.g., `A B +`).

Converting an infix expression to its postfix equivalent is a fundamental problem that highlights the power of stacks in managing operator precedence and associativity. Your task is to implement a program that takes an infix expression as input and returns its postfix representation.","*   The input `infixExpression` will be a string consisting of single-character operands (uppercase English letters A-Z), and the operators `+`, `-`, `*`, `/`, and parentheses `(` `)`. 
*   The input expression will be valid and well-formed (no missing operands, no unmatched parentheses, etc.).
*   The length of the `infixExpression` will be between 1 and 100 characters.
*   Operators `*` and `/` have higher precedence than `+` and `-`.
*   All operators are left-associative.",A+B*C,"ABC*+


**","Input: (A+B)*C
Output: AB+C*
Input: A*(B+C)/D
Output: ABC+*D/
Input: X-Y/Z+M*N
Output: XYZ/-MN*+
Input: P+Q/(R-S)*T
Output: PQRS-/T*+","#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <stdbool.h>

#define MAX_STACK_SIZE 101 // Max expression length + 1

typedef struct {
    char items[MAX_STACK_SIZE];
    int top;
} Stack;

void initStack(Stack* s) {
    s->top = -1;
}

bool isEmpty(Stack* s) {
    return s->top == -1;
}

void push(Stack* s, char value) {
    if (s->top == MAX_STACK_SIZE - 1) {
        // Stack overflow, should not happen with valid constraints
        return;
    }
    s->items[++(s->top)] = value;
}

char pop(Stack* s) {
    if (s->top == -1) {
        // Stack underflow, should not happen with valid logic
        return '\0'; // Or handle error appropriately
    }
    return s->items[(s->top)--];
}

char peek(Stack* s) {
    if (s->top == -1) {
        return '\0'; // Or handle error appropriately
    }
    return s->items[s->top];
}

int getPrecedence(char op) {
    switch (op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        default:
            return 0; // For operands, parentheses
    }
}

char* infixToPostfix(const char* infixExpression) {
    Stack operatorStack;
    initStack(&operatorStack);

    int len = strlen(infixExpression);
    char* postfixResult = (char*)malloc(sizeof(char) * (len + 1));
    if (postfixResult == NULL) {
        fprintf(stderr, ""Memory allocation failed\n"");
        exit(EXIT_FAILURE);
    }
    int k = 0; // Index for postfixResult

    for (int i = 0; i < len; i++) {
        char ch = infixExpression[i];

        if ((ch >= 'A' && ch <= 'Z') || (ch >= '0' && ch <= '9')) {
            // Operand
            postfixResult[k++] = ch;
        } else if (ch == '(') {
            push(&operatorStack, ch);
        } else if (ch == ')') {
            while (!isEmpty(&operatorStack) && peek(&operatorStack) != '(') {
                postfixResult[k++] = pop(&operatorStack);
            }
            if (!isEmpty(&operatorStack) && peek(&operatorStack) == '(') {
                pop(&operatorStack); // Pop '('
            }
        } else { // Operator
            while (!isEmpty(&operatorStack) && peek(&operatorStack) != '(' && 
                   getPrecedence(peek(&operatorStack)) >= getPrecedence(ch)) {
                postfixResult[k++] = pop(&operatorStack);
            }
            push(&operatorStack, ch);
        }
    }

    // Pop any remaining operators from the stack
    while (!isEmpty(&operatorStack)) {
        postfixResult[k++] = pop(&operatorStack);
    }

    postfixResult[k] = '\0'; // Null-terminate the string
    return postfixResult;
}

int main() {
    char infix[MAX_STACK_SIZE];
    if (scanf(""%s"", infix) != 1) {
        fprintf(stderr, ""Failed to read input\n"");
        return 1;
    }

    char* postfix = infixToPostfix(infix);
    printf(""%s\n"", postfix);

    free(postfix); // Free allocated memory

    return 0;
}","def get_precedence(op):
    if op == '+' or op == '-':
        return 1
    elif op == '*' or op == '/':
        return 2
    else:
        return 0  # For operands, parentheses

def infix_to_postfix(infix_expression):
    postfix_result = []
    operator_stack = []

    for char in infix_expression:
        if 'A' <= char <= 'Z' or 'a' <= char <= 'z' or '0' <= char <= '9':
            # Operand
            postfix_result.append(char)
        elif char == '(':{
            operator_stack.append(char)
        }elif char == ')':
            while operator_stack and operator_stack[-1] != '(':{
                postfix_result.append(operator_stack.pop())
            }if operator_stack and operator_stack[-1] == '(':
                operator_stack.pop()  # Pop '('
        else:  # Operator
            while operator_stack and operator_stack[-1] != '(' and \
                  get_precedence(operator_stack[-1]) >= get_precedence(char):
                postfix_result.append(operator_stack.pop())
            operator_stack.append(char)
    
    # Pop any remaining operators from the stack
    while operator_stack:
        postfix_result.append(operator_stack.pop())

    return """".join(postfix_result)

if __name__ == ""__main__"":
    infix = input()
    postfix = infix_to_postfix(infix)
    print(postfix)","import java.util.Scanner;
import java.util.Stack;

public class InfixToPostfix {

    // Function to get precedence of operators
    private static int getPrecedence(char op) {
        switch (op) {
            case '+':
            case '-':
                return 1;
            case '*':
            case '/':
                return 2;
            default:
                return 0; // For operands, parentheses
        }
    }

    public static String infixToPostfix(String infixExpression) {
        StringBuilder postfixResult = new StringBuilder();
        Stack<Character> operatorStack = new Stack<>();

        for (char ch : infixExpression.toCharArray()) {
            if (Character.isLetterOrDigit(ch)) {
                // Operand
                postfixResult.append(ch);
            } else if (ch == '(') {
                operatorStack.push(ch);
            } else if (ch == ')') {
                while (!operatorStack.isEmpty() && operatorStack.peek() != '(') {
                    postfixResult.append(operatorStack.pop());
                }
                if (!operatorStack.isEmpty() && operatorStack.peek() == '(') {
                    operatorStack.pop(); // Pop '('
                }
            } else { // Operator
                while (!operatorStack.isEmpty() && operatorStack.peek() != '(' && 
                       getPrecedence(operatorStack.peek()) >= getPrecedence(ch)) {
                    postfixResult.append(operatorStack.pop());
                }
                operatorStack.push(ch);
            }
        }

        // Pop any remaining operators from the stack
        while (!operatorStack.isEmpty()) {
            postfixResult.append(operatorStack.pop());
        }

        return postfixResult.toString();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String infix = scanner.nextLine();
        String postfix = infixToPostfix(infix);
        System.out.println(postfix);
        scanner.close();
    }
}","const readline = require('readline');

// Function to get precedence of operators
function getPrecedence(op) {
    switch (op) {
        case '+':
        case '-':
            return 1;
        case '*':
        case '/':
            return 2;
        default:
            return 0; // For operands, parentheses
    }
}

function infixToPostfix(infixExpression) {
    let postfixResult = [];
    let operatorStack = [];

    for (let i = 0; i < infixExpression.length; i++) {
        let ch = infixExpression[i];

        if (/[a-zA-Z0-9]/.test(ch)) {
            // Operand (letter or digit)
            postfixResult.push(ch);
        } else if (ch === '(') {
            operatorStack.push(ch);
        } else if (ch === ')') {
            while (operatorStack.length > 0 && operatorStack[operatorStack.length - 1] !== '(') {
                postfixResult.push(operatorStack.pop());
            }
            if (operatorStack.length > 0 && operatorStack[operatorStack.length - 1] === '(') {
                operatorStack.pop(); // Pop '('
            }
        } else { // Operator
            while (operatorStack.length > 0 && operatorStack[operatorStack.length - 1] !== '(' && 
                   getPrecedence(operatorStack[operatorStack.length - 1]) >= getPrecedence(ch)) {
                postfixResult.push(operatorStack.pop());
            }
            operatorStack.push(ch);
        }
    }

    // Pop any remaining operators from the stack
    while (operatorStack.length > 0) {
        postfixResult.push(operatorStack.pop());
    }

    return postfixResult.join('');
}

// Main function to handle input/output
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.on('line', (line) => {
    const infix = line.trim();
    const postfix = infixToPostfix(infix);
    console.log(postfix);
    rl.close();
});","#include <iostream>
#include <string>
#include <stack>
#include <map>

// Function to get precedence of operators
int getPrecedence(char op) {
    if (op == '+' || op == '-') {
        return 1;
    } else if (op == '*' || op == '/') {
        return 2;
    } else {
        return 0; // For operands, parentheses
    }
}

std::string infixToPostfix(const std::string& infixExpression) {
    std::string postfixResult = """";
    std::stack<char> operatorStack;

    for (char& ch : infixExpression) {
        if (isalnum(ch)) {
            // Operand (letter or digit)
            postfixResult += ch;
        } else if (ch == '(') {
            operatorStack.push(ch);
        } else if (ch == ')') {
            while (!operatorStack.empty() && operatorStack.top() != '(') {
                postfixResult += operatorStack.top();
                operatorStack.pop();
            }
            if (!operatorStack.empty() && operatorStack.top() == '(') {
                operatorStack.pop(); // Pop '('
            }
        } else { // Operator
            while (!operatorStack.empty() && operatorStack.top() != '(' && 
                   getPrecedence(operatorStack.top()) >= getPrecedence(ch)) {
                postfixResult += operatorStack.top();
                operatorStack.pop();
            }
            operatorStack.push(ch);
        }
    }

    // Pop any remaining operators from the stack
    while (!operatorStack.empty()) {
        postfixResult += operatorStack.top();
        operatorStack.pop();
    }

    return postfixResult;
}

int main() {
    std::string infix;
    std::cin >> infix;

    std::string postfix = infixToPostfix(infix);
    std::cout << postfix << std::endl;

    return 0;
}",4.2
Yellow-55,Prefix & Suffix Sums,"*   Prefix Sums
*   Array Traversal
*   Time Complexity Optimization for repeated queries","Given an array of integers `nums`, your task is to design a system that can efficiently calculate the sum of elements between specified indices `i` and `j` (inclusive), where `i <= j`. You will receive multiple such queries for the same array. This means you should pre-process the array to make each sum query as fast as possible.","*   `1 <= nums.length <= 10^4`
*   `-1000 <= nums[k] <= 1000`
*   `0 <= i <= j < nums.length`
*   `1 <= num_queries <= 10^4`
*   The sum of elements will fit within a 64-bit signed integer (long in Java/C++, long long in C).","6
-2 0 3 -5 2 -1
3
0 2
2 5
0 5

Explanation:
*   The array `nums` is `[-2, 0, 3, -5, 2, -1]`. Its length is 6.
*   There are 3 queries.
*   Query 1: `(0, 2)` -> Sum of `nums[0]` through `nums[2]` is `(-2 + 0 + 3) = 1`
*   Query 2: `(2, 5)` -> Sum of `nums[2]` through `nums[5]` is `(3 + -5 + 2 + -1) = -1`
*   Query 3: `(0, 5)` -> Sum of `nums[0]` through `nums[5]` is `(-2 + 0 + 3 + -5 + 2 + -1) = -3`

####","1
-1
-3","Input: 5
1 2 3 4 5
3
0 0
0 4
2 3
Output: 1
15
7
Input: 1
10
1
0 0
Output: 10
Input: 5
-1 -2 -3 -4 -5
2
0 1
2 4
Output: -3
-12
Input: 6
7 1 5 3 6 4
2
0 5
1 3
Output: 26
9","#include <stdio.h>
#include <stdlib.h>

// Function to precompute prefix sums
void computePrefixSums(int* nums, int numsSize, long long* prefixSums) {
    prefixSums[0] = 0;
    for (int i = 0; i < numsSize; i++) {
        prefixSums[i + 1] = prefixSums[i] + nums[i];
    }
}

// Function to calculate sum of a range
long long sumRange(long long* prefixSums, int i, int j) {
    return prefixSums[j + 1] - prefixSums[i];
}

int main() {
    int numsSize;
    scanf(""%d"", &numsSize);

    int* nums = (int*)malloc(numsSize * sizeof(int));
    if (nums == NULL) {
        return 1; // Error allocating memory
    }

    for (int i = 0; i < numsSize; i++) {
        scanf(""%d"", &nums[i]);
    }

    // Allocate memory for prefix sums array (size numsSize + 1)
    long long* prefixSums = (long long*)malloc((numsSize + 1) * sizeof(long long));
    if (prefixSums == NULL) {
        free(nums);
        return 1; // Error allocating memory
    }

    computePrefixSums(nums, numsSize, prefixSums);

    int numQueries;
    scanf(""%d"", &numQueries);

    for (int q = 0; q < numQueries; q++) {
        int i, j;
        scanf(""%d %d"", &i, &j);
        printf(""%lld\n"", sumRange(prefixSums, i, j));
    }

    free(nums);
    free(prefixSums);

    return 0;
}","class NumArray:
    def __init__(self, nums: list[int]):
        self.prefix_sums = [0] * (len(nums) + 1)
        for i in range(len(nums)):
            self.prefix_sums[i + 1] = self.prefix_sums[i] + nums[i]

    def sumRange(self, i: int, j: int) -> int:
        return self.prefix_sums[j + 1] - self.prefix_sums[i]

def main():
    nums_size = int(input())
    nums = list(map(int, input().split()))

    obj = NumArray(nums)

    num_queries = int(input())
    results = []
    for _ in range(num_queries):
        i, j = map(int, input().split())
        results.append(str(obj.sumRange(i, j)))
    
    print(""\n"".join(results))

if __name__ == ""__main__"":
    main()","import java.util.Scanner;

class NumArray {
    private long[] prefixSums;

    // Constructor to precompute prefix sums
    public NumArray(int[] nums) {
        prefixSums = new long[nums.length + 1];
        prefixSums[0] = 0;
        for (int i = 0; i < nums.length; i++) {
            prefixSums[i + 1] = prefixSums[i] + nums[i];
        }
    }

    // Function to calculate sum of a range
    public long sumRange(int i, int j) {
        return prefixSums[j + 1] - prefixSums[i];
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int numsSize = scanner.nextInt();
        int[] nums = new int[numsSize];
        for (int i = 0; i < numsSize; i++) {
            nums[i] = scanner.nextInt();
        }

        NumArray obj = new NumArray(nums); // Create object, precomputes prefix sums

        int numQueries = scanner.nextInt();
        for (int q = 0; q < numQueries; q++) {
            int i = scanner.nextInt();
            int j = scanner.nextInt();
            System.out.println(obj.sumRange(i, j));
        }

        scanner.close();
    }
}","class NumArray {
    /**
     * @param {number[]} nums
     */
    constructor(nums) {
        this.prefixSums = new Array(nums.length + 1).fill(0);
        for (let i = 0; i < nums.length; i++) {
            this.prefixSums[i + 1] = this.prefixSums[i] + nums[i];
        }
    }

    /**
     * @param {number} i
     * @param {number} j
     * @return {number}
     */
    sumRange(i, j) {
        return this.prefixSums[j + 1] - this.prefixSums[i];
    }
}

function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let lines = [];
    rl.on('line', (line) => {
        lines.push(line);
    }).on('close', () => {
        let lineIdx = 0;

        const numsSize = parseInt(lines[lineIdx++]);
        const nums = lines[lineIdx++].split(' ').map(Number);

        const obj = new NumArray(nums);

        const numQueries = parseInt(lines[lineIdx++]);
        let results = [];
        for (let q = 0; q < numQueries; q++) {
            const [i, j] = lines[lineIdx++].split(' ').map(Number);
            results.push(obj.sumRange(i, j));
        }
        console.log(results.join('\n'));
    });
}

main();","#include <iostream>
#include <vector>

// Class to encapsulate the logic
class NumArray {
private:
    std::vector<long long> prefixSums;

public:
    // Constructor to precompute prefix sums
    NumArray(const std::vector<int>& nums) {
        prefixSums.resize(nums.size() + 1, 0);
        for (int i = 0; i < nums.size(); ++i) {
            prefixSums[i + 1] = prefixSums[i] + nums[i];
        }
    }

    // Function to calculate sum of a range
    long long sumRange(int i, int j) {
        return prefixSums[j + 1] - prefixSums[i];
    }
};

int main() {
    std::ios_base::sync_with_stdio(false); // Optimize C++ standard streams
    std::cin.tie(NULL);

    int numsSize;
    std::cin >> numsSize;

    std::vector<int> nums(numsSize);
    for (int i = 0; i < numsSize; ++i) {
        std::cin >> nums[i];
    }

    NumArray obj(nums); // Create object, precomputes prefix sums

    int numQueries;
    std::cin >> numQueries;

    for (int q = 0; q < numQueries; ++q) {
        int i, j;
        std::cin >> i >> j;
        std::cout << obj.sumRange(i, j) << ""\n"";
    }

    return 0;
}",4.4
Yellow-56,Frequency Count / Anagrams,"*   String Manipulation
*   Frequency Counting
*   Arrays","An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. For example, ""listen"" is an anagram of ""silent"".

Your task is to write a function that determines if two given strings, `s1` and `s2`, are anagrams of each other.","*   `s1` and `s2` consist of lowercase English letters.
*   `1 <= s1.length, s2.length <= 1000`","s1 = ""listen""
s2 = ""silent""","true

**Example 2:**","Input: apple aple
Output: false
Input: aabbcc abcabc
Output: true
Input: anagram nagaram
Output: true
Input: rat car
Output: false
Input: topcoder coderpot
Output: true","#include <stdio.h>
#include <string.h>
#include <stdbool.h>
#include <stdlib.h>

// Function to check if two strings are anagrams
bool areAnagrams(const char* s1, const char* s2) {
    int len1 = strlen(s1);
    int len2 = strlen(s2);

    if (len1 != len2) {
        return false;
    }

    int freq[26] = {0}; // Frequency array for lowercase English letters

    // Increment counts for characters in s1
    for (int i = 0; i < len1; i++) {
        freq[s1[i] - 'a']++;
    }

    // Decrement counts for characters in s2
    for (int i = 0; i < len2; i++) {
        freq[s2[i] - 'a']--;
    }

    // Check if all counts in the frequency array are zero
    for (int i = 0; i < 26; i++) {
        if (freq[i] != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    char s1_buffer[1001]; // Max length 1000 + null terminator
    char s2_buffer[1001];

    // Read input strings
    if (scanf(""%s %s"", s1_buffer, s2_buffer) != 2) {
        fprintf(stderr, ""Error reading input.\n"");
        return 1;
    }

    // Call the core logic function
    if (areAnagrams(s1_buffer, s2_buffer)) {
        printf(""true\n"");
    } else {
        printf(""false\n"");
    }

    return 0;
}","import sys

def are_anagrams(s1: str, s2: str) -> bool:
    if len(s1) != len(s2):
        return False

    freq = [0] * 26  # Frequency list for lowercase English letters

    # Increment counts for characters in s1
    for char_code in map(ord, s1):
        freq[char_code - ord('a')] += 1

    # Decrement counts for characters in s2
    for char_code in map(ord, s2):
        freq[char_code - ord('a')] -= 1

    # Check if all counts in the frequency list are zero
    for count in freq:
        if count != 0:
            return False

    return True

if __name__ == ""__main__"":
    # Read input strings from stdin
    # Assuming input will be two space-separated strings on one line
    try:
        s1, s2 = sys.stdin.readline().strip().split()
    except ValueError:
        print(""Error: Please provide two space-separated strings."", file=sys.stderr)
        sys.exit(1)

    # Call the core logic function
    result = are_anagrams(s1, s2)
    print(str(result).lower()) # Print ""true"" or ""false"" in lowercase","import java.util.Scanner;

public class AnagramChecker {

    // Function to check if two strings are anagrams
    public static boolean areAnagrams(String s1, String s2) {
        if (s1.length() != s2.length()) {
            return false;
        }

        int[] freq = new int[26]; // Frequency array for lowercase English letters

        // Increment counts for characters in s1
        for (char c : s1.toCharArray()) {
            freq[c - 'a']++;
        }

        // Decrement counts for characters in s2
        for (char c : s2.toCharArray()) {
            freq[c - 'a']--;
        }

        // Check if all counts in the frequency array are zero
        for (int count : freq) {
            if (count != 0) {
                return false;
            }
        }

        return true;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read input strings
        String s1 = scanner.next();
        String s2 = scanner.next();

        // Call the core logic function
        if (areAnagrams(s1, s2)) {
            System.out.println(""true"");
        } else {
            System.out.println(""false"");
        }

        scanner.close();
    }
}","function areAnagrams(s1, s2) {
    if (s1.length !== s2.length) {
        return false;
    }

    const freq = new Array(26).fill(0); // Frequency array for lowercase English letters

    // Increment counts for characters in s1
    for (let i = 0; i < s1.length; i++) {
        freq[s1.charCodeAt(i) - 'a'.charCodeAt(0)]++;
    }

    // Decrement counts for characters in s2
    for (let i = 0; i < s2.length; i++) {
        freq[s2.charCodeAt(i) - 'a'.charCodeAt(0)]--;
    }

    // Check if all counts in the frequency array are zero
    for (let i = 0; i < freq.length; i++) {
        if (freq[i] !== 0) {
            return false;
        }
    }

    return true;
}

// Function to handle input and output for the problem
function main() {
    // Read input from stdin
    // Assuming input is two space-separated strings on a single line
    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim();
    const [s1, s2] = input.split(' ');

    // Call the core logic function
    const result = areAnagrams(s1, s2);
    console.log(result.toString()); // Output ""true"" or ""false""
}

// Ensure main is called when the script runs
main();","#include <iostream>
#include <string>
#include <vector>

// Function to check if two strings are anagrams
bool areAnagrams(const std::string& s1, const std::string& s2) {
    if (s1.length() != s2.length()) {
        return false;
    }

    std::vector<int> freq(26, 0); // Frequency vector for lowercase English letters

    // Increment counts for characters in s1
    for (char c : s1) {
        freq[c - 'a']++;
    }

    // Decrement counts for characters in s2
    for (char c : s2) {
        freq[c - 'a']--;
    }

    // Check if all counts in the frequency vector are zero
    for (int count : freq) {
        if (count != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    std::string s1, s2;

    // Read input strings
    std::cin >> s1 >> s2;

    // Call the core logic function
    if (areAnagrams(s1, s2)) {
        std::cout << ""true"" << std::endl;
    } else {
        std::cout << ""false"" << std::endl;
    }

    return 0;
}",3.8
Yellow-57,Frequency Count / Anagrams,"*   Frequency Counting
*   Arrays (as frequency counters)
*   String Manipulation
*   Basic Conditional Logic","An anagram is a word or phrase formed by rearranging the letters of a different word or phrase, typically using all the original letters exactly once. For example, ""listen"" is an anagram of ""silent"".

Your task is to implement a function that determines whether two given strings are anagrams of each other. For this problem, we will assume the input strings contain only lowercase English letters and the comparison should be case-sensitive.","*   The input strings `s1` and `s2` will consist only of lowercase English letters ('a'-'z').
*   The length of each string will be between 0 and 1000 characters, inclusive.","**
s1 = ""listen""
s2 = ""silent""

**","**
true

**","Input: race
Output: true
Input: topcoder
Output: false
Input: apple
Output: false
Input: mom
Output: true
Input: 
Output: true","#include <stdio.h>
#include <string.h>
#include <stdbool.h>

// Function to check if two strings are anagrams
bool areAnagrams(const char* s1, const char* s2) {
    int len1 = strlen(s1);
    int len2 = strlen(s2);

    // If lengths are different, they cannot be anagrams
    if (len1 != len2) {
        return false;
    }

    // Frequency array for lowercase English letters
    // 'a' through 'z' (26 characters)
    int freq[26] = {0};

    // Populate frequencies for s1
    for (int i = 0; i < len1; i++) {
        freq[s1[i] - 'a']++;
    }

    // Decrement frequencies for s2
    for (int i = 0; i < len2; i++) {
        freq[s2[i] - 'a']--;
    }

    // Check if all frequencies are zero
    for (int i = 0; i < 26; i++) {
        if (freq[i] != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    char s1[1001]; // Max length 1000 + null terminator
    char s2[1001];

    // Read the first string
    // fgets reads the newline character if present, need to remove it
    if (fgets(s1, sizeof(s1), stdin) != NULL) {
        s1[strcspn(s1, ""\n"")] = 0; // Remove newline
    } else {
        return 1; // Error reading input
    }

    // Read the second string
    if (fgets(s2, sizeof(s2), stdin) != NULL) {
        s2[strcspn(s2, ""\n"")] = 0; // Remove newline
    } else {
        return 1; // Error reading input
    }

    if (areAnagrams(s1, s2)) {
        printf(""true\n"");
    } else {
        printf(""false\n"");
    }

    return 0;
}","def are_anagrams(s1: str, s2: str) -> bool:
    """"""
    Checks if two strings are anagrams of each other.
    Assumes strings contain only lowercase English letters.
    """"""
    # If lengths are different, they cannot be anagrams
    if len(s1) != len(s2):
        return False

    # Frequency array (list) for lowercase English letters
    # 'a' through 'z' (26 characters)
    freq = [0] * 26

    # Populate frequencies for s1
    for char_code in map(ord, s1):
        freq[char_code - ord('a')] += 1

    # Decrement frequencies for s2
    for char_code in map(ord, s2):
        freq[char_code - ord('a')] -= 1

    # Check if all frequencies are zero
    for count in freq:
        if count != 0:
            return False

    return True

if __name__ == ""__main__"":
    # Read the first string
    s1 = input()

    # Read the second string
    s2 = input()

    if are_anagrams(s1, s2):
        print(""true"")
    else:
        print(""false"")","import java.util.Scanner;

public class AnagramChecker {

    // Function to check if two strings are anagrams
    public static boolean areAnagrams(String s1, String s2) {
        // If lengths are different, they cannot be anagrams
        if (s1.length() != s2.length()) {
            return false;
        }

        // Frequency array for lowercase English letters
        // 'a' through 'z' (26 characters)
        int[] freq = new int[26];
        // Java initializes int arrays to 0 by default, so no explicit fill needed

        // Populate frequencies for s1
        for (char c : s1.toCharArray()) {
            freq[c - 'a']++;
        }

        // Decrement frequencies for s2
        for (char c : s2.toCharArray()) {
            freq[c - 'a']--;
        }

        // Check if all frequencies are zero
        for (int count : freq) {
            if (count != 0) {
                return false;
            }
        }

        return true;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        // Read the first string
        String s1 = scanner.nextLine();

        // Read the second string
        String s2 = scanner.nextLine();

        if (areAnagrams(s1, s2)) {
            System.out.println(""true"");
        } else {
            System.out.println(""false"");
        }

        scanner.close();
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let lines = [];
rl.on('line', (line) => {
    lines.push(line);
}).on('close', () => {
    const s1 = lines[0];
    const s2 = lines[1];

    if (areAnagrams(s1, s2)) {
        console.log(""true"");
    } else {
        console.log(""false"");
    }
});

// Function to check if two strings are anagrams
function areAnagrams(s1, s2) {
    // If lengths are different, they cannot be anagrams
    if (s1.length !== s2.length) {
        return false;
    }

    // Frequency array for lowercase English letters
    // 'a' through 'z' (26 characters)
    const freq = new Array(26).fill(0);

    // Populate frequencies for s1
    for (let i = 0; i < s1.length; i++) {
        freq[s1.charCodeAt(i) - 'a'.charCodeAt(0)]++;
    }

    // Decrement frequencies for s2
    for (let i = 0; i < s2.length; i++) {
        freq[s2.charCodeAt(i) - 'a'.charCodeAt(0)]--;
    }

    // Check if all frequencies are zero
    for (let i = 0; i < 26; i++) {
        if (freq[i] !== 0) {
            return false;
        }
    }

    return true;
}","#include <iostream>
#include <string>
#include <vector>

// Function to check if two strings are anagrams
bool areAnagrams(const std::string& s1, const std::string& s2) {
    // If lengths are different, they cannot be anagrams
    if (s1.length() != s2.length()) {
        return false;
    }

    // Frequency array for lowercase English letters
    // 'a' through 'z' (26 characters)
    std::vector<int> freq(26, 0);

    // Populate frequencies for s1
    for (char c : s1) {
        freq[c - 'a']++;
    }

    // Decrement frequencies for s2
    for (char c : s2) {
        freq[c - 'a']--;
    }

    // Check if all frequencies are zero
    for (int count : freq) {
        if (count != 0) {
            return false;
        }
    }

    return true;
}

int main() {
    std::string s1, s2;

    // Read the first string
    std::getline(std::cin, s1);

    // Read the second string
    std::getline(std::cin, s2);

    if (areAnagrams(s1, s2)) {
        std::cout << ""true"" << std::endl;
    } else {
        std::cout << ""false"" << std::endl;
    }

    return 0;
}",4.2
White-103,Basic String Manipulation,"- Basic string input/output
- String iteration
- Character access in strings
- Building a new string","Write a program that takes a single word or sentence as input and prints its characters in reverse order. For example, if the input is ""hello"", the output should be ""olleh"".","- The input string will consist of printable ASCII characters.
- The length of the string will be between 1 and 1000 characters.",`world`,`dlrow`,"Input: programming
Output: gnimmargorp
Input: a
Output: a
Input: level
Output: level
Input: 12345
Output: 54321
Input: hello world
Output: dlrow olleh","#include <stdio.h>
#include <string.h>
#include <stdlib.h>

// Function to reverse a string
char* reverseString(const char* s) {
    int length = strlen(s);
    char* reversed_s = (char*)malloc(sizeof(char) * (length + 1)); // +1 for null terminator
    if (reversed_s == NULL) {
        // Handle allocation error
        return NULL;
    }

    for (int i = 0; i < length; i++) {
        reversed_s[i] = s[length - 1 - i];
    }
    reversed_s[length] = '\0'; // Null-terminate the new string

    return reversed_s;
}

int main() {
    char input_buffer[1002]; // Max 1000 chars + newline + null terminator
    
    // Read input string, including spaces
    if (fgets(input_buffer, sizeof(input_buffer), stdin) != NULL) {
        // Remove trailing newline character, if present
        input_buffer[strcspn(input_buffer, ""\n"")] = 0;

        char* reversed = reverseString(input_buffer);
        if (reversed != NULL) {
            printf(""%s\n"", reversed);
            free(reversed); // Free the dynamically allocated memory
        }
    }

    return 0;
}","def reverse_string(s: str) -> str:
    reversed_chars = []
    for i in range(len(s) - 1, -1, -1):
        reversed_chars.append(s[i])
    return """".join(reversed_chars)

if __name__ == ""__main__"":
    input_s = input() # Read a line from stdin
    result = reverse_string(input_s)
    print(result)","import java.util.Scanner;

public class Main {

    // Function to reverse a string
    public static String reverseString(String s) {
        StringBuilder sb = new StringBuilder();
        for (int i = s.length() - 1; i >= 0; i--) {
            sb.append(s.charAt(i));
        }
        return sb.toString();
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        String inputString = scanner.nextLine(); // Read entire line
        
        String reversed = reverseString(inputString);
        System.out.println(reversed);
        
        scanner.close();
    }
}","function reverseString(s) {
    let reversed_s = """";
    for (let i = s.length - 1; i >= 0; i--) {
        reversed_s += s[i];
    }
    return reversed_s;
}

// Node.js specific for reading input
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.on('line', (input) => {
    const result = reverseString(input);
    console.log(result);
    rl.close();
});","#include <iostream>
#include <string>

// Function to reverse a string
std::string reverseString(const std::string& s) {
    std::string reversed_s = """";
    for (int i = s.length() - 1; i >= 0; --i) {
        reversed_s += s[i];
    }
    return reversed_s;
}

int main() {
    std::string input_s;
    std::getline(std::cin, input_s); // Read entire line

    std::string reversed = reverseString(input_s);
    std::cout << reversed << std::endl;

    return 0;
}",4.4
Yellow-58,Intro to Backtracking,"*   **Backtracking**: A general algorithm for finding all (or some) solutions to computational problems, that incrementally builds candidates to the solutions, and abandons a candidate (""backtracks"") as soon as it determines that the candidate cannot possibly be completed to a valid solution.
*   **Recursion**: A method where the solution to a problem depends on solutions to smaller instances of the same problem.
*   **Decision Tree**: Visualizing the choices made at each step of the algorithm as a tree structure, where each node represents a decision point (e.g., include or exclude an element).
*   **Time and Space Complexity Analysis**: Understanding how the resources consumed by an algorithm scale with input size.","Given an array of distinct integers `nums`, return all possible subsets (the power set). The solution set must not contain duplicate subsets. The order of the subsets or the elements within a subset does not matter.","*   `1 <= nums.length <= 10`
*   `-10 <= nums[i] <= 10`
*   All the integers in `nums` are unique.","`nums = [1, 2, 3]`","1
2
1 2
3
1 3
2 3
1 2 3

(Note: The empty line represents the empty set. The order of subsets in the output may vary.)","Input: 1
5
Output:

5
Input: 2
0 1
Output:

0
1
0 1
Input: 4
7 8 9 10
Output:

7
8
7 8
9
7 9
8 9
7 8 9
10
7 10
8 10
7 8 10
9 10
7 9 10
8 9 10
7 8 9 10
Input: 3
-1 0 1
Output:

-1
0
-1 0
1
-1 1
0 1
-1 0 1","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Structure to hold a single subset
typedef struct {
    int* elements;
    int size;
} Subset;

// Global list of all subsets found
Subset* allSubsets = NULL;
int allSubsetsCount = 0;
int allSubsetsCapacity = 0;

// Helper function to add a subset to the global list
void addSubset(int* current_subset, int current_size) {
    if (allSubsetsCount >= allSubsetsCapacity) {
        allSubsetsCapacity = allSubsetsCapacity == 0 ? 1 : allSubsetsCapacity * 2;
        allSubsets = (Subset*)realloc(allSubsets, allSubsetsCapacity * sizeof(Subset));
        if (allSubsets == NULL) {
            perror(""realloc failed"");
            exit(EXIT_FAILURE);
        }
    }
    Subset newSubset;
    newSubset.elements = (int*)malloc(current_size * sizeof(int));
    if (newSubset.elements == NULL) {
        perror(""malloc failed"");
        exit(EXIT_FAILURE);
    }
    memcpy(newSubset.elements, current_subset, current_size * sizeof(int));
    newSubset.size = current_size;
    allSubsets[allSubsetsCount++] = newSubset;
}

// The backtracking logic
void backtrack(int* nums, int numsSize, int index, int* current_subset, int current_size) {
    // Add the current_subset to the result list (base case for each path)
    addSubset(current_subset, current_size);

    for (int i = index; i < numsSize; i++) {
        // Include nums[i]
        current_subset[current_size] = nums[i];
        current_size++;

        // Recurse with the next index
        backtrack(nums, numsSize, i + 1, current_subset, current_size);

        // Exclude nums[i] (backtrack)
        current_size--; // Effectively remove the last element
    }
}

// Main function to find all subsets
Subset* findSubsets(int* nums, int numsSize, int* returnSize) {
    int* current_subset = (int*)malloc(numsSize * sizeof(int)); // Max possible subset size is numsSize
    if (current_subset == NULL) {
        perror(""malloc failed"");
        exit(EXIT_FAILURE);
    }

    // Reset global variables for findSubsets to be callable multiple times (if needed)
    if (allSubsets != NULL) {
        for (int i = 0; i < allSubsetsCount; i++) {
            free(allSubsets[i].elements);
        }
        free(allSubsets);
    }
    allSubsets = NULL;
    allSubsetsCount = 0;
    allSubsetsCapacity = 0;

    backtrack(nums, numsSize, 0, current_subset, 0);

    free(current_subset);

    *returnSize = allSubsetsCount;
    return allSubsets;
}


// --- Main function for I/O ---
int main() {
    int n;
    scanf(""%d"", &n);

    int* nums = (int*)malloc(n * sizeof(int));
    if (nums == NULL) {
        perror(""malloc failed"");
        return EXIT_FAILURE;
    }

    for (int i = 0; i < n; i++) {
        scanf(""%d"", &nums[i]);
    }

    int resultSize;
    Subset* resultSubsets = findSubsets(nums, n, &resultSize);

    // Print the subsets
    for (int i = 0; i < resultSize; i++) {
        for (int j = 0; j < resultSubsets[i].size; j++) {
            printf(""%d%s"", resultSubsets[i].elements[j], (j == resultSubsets[i].size - 1) ? """" : "" "");
        }
        printf(""\n"");
        free(resultSubsets[i].elements); // Free individual subset elements
    }
    free(resultSubsets); // Free the array of Subsets
    free(nums);

    return 0;
}","class Solution:
    def findSubsets(self, nums: list[int]) -> list[list[int]]:
        result = []
        current_subset = []

        # Optional: Sort nums to ensure consistent output order, though not strictly required.
        # nums.sort()

        def backtrack(index):
            # Add a copy of the current_subset to the result list (base case for each path)
            result.append(list(current_subset))

            for i in range(index, len(nums)):
                # Include nums[i]
                current_subset.append(nums[i])

                # Recurse with the next index
                backtrack(i + 1)

                # Exclude nums[i] (backtrack)
                current_subset.pop()

        backtrack(0)
        return result

# --- Main function for I/O ---
if __name__ == ""__main__"":
    n = int(input())
    nums = list(map(int, input().split()))

    sol = Solution()
    result = sol.findSubsets(nums)

    # Print the subsets
    for subset in result:
        print(*subset) # Uses * to unpack the list and print elements space-separated, prints empty line for empty list","import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;
import java.util.Scanner;

class Solution {

    // The backtracking logic
    private void backtrack(int[] nums, int index, List<Integer> currentSubset, List<List<Integer>> result) {
        // Add a copy of the currentSubset to the result list (base case for each path)
        result.add(new ArrayList<>(currentSubset));

        for (int i = index; i < nums.length; i++) {
            // Include nums[i]
            currentSubset.add(nums[i]);

            // Recurse with the next index
            backtrack(nums, i + 1, currentSubset, result);

            // Exclude nums[i] (backtrack)
            currentSubset.remove(currentSubset.size() - 1);
        }
    }

    // Main function to find all subsets
    public List<List<Integer>> findSubsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();

        // Optional: Sort nums to ensure consistent output order, though not strictly required.
        // Arrays.sort(nums);

        backtrack(nums, 0, currentSubset, result);
        return result;
    }
}

// --- Main class for I/O ---
public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        int[] nums = new int[n];
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }

        Solution sol = new Solution();
        List<List<Integer>> result = sol.findSubsets(nums);

        // Print the subsets
        for (List<Integer> subset : result) {
            for (int i = 0; i < subset.size(); i++) {
                System.out.print(subset.get(i) + (i == subset.size() - 1 ? """" : "" ""));
            }
            System.out.println();
        }

        scanner.close();
    }
}","class Solution {
    findSubsets(nums) {
        const result = [];
        const currentSubset = [];

        // Optional: Sort nums to ensure consistent output order, though not strictly required.
        // nums.sort((a, b) => a - b);

        const backtrack = (index) => {
            // Add a copy of the currentSubset to the result list
            result.push([...currentSubset]);

            for (let i = index; i < nums.length; i++) {
                // Include nums[i]
                currentSubset.push(nums[i]);

                // Recurse with the next index
                backtrack(i + 1);

                // Exclude nums[i] (backtrack)
                currentSubset.pop();
            }
        };

        backtrack(0);
        return result;
    }
}

// --- Main function for I/O ---
const main = () => {
    const input = require('fs').readFileSync('/dev/stdin', 'utf8').trim().split('\n');
    let lineIndex = 0;

    const n = parseInt(input[lineIndex++], 10);
    const nums = input[lineIndex++].split(' ').map(Number);

    const sol = new Solution();
    const result = sol.findSubsets(nums);

    // Print the subsets
    for (const subset of result) {
        console.log(subset.join(' ')); // Prints empty string for empty array, resulting in an empty line
    }
};

main();","#include <iostream>
#include <vector>
#include <algorithm> // For std::sort (optional)

// The backtracking logic
void backtrack(const std::vector<int>& nums, int index, std::vector<int>& current_subset, std::vector<std::vector<int>>& result) {
    // Add the current_subset to the result list (base case for each path)
    result.push_back(current_subset);

    for (int i = index; i < nums.size(); ++i) {
        // Include nums[i]
        current_subset.push_back(nums[i]);

        // Recurse with the next index
        backtrack(nums, i + 1, current_subset, result);

        // Exclude nums[i] (backtrack)
        current_subset.pop_back();
    }
}

// Main function to find all subsets
std::vector<std::vector<int>> findSubsets(std::vector<int>& nums) {
    std::vector<std::vector<int>> result;
    std::vector<int> current_subset;

    // Optional: Sort nums to ensure consistent output order, though not strictly required.
    // std::sort(nums.begin(), nums.end());

    backtrack(nums, 0, current_subset, result);
    return result;
}

// --- Main function for I/O ---
int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n;
    std::cin >> n;

    std::vector<int> nums(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> nums[i];
    }

    std::vector<std::vector<int>> result = findSubsets(nums);

    // Print the subsets
    for (const auto& subset : result) {
        for (size_t i = 0; i < subset.size(); ++i) {
            std::cout << subset[i] << (i == subset.size() - 1 ? """" : "" "");
        }
        std::cout << std::endl;
    }

    return 0;
}",4.0
Yellow-59,Prefix & Suffix Sums,"*   Prefix Sums
*   Array Manipulation
*   Time Complexity Optimization
*   Basic I/O Operations","Given an array of integers `nums` and a list of `queries`, your task is to efficiently calculate the sum of elements within specified ranges for each query. Each query consists of two indices, `L` and `R`, representing a 0-indexed range `[L, R]` (inclusive). For each query, you must return the sum of `nums[L]` through `nums[R]` inclusive.","*   `1 <= N <= 10^5` (where `N` is the length of `nums`)
*   `-1000 <= nums[i] <= 1000`
*   `1 <= Q <= 10^5` (where `Q` is the number of queries)
*   `0 <= L <= R < N` for all queries
*   The sum of any range will fit within a standard 32-bit signed integer.","**

5
1 2 3 4 5
2
0 2
2 4


**Explanation:**

`nums = [1, 2, 3, 4, 5]`
`queries = [[0, 2], [2, 4]]`

*   For query `[0, 2]`: `nums[0] + nums[1] + nums[2] = 1 + 2 + 3 = 6`
*   For query `[2, 4]`: `nums[2] + nums[3] + nums[4] = 3 + 4 + 5 = 12`

**","**

6
12","Input: 1
10
1
0 0
Output: 10
Input: 4
0 0 0 0
3
0 0
1 2
0 3
Output: 0
0
0
Input: 5
-1 2 -3 4 -5
3
0 1
1 3
0 4
Output: 1
3
-3
Input: 5
7 1 8 2 9
1
0 4
Output: 27
Input: 6
1 2 3 4 5 6
4
0 2
1 3
2 4
3 5
Output: 6
9
12
15","#include <stdio.h>
#include <stdlib.h>

// Function to calculate range sums using prefix sums
// nums: pointer to the input array
// numsSize: size of the input array
// queries: 2D array of queries, where each query is {L, R}
// queriesSize: number of queries
// returnSize: pointer to an int to store the size of the returned array
// Returns a dynamically allocated array of integers containing the sum for each query
int* solve(int* nums, int numsSize, int** queries, int queriesSize, int* returnSize) {
    if (numsSize == 0) {
        *returnSize = 0;
        return NULL;
    }

    // Allocate memory for prefix sum array (size numsSize + 1)
    int* prefixSums = (int*)calloc(numsSize + 1, sizeof(int));
    if (prefixSums == NULL) {
        // Handle allocation failure
        *returnSize = 0;
        return NULL;
    }

    // Build prefix sum array
    // prefixSums[i] stores the sum of nums[0...i-1]
    for (int i = 0; i < numsSize; i++) {
        prefixSums[i+1] = prefixSums[i] + nums[i];
    }

    // Allocate memory for results array
    int* results = (int*)malloc(queriesSize * sizeof(int));
    if (results == NULL) {
        // Handle allocation failure
        free(prefixSums);
        *returnSize = 0;
        return NULL;
    }

    // Process each query
    for (int i = 0; i < queriesSize; i++) {
        int L = queries[i][0];
        int R = queries[i][1];
        // Sum of nums[L...R] is prefixSums[R+1] - prefixSums[L]
        results[i] = prefixSums[R+1] - prefixSums[L];
    }

    // Clean up allocated memory for prefixSums
    free(prefixSums);
    *returnSize = queriesSize;
    return results;
}

int main() {
    int N;
    scanf(""%d"", &N);

    int* nums = (int*)malloc(N * sizeof(int));
    if (nums == NULL) return 1; // Allocation failed
    for (int i = 0; i < N; i++) {
        scanf(""%d"", &nums[i]);
    }

    int Q;
    scanf(""%d"", &Q);

    int** queries = (int**)malloc(Q * sizeof(int*));
    if (queries == NULL) {
        free(nums);
        return 1; // Allocation failed
    }
    for (int i = 0; i < Q; i++) {
        queries[i] = (int*)malloc(2 * sizeof(int)); // Each query has L and R
        if (queries[i] == NULL) {
            // Free previously allocated queries and nums
            for (int j = 0; j < i; j++) {
                free(queries[j]);
            }
            free(queries);
            free(nums);
            return 1; // Allocation failed
        }
        scanf(""%d %d"", &queries[i][0], &queries[i][1]);
    }

    int returnSize;
    int* results = solve(nums, N, queries, Q, &returnSize);

    for (int i = 0; i < returnSize; i++) {
        printf(""%d\n"", results[i]);
    }

    // Free all dynamically allocated memory
    free(nums);
    for (int i = 0; i < Q; i++) {
        free(queries[i]);
    }
    free(queries);
    free(results);

    return 0;
}","import sys

def solve(nums, queries):
    if not nums:
        return []

    # Build prefix sum array
    # prefix_sums[i] stores the sum of nums[0...i-1]
    prefix_sums = [0] * (len(nums) + 1)
    for i in range(len(nums)):
        prefix_sums[i+1] = prefix_sums[i] + nums[i]

    results = []
    # Process each query
    for L, R in queries:
        # Sum of nums[L...R] is prefix_sums[R+1] - prefix_sums[L]
        results.append(prefix_sums[R+1] - prefix_sums[L])

    return results

if __name__ == '__main__':
    N = int(sys.stdin.readline())
    nums = list(map(int, sys.stdin.readline().split()))

    Q = int(sys.stdin.readline())
    queries = []
    for _ in range(Q):
        L, R = map(int, sys.stdin.readline().split())
        queries.append([L, R])

    results = solve(nums, queries)

    for result in results:
        sys.stdout.write(str(result) + ""\n"")","import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

class Solution {
    public List<Integer> solve(int[] nums, int[][] queries) {
        List<Integer> results = new ArrayList<>();
        if (nums == null || nums.length == 0) {
            return results;
        }

        // Build prefix sum array
        // prefixSums[i] stores the sum of nums[0...i-1]
        int[] prefixSums = new int[nums.length + 1];
        prefixSums[0] = 0;
        for (int i = 0; i < nums.length; i++) {
            prefixSums[i+1] = prefixSums[i] + nums[i];
        }

        // Process each query
        for (int[] query : queries) {
            int L = query[0];
            int R = query[1];
            // Sum of nums[L...R] is prefixSums[R+1] - prefixSums[L]
            results.add(prefixSums[R+1] - prefixSums[L]);
        }

        return results;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int N = scanner.nextInt();
        int[] nums = new int[N];
        for (int i = 0; i < N; i++) {
            nums[i] = scanner.nextInt();
        }

        int Q = scanner.nextInt();
        int[][] queries = new int[Q][2];
        for (int i = 0; i < Q; i++) {
            queries[i][0] = scanner.nextInt();
            queries[i][1] = scanner.nextInt();
        }

        Solution sol = new Solution();
        List<Integer> results = sol.solve(nums, queries);

        for (int result : results) {
            System.out.println(result);
        }

        scanner.close();
    }
}","const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let inputLines = [];
rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    let lineIdx = 0;

    const N = parseInt(inputLines[lineIdx++]);
    const nums = inputLines[lineIdx++].split(' ').map(Number);

    const Q = parseInt(inputLines[lineIdx++]);
    const queries = [];
    for (let i = 0; i < Q; i++) {
        queries.push(inputLines[lineIdx++].split(' ').map(Number));
    }

    const results = solve(nums, queries);

    results.forEach(result => {
        console.log(result);
    });
});


function solve(nums, queries) {
    if (nums.length === 0) {
        return [];
    }

    // Build prefix sum array
    // prefixSums[i] stores the sum of nums[0...i-1]
    const prefixSums = new Array(nums.length + 1).fill(0);
    for (let i = 0; i < nums.length; i++) {
        prefixSums[i+1] = prefixSums[i] + nums[i];
    }

    const results = [];
    // Process each query
    for (const query of queries) {
        const L = query[0];
        const R = query[1];
        // Sum of nums[L...R] is prefixSums[R+1] - prefixSums[L]
        results.push(prefixSums[R+1] - prefixSums[L]);
    }

    return results;
}","#include <iostream>
#include <vector>
#include <numeric> // Optional, but good to know

std::vector<int> solve(const std::vector<int>& nums, const std::vector<std::vector<int>>& queries) {
    if (nums.empty()) {
        return {};
    }

    // Build prefix sum array
    // prefixSums[i] stores the sum of nums[0...i-1]
    std::vector<int> prefixSums(nums.size() + 1, 0);
    for (int i = 0; i < nums.size(); ++i) {
        prefixSums[i+1] = prefixSums[i] + nums[i];
    }

    std::vector<int> results;
    results.reserve(queries.size()); // Pre-allocate memory for efficiency

    // Process each query
    for (const auto& query : queries) {
        int L = query[0];
        int R = query[1];
        // Sum of nums[L...R] is prefixSums[R+1] - prefixSums[L]
        results.push_back(prefixSums[R+1] - prefixSums[L]);
    }

    return results;
}

int main() {
    std::ios_base::sync_with_stdio(false); // Optimize C++ standard streams
    std::cin.tie(NULL);                   // Untie cin from cout

    int N;
    std::cin >> N;

    std::vector<int> nums(N);
    for (int i = 0; i < N; ++i) {
        std::cin >> nums[i];
    }

    int Q;
    std::cin >> Q;

    std::vector<std::vector<int>> queries(Q, std::vector<int>(2));
    for (int i = 0; i < Q; ++i) {
        std::cin >> queries[i][0] >> queries[i][1];
    }

    std::vector<int> results = solve(nums, queries);

    for (int result : results) {
        std::cout << result << ""\n"";
    }

    return 0;
}",4.4
Yellow-60,Intro to Backtracking,"- **Backtracking**: A general algorithm for finding all (or some) solutions to computational problems that incrementally builds candidates to the solutions, and abandons a candidate (""backtracks"") as soon as it determines that the candidate cannot possibly be completed to a valid solution.
- **Recursion**: A method where the solution to a problem depends on solutions to smaller instances of the same problem.
- **Decision Trees**: Visualizing the choices made at each step of the backtracking process helps in understanding how all possibilities are explored.","Given an array `nums` of distinct integers, return all possible subsets (the power set). The solution set must not contain duplicate subsets. The order of subsets or the order of elements within a subset does not matter.","- `1 <= nums.length <= 10`
- `-10 <= nums[i] <= 10`
- All the integers in `nums` are unique.","`nums = [1, 2, 3]`","`[[], [1], [2], [3], [1, 2], [1, 3], [2, 3], [1, 2, 3]]`
(The order of subsets and elements within subsets shown here is just one possible valid output order.)","Input: 0
Output: [[]]
Input: 1
0
Output: [[], [0]]
Input: 2
1 2
Output: [[], [1], [2], [1, 2]]
Input: 3
-1 0 1
Output: [[], [-1], [0], [1], [-1, 0], [-1, 1], [0, 1], [-1, 0, 1]]
Input: 4
4 5 6 7
Output: [[], [4], [5], [6], [7], [4, 5], [4, 6], [4, 7], [5, 6], [5, 7], [6, 7], [4, 5, 6], [4, 5, 7], [4, 6, 7], [5, 6, 7], [4, 5, 6, 7]]","#include <stdio.h>
#include <stdlib.h>

// Helper function to print a single subset
void printSubset(int* subset, int subsetSize) {
    printf(""["");
    for (int i = 0; i < subsetSize; i++) {
        printf(""%d"", subset[i]);
        if (i < subsetSize - 1) {
            printf("", "");
        }
    }
    printf(""]"");
}

// Backtracking function
// current_subset: buffer to hold the current subset elements
// subset_size: current number of elements in current_subset
// nums: input array
// nums_size: size of input array
// index: current index in nums to consider
void backtrack(int* current_subset, int subset_size, int* nums, int nums_size, int index) {
    // Base case: All elements considered
    if (index == nums_size) {
        printSubset(current_subset, subset_size);
        printf(""\n"");
        return;
    }

    // Decision 1: Exclude nums[index]
    // Simply move to the next element without adding current one
    backtrack(current_subset, subset_size, nums, nums_size, index + 1);

    // Decision 2: Include nums[index]
    // Add current element to subset buffer
    current_subset[subset_size] = nums[index];
    // Recurse with the new element included and an increased subset_size
    backtrack(current_subset, subset_size + 1, nums, nums_size, index + 1);
    // No explicit ""remove"" (pop) needed for current_subset[subset_size] because
    // when the function returns, the 'subset_size' in the calling context
    // will naturally revert to its previous value, effectively pruning the element.
}

// Main logic function to initiate the subset generation
void generateSubsets(int* nums, int nums_size) {
    // A temporary buffer to hold the current subset. Max size is nums_size.
    int* current_subset = (int*)malloc(sizeof(int) * nums_size);
    if (current_subset == NULL) {
        fprintf(stderr, ""Memory allocation failed\n"");
        return;
    }

    backtrack(current_subset, 0, nums, nums_size, 0);

    free(current_subset);
}

int main() {
    int nums_size;
    // Read the number of elements
    scanf(""%d"", &nums_size);

    int* nums = (int*)malloc(sizeof(int) * nums_size);
    if (nums == NULL) {
        fprintf(stderr, ""Memory allocation failed\n"");
        return 1;
    }

    // Read the elements into the array
    for (int i = 0; i < nums_size; i++) {
        scanf(""%d"", &nums[i]);
    }

    // Call the logic function
    generateSubsets(nums, nums_size);

    // Free dynamically allocated memory
    free(nums);
    return 0;
}","import sys

class Solution:
    def _backtrack(self, index, current_subset, nums, result):
        # Base case: All elements considered
        if index == len(nums):
            result.append(list(current_subset)) # Add a copy of the current_subset
            return

        # Decision 1: Exclude nums[index]
        self._backtrack(index + 1, current_subset, nums, result)

        # Decision 2: Include nums[index]
        current_subset.append(nums[index]) # Add the current element
        self._backtrack(index + 1, current_subset, nums, result)
        # Backtrack: Remove the last added element to explore other paths
        current_subset.pop()

    def generateSubsets(self, nums):
        result = []
        current_subset = []
        self._backtrack(0, current_subset, nums, result)
        return result

def main():
    # Read the number of elements
    n = int(sys.stdin.readline())
    # Read the elements into the list
    nums = list(map(int, sys.stdin.readline().split()))

    sol = Solution()
    all_subsets = sol.generateSubsets(nums)

    # Sort the subsets for consistent output, first by size, then lexicographically
    all_subsets.sort(key=lambda x: (len(x), x))

    # Print the result in the desired format
    sys.stdout.write(""["")
    for i, subset in enumerate(all_subsets):
        sys.stdout.write(""["")
        sys.stdout.write("", "".join(map(str, subset)))
        sys.stdout.write(""]"")
        if i < len(all_subsets) - 1:
            sys.stdout.write("", "")
    sys.stdout.write(""]\n"")

if __name__ == ""__main__"":
    main()","import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Scanner;

public class Solution {

    // Backtracking function to generate subsets
    private void backtrack(int index, List<Integer> currentSubset, int[] nums, List<List<Integer>> result) {
        // Base case: All elements considered
        if (index == nums.length) {
            result.add(new ArrayList<>(currentSubset)); // Add a copy of the currentSubset
            return;
        }

        // Decision 1: Exclude nums[index]
        backtrack(index + 1, currentSubset, nums, result);

        // Decision 2: Include nums[index]
        currentSubset.add(nums[index]); // Add the current element
        backtrack(index + 1, currentSubset, nums, result);
        // Backtrack: Remove the last added element to explore other paths
        currentSubset.remove(currentSubset.size() - 1);
    }

    // Main logic function for generating subsets
    public List<List<Integer>> generateSubsets(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        List<Integer> currentSubset = new ArrayList<>();
        backtrack(0, currentSubset, nums, result);
        return result;
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        // Read the number of elements
        int n = scanner.nextInt();
        int[] nums = new int[n];
        // Read the elements into the array
        for (int i = 0; i < n; i++) {
            nums[i] = scanner.nextInt();
        }
        scanner.close();

        Solution sol = new Solution();
        List<List<Integer>> allSubsets = sol.generateSubsets(nums);

        // Sort the subsets for consistent output, first by size, then lexicographically
        Collections.sort(allSubsets, (a, b) -> {
            if (a.size() != b.size()) {
                return a.size() - b.size();
            }
            for (int i = 0; i < a.size(); i++) {
                int cmp = Integer.compare(a.get(i), b.get(i));
                if (cmp != 0) {
                    return cmp;
                }
            }
            return 0; // Equal
        });

        // Print the result in the desired format
        System.out.print(""["");
        for (int i = 0; i < allSubsets.size(); i++) {
            List<Integer> subset = allSubsets.get(i);
            System.out.print(""["");
            for (int j = 0; j < subset.size(); j++) {
                System.out.print(subset.get(j));
                if (j < subset.size() - 1) {
                    System.out.print("", "");
                }
            }
            System.out.print(""]"");
            if (i < allSubsets.size() - 1) {
                System.out.print("", "");
            }
        }
        System.out.println(""]"");
    }
}","// Backtracking function to generate subsets
function backtrack(index, currentSubset, nums, result) {
    // Base case: All elements considered
    if (index === nums.length) {
        result.push([...currentSubset]); // Add a copy of the currentSubset
        return;
    }

    // Decision 1: Exclude nums[index]
    backtrack(index + 1, currentSubset, nums, result);

    // Decision 2: Include nums[index]
    currentSubset.push(nums[index]); // Add the current element
    backtrack(index + 1, currentSubset, nums, result);
    // Backtrack: Remove the last added element to explore other paths
    currentSubset.pop();
}

// Main logic function for generating subsets
function generateSubsets(nums) {
    const result = [];
    const currentSubset = [];
    backtrack(0, currentSubset, nums, result);
    return result;
}

// Main execution function to handle I/O
function main() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    let inputLines = [];
    rl.on('line', (line) => {
        inputLines.push(line);
    });

    rl.on('close', () => {
        // Read the number of elements
        const n = parseInt(inputLines[0]);
        // Read the elements into the array
        const nums = inputLines[1].split(' ').map(Number);

        // Call the logic function
        const allSubsets = generateSubsets(nums);

        // Sort the subsets for consistent output, first by size, then lexicographically
        allSubsets.sort((a, b) => {
            if (a.length !== b.length) {
                return a.length - b.length;
            }
            for (let i = 0; i < a.length; i++) {
                if (a[i] !== b[i]) {
                    return a[i] - b[i];
                }
            }
            return 0; // Equal
        });

        // Print the result in the desired format
        process.stdout.write(""["");
        for (let i = 0; i < allSubsets.length; i++) {
            const subset = allSubsets[i];
            process.stdout.write(""["");
            process.stdout.write(subset.join("", ""));
            process.stdout.write(""]"");
            if (i < allSubsets.length - 1) {
                process.stdout.write("", "");
            }
        }
        process.stdout.write(""]\n"");
    });
}

main();","#include <iostream>
#include <vector>
#include <algorithm> // For std::sort
#include <string>

// Function to print a vector of integers in the desired format
void printVector(const std::vector<int>& vec) {
    std::cout << ""["";
    for (size_t i = 0; i < vec.size(); ++i) {
        std::cout << vec[i];
        if (i < vec.size() - 1) {
            std::cout << "", "";
        }
    }
    std::cout << ""]"";
}

// Backtracking function to generate subsets
void backtrack(int index, std::vector<int>& current_subset, const std::vector<int>& nums, std::vector<std::vector<int>>& result) {
    // Base case: All elements considered
    if (index == nums.size()) {
        result.push_back(current_subset); // Add a copy of the current_subset
        return;
    }

    // Decision 1: Exclude nums[index]
    backtrack(index + 1, current_subset, nums, result);

    // Decision 2: Include nums[index]
    current_subset.push_back(nums[index]); // Add the current element
    backtrack(index + 1, current_subset, nums, result);
    // Backtrack: Remove the last added element to explore other paths
    current_subset.pop_back();
}

// Main logic function for generating subsets
std::vector<std::vector<int>> generateSubsets(const std::vector<int>& nums) {
    std::vector<std::vector<int>> result;
    std::vector<int> current_subset;
    backtrack(0, current_subset, nums, result);
    return result;
}

int main() {
    int n;
    // Read the number of elements
    std::cin >> n;

    std::vector<int> nums(n);
    // Read the elements into the vector
    for (int i = 0; i < n; ++i) {
        std::cin >> nums[i];
    }

    // Call the logic function
    std::vector<std::vector<int>> allSubsets = generateSubsets(nums);

    // Sort the subsets for consistent output, first by size, then lexicographically
    std::sort(allSubsets.begin(), allSubsets.end(), [](const std::vector<int>& a, const std::vector<int>& b) {
        if (a.size() != b.size()) {
            return a.size() < b.size();
        }
        for (size_t i = 0; i < a.size(); ++i) {
            if (a[i] != b[i]) {
                return a[i] < b[i];
            }
        }
        return false; // Equal
    });

    // Print the result in the desired format
    std::cout << ""["";
    for (size_t i = 0; i < allSubsets.size(); ++i) {
        printVector(allSubsets[i]);
        if (i < allSubsets.size() - 1) {
            std::cout << "", "";
        }
    }
    std::cout << ""]"" << std::endl;

    return 0;
}",4.4
Yellow-61,LeetCode,"*   **Recursion/Backtracking**: This problem is a classic example of using recursion to explore all possible paths to a solution. We make a choice, explore the consequences, and then ""backtrack"" to try another choice.
*   **Decision Tree**: Imagine a tree where at each step, you decide whether to add an opening parenthesis or a closing parenthesis. The goal is to find all paths from the root to a leaf that form a valid parentheses string.
*   **State Management**: During recursion, we keep track of how many opening parentheses we've used, how many closing parentheses we've used, and the current string we're building.
*   **Base Case**: The condition under which the recursion stops and a valid solution is found (e.g., when we've used all `n` opening and `n` closing parentheses).
*   **Pruning (Optimization)**: We can avoid exploring paths that will never lead to a valid solution. For instance, we should never add a closing parenthesis if we haven't added an opening one first, or if we've already used all `n` opening parentheses.","You are given a number `n`, which represents the number of pairs of parentheses you need to generate. Your task is to write a function that generates all possible combinations of well-formed parentheses.

A ""well-formed"" parentheses string means that:
1. Every opening parenthesis '(' has a corresponding closing parenthesis ')'.
2. Every closing parenthesis ')' has a corresponding opening parenthesis '('.
3. Parentheses are correctly nested (e.g., `()` is well-formed, `)(` is not).

For example, if `n = 3`, you need to generate all combinations of 3 pairs of parentheses that are well-formed.",*   `1 <= n <= 8`,"** `n = 3`

**","**

((()))
(()())
(())()
()(())
()()()

(The order of the strings in the output does not matter.)","Input: 1
Output:
(),Input: 2
Output:
(())
()(),Input: 3
Output:
((()))
(()())
(())()
()(())
()()(),Input: 4
Output:
(((())))
((()()))
((())())
((()))()
(()(()))
(()()())
(()())()
(())()()
()((()))
()(()())
()(())()
()()(())
()()()()","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Helper function for backtracking
void backtrack(char** result, int* resultSize, char* current_path, int path_idx, int open_count, int close_count, int n) {
    if (path_idx == 2 * n) {
        // Base case: current_path is complete
        current_path[path_idx] = '\0'; // Null-terminate the string
        // Dynamically reallocate result array if needed (simplified for common LeetCode size constraints here)
        // For n=8, Catalan(8) is 1430, so initial allocation of 2000 is safe.
        result[*resultSize] = strdup(current_path); // Duplicate and store the string
        (*resultSize)++;
        return;
    }

    // Try adding an open parenthesis
    if (open_count < n) {
        current_path[path_idx] = '(';
        backtrack(result, resultSize, current_path, path_idx + 1, open_count + 1, close_count, n);
    }

    // Try adding a close parenthesis
    if (close_count < open_count) {
        current_path[path_idx] = ')';
        backtrack(result, resultSize, current_path, path_idx + 1, open_count, close_count + 1, n);
    }
}

// Main function signature as typically expected by LeetCode C for string arrays
char** generateParenthesis(int n, int* returnSize) {
    // Max number of solutions is Catalan(n), which is large but bounded for n=8.
    // C(8) = 1430. Max length of string is 2*8 + 1 = 17.
    // Let's pre-allocate a reasonable upper bound for results. 2000 pointers should be fine.
    char** result = (char**)malloc(sizeof(char*) * 2000); 
    *returnSize = 0;

    // A buffer to build the current parenthesis string
    char* current_path = (char*)malloc(sizeof(char) * (2 * n + 1));

    backtrack(result, returnSize, current_path, 0, 0, 0, n);

    free(current_path); // Free the temporary buffer
    return result;
}

// Main function to handle I/O for testing
int main() {
    int n;
    // Read n from stdin
    if (scanf(""%d"", &n) != 1) {
        fprintf(stderr, ""Error reading input.\n"");
        return 1;
    }

    int returnSize;
    char** result = generateParenthesis(n, &returnSize);

    // Print results, one per line
    for (int i = 0; i < returnSize; i++) {
        printf(""%s\n"", result[i]);
        free(result[i]); // Free each string
    }
    free(result); // Free the array of pointers

    return 0;
}","import sys

class Solution:
    def generateParenthesis(self, n: int) -> list[str]:
        result = []
        # current_path is a list of characters for efficient appending/popping
        current_path = []

        def backtrack(open_count, close_count):
            # Base case: current_path is complete
            if open_count == n and close_count == n:
                result.append("""".join(current_path))
                return

            # Try adding an open parenthesis
            if open_count < n:
                current_path.append('(') # Add
                backtrack(open_count + 1, close_count)
                current_path.pop() # Backtrack

            # Try adding a close parenthesis
            if close_count < open_count:
                current_path.append(')') # Add
                backtrack(open_count, close_count + 1)
                current_path.pop() # Backtrack

        backtrack(0, 0)
        return result

def main():
    n = int(sys.stdin.readline()) # Read n from stdin

    sol = Solution()
    result = sol.generateParenthesis(n)

    # Print results, one per line
    for s in result:
        sys.stdout.write(s + '\n')

if __name__ == '__main__':
    main()","import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

class Solution {
    public List<String> generateParenthesis(int n) {
        List<String> result = new ArrayList<>();
        // Using a StringBuilder for efficient string manipulation during backtracking
        backtrack(result, new StringBuilder(), 0, 0, n);
        return result;
    }

    private void backtrack(List<String> result, StringBuilder currentPath, int openCount, int closeCount, int n) {
        // Base case: currentPath is complete
        if (currentPath.length() == 2 * n) {
            result.add(currentPath.toString());
            return;
        }

        // Try adding an open parenthesis
        if (openCount < n) {
            currentPath.append('('); // Add
            backtrack(result, currentPath, openCount + 1, closeCount, n);
            currentPath.deleteCharAt(currentPath.length() - 1); // Backtrack
        }

        // Try adding a close parenthesis
        if (closeCount < openCount) {
            currentPath.append(')'); // Add
            backtrack(result, currentPath, openCount, closeCount + 1, n);
            currentPath.deleteCharAt(currentPath.length() - 1); // Backtrack
        }
    }
}

public class Main {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        int n = scanner.nextInt();
        scanner.close();

        Solution sol = new Solution();
        List<String> result = sol.generateParenthesis(n);

        // Print results, one per line
        for (String s : result) {
            System.out.println(s);
        }
    }
}","// Function as typically expected in LeetCode environment
function generateParenthesis(n) {
    const result = [];
    // currentPath is an array of characters for efficient appending/popping
    const currentPath = [];

    function backtrack(openCount, closeCount) {
        // Base case: currentPath is complete
        if (currentPath.length === 2 * n) {
            result.push(currentPath.join(''));
            return;
        }

        // Try adding an open parenthesis
        if (openCount < n) {
            currentPath.push('('); // Add
            backtrack(openCount + 1, closeCount);
            currentPath.pop(); // Backtrack
        }

        // Try adding a close parenthesis
        if (closeCount < openCount) {
            currentPath.push(')'); // Add
            backtrack(openCount, closeCount + 1);
            currentPath.pop(); // Backtrack
        }
    }

    backtrack(0, 0);
    return result;
}

// Main function to handle I/O for testing
// In a typical LeetCode environment, only the generateParenthesis function is expected.
// For raw runnable code, we need to simulate input/output.
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

rl.question('', (input) => {
    const n = parseInt(input.trim(), 10);

    const result = generateParenthesis(n);

    // Print results, one per line
    for (const s of result) {
        console.log(s);
    }

    rl.close();
});","#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

class Solution {
public:
    void backtrack(std::vector<std::string>& result, std::string& current_path, int open_count, int close_count, int n) {
        // Base case: current_path is complete
        if (current_path.length() == 2 * n) {
            result.push_back(current_path);
            return;
        }

        // Try adding an open parenthesis
        if (open_count < n) {
            current_path.push_back('('); // Add
            backtrack(result, current_path, open_count + 1, close_count, n);
            current_path.pop_back(); // Backtrack
        }

        // Try adding a close parenthesis
        if (close_count < open_count) {
            current_path.push_back(')'); // Add
            backtrack(result, current_path, open_count, close_count + 1, n);
            current_path.pop_back(); // Backtrack
        }
    }

    std::vector<std::string> generateParenthesis(int n) {
        std::vector<std::string> result;
        std::string current_path; // Use a single string for building
        current_path.reserve(2 * n); // Pre-allocate memory for efficiency
        backtrack(result, current_path, 0, 0, n);
        return result;
    }
};

int main() {
    int n;
    // Read n from stdin
    std::cin >> n;

    Solution sol;
    std::vector<std::string> result = sol.generateParenthesis(n);

    // Print results, one per line
    for (const std::string& s : result) {
        std::cout << s << std::endl;
    }

    return 0;
}",4.2
Yellow-62,Sliding Window (Introductory problems),"*   Sliding Window Technique
*   Queue (or Deque) for efficient tracking of elements
*   Array traversal","You are given an array of `N` integers and an integer `K`. Your task is to find the first negative integer for each and every contiguous subarray (window) of size `K`. If a window does not contain any negative integers, you should report `0` for that window.","*   `1 <= N <= 10^5`
*   `1 <= K <= N`
*   `-10^9 <= A[i] <= 10^9`","**
N = 8, K = 3
A = [12, -1, -7, 8, -15, 30, 16, 28]

**","**
-1 -1 -7 -15 -15 0

**","Input: 5 2
1 2 3 4 5
Output: 0 0 0 0
Input: 4 2
-1 -2 -3 -4
Output: -1 -2 -3
Input: 5 5
10 -20 30 -40 50
Output: -20
Input: 6 1
-5 0 10 -15 20 -25
Output: -5 0 0 -15 0 -25
Input: 6 3
-1 -2 3 -4 5 -6
Output: -1 -2 -4 -4","#include <stdio.h>
#include <stdlib.h> // For malloc, free
#include <stdbool.h> // For bool

// A simple queue implementation using an array for indices
typedef struct {
    int* data;
    int front;
    int rear;
    int capacity;
    int size;
} Queue;

Queue* createQueue(int capacity) {
    Queue* q = (Queue*)malloc(sizeof(Queue));
    q->capacity = capacity;
    q->front = 0;
    q->rear = -1;
    q->size = 0;
    q->data = (int*)malloc(sizeof(int) * capacity);
    return q;
}

void enqueue(Queue* q, int item) {
    if (q->size == q->capacity) {
        // In this problem, max capacity is N, so it's fine.
        // A real-world queue might need dynamic resizing or error handling.
        return;
    }
    q->rear = (q->rear + 1) % q->capacity;
    q->data[q->rear] = item;
    q->size++;
}

int dequeue(Queue* q) {
    if (q->size == 0) {
        return -1; // Or some error indicator
    }
    int item = q->data[q->front];
    q->front = (q->front + 1) % q->capacity;
    q->size--;
    return item;
}

int getFront(Queue* q) {
    if (q->size == 0) {
        return -1; // Or some error indicator
    }
    return q->data[q->front];
}

bool isEmpty(Queue* q) {
    return q->size == 0;
}

void freeQueue(Queue* q) {
    free(q->data);
    free(q);
}

void findFirstNegativeInWindows(int arr[], int n, int k) {
    Queue* q = createQueue(n); // Queue stores indices of negative numbers

    for (int i = 0; i < n; i++) {
        // Remove elements from the front of the queue that are out of the current window
        if (!isEmpty(q) && getFront(q) <= i - k) {
            dequeue(q);
        }

        // Add the current element's index if it's negative
        if (arr[i] < 0) {
            enqueue(q, i);
        }

        // If the window has reached size K, print the first negative
        if (i >= k - 1) {
            if (!isEmpty(q)) {
                printf(""%d "", arr[getFront(q)]);
            } else {
                printf(""0 "");
            }
        }
    }
    printf(""\n"");

    freeQueue(q);
}

int main() {
    int n, k;
    scanf(""%d %d"", &n, &k);

    int* arr = (int*)malloc(sizeof(int) * n);
    for (int i = 0; i < n; i++) {
        scanf(""%d"", &arr[i]);
    }

    findFirstNegativeInWindows(arr, n, k);

    free(arr);

    return 0;
}","import collections

def find_first_negative_in_windows(arr, n, k):
    dq = collections.deque() # Stores indices of negative numbers
    result = []

    for i in range(n):
        # Remove elements from the front of the deque that are out of the current window
        # An index 'idx' is out of the window [i-k+1, i] if idx <= i-k
        if dq and dq[0] <= i - k:
            dq.popleft()

        # Add the current element's index if it's negative
        if arr[i] < 0:
            dq.append(i)

        # If the window has reached size K, append the first negative
        # The window is [i-k+1 ... i]
        if i >= k - 1:
            if dq:
                result.append(str(arr[dq[0]]))
            else:
                result.append(""0"")

    print("" "".join(result))

if __name__ == ""__main__"":
    n, k = map(int, input().split())
    arr = list(map(int, input().split()))

    find_first_negative_in_windows(arr, n, k)","import java.util.LinkedList;
import java.util.Queue;
import java.util.Scanner;

public class FirstNegativeInWindow {

    public static void findFirstNegativeInWindows(int[] arr, int n, int k) {
        // Use a LinkedList as a Queue to store indices of negative numbers
        Queue<Integer> dq = new LinkedList<>();

        StringBuilder result = new StringBuilder();

        for (int i = 0; i < n; i++) {
            // Remove elements from the front of the queue that are out of the current window
            // An index 'idx' is out of the window [i-k+1, i] if idx <= i-k
            if (!dq.isEmpty() && dq.peek() <= i - k) {
                dq.poll();
            }

            // Add the current element's index if it's negative
            if (arr[i] < 0) {
                // For a Queue, add() (or offer()) adds to the tail.
                dq.add(i);
            }

            // If the window has reached size K, append the first negative
            // The window is [i-k+1 ... i]
            if (i >= k - 1) {
                if (!dq.isEmpty()) {
                    result.append(arr[dq.peek()]).append("" "");
                } else {
                    result.append(""0 "");
                }
            }
        }
        System.out.println(result.toString().trim());
    }

    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);

        int n = scanner.nextInt();
        int k = scanner.nextInt();

        int[] arr = new int[n];
        for (int i = 0; i < n; i++) {
            arr[i] = scanner.nextInt();
        }

        findFirstNegativeInWindows(arr, n, k);

        scanner.close();
    }
}","function findFirstNegativeInWindows(arr, n, k) {
    const dq = []; // Stores indices of negative numbers (simulated deque using array methods)
    const result = [];

    for (let i = 0; i < n; i++) {
        // Remove elements from the front of the deque that are out of the current window
        // An index 'idx' is out of the window [i-k+1, i] if idx <= i-k
        while (dq.length > 0 && dq[0] <= i - k) {
            dq.shift(); // Remove from front
        }

        // Add the current element's index if it's negative
        if (arr[i] < 0) {
            dq.push(i); // Add to back
        }

        // If the window has reached size K, append the first negative
        // The window is [i-k+1 ... i]
        if (i >= k - 1) {
            if (dq.length > 0) {
                result.push(arr[dq[0]]); // Peek at front
            } else {
                result.push(0);
            }
        }
    }
    console.log(result.join("" ""));
}

// Handle input/output for competitive programming environment
// Reads N and K from the first line
// Reads array elements from the second line
const readline = require('readline');
const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

let inputLines = [];
rl.on('line', (line) => {
    inputLines.push(line);
});

rl.on('close', () => {
    const nk = inputLines[0].split(' ').map(Number);
    const n = nk[0];
    const k = nk[1];
    const arr = inputLines[1].split(' ').map(Number);

    findFirstNegativeInWindows(arr, n, k);
});","#include <iostream>
#include <vector>
#include <deque>

void findFirstNegativeInWindows(const std::vector<int>& arr, int n, int k) {
    std::deque<int> dq; // Stores indices of negative numbers

    for (int i = 0; i < n; ++i) {
        // Remove elements from the front of the deque that are out of the current window
        // An index 'idx' is out of the window [i-k+1, i] if idx <= i-k
        if (!dq.empty() && dq.front() <= i - k) {
            dq.pop_front();
        }

        // Add the current element's index if it's negative
        if (arr[i] < 0) {
            dq.push_back(i);
        }

        // If the window has reached size K, print the first negative
        // The window is [i-k+1 ... i]
        if (i >= k - 1) {
            if (!dq.empty()) {
                std::cout << arr[dq.front()] << "" "";
            } else {
                std::cout << ""0 "";
            }
        }
    }
    std::cout << std::endl;
}

int main() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    int n, k;
    std::cin >> n >> k;

    std::vector<int> arr(n);
    for (int i = 0; i < n; ++i) {
        std::cin >> arr[i];
    }

    findFirstNegativeInWindows(arr, n, k);

    return 0;
}",4.4
Yellow-63,Queue Implementation (Array/LL),"- Queue Data Structure (FIFO - First-In, First-Out)
- Singly Linked Lists
- Node management (pointers/references)
- Basic Data Structure Operations (add, remove, peek, check emptiness, size)
- Edge case handling (e.g., empty queue operations)","Implement a Queue data structure using a singly linked list. Your queue should support the following operations:

- `enqueue(value)`: Add an element to the rear of the queue.
- `dequeue()`: Remove and return the element from the front of the queue. If the queue is empty, indicate this.
- `peek()`: Return the element at the front of the queue without removing it. If the queue is empty, indicate this.
- `isEmpty()`: Return `true` if the queue is empty, `false` otherwise.
- `size()`: Return the current number of elements in the queue.

Your implementation should correctly handle all edge cases, such as performing operations on an empty queue.","- The queue will store integers.
- Maximum number of operations: 1000.
- Values of elements for `enqueue` will be between -10^9 and 10^9.
- For `dequeue` and `peek` on an empty queue, print ""Queue is empty"".","7
enqueue 10
enqueue 20
dequeue
peek
size
isEmpty
dequeue


####","10
20
1
false
20","Input: 5
enqueue 1
enqueue 2
dequeue
dequeue
isEmpty
Output: 1
2
true
Input: 8
enqueue 100
peek
enqueue 200
dequeue
size
enqueue 300
dequeue
peek
Output: 100
100
1
300
Input: 6
isEmpty
dequeue
peek
enqueue 50
size
isEmpty
Output: true
Queue is empty
Queue is empty
1
false
Input: 9
enqueue 1
enqueue 2
dequeue
enqueue 3
enqueue 4
dequeue
dequeue
dequeue
isEmpty
Output: 1
2
3
4
true","#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Define a Node structure
typedef struct Node {
    int data;
    struct Node* next;
} Node;

// Define a Queue structure
typedef struct Queue {
    Node* front;
    Node* rear;
    int currentSize;
} Queue;

// Function to initialize a new Queue
Queue* createQueue() {
    Queue* q = (Queue*)malloc(sizeof(Queue));
    if (q == NULL) {
        perror(""Failed to allocate memory for queue"");
        exit(EXIT_FAILURE);
    }
    q->front = NULL;
    q->rear = NULL;
    q->currentSize = 0;
    return q;
}

// Function to check if the queue is empty
int isEmpty(Queue* q) {
    return q->front == NULL;
}

// Function to get the current size of the queue
int size(Queue* q) {
    return q->currentSize;
}

// Function to add an element to the rear of the queue
void enqueue(Queue* q, int value) {
    Node* newNode = (Node*)malloc(sizeof(Node));
    if (newNode == NULL) {
        perror(""Failed to allocate memory for node"");
        exit(EXIT_FAILURE);
    }
    newNode->data = value;
    newNode->next = NULL;

    if (isEmpty(q)) {
        q->front = newNode;
        q->rear = newNode;
    } else {
        q->rear->next = newNode;
        q->rear = newNode;
    }
    q->currentSize++;
}

// Function to remove and return the element from the front of the queue
// Returns an indicator (e.g., -1 for error) or uses an output parameter
// For simplicity, we'll print and return 0 if empty, otherwise the value
int dequeue(Queue* q) {
    if (isEmpty(q)) {
        printf(""Queue is empty\n"");
        return -1; // Indicate error or special value
    }
    Node* temp = q->front;
    int dequeuedValue = temp->data;
    q->front = q->front->next;

    if (q->front == NULL) { // If queue becomes empty after dequeue
        q->rear = NULL;
    }
    free(temp);
    q->currentSize--;
    return dequeuedValue;
}

// Function to peek at the front element without removing it
int peek(Queue* q) {
    if (isEmpty(q)) {
        printf(""Queue is empty\n"");
        return -1; // Indicate error or special value
    }
    return q->front->data;
}

// Function to free all memory associated with the queue
void freeQueue(Queue* q) {
    Node* current = q->front;
    Node* next;
    while (current != NULL) {
        next = current->next;
        free(current);
        current = next;
    }
    free(q);
}

int main() {
    Queue* myQueue = createQueue();
    int N;
    scanf(""%d"", &N);

    char command[20];
    int value;
    int result;

    for (int i = 0; i < N; i++) {
        scanf(""%s"", command);
        if (strcmp(command, ""enqueue"") == 0) {
            scanf(""%d"", &value);
            enqueue(myQueue, value);
        } else if (strcmp(command, ""dequeue"") == 0) {
            result = dequeue(myQueue);
            if (result != -1) {
                printf(""%d\n"", result);
            }
        } else if (strcmp(command, ""peek"") == 0) {
            result = peek(myQueue);
            if (result != -1) {
                printf(""%d\n"", result);
            }
        } else if (strcmp(command, ""isEmpty"") == 0) {
            if (isEmpty(myQueue)) {
                printf(""true\n"");
            } else {
                printf(""false\n"");
            }
        } else if (strcmp(command, ""size"") == 0) {
            printf(""%d\n"", size(myQueue));
        }
    }

    freeQueue(myQueue);

    return 0;
}","class Node:
    def __init__(self, data):
        self.data = data
        self.next = None

class Queue:
    def __init__(self):
        self.front = None
        self.rear = None
        self.current_size = 0

    def is_empty(self):
        return self.front is None

    def size(self):
        return self.current_size

    def enqueue(self, value):
        new_node = Node(value)
        if self.is_empty():
            self.front = new_node
            self.rear = new_node
        else:
            self.rear.next = new_node
            self.rear = new_node
        self.current_size += 1

    def dequeue(self):
        if self.is_empty():
            print(""Queue is empty"")
            return -1  # Indicate error or special value
        dequeued_value = self.front.data
        self.front = self.front.next

        if self.front is None:  # If queue becomes empty after dequeue
            self.rear = None
        self.current_size -= 1
        return dequeued_value

    def peek(self):
        if self.is_empty():
            print(""Queue is empty"")
            return -1  # Indicate error or special value
        return self.front.data

def solve():
    my_queue = Queue()
    N = int(input())

    for _ in range(N):
        command_parts = input().split()
        command = command_parts[0]

        if command == ""enqueue"":
            value = int(command_parts[1])
            my_queue.enqueue(value)
        elif command == ""dequeue"":
            result = my_queue.dequeue()
            if result != -1:
                print(result)
        elif command == ""peek"":
            result = my_queue.peek()
            if result != -1:
                print(result)
        elif command == ""isEmpty"":
            print(str(my_queue.is_empty()).lower())
        elif command == ""size"":
            print(my_queue.size())

if __name__ == '__main__':
    solve()","import java.util.Scanner;

class Node {
    int data;
    Node next;

    public Node(int data) {
        this.data = data;
        this.next = null;
    }
}

class Queue {
    private Node front;
    private Node rear;
    private int currentSize;

    public Queue() {
        this.front = null;
        this.rear = null;
        this.currentSize = 0;
    }

    public boolean isEmpty() {
        return front == null;
    }

    public int size() {
        return currentSize;
    }

    public void enqueue(int value) {
        Node newNode = new Node(value);
        if (isEmpty()) {
            front = newNode;
            rear = newNode;
        } else {
            rear.next = newNode;
            rear = newNode;
        }
        currentSize++;
    }

    public int dequeue() {
        if (isEmpty()) {
            System.out.println(""Queue is empty"");
            return -1; // Indicate error or special value
        }
        int dequeuedValue = front.data;
        front = front.next;

        if (front == null) { // If queue becomes empty after dequeue
            rear = null;
        }
        currentSize--;
        return dequeuedValue;
    }

    public int peek() {
        if (isEmpty()) {
            System.out.println(""Queue is empty"");
            return -1; // Indicate error or special value
        }
        return front.data;
    }
}

public class Solution {
    public static void main(String[] args) {
        Scanner scanner = new Scanner(System.in);
        Queue myQueue = new Queue();

        int N = scanner.nextInt();
        scanner.nextLine(); // Consume newline

        for (int i = 0; i < N; i++) {
            String line = scanner.nextLine();
            String[] parts = line.split("" "");
            String command = parts[0];

            if (command.equals(""enqueue"")) {
                int value = Integer.parseInt(parts[1]);
                myQueue.enqueue(value);
            } else if (command.equals(""dequeue"")) {
                int result = myQueue.dequeue();
                if (result != -1) {
                    System.out.println(result);
                }
            } else if (command.equals(""peek"")) {
                int result = myQueue.peek();
                if (result != -1) {
                    System.out.println(result);
                }
            } else if (command.equals(""isEmpty"")) {
                System.out.println(myQueue.isEmpty());
            } else if (command.equals(""size"")) {
                System.out.println(myQueue.size());
            }
        }

        scanner.close();
    }
}","class Node {
    constructor(data) {
        this.data = data;
        this.next = null;
    }
}

class Queue {
    constructor() {
        this.front = null;
        this.rear = null;
        this.currentSize = 0;
    }

    isEmpty() {
        return this.front === null;
    }

    size() {
        return this.currentSize;
    }

    enqueue(value) {
        const newNode = new Node(value);
        if (this.isEmpty()) {
            this.front = newNode;
            this.rear = newNode;
        } else {
            this.rear.next = newNode;
            this.rear = newNode;
        }
        this.currentSize++;
    }

    dequeue() {
        if (this.isEmpty()) {
            console.log(""Queue is empty"");
            return -1; // Indicate error or special value
        }
        const dequeuedValue = this.front.data;
        this.front = this.front.next;

        if (this.front === null) { // If queue becomes empty after dequeue
            this.rear = null;
        }
        this.currentSize--;
        return dequeuedValue;
    }

    peek() {
        if (this.isEmpty()) {
            console.log(""Queue is empty"");
            return -1; // Indicate error or special value
        }
        return this.front.data;
    }
}

function solve() {
    const readline = require('readline');
    const rl = readline.createInterface({
        input: process.stdin,
        output: process.stdout
    });

    const myQueue = new Queue();
    let N;
    let lineNumber = 0;
    let commands = [];

    rl.on('line', (line) => {
        if (lineNumber === 0) {
            N = parseInt(line);
        } else {
            commands.push(line);
        }
        lineNumber++;

        if (lineNumber > N) {
            rl.close();
        }
    });

    rl.on('close', () => {
        for (const commandLine of commands) {
            const parts = commandLine.split(' ');
            const command = parts[0];

            if (command === ""enqueue"") {
                const value = parseInt(parts[1]);
                myQueue.enqueue(value);
            } else if (command === ""dequeue"") {
                const result = myQueue.dequeue();
                if (result !== -1) {
                    console.log(result);
                }
            } else if (command === ""peek"") {
                const result = myQueue.peek();
                if (result !== -1) {
                    console.log(result);
                }
            } else if (command === ""isEmpty"") {
                console.log(myQueue.isEmpty());
            } else if (command === ""size"") {
                console.log(myQueue.size());
            }
        }
    });
}

solve();","#include <iostream>
#include <string>

// Define a Node structure
struct Node {
    int data;
    Node* next;

    Node(int val) : data(val), next(nullptr) {}
};

// Define a Queue class
class Queue {
private:
    Node* frontPtr;
    Node* rearPtr;
    int currentSize;

public:
    // Constructor
    Queue() : frontPtr(nullptr), rearPtr(nullptr), currentSize(0) {}

    // Destructor to free memory
    ~Queue() {
        while (frontPtr != nullptr) {
            Node* temp = frontPtr;
            frontPtr = frontPtr->next;
            delete temp;
        }
    }

    // Function to check if the queue is empty
    bool isEmpty() {
        return frontPtr == nullptr;
    }

    // Function to get the current size of the queue
    int size() {
        return currentSize;
    }

    // Function to add an element to the rear of the queue
    void enqueue(int value) {
        Node* newNode = new Node(value);
        if (isEmpty()) {
            frontPtr = newNode;
            rearPtr = newNode;
        } else {
            rearPtr->next = newNode;
            rearPtr = newNode;
        }
        currentSize++;
    }

    // Function to remove and return the element from the front of the queue
    int dequeue() {
        if (isEmpty()) {
            std::cout << ""Queue is empty"" << std::endl;
            return -1; // Indicate error or special value
        }
        Node* temp = frontPtr;
        int dequeuedValue = temp->data;
        frontPtr = frontPtr->next;

        if (frontPtr == nullptr) { // If queue becomes empty after dequeue
            rearPtr = nullptr;
        }
        delete temp;
        currentSize--;
        return dequeuedValue;
    }

    // Function to peek at the front element without removing it
    int peek() {
        if (isEmpty()) {
            std::cout << ""Queue is empty"" << std::endl;
            return -1; // Indicate error or special value
        }
        return frontPtr->data;
    }
};

int main() {
    Queue myQueue;
    int N;
    std::cin >> N;

    std::string command;
    int value;
    int result;

    for (int i = 0; i < N; i++) {
        std::cin >> command;
        if (command == ""enqueue"") {
            std::cin >> value;
            myQueue.enqueue(value);
        } else if (command == ""dequeue"") {
            result = myQueue.dequeue();
            if (result != -1) {
                std::cout << result << std::endl;
            }
        } else if (command == ""peek"") {
            result = myQueue.peek();
            if (result != -1) {
                std::cout << result << std::endl;
            }
        } else if (command == ""isEmpty"") {
            if (myQueue.isEmpty()) {
                std::cout << ""true"" << std::endl;
            } else {
                std::cout << ""false"" << std::endl;
            }
        } else if (command == ""size"") {
            std::cout << myQueue.size() << std::endl;
        }
    }

    return 0;
}",4.4
